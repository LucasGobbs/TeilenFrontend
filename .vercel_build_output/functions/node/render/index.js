var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = {exports: {}}).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, {get: all[name2], enumerable: true});
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    function log(message) {
      console.log(`[dotenv][DEBUG] ${message}`);
    }
    var NEWLINE = "\n";
    var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
    var RE_NEWLINES = /\\n/g;
    var NEWLINES_MATCH = /\r\n|\n|\r/;
    function parse(src2, options2) {
      const debug = Boolean(options2 && options2.debug);
      const obj = {};
      src2.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
        const keyValueArr = line.match(RE_INI_KEY_VAL);
        if (keyValueArr != null) {
          const key = keyValueArr[1];
          let val = keyValueArr[2] || "";
          const end = val.length - 1;
          const isDoubleQuoted = val[0] === '"' && val[end] === '"';
          const isSingleQuoted = val[0] === "'" && val[end] === "'";
          if (isSingleQuoted || isDoubleQuoted) {
            val = val.substring(1, end);
            if (isDoubleQuoted) {
              val = val.replace(RE_NEWLINES, NEWLINE);
            }
          } else {
            val = val.trim();
          }
          obj[key] = val;
        } else if (debug) {
          log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
        }
      });
      return obj;
    }
    function config2(options2) {
      let dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      let debug = false;
      if (options2) {
        if (options2.path != null) {
          dotenvPath = options2.path;
        }
        if (options2.encoding != null) {
          encoding = options2.encoding;
        }
        if (options2.debug != null) {
          debug = true;
        }
      }
      try {
        const parsed = parse(fs.readFileSync(dotenvPath, {encoding}), {debug});
        Object.keys(parsed).forEach(function(key) {
          if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
            process.env[key] = parsed[key];
          } else if (debug) {
            log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
          }
        });
        return {parsed};
      } catch (e) {
        return {error: e};
      }
    }
    module2.exports.config = config2;
    module2.exports.parse = parse;
  }
});

// node_modules/bson/lib/bson/map.js
var require_map = __commonJS({
  "node_modules/bson/lib/bson/map.js"(exports2, module2) {
    "use strict";
    if (typeof global.Map !== "undefined") {
      module2.exports = global.Map;
      module2.exports.Map = global.Map;
    } else {
      Map2 = function(array) {
        this._keys = [];
        this._values = {};
        for (var i = 0; i < array.length; i++) {
          if (array[i] == null)
            continue;
          var entry = array[i];
          var key = entry[0];
          var value = entry[1];
          this._keys.push(key);
          this._values[key] = {v: value, i: this._keys.length - 1};
        }
      };
      Map2.prototype.clear = function() {
        this._keys = [];
        this._values = {};
      };
      Map2.prototype.delete = function(key) {
        var value = this._values[key];
        if (value == null)
          return false;
        delete this._values[key];
        this._keys.splice(value.i, 1);
        return true;
      };
      Map2.prototype.entries = function() {
        var self2 = this;
        var index2 = 0;
        return {
          next: function() {
            var key = self2._keys[index2++];
            return {
              value: key !== void 0 ? [key, self2._values[key].v] : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Map2.prototype.forEach = function(callback, self2) {
        self2 = self2 || this;
        for (var i = 0; i < this._keys.length; i++) {
          var key = this._keys[i];
          callback.call(self2, this._values[key].v, key, self2);
        }
      };
      Map2.prototype.get = function(key) {
        return this._values[key] ? this._values[key].v : void 0;
      };
      Map2.prototype.has = function(key) {
        return this._values[key] != null;
      };
      Map2.prototype.keys = function() {
        var self2 = this;
        var index2 = 0;
        return {
          next: function() {
            var key = self2._keys[index2++];
            return {
              value: key !== void 0 ? key : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Map2.prototype.set = function(key, value) {
        if (this._values[key]) {
          this._values[key].v = value;
          return this;
        }
        this._keys.push(key);
        this._values[key] = {v: value, i: this._keys.length - 1};
        return this;
      };
      Map2.prototype.values = function() {
        var self2 = this;
        var index2 = 0;
        return {
          next: function() {
            var key = self2._keys[index2++];
            return {
              value: key !== void 0 ? self2._values[key].v : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Object.defineProperty(Map2.prototype, "size", {
        enumerable: true,
        get: function() {
          return this._keys.length;
        }
      });
      module2.exports = Map2;
      module2.exports.Map = Map2;
    }
    var Map2;
  }
});

// node_modules/bson/lib/bson/long.js
var require_long = __commonJS({
  "node_modules/bson/lib/bson/long.js"(exports2, module2) {
    function Long2(low, high) {
      if (!(this instanceof Long2))
        return new Long2(low, high);
      this._bsontype = "Long";
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    Long2.prototype.toInt = function() {
      return this.low_;
    };
    Long2.prototype.toNumber = function() {
      return this.high_ * Long2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Long2.prototype.toBigInt = function() {
      return BigInt(this.toString());
    };
    Long2.prototype.toJSON = function() {
      return this.toString();
    };
    Long2.prototype.toString = function(opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (this.isZero()) {
        return "0";
      }
      if (this.isNegative()) {
        if (this.equals(Long2.MIN_VALUE)) {
          var radixLong = Long2.fromNumber(radix);
          var div = this.div(radixLong);
          var rem = div.multiply(radixLong).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return "-" + this.negate().toString(radix);
        }
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = "";
      while (!rem.isZero()) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = "0" + digits;
          }
          result = "" + digits + result;
        }
      }
    };
    Long2.prototype.getHighBits = function() {
      return this.high_;
    };
    Long2.prototype.getLowBits = function() {
      return this.low_;
    };
    Long2.prototype.getLowBitsUnsigned = function() {
      return this.low_ >= 0 ? this.low_ : Long2.TWO_PWR_32_DBL_ + this.low_;
    };
    Long2.prototype.getNumBitsAbs = function() {
      if (this.isNegative()) {
        if (this.equals(Long2.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ !== 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) !== 0) {
            break;
          }
        }
        return this.high_ !== 0 ? bit + 33 : bit + 1;
      }
    };
    Long2.prototype.isZero = function() {
      return this.high_ === 0 && this.low_ === 0;
    };
    Long2.prototype.isNegative = function() {
      return this.high_ < 0;
    };
    Long2.prototype.isOdd = function() {
      return (this.low_ & 1) === 1;
    };
    Long2.prototype.equals = function(other) {
      return this.high_ === other.high_ && this.low_ === other.low_;
    };
    Long2.prototype.notEquals = function(other) {
      return this.high_ !== other.high_ || this.low_ !== other.low_;
    };
    Long2.prototype.lessThan = function(other) {
      return this.compare(other) < 0;
    };
    Long2.prototype.lessThanOrEqual = function(other) {
      return this.compare(other) <= 0;
    };
    Long2.prototype.greaterThan = function(other) {
      return this.compare(other) > 0;
    };
    Long2.prototype.greaterThanOrEqual = function(other) {
      return this.compare(other) >= 0;
    };
    Long2.prototype.compare = function(other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Long2.prototype.negate = function() {
      if (this.equals(Long2.MIN_VALUE)) {
        return Long2.MIN_VALUE;
      } else {
        return this.not().add(Long2.ONE);
      }
    };
    Long2.prototype.add = function(other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long2.prototype.subtract = function(other) {
      return this.add(other.negate());
    };
    Long2.prototype.multiply = function(other) {
      if (this.isZero()) {
        return Long2.ZERO;
      } else if (other.isZero()) {
        return Long2.ZERO;
      }
      if (this.equals(Long2.MIN_VALUE)) {
        return other.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      } else if (other.equals(Long2.MIN_VALUE)) {
        return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Long2.TWO_PWR_24_) && other.lessThan(Long2.TWO_PWR_24_)) {
        return Long2.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long2.prototype.div = function(other) {
      if (other.isZero()) {
        throw Error("division by zero");
      } else if (this.isZero()) {
        return Long2.ZERO;
      }
      if (this.equals(Long2.MIN_VALUE)) {
        if (other.equals(Long2.ONE) || other.equals(Long2.NEG_ONE)) {
          return Long2.MIN_VALUE;
        } else if (other.equals(Long2.MIN_VALUE)) {
          return Long2.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Long2.ZERO)) {
            return other.isNegative() ? Long2.ONE : Long2.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Long2.MIN_VALUE)) {
        return Long2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Long2.ZERO;
      rem = this;
      while (rem.greaterThanOrEqual(other)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Long2.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Long2.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Long2.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Long2.prototype.modulo = function(other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Long2.prototype.not = function() {
      return Long2.fromBits(~this.low_, ~this.high_);
    };
    Long2.prototype.and = function(other) {
      return Long2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Long2.prototype.or = function(other) {
      return Long2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Long2.prototype.xor = function(other) {
      return Long2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Long2.prototype.shiftLeft = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Long2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Long2.fromBits(0, low << numBits - 32);
        }
      }
    };
    Long2.prototype.shiftRight = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Long2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Long2.prototype.shiftRightUnsigned = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits === 32) {
          return Long2.fromBits(high, 0);
        } else {
          return Long2.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Long2.fromInt = function(value) {
      if (-128 <= value && value < 128) {
        var cachedObj = Long2.INT_CACHE_[value];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Long2(value | 0, value < 0 ? -1 : 0);
      if (-128 <= value && value < 128) {
        Long2.INT_CACHE_[value] = obj;
      }
      return obj;
    };
    Long2.fromNumber = function(value) {
      if (isNaN(value) || !isFinite(value)) {
        return Long2.ZERO;
      } else if (value <= -Long2.TWO_PWR_63_DBL_) {
        return Long2.MIN_VALUE;
      } else if (value + 1 >= Long2.TWO_PWR_63_DBL_) {
        return Long2.MAX_VALUE;
      } else if (value < 0) {
        return Long2.fromNumber(-value).negate();
      } else {
        return new Long2(value % Long2.TWO_PWR_32_DBL_ | 0, value / Long2.TWO_PWR_32_DBL_ | 0);
      }
    };
    Long2.fromBigInt = function(value) {
      return Long2.fromString(value.toString(10), 10);
    };
    Long2.fromBits = function(lowBits, highBits) {
      return new Long2(lowBits, highBits);
    };
    Long2.fromString = function(str, opt_radix) {
      if (str.length === 0) {
        throw Error("number format error: empty string");
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (str.charAt(0) === "-") {
        return Long2.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf("-") >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 8));
      var result = Long2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Long2.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Long2.fromNumber(value));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Long2.fromNumber(value));
        }
      }
      return result;
    };
    Long2.INT_CACHE_ = {};
    Long2.TWO_PWR_16_DBL_ = 1 << 16;
    Long2.TWO_PWR_24_DBL_ = 1 << 24;
    Long2.TWO_PWR_32_DBL_ = Long2.TWO_PWR_16_DBL_ * Long2.TWO_PWR_16_DBL_;
    Long2.TWO_PWR_31_DBL_ = Long2.TWO_PWR_32_DBL_ / 2;
    Long2.TWO_PWR_48_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_16_DBL_;
    Long2.TWO_PWR_64_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_32_DBL_;
    Long2.TWO_PWR_63_DBL_ = Long2.TWO_PWR_64_DBL_ / 2;
    Long2.ZERO = Long2.fromInt(0);
    Long2.ONE = Long2.fromInt(1);
    Long2.NEG_ONE = Long2.fromInt(-1);
    Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0);
    Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0);
    Long2.TWO_PWR_24_ = Long2.fromInt(1 << 24);
    module2.exports = Long2;
    module2.exports.Long = Long2;
  }
});

// node_modules/bson/lib/bson/double.js
var require_double = __commonJS({
  "node_modules/bson/lib/bson/double.js"(exports2, module2) {
    function Double2(value) {
      if (!(this instanceof Double2))
        return new Double2(value);
      this._bsontype = "Double";
      this.value = value;
    }
    Double2.prototype.valueOf = function() {
      return this.value;
    };
    Double2.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Double2;
    module2.exports.Double = Double2;
  }
});

// node_modules/bson/lib/bson/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/bson/lib/bson/timestamp.js"(exports2, module2) {
    function Timestamp2(low, high) {
      if (!(this instanceof Timestamp2))
        return new Timestamp2(low, high);
      this._bsontype = "Timestamp";
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    Timestamp2.prototype.toInt = function() {
      return this.low_;
    };
    Timestamp2.prototype.toNumber = function() {
      return this.high_ * Timestamp2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Timestamp2.prototype.toJSON = function() {
      return this.toString();
    };
    Timestamp2.prototype.toString = function(opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (this.isZero()) {
        return "0";
      }
      if (this.isNegative()) {
        if (this.equals(Timestamp2.MIN_VALUE)) {
          var radixTimestamp = Timestamp2.fromNumber(radix);
          var div = this.div(radixTimestamp);
          var rem = div.multiply(radixTimestamp).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return "-" + this.negate().toString(radix);
        }
      }
      var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = "";
      while (!rem.isZero()) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = "0" + digits;
          }
          result = "" + digits + result;
        }
      }
    };
    Timestamp2.prototype.getHighBits = function() {
      return this.high_;
    };
    Timestamp2.prototype.getLowBits = function() {
      return this.low_;
    };
    Timestamp2.prototype.getLowBitsUnsigned = function() {
      return this.low_ >= 0 ? this.low_ : Timestamp2.TWO_PWR_32_DBL_ + this.low_;
    };
    Timestamp2.prototype.getNumBitsAbs = function() {
      if (this.isNegative()) {
        if (this.equals(Timestamp2.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ !== 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) !== 0) {
            break;
          }
        }
        return this.high_ !== 0 ? bit + 33 : bit + 1;
      }
    };
    Timestamp2.prototype.isZero = function() {
      return this.high_ === 0 && this.low_ === 0;
    };
    Timestamp2.prototype.isNegative = function() {
      return this.high_ < 0;
    };
    Timestamp2.prototype.isOdd = function() {
      return (this.low_ & 1) === 1;
    };
    Timestamp2.prototype.equals = function(other) {
      return this.high_ === other.high_ && this.low_ === other.low_;
    };
    Timestamp2.prototype.notEquals = function(other) {
      return this.high_ !== other.high_ || this.low_ !== other.low_;
    };
    Timestamp2.prototype.lessThan = function(other) {
      return this.compare(other) < 0;
    };
    Timestamp2.prototype.lessThanOrEqual = function(other) {
      return this.compare(other) <= 0;
    };
    Timestamp2.prototype.greaterThan = function(other) {
      return this.compare(other) > 0;
    };
    Timestamp2.prototype.greaterThanOrEqual = function(other) {
      return this.compare(other) >= 0;
    };
    Timestamp2.prototype.compare = function(other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Timestamp2.prototype.negate = function() {
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.MIN_VALUE;
      } else {
        return this.not().add(Timestamp2.ONE);
      }
    };
    Timestamp2.prototype.add = function(other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp2.prototype.subtract = function(other) {
      return this.add(other.negate());
    };
    Timestamp2.prototype.multiply = function(other) {
      if (this.isZero()) {
        return Timestamp2.ZERO;
      } else if (other.isZero()) {
        return Timestamp2.ZERO;
      }
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return other.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return this.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Timestamp2.TWO_PWR_24_) && other.lessThan(Timestamp2.TWO_PWR_24_)) {
        return Timestamp2.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp2.prototype.div = function(other) {
      if (other.isZero()) {
        throw Error("division by zero");
      } else if (this.isZero()) {
        return Timestamp2.ZERO;
      }
      if (this.equals(Timestamp2.MIN_VALUE)) {
        if (other.equals(Timestamp2.ONE) || other.equals(Timestamp2.NEG_ONE)) {
          return Timestamp2.MIN_VALUE;
        } else if (other.equals(Timestamp2.MIN_VALUE)) {
          return Timestamp2.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Timestamp2.ZERO)) {
            return other.isNegative() ? Timestamp2.ONE : Timestamp2.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Timestamp2.ZERO;
      rem = this;
      while (rem.greaterThanOrEqual(other)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Timestamp2.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Timestamp2.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Timestamp2.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Timestamp2.prototype.modulo = function(other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Timestamp2.prototype.not = function() {
      return Timestamp2.fromBits(~this.low_, ~this.high_);
    };
    Timestamp2.prototype.and = function(other) {
      return Timestamp2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Timestamp2.prototype.or = function(other) {
      return Timestamp2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Timestamp2.prototype.xor = function(other) {
      return Timestamp2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Timestamp2.prototype.shiftLeft = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Timestamp2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Timestamp2.fromBits(0, low << numBits - 32);
        }
      }
    };
    Timestamp2.prototype.shiftRight = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Timestamp2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Timestamp2.prototype.shiftRightUnsigned = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits === 32) {
          return Timestamp2.fromBits(high, 0);
        } else {
          return Timestamp2.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Timestamp2.fromInt = function(value) {
      if (-128 <= value && value < 128) {
        var cachedObj = Timestamp2.INT_CACHE_[value];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Timestamp2(value | 0, value < 0 ? -1 : 0);
      if (-128 <= value && value < 128) {
        Timestamp2.INT_CACHE_[value] = obj;
      }
      return obj;
    };
    Timestamp2.fromNumber = function(value) {
      if (isNaN(value) || !isFinite(value)) {
        return Timestamp2.ZERO;
      } else if (value <= -Timestamp2.TWO_PWR_63_DBL_) {
        return Timestamp2.MIN_VALUE;
      } else if (value + 1 >= Timestamp2.TWO_PWR_63_DBL_) {
        return Timestamp2.MAX_VALUE;
      } else if (value < 0) {
        return Timestamp2.fromNumber(-value).negate();
      } else {
        return new Timestamp2(value % Timestamp2.TWO_PWR_32_DBL_ | 0, value / Timestamp2.TWO_PWR_32_DBL_ | 0);
      }
    };
    Timestamp2.fromBits = function(lowBits, highBits) {
      return new Timestamp2(lowBits, highBits);
    };
    Timestamp2.fromString = function(str, opt_radix) {
      if (str.length === 0) {
        throw Error("number format error: empty string");
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (str.charAt(0) === "-") {
        return Timestamp2.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf("-") >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 8));
      var result = Timestamp2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Timestamp2.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Timestamp2.fromNumber(value));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Timestamp2.fromNumber(value));
        }
      }
      return result;
    };
    Timestamp2.INT_CACHE_ = {};
    Timestamp2.TWO_PWR_16_DBL_ = 1 << 16;
    Timestamp2.TWO_PWR_24_DBL_ = 1 << 24;
    Timestamp2.TWO_PWR_32_DBL_ = Timestamp2.TWO_PWR_16_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
    Timestamp2.TWO_PWR_31_DBL_ = Timestamp2.TWO_PWR_32_DBL_ / 2;
    Timestamp2.TWO_PWR_48_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
    Timestamp2.TWO_PWR_64_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_32_DBL_;
    Timestamp2.TWO_PWR_63_DBL_ = Timestamp2.TWO_PWR_64_DBL_ / 2;
    Timestamp2.ZERO = Timestamp2.fromInt(0);
    Timestamp2.ONE = Timestamp2.fromInt(1);
    Timestamp2.NEG_ONE = Timestamp2.fromInt(-1);
    Timestamp2.MAX_VALUE = Timestamp2.fromBits(4294967295 | 0, 2147483647 | 0);
    Timestamp2.MIN_VALUE = Timestamp2.fromBits(0, 2147483648 | 0);
    Timestamp2.TWO_PWR_24_ = Timestamp2.fromInt(1 << 24);
    module2.exports = Timestamp2;
    module2.exports.Timestamp = Timestamp2;
  }
});

// node_modules/bson/lib/bson/parser/utils.js
var require_utils = __commonJS({
  "node_modules/bson/lib/bson/parser/utils.js"(exports2, module2) {
    "use strict";
    function normalizedFunctionString(fn) {
      return fn.toString().replace(/function *\(/, "function (");
    }
    function newBuffer(item, encoding) {
      return new Buffer(item, encoding);
    }
    function allocBuffer() {
      return Buffer.alloc.apply(Buffer, arguments);
    }
    function toBuffer() {
      return Buffer.from.apply(Buffer, arguments);
    }
    module2.exports = {
      normalizedFunctionString,
      allocBuffer: typeof Buffer.alloc === "function" ? allocBuffer : newBuffer,
      toBuffer: typeof Buffer.from === "function" ? toBuffer : newBuffer
    };
  }
});

// node_modules/bson/lib/bson/objectid.js
var require_objectid = __commonJS({
  "node_modules/bson/lib/bson/objectid.js"(exports2, module2) {
    var inspect = "inspect";
    var utils2 = require_utils();
    var MACHINE_ID = parseInt(Math.random() * 16777215, 10);
    var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
    try {
      if (Buffer && Buffer.from) {
        hasBufferType = true;
        inspect = require("util").inspect.custom || "inspect";
      }
    } catch (err) {
      hasBufferType = false;
    }
    var hasBufferType;
    var ObjectID2 = function ObjectID3(id) {
      if (id instanceof ObjectID3)
        return id;
      if (!(this instanceof ObjectID3))
        return new ObjectID3(id);
      this._bsontype = "ObjectID";
      if (id == null || typeof id === "number") {
        this.id = this.generate(id);
        if (ObjectID3.cacheHexString)
          this.__id = this.toString("hex");
        return;
      }
      var valid = ObjectID3.isValid(id);
      if (!valid && id != null) {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      } else if (valid && typeof id === "string" && id.length === 24 && hasBufferType) {
        return new ObjectID3(utils2.toBuffer(id, "hex"));
      } else if (valid && typeof id === "string" && id.length === 24) {
        return ObjectID3.createFromHexString(id);
      } else if (id != null && id.length === 12) {
        this.id = id;
      } else if (id != null && typeof id.toHexString === "function") {
        return id;
      } else {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      }
      if (ObjectID3.cacheHexString)
        this.__id = this.toString("hex");
    };
    var hexTable = [];
    for (var i = 0; i < 256; i++) {
      hexTable[i] = (i <= 15 ? "0" : "") + i.toString(16);
    }
    ObjectID2.prototype.toHexString = function() {
      if (ObjectID2.cacheHexString && this.__id)
        return this.__id;
      var hexString = "";
      if (!this.id || !this.id.length) {
        throw new Error("invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [" + JSON.stringify(this.id) + "]");
      }
      if (this.id instanceof _Buffer) {
        hexString = convertToHex(this.id);
        if (ObjectID2.cacheHexString)
          this.__id = hexString;
        return hexString;
      }
      for (var i2 = 0; i2 < this.id.length; i2++) {
        hexString += hexTable[this.id.charCodeAt(i2)];
      }
      if (ObjectID2.cacheHexString)
        this.__id = hexString;
      return hexString;
    };
    ObjectID2.prototype.get_inc = function() {
      return ObjectID2.index = (ObjectID2.index + 1) % 16777215;
    };
    ObjectID2.prototype.getInc = function() {
      return this.get_inc();
    };
    ObjectID2.prototype.generate = function(time) {
      if (typeof time !== "number") {
        time = ~~(Date.now() / 1e3);
      }
      var pid = (typeof process === "undefined" || process.pid === 1 ? Math.floor(Math.random() * 1e5) : process.pid) % 65535;
      var inc = this.get_inc();
      var buffer = utils2.allocBuffer(12);
      buffer[3] = time & 255;
      buffer[2] = time >> 8 & 255;
      buffer[1] = time >> 16 & 255;
      buffer[0] = time >> 24 & 255;
      buffer[6] = MACHINE_ID & 255;
      buffer[5] = MACHINE_ID >> 8 & 255;
      buffer[4] = MACHINE_ID >> 16 & 255;
      buffer[8] = pid & 255;
      buffer[7] = pid >> 8 & 255;
      buffer[11] = inc & 255;
      buffer[10] = inc >> 8 & 255;
      buffer[9] = inc >> 16 & 255;
      return buffer;
    };
    ObjectID2.prototype.toString = function(format2) {
      if (this.id && this.id.copy) {
        return this.id.toString(typeof format2 === "string" ? format2 : "hex");
      }
      return this.toHexString();
    };
    ObjectID2.prototype[inspect] = ObjectID2.prototype.toString;
    ObjectID2.prototype.toJSON = function() {
      return this.toHexString();
    };
    ObjectID2.prototype.equals = function equals(otherId) {
      if (otherId instanceof ObjectID2) {
        return this.toString() === otherId.toString();
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12 && this.id instanceof _Buffer) {
        return otherId === this.id.toString("binary");
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 24) {
        return otherId.toLowerCase() === this.toHexString();
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12) {
        return otherId === this.id;
      } else if (otherId != null && (otherId instanceof ObjectID2 || otherId.toHexString)) {
        return otherId.toHexString() === this.toHexString();
      } else {
        return false;
      }
    };
    ObjectID2.prototype.getTimestamp = function() {
      var timestamp = new Date();
      var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      timestamp.setTime(Math.floor(time) * 1e3);
      return timestamp;
    };
    ObjectID2.index = ~~(Math.random() * 16777215);
    ObjectID2.createPk = function createPk() {
      return new ObjectID2();
    };
    ObjectID2.createFromTime = function createFromTime(time) {
      var buffer = utils2.toBuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      buffer[3] = time & 255;
      buffer[2] = time >> 8 & 255;
      buffer[1] = time >> 16 & 255;
      buffer[0] = time >> 24 & 255;
      return new ObjectID2(buffer);
    };
    var decodeLookup = [];
    i = 0;
    while (i < 10)
      decodeLookup[48 + i] = i++;
    while (i < 16)
      decodeLookup[65 - 10 + i] = decodeLookup[97 - 10 + i] = i++;
    var _Buffer = Buffer;
    var convertToHex = function(bytes) {
      return bytes.toString("hex");
    };
    ObjectID2.createFromHexString = function createFromHexString(string2) {
      if (typeof string2 === "undefined" || string2 != null && string2.length !== 24) {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      }
      if (hasBufferType)
        return new ObjectID2(utils2.toBuffer(string2, "hex"));
      var array = new _Buffer(12);
      var n = 0;
      var i2 = 0;
      while (i2 < 24) {
        array[n++] = decodeLookup[string2.charCodeAt(i2++)] << 4 | decodeLookup[string2.charCodeAt(i2++)];
      }
      return new ObjectID2(array);
    };
    ObjectID2.isValid = function isValid(id) {
      if (id == null)
        return false;
      if (typeof id === "number") {
        return true;
      }
      if (typeof id === "string") {
        return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);
      }
      if (id instanceof ObjectID2) {
        return true;
      }
      if (id instanceof _Buffer) {
        return true;
      }
      if (typeof id.toHexString === "function" && (id.id instanceof _Buffer || typeof id.id === "string")) {
        return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);
      }
      return false;
    };
    Object.defineProperty(ObjectID2.prototype, "generationTime", {
      enumerable: true,
      get: function() {
        return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      },
      set: function(value) {
        this.id[3] = value & 255;
        this.id[2] = value >> 8 & 255;
        this.id[1] = value >> 16 & 255;
        this.id[0] = value >> 24 & 255;
      }
    });
    module2.exports = ObjectID2;
    module2.exports.ObjectID = ObjectID2;
    module2.exports.ObjectId = ObjectID2;
  }
});

// node_modules/bson/lib/bson/regexp.js
var require_regexp = __commonJS({
  "node_modules/bson/lib/bson/regexp.js"(exports2, module2) {
    function BSONRegExp2(pattern, options2) {
      if (!(this instanceof BSONRegExp2))
        return new BSONRegExp2();
      this._bsontype = "BSONRegExp";
      this.pattern = pattern || "";
      this.options = options2 || "";
      for (var i = 0; i < this.options.length; i++) {
        if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
          throw new Error("the regular expression options [" + this.options[i] + "] is not supported");
        }
      }
    }
    module2.exports = BSONRegExp2;
    module2.exports.BSONRegExp = BSONRegExp2;
  }
});

// node_modules/bson/lib/bson/symbol.js
var require_symbol = __commonJS({
  "node_modules/bson/lib/bson/symbol.js"(exports2, module2) {
    var inspect = Buffer ? require("util").inspect.custom || "inspect" : "inspect";
    function Symbol2(value) {
      if (!(this instanceof Symbol2))
        return new Symbol2(value);
      this._bsontype = "Symbol";
      this.value = value;
    }
    Symbol2.prototype.valueOf = function() {
      return this.value;
    };
    Symbol2.prototype.toString = function() {
      return this.value;
    };
    Symbol2.prototype[inspect] = function() {
      return this.value;
    };
    Symbol2.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Symbol2;
    module2.exports.Symbol = Symbol2;
  }
});

// node_modules/bson/lib/bson/int_32.js
var require_int_32 = __commonJS({
  "node_modules/bson/lib/bson/int_32.js"(exports2, module2) {
    var Int322 = function(value) {
      if (!(this instanceof Int322))
        return new Int322(value);
      this._bsontype = "Int32";
      this.value = value;
    };
    Int322.prototype.valueOf = function() {
      return this.value;
    };
    Int322.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Int322;
    module2.exports.Int32 = Int322;
  }
});

// node_modules/bson/lib/bson/code.js
var require_code = __commonJS({
  "node_modules/bson/lib/bson/code.js"(exports2, module2) {
    var Code2 = function Code3(code, scope) {
      if (!(this instanceof Code3))
        return new Code3(code, scope);
      this._bsontype = "Code";
      this.code = code;
      this.scope = scope;
    };
    Code2.prototype.toJSON = function() {
      return {scope: this.scope, code: this.code};
    };
    module2.exports = Code2;
    module2.exports.Code = Code2;
  }
});

// node_modules/bson/lib/bson/decimal128.js
var require_decimal128 = __commonJS({
  "node_modules/bson/lib/bson/decimal128.js"(exports2, module2) {
    "use strict";
    var Long2 = require_long();
    var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
    var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
    var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
    var EXPONENT_MAX = 6111;
    var EXPONENT_MIN = -6176;
    var EXPONENT_BIAS = 6176;
    var MAX_DIGITS = 34;
    var NAN_BUFFER = [
      124,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_NEGATIVE_BUFFER = [
      248,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_POSITIVE_BUFFER = [
      120,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
    var utils2 = require_utils();
    var isDigit = function(value) {
      return !isNaN(parseInt(value, 10));
    };
    var divideu128 = function(value) {
      var DIVISOR = Long2.fromNumber(1e3 * 1e3 * 1e3);
      var _rem = Long2.fromNumber(0);
      var i = 0;
      if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
        return {quotient: value, rem: _rem};
      }
      for (i = 0; i <= 3; i++) {
        _rem = _rem.shiftLeft(32);
        _rem = _rem.add(new Long2(value.parts[i], 0));
        value.parts[i] = _rem.div(DIVISOR).low_;
        _rem = _rem.modulo(DIVISOR);
      }
      return {quotient: value, rem: _rem};
    };
    var multiply64x2 = function(left, right) {
      if (!left && !right) {
        return {high: Long2.fromNumber(0), low: Long2.fromNumber(0)};
      }
      var leftHigh = left.shiftRightUnsigned(32);
      var leftLow = new Long2(left.getLowBits(), 0);
      var rightHigh = right.shiftRightUnsigned(32);
      var rightLow = new Long2(right.getLowBits(), 0);
      var productHigh = leftHigh.multiply(rightHigh);
      var productMid = leftHigh.multiply(rightLow);
      var productMid2 = leftLow.multiply(rightHigh);
      var productLow = leftLow.multiply(rightLow);
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productMid = new Long2(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productLow = productMid.shiftLeft(32).add(new Long2(productLow.getLowBits(), 0));
      return {high: productHigh, low: productLow};
    };
    var lessThan = function(left, right) {
      var uhleft = left.high_ >>> 0;
      var uhright = right.high_ >>> 0;
      if (uhleft < uhright) {
        return true;
      } else if (uhleft === uhright) {
        var ulleft = left.low_ >>> 0;
        var ulright = right.low_ >>> 0;
        if (ulleft < ulright)
          return true;
      }
      return false;
    };
    var Decimal1282 = function(bytes) {
      this._bsontype = "Decimal128";
      this.bytes = bytes;
    };
    Decimal1282.fromString = function(string2) {
      var isNegative = false;
      var sawRadix = false;
      var foundNonZero = false;
      var significantDigits = 0;
      var nDigitsRead = 0;
      var nDigits = 0;
      var radixPosition = 0;
      var firstNonZero = 0;
      var digits = [0];
      var nDigitsStored = 0;
      var digitsInsert = 0;
      var firstDigit = 0;
      var lastDigit = 0;
      var exponent = 0;
      var i = 0;
      var significandHigh = [0, 0];
      var significandLow = [0, 0];
      var biasedExponent = 0;
      var index2 = 0;
      string2 = string2.trim();
      if (string2.length >= 7e3) {
        throw new Error("" + string2 + " not a valid Decimal128 string");
      }
      var stringMatch = string2.match(PARSE_STRING_REGEXP);
      var infMatch = string2.match(PARSE_INF_REGEXP);
      var nanMatch = string2.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || string2.length === 0) {
        throw new Error("" + string2 + " not a valid Decimal128 string");
      }
      if (stringMatch && stringMatch[4] && stringMatch[2] === void 0) {
        throw new Error("" + string2 + " not a valid Decimal128 string");
      }
      if (string2[index2] === "+" || string2[index2] === "-") {
        isNegative = string2[index2++] === "-";
      }
      if (!isDigit(string2[index2]) && string2[index2] !== ".") {
        if (string2[index2] === "i" || string2[index2] === "I") {
          return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
        } else if (string2[index2] === "N") {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
      }
      while (isDigit(string2[index2]) || string2[index2] === ".") {
        if (string2[index2] === ".") {
          if (sawRadix) {
            return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
          }
          sawRadix = true;
          index2 = index2 + 1;
          continue;
        }
        if (nDigitsStored < 34) {
          if (string2[index2] !== "0" || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(string2[index2], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero) {
          nDigits = nDigits + 1;
        }
        if (sawRadix) {
          radixPosition = radixPosition + 1;
        }
        nDigitsRead = nDigitsRead + 1;
        index2 = index2 + 1;
      }
      if (sawRadix && !nDigitsRead) {
        throw new Error("" + string2 + " not a valid Decimal128 string");
      }
      if (string2[index2] === "e" || string2[index2] === "E") {
        var match = string2.substr(++index2).match(EXPONENT_REGEX);
        if (!match || !match[2]) {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
        exponent = parseInt(match[0], 10);
        index2 = index2 + match[0].length;
      }
      if (string2[index2]) {
        return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
      }
      firstDigit = 0;
      if (!nDigitsStored) {
        firstDigit = 0;
        lastDigit = 0;
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (exponent !== 0 && significantDigits !== 1) {
          while (string2[firstNonZero + significantDigits - 1] === "0") {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit - firstDigit > MAX_DIGITS) {
          var digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
        exponent = exponent - 1;
      }
      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
        if (lastDigit === 0) {
          exponent = EXPONENT_MIN;
          significantDigits = 0;
          break;
        }
        if (nDigitsStored < nDigits) {
          nDigits = nDigits - 1;
        } else {
          lastDigit = lastDigit - 1;
        }
        if (exponent < EXPONENT_MAX) {
          exponent = exponent + 1;
        } else {
          digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
      }
      if (lastDigit - firstDigit + 1 < significantDigits && string2[significantDigits] !== "0") {
        var endOfString = nDigitsRead;
        if (sawRadix && exponent === EXPONENT_MIN) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        var roundDigit = parseInt(string2[firstNonZero + lastDigit + 1], 10);
        var roundBit = 0;
        if (roundDigit >= 5) {
          roundBit = 1;
          if (roundDigit === 5) {
            roundBit = digits[lastDigit] % 2 === 1;
            for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
              if (parseInt(string2[i], 10)) {
                roundBit = 1;
                break;
              }
            }
          }
        }
        if (roundBit) {
          var dIdx = lastDigit;
          for (; dIdx >= 0; dIdx--) {
            if (++digits[dIdx] > 9) {
              digits[dIdx] = 0;
              if (dIdx === 0) {
                if (exponent < EXPONENT_MAX) {
                  exponent = exponent + 1;
                  digits[dIdx] = 1;
                } else {
                  return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
                }
              }
            } else {
              break;
            }
          }
        }
      }
      significandHigh = Long2.fromNumber(0);
      significandLow = Long2.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = Long2.fromNumber(0);
        significandLow = Long2.fromNumber(0);
      } else if (lastDigit - firstDigit < 17) {
        dIdx = firstDigit;
        significandLow = Long2.fromNumber(digits[dIdx++]);
        significandHigh = new Long2(0, 0);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long2.fromNumber(10));
          significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
        }
      } else {
        dIdx = firstDigit;
        significandHigh = Long2.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(Long2.fromNumber(10));
          significandHigh = significandHigh.add(Long2.fromNumber(digits[dIdx]));
        }
        significandLow = Long2.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long2.fromNumber(10));
          significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
        }
      }
      var significand = multiply64x2(significandHigh, Long2.fromString("100000000000000000"));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(Long2.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      var dec2 = {low: Long2.fromNumber(0), high: Long2.fromNumber(0)};
      if (significand.high.shiftRightUnsigned(49).and(Long2.fromNumber(1)).equals(Long2.fromNumber)) {
        dec2.high = dec2.high.or(Long2.fromNumber(3).shiftLeft(61));
        dec2.high = dec2.high.or(Long2.fromNumber(biasedExponent).and(Long2.fromNumber(16383).shiftLeft(47)));
        dec2.high = dec2.high.or(significand.high.and(Long2.fromNumber(140737488355327)));
      } else {
        dec2.high = dec2.high.or(Long2.fromNumber(biasedExponent & 16383).shiftLeft(49));
        dec2.high = dec2.high.or(significand.high.and(Long2.fromNumber(562949953421311)));
      }
      dec2.low = significand.low;
      if (isNegative) {
        dec2.high = dec2.high.or(Long2.fromString("9223372036854775808"));
      }
      var buffer = utils2.allocBuffer(16);
      index2 = 0;
      buffer[index2++] = dec2.low.low_ & 255;
      buffer[index2++] = dec2.low.low_ >> 8 & 255;
      buffer[index2++] = dec2.low.low_ >> 16 & 255;
      buffer[index2++] = dec2.low.low_ >> 24 & 255;
      buffer[index2++] = dec2.low.high_ & 255;
      buffer[index2++] = dec2.low.high_ >> 8 & 255;
      buffer[index2++] = dec2.low.high_ >> 16 & 255;
      buffer[index2++] = dec2.low.high_ >> 24 & 255;
      buffer[index2++] = dec2.high.low_ & 255;
      buffer[index2++] = dec2.high.low_ >> 8 & 255;
      buffer[index2++] = dec2.high.low_ >> 16 & 255;
      buffer[index2++] = dec2.high.low_ >> 24 & 255;
      buffer[index2++] = dec2.high.high_ & 255;
      buffer[index2++] = dec2.high.high_ >> 8 & 255;
      buffer[index2++] = dec2.high.high_ >> 16 & 255;
      buffer[index2++] = dec2.high.high_ >> 24 & 255;
      return new Decimal1282(buffer);
    };
    var COMBINATION_MASK = 31;
    var EXPONENT_MASK = 16383;
    var COMBINATION_INFINITY = 30;
    var COMBINATION_NAN = 31;
    EXPONENT_BIAS = 6176;
    Decimal1282.prototype.toString = function() {
      var high;
      var midh;
      var midl;
      var low;
      var combination;
      var biased_exponent;
      var significand_digits = 0;
      var significand = new Array(36);
      for (var i = 0; i < significand.length; i++)
        significand[i] = 0;
      var index2 = 0;
      var exponent;
      var scientific_exponent;
      var is_zero = false;
      var significand_msb;
      var significand128 = {parts: new Array(4)};
      i;
      var j, k;
      var string2 = [];
      index2 = 0;
      var buffer = this.bytes;
      low = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      midl = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      midh = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      high = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      index2 = 0;
      var dec2 = {
        low: new Long2(low, midl),
        high: new Long2(midh, high)
      };
      if (dec2.high.lessThan(Long2.ZERO)) {
        string2.push("-");
      }
      combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string2.join("") + "Infinity";
        } else if (combination === COMBINATION_NAN) {
          return "NaN";
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 8 + (high >> 14 & 1);
        }
      } else {
        significand_msb = high >> 14 & 7;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k = 3; k >= 0; k--) {
          var least_digits = 0;
          var result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low_;
          if (!least_digits)
            continue;
          for (j = 8; j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index2] = 0;
      } else {
        significand_digits = 36;
        i = 0;
        while (!significand[index2]) {
          i++;
          significand_digits = significand_digits - 1;
          index2 = index2 + 1;
        }
      }
      scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        string2.push(significand[index2++]);
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string2.push(".");
        }
        for (i = 0; i < significand_digits; i++) {
          string2.push(significand[index2++]);
        }
        string2.push("E");
        if (scientific_exponent > 0) {
          string2.push("+" + scientific_exponent);
        } else {
          string2.push(scientific_exponent);
        }
      } else {
        if (exponent >= 0) {
          for (i = 0; i < significand_digits; i++) {
            string2.push(significand[index2++]);
          }
        } else {
          var radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (i = 0; i < radix_position; i++) {
              string2.push(significand[index2++]);
            }
          } else {
            string2.push("0");
          }
          string2.push(".");
          while (radix_position++ < 0) {
            string2.push("0");
          }
          for (i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
            string2.push(significand[index2++]);
          }
        }
      }
      return string2.join("");
    };
    Decimal1282.prototype.toJSON = function() {
      return {$numberDecimal: this.toString()};
    };
    module2.exports = Decimal1282;
    module2.exports.Decimal128 = Decimal1282;
  }
});

// node_modules/bson/lib/bson/min_key.js
var require_min_key = __commonJS({
  "node_modules/bson/lib/bson/min_key.js"(exports2, module2) {
    function MinKey2() {
      if (!(this instanceof MinKey2))
        return new MinKey2();
      this._bsontype = "MinKey";
    }
    module2.exports = MinKey2;
    module2.exports.MinKey = MinKey2;
  }
});

// node_modules/bson/lib/bson/max_key.js
var require_max_key = __commonJS({
  "node_modules/bson/lib/bson/max_key.js"(exports2, module2) {
    function MaxKey2() {
      if (!(this instanceof MaxKey2))
        return new MaxKey2();
      this._bsontype = "MaxKey";
    }
    module2.exports = MaxKey2;
    module2.exports.MaxKey = MaxKey2;
  }
});

// node_modules/bson/lib/bson/db_ref.js
var require_db_ref = __commonJS({
  "node_modules/bson/lib/bson/db_ref.js"(exports2, module2) {
    function DBRef2(namespace, oid, db) {
      if (!(this instanceof DBRef2))
        return new DBRef2(namespace, oid, db);
      this._bsontype = "DBRef";
      this.namespace = namespace;
      this.oid = oid;
      this.db = db;
    }
    DBRef2.prototype.toJSON = function() {
      return {
        $ref: this.namespace,
        $id: this.oid,
        $db: this.db == null ? "" : this.db
      };
    };
    module2.exports = DBRef2;
    module2.exports.DBRef = DBRef2;
  }
});

// node_modules/bson/lib/bson/binary.js
var require_binary = __commonJS({
  "node_modules/bson/lib/bson/binary.js"(exports2, module2) {
    if (typeof global !== "undefined") {
      Buffer2 = require("buffer").Buffer;
    }
    var Buffer2;
    var utils2 = require_utils();
    function Binary2(buffer, subType) {
      if (!(this instanceof Binary2))
        return new Binary2(buffer, subType);
      if (buffer != null && !(typeof buffer === "string") && !Buffer2.isBuffer(buffer) && !(buffer instanceof Uint8Array) && !Array.isArray(buffer)) {
        throw new Error("only String, Buffer, Uint8Array or Array accepted");
      }
      this._bsontype = "Binary";
      if (buffer instanceof Number) {
        this.sub_type = buffer;
        this.position = 0;
      } else {
        this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
        this.position = 0;
      }
      if (buffer != null && !(buffer instanceof Number)) {
        if (typeof buffer === "string") {
          if (typeof Buffer2 !== "undefined") {
            this.buffer = utils2.toBuffer(buffer);
          } else if (typeof Uint8Array !== "undefined" || Object.prototype.toString.call(buffer) === "[object Array]") {
            this.buffer = writeStringToArray(buffer);
          } else {
            throw new Error("only String, Buffer, Uint8Array or Array accepted");
          }
        } else {
          this.buffer = buffer;
        }
        this.position = buffer.length;
      } else {
        if (typeof Buffer2 !== "undefined") {
          this.buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE);
        } else if (typeof Uint8Array !== "undefined") {
          this.buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE));
        } else {
          this.buffer = new Array(Binary2.BUFFER_SIZE);
        }
        this.position = 0;
      }
    }
    Binary2.prototype.put = function put(byte_value) {
      if (byte_value["length"] != null && typeof byte_value !== "number" && byte_value.length !== 1)
        throw new Error("only accepts single character String, Uint8Array or Array");
      if (typeof byte_value !== "number" && byte_value < 0 || byte_value > 255)
        throw new Error("only accepts number in a valid unsigned byte range 0-255");
      var decoded_byte = null;
      if (typeof byte_value === "string") {
        decoded_byte = byte_value.charCodeAt(0);
      } else if (byte_value["length"] != null) {
        decoded_byte = byte_value[0];
      } else {
        decoded_byte = byte_value;
      }
      if (this.buffer.length > this.position) {
        this.buffer[this.position++] = decoded_byte;
      } else {
        if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
          var buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE + this.buffer.length);
          this.buffer.copy(buffer, 0, 0, this.buffer.length);
          this.buffer = buffer;
          this.buffer[this.position++] = decoded_byte;
        } else {
          buffer = null;
          if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
            buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE + this.buffer.length));
          } else {
            buffer = new Array(Binary2.BUFFER_SIZE + this.buffer.length);
          }
          for (var i = 0; i < this.buffer.length; i++) {
            buffer[i] = this.buffer[i];
          }
          this.buffer = buffer;
          this.buffer[this.position++] = decoded_byte;
        }
      }
    };
    Binary2.prototype.write = function write(string2, offset) {
      offset = typeof offset === "number" ? offset : this.position;
      if (this.buffer.length < offset + string2.length) {
        var buffer = null;
        if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
          buffer = utils2.allocBuffer(this.buffer.length + string2.length);
          this.buffer.copy(buffer, 0, 0, this.buffer.length);
        } else if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
          buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string2.length));
          for (var i = 0; i < this.position; i++) {
            buffer[i] = this.buffer[i];
          }
        }
        this.buffer = buffer;
      }
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(string2) && Buffer2.isBuffer(this.buffer)) {
        string2.copy(this.buffer, offset, 0, string2.length);
        this.position = offset + string2.length > this.position ? offset + string2.length : this.position;
      } else if (typeof Buffer2 !== "undefined" && typeof string2 === "string" && Buffer2.isBuffer(this.buffer)) {
        this.buffer.write(string2, offset, "binary");
        this.position = offset + string2.length > this.position ? offset + string2.length : this.position;
      } else if (Object.prototype.toString.call(string2) === "[object Uint8Array]" || Object.prototype.toString.call(string2) === "[object Array]" && typeof string2 !== "string") {
        for (i = 0; i < string2.length; i++) {
          this.buffer[offset++] = string2[i];
        }
        this.position = offset > this.position ? offset : this.position;
      } else if (typeof string2 === "string") {
        for (i = 0; i < string2.length; i++) {
          this.buffer[offset++] = string2.charCodeAt(i);
        }
        this.position = offset > this.position ? offset : this.position;
      }
    };
    Binary2.prototype.read = function read2(position, length) {
      length = length && length > 0 ? length : this.position;
      if (this.buffer["slice"]) {
        return this.buffer.slice(position, position + length);
      } else {
        var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
        for (var i = 0; i < length; i++) {
          buffer[i] = this.buffer[position++];
        }
      }
      return buffer;
    };
    Binary2.prototype.value = function value(asRaw) {
      asRaw = asRaw == null ? false : asRaw;
      if (asRaw && typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer) && this.buffer.length === this.position)
        return this.buffer;
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
        return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString("binary", 0, this.position);
      } else {
        if (asRaw) {
          if (this.buffer["slice"] != null) {
            return this.buffer.slice(0, this.position);
          } else {
            var newBuffer = Object.prototype.toString.call(this.buffer) === "[object Uint8Array]" ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
            for (var i = 0; i < this.position; i++) {
              newBuffer[i] = this.buffer[i];
            }
            return newBuffer;
          }
        } else {
          return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
        }
      }
    };
    Binary2.prototype.length = function length() {
      return this.position;
    };
    Binary2.prototype.toJSON = function() {
      return this.buffer != null ? this.buffer.toString("base64") : "";
    };
    Binary2.prototype.toString = function(format2) {
      return this.buffer != null ? this.buffer.slice(0, this.position).toString(format2) : "";
    };
    var BSON_BINARY_SUBTYPE_DEFAULT = 0;
    var writeStringToArray = function(data) {
      var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        buffer[i] = data.charCodeAt(i);
      }
      return buffer;
    };
    var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
      var result = "";
      for (var i = startIndex; i < endIndex; i++) {
        result = result + String.fromCharCode(byteArray[i]);
      }
      return result;
    };
    Binary2.BUFFER_SIZE = 256;
    Binary2.SUBTYPE_DEFAULT = 0;
    Binary2.SUBTYPE_FUNCTION = 1;
    Binary2.SUBTYPE_BYTE_ARRAY = 2;
    Binary2.SUBTYPE_UUID_OLD = 3;
    Binary2.SUBTYPE_UUID = 4;
    Binary2.SUBTYPE_MD5 = 5;
    Binary2.SUBTYPE_USER_DEFINED = 128;
    module2.exports = Binary2;
    module2.exports.Binary = Binary2;
  }
});

// node_modules/bson/lib/bson/parser/deserializer.js
var require_deserializer = __commonJS({
  "node_modules/bson/lib/bson/parser/deserializer.js"(exports, module) {
    "use strict";
    var Long = require_long().Long;
    var Double = require_double().Double;
    var Timestamp = require_timestamp().Timestamp;
    var ObjectID = require_objectid().ObjectID;
    var Symbol = require_symbol().Symbol;
    var Code = require_code().Code;
    var MinKey = require_min_key().MinKey;
    var MaxKey = require_max_key().MaxKey;
    var Decimal128 = require_decimal128();
    var Int32 = require_int_32();
    var DBRef = require_db_ref().DBRef;
    var BSONRegExp = require_regexp().BSONRegExp;
    var Binary = require_binary().Binary;
    var utils = require_utils();
    var deserialize = function(buffer, options2, isArray) {
      options2 = options2 == null ? {} : options2;
      var index2 = options2 && options2.index ? options2.index : 0;
      var size = buffer[index2] | buffer[index2 + 1] << 8 | buffer[index2 + 2] << 16 | buffer[index2 + 3] << 24;
      if (size < 5 || buffer.length < size || size + index2 > buffer.length) {
        throw new Error("corrupt bson message");
      }
      if (buffer[index2 + size - 1] !== 0) {
        throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
      }
      return deserializeObject(buffer, index2, options2, isArray);
    };
    var deserializeObject = function(buffer, index2, options2, isArray) {
      var evalFunctions = options2["evalFunctions"] == null ? false : options2["evalFunctions"];
      var cacheFunctions = options2["cacheFunctions"] == null ? false : options2["cacheFunctions"];
      var cacheFunctionsCrc32 = options2["cacheFunctionsCrc32"] == null ? false : options2["cacheFunctionsCrc32"];
      if (!cacheFunctionsCrc32)
        var crc32 = null;
      var fieldsAsRaw = options2["fieldsAsRaw"] == null ? null : options2["fieldsAsRaw"];
      var raw = options2["raw"] == null ? false : options2["raw"];
      var bsonRegExp = typeof options2["bsonRegExp"] === "boolean" ? options2["bsonRegExp"] : false;
      var promoteBuffers = options2["promoteBuffers"] == null ? false : options2["promoteBuffers"];
      var promoteLongs = options2["promoteLongs"] == null ? true : options2["promoteLongs"];
      var promoteValues = options2["promoteValues"] == null ? true : options2["promoteValues"];
      var startIndex = index2;
      if (buffer.length < 5)
        throw new Error("corrupt bson message < 5 bytes long");
      var size = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      if (size < 5 || size > buffer.length)
        throw new Error("corrupt bson message");
      var object = isArray ? [] : {};
      var arrayIndex = 0;
      var done = false;
      while (!done) {
        var elementType = buffer[index2++];
        if (elementType === 0)
          break;
        var i = index2;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error("Bad BSON Document: illegal CString");
        var name2 = isArray ? arrayIndex++ : buffer.toString("utf8", index2, i);
        index2 = i + 1;
        if (elementType === BSON.BSON_DATA_STRING) {
          var stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          object[name2] = buffer.toString("utf8", index2, index2 + stringSize - 1);
          index2 = index2 + stringSize;
        } else if (elementType === BSON.BSON_DATA_OID) {
          var oid = utils.allocBuffer(12);
          buffer.copy(oid, 0, index2, index2 + 12);
          object[name2] = new ObjectID(oid);
          index2 = index2 + 12;
        } else if (elementType === BSON.BSON_DATA_INT && promoteValues === false) {
          object[name2] = new Int32(buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24);
        } else if (elementType === BSON.BSON_DATA_INT) {
          object[name2] = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
        } else if (elementType === BSON.BSON_DATA_NUMBER && promoteValues === false) {
          object[name2] = new Double(buffer.readDoubleLE(index2));
          index2 = index2 + 8;
        } else if (elementType === BSON.BSON_DATA_NUMBER) {
          object[name2] = buffer.readDoubleLE(index2);
          index2 = index2 + 8;
        } else if (elementType === BSON.BSON_DATA_DATE) {
          var lowBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          var highBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          object[name2] = new Date(new Long(lowBits, highBits).toNumber());
        } else if (elementType === BSON.BSON_DATA_BOOLEAN) {
          if (buffer[index2] !== 0 && buffer[index2] !== 1)
            throw new Error("illegal boolean type value");
          object[name2] = buffer[index2++] === 1;
        } else if (elementType === BSON.BSON_DATA_OBJECT) {
          var _index = index2;
          var objectSize = buffer[index2] | buffer[index2 + 1] << 8 | buffer[index2 + 2] << 16 | buffer[index2 + 3] << 24;
          if (objectSize <= 0 || objectSize > buffer.length - index2)
            throw new Error("bad embedded document length in bson");
          if (raw) {
            object[name2] = buffer.slice(index2, index2 + objectSize);
          } else {
            object[name2] = deserializeObject(buffer, _index, options2, false);
          }
          index2 = index2 + objectSize;
        } else if (elementType === BSON.BSON_DATA_ARRAY) {
          _index = index2;
          objectSize = buffer[index2] | buffer[index2 + 1] << 8 | buffer[index2 + 2] << 16 | buffer[index2 + 3] << 24;
          var arrayOptions = options2;
          var stopIndex = index2 + objectSize;
          if (fieldsAsRaw && fieldsAsRaw[name2]) {
            arrayOptions = {};
            for (var n in options2)
              arrayOptions[n] = options2[n];
            arrayOptions["raw"] = true;
          }
          object[name2] = deserializeObject(buffer, _index, arrayOptions, true);
          index2 = index2 + objectSize;
          if (buffer[index2 - 1] !== 0)
            throw new Error("invalid array terminator byte");
          if (index2 !== stopIndex)
            throw new Error("corrupted array bson");
        } else if (elementType === BSON.BSON_DATA_UNDEFINED) {
          object[name2] = void 0;
        } else if (elementType === BSON.BSON_DATA_NULL) {
          object[name2] = null;
        } else if (elementType === BSON.BSON_DATA_LONG) {
          lowBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          highBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          var long = new Long(lowBits, highBits);
          if (promoteLongs && promoteValues === true) {
            object[name2] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
          } else {
            object[name2] = long;
          }
        } else if (elementType === BSON.BSON_DATA_DECIMAL128) {
          var bytes = utils.allocBuffer(16);
          buffer.copy(bytes, 0, index2, index2 + 16);
          index2 = index2 + 16;
          var decimal128 = new Decimal128(bytes);
          object[name2] = decimal128.toObject ? decimal128.toObject() : decimal128;
        } else if (elementType === BSON.BSON_DATA_BINARY) {
          var binarySize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          var totalBinarySize = binarySize;
          var subType = buffer[index2++];
          if (binarySize < 0)
            throw new Error("Negative binary type element size found");
          if (binarySize > buffer.length)
            throw new Error("Binary type size larger than document size");
          if (buffer["slice"] != null) {
            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
              if (binarySize < 0)
                throw new Error("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to short binary size");
            }
            if (promoteBuffers && promoteValues) {
              object[name2] = buffer.slice(index2, index2 + binarySize);
            } else {
              object[name2] = new Binary(buffer.slice(index2, index2 + binarySize), subType);
            }
          } else {
            var _buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
              if (binarySize < 0)
                throw new Error("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to short binary size");
            }
            for (i = 0; i < binarySize; i++) {
              _buffer[i] = buffer[index2 + i];
            }
            if (promoteBuffers && promoteValues) {
              object[name2] = _buffer;
            } else {
              object[name2] = new Binary(_buffer, subType);
            }
          }
          index2 = index2 + binarySize;
        } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === false) {
          i = index2;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          var source = buffer.toString("utf8", index2, i);
          index2 = i + 1;
          i = index2;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          var regExpOptions = buffer.toString("utf8", index2, i);
          index2 = i + 1;
          var optionsArray = new Array(regExpOptions.length);
          for (i = 0; i < regExpOptions.length; i++) {
            switch (regExpOptions[i]) {
              case "m":
                optionsArray[i] = "m";
                break;
              case "s":
                optionsArray[i] = "g";
                break;
              case "i":
                optionsArray[i] = "i";
                break;
            }
          }
          object[name2] = new RegExp(source, optionsArray.join(""));
        } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === true) {
          i = index2;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          source = buffer.toString("utf8", index2, i);
          index2 = i + 1;
          i = index2;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          regExpOptions = buffer.toString("utf8", index2, i);
          index2 = i + 1;
          object[name2] = new BSONRegExp(source, regExpOptions);
        } else if (elementType === BSON.BSON_DATA_SYMBOL) {
          stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          object[name2] = new Symbol(buffer.toString("utf8", index2, index2 + stringSize - 1));
          index2 = index2 + stringSize;
        } else if (elementType === BSON.BSON_DATA_TIMESTAMP) {
          lowBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          highBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          object[name2] = new Timestamp(lowBits, highBits);
        } else if (elementType === BSON.BSON_DATA_MIN_KEY) {
          object[name2] = new MinKey();
        } else if (elementType === BSON.BSON_DATA_MAX_KEY) {
          object[name2] = new MaxKey();
        } else if (elementType === BSON.BSON_DATA_CODE) {
          stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          var functionString = buffer.toString("utf8", index2, index2 + stringSize - 1);
          if (evalFunctions) {
            if (cacheFunctions) {
              var hash2 = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
              object[name2] = isolateEvalWithHash(functionCache, hash2, functionString, object);
            } else {
              object[name2] = isolateEval(functionString);
            }
          } else {
            object[name2] = new Code(functionString);
          }
          index2 = index2 + stringSize;
        } else if (elementType === BSON.BSON_DATA_CODE_W_SCOPE) {
          var totalSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (totalSize < 4 + 4 + 4 + 1) {
            throw new Error("code_w_scope total size shorter minimum expected length");
          }
          stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          functionString = buffer.toString("utf8", index2, index2 + stringSize - 1);
          index2 = index2 + stringSize;
          _index = index2;
          objectSize = buffer[index2] | buffer[index2 + 1] << 8 | buffer[index2 + 2] << 16 | buffer[index2 + 3] << 24;
          var scopeObject = deserializeObject(buffer, _index, options2, false);
          index2 = index2 + objectSize;
          if (totalSize < 4 + 4 + objectSize + stringSize) {
            throw new Error("code_w_scope total size is to short, truncating scope");
          }
          if (totalSize > 4 + 4 + objectSize + stringSize) {
            throw new Error("code_w_scope total size is to long, clips outer document");
          }
          if (evalFunctions) {
            if (cacheFunctions) {
              hash2 = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
              object[name2] = isolateEvalWithHash(functionCache, hash2, functionString, object);
            } else {
              object[name2] = isolateEval(functionString);
            }
            object[name2].scope = scopeObject;
          } else {
            object[name2] = new Code(functionString, scopeObject);
          }
        } else if (elementType === BSON.BSON_DATA_DBPOINTER) {
          stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          var namespace = buffer.toString("utf8", index2, index2 + stringSize - 1);
          index2 = index2 + stringSize;
          var oidBuffer = utils.allocBuffer(12);
          buffer.copy(oidBuffer, 0, index2, index2 + 12);
          oid = new ObjectID(oidBuffer);
          index2 = index2 + 12;
          var parts = namespace.split(".");
          var db = parts.shift();
          var collection = parts.join(".");
          object[name2] = new DBRef(collection, oid, db);
        } else {
          throw new Error("Detected unknown BSON type " + elementType.toString(16) + ' for fieldname "' + name2 + '", are you using the latest BSON parser');
        }
      }
      if (size !== index2 - startIndex) {
        if (isArray)
          throw new Error("corrupt array bson");
        throw new Error("corrupt object bson");
      }
      if (object["$id"] != null)
        object = new DBRef(object["$ref"], object["$id"], object["$db"]);
      return object;
    };
    var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
      var value = null;
      if (functionCache[hash] == null) {
        eval("value = " + functionString);
        functionCache[hash] = value;
      }
      return functionCache[hash].bind(object);
    };
    var isolateEval = function(functionString) {
      var value = null;
      eval("value = " + functionString);
      return value;
    };
    var BSON = {};
    var functionCache = BSON.functionCache = {};
    BSON.BSON_DATA_NUMBER = 1;
    BSON.BSON_DATA_STRING = 2;
    BSON.BSON_DATA_OBJECT = 3;
    BSON.BSON_DATA_ARRAY = 4;
    BSON.BSON_DATA_BINARY = 5;
    BSON.BSON_DATA_UNDEFINED = 6;
    BSON.BSON_DATA_OID = 7;
    BSON.BSON_DATA_BOOLEAN = 8;
    BSON.BSON_DATA_DATE = 9;
    BSON.BSON_DATA_NULL = 10;
    BSON.BSON_DATA_REGEXP = 11;
    BSON.BSON_DATA_DBPOINTER = 12;
    BSON.BSON_DATA_CODE = 13;
    BSON.BSON_DATA_SYMBOL = 14;
    BSON.BSON_DATA_CODE_W_SCOPE = 15;
    BSON.BSON_DATA_INT = 16;
    BSON.BSON_DATA_TIMESTAMP = 17;
    BSON.BSON_DATA_LONG = 18;
    BSON.BSON_DATA_DECIMAL128 = 19;
    BSON.BSON_DATA_MIN_KEY = 255;
    BSON.BSON_DATA_MAX_KEY = 127;
    BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON.BSON_INT32_MAX = 2147483647;
    BSON.BSON_INT32_MIN = -2147483648;
    BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON.JS_INT_MAX = 9007199254740992;
    BSON.JS_INT_MIN = -9007199254740992;
    var JS_INT_MAX_LONG = Long.fromNumber(9007199254740992);
    var JS_INT_MIN_LONG = Long.fromNumber(-9007199254740992);
    module.exports = deserialize;
  }
});

// node_modules/bson/lib/bson/float_parser.js
var require_float_parser = __commonJS({
  "node_modules/bson/lib/bson/float_parser.js"(exports2) {
    var readIEEE754 = function(buffer, offset, endian, mLen, nBytes) {
      var e, m, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = bBE ? 0 : nBytes - 1, d = bBE ? 1 : -1, s2 = buffer[offset + i];
      i += d;
      e = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8)
        ;
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8)
        ;
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    var writeIEEE754 = function(buffer, value, offset, endian, mLen, nBytes) {
      var e, m, c, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = bBE ? nBytes - 1 : 0, d = bBE ? -1 : 1, s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8)
        ;
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8)
        ;
      buffer[offset + i - d] |= s2 * 128;
    };
    exports2.readIEEE754 = readIEEE754;
    exports2.writeIEEE754 = writeIEEE754;
  }
});

// node_modules/bson/lib/bson/parser/serializer.js
var require_serializer = __commonJS({
  "node_modules/bson/lib/bson/parser/serializer.js"(exports2, module2) {
    "use strict";
    var writeIEEE754 = require_float_parser().writeIEEE754;
    var Long2 = require_long().Long;
    var Map2 = require_map();
    var Binary2 = require_binary().Binary;
    var normalizedFunctionString = require_utils().normalizedFunctionString;
    var regexp = /\x00/;
    var ignoreKeys = ["$db", "$ref", "$id", "$clusterTime"];
    var isDate = function isDate2(d) {
      return typeof d === "object" && Object.prototype.toString.call(d) === "[object Date]";
    };
    var isRegExp = function isRegExp2(d) {
      return Object.prototype.toString.call(d) === "[object RegExp]";
    };
    var serializeString = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_STRING;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes + 1;
      buffer[index2 - 1] = 0;
      var size = buffer.write(value, index2 + 4, "utf8");
      buffer[index2 + 3] = size + 1 >> 24 & 255;
      buffer[index2 + 2] = size + 1 >> 16 & 255;
      buffer[index2 + 1] = size + 1 >> 8 & 255;
      buffer[index2] = size + 1 & 255;
      index2 = index2 + 4 + size;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeNumber = function(buffer, key, value, index2, isArray) {
      if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
        if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
          buffer[index2++] = BSON2.BSON_DATA_INT;
          var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
          index2 = index2 + numberOfWrittenBytes;
          buffer[index2++] = 0;
          buffer[index2++] = value & 255;
          buffer[index2++] = value >> 8 & 255;
          buffer[index2++] = value >> 16 & 255;
          buffer[index2++] = value >> 24 & 255;
        } else if (value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
          buffer[index2++] = BSON2.BSON_DATA_NUMBER;
          numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
          index2 = index2 + numberOfWrittenBytes;
          buffer[index2++] = 0;
          writeIEEE754(buffer, value, index2, "little", 52, 8);
          index2 = index2 + 8;
        } else {
          buffer[index2++] = BSON2.BSON_DATA_LONG;
          numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
          index2 = index2 + numberOfWrittenBytes;
          buffer[index2++] = 0;
          var longVal = Long2.fromNumber(value);
          var lowBits = longVal.getLowBits();
          var highBits = longVal.getHighBits();
          buffer[index2++] = lowBits & 255;
          buffer[index2++] = lowBits >> 8 & 255;
          buffer[index2++] = lowBits >> 16 & 255;
          buffer[index2++] = lowBits >> 24 & 255;
          buffer[index2++] = highBits & 255;
          buffer[index2++] = highBits >> 8 & 255;
          buffer[index2++] = highBits >> 16 & 255;
          buffer[index2++] = highBits >> 24 & 255;
        }
      } else {
        buffer[index2++] = BSON2.BSON_DATA_NUMBER;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
        index2 = index2 + numberOfWrittenBytes;
        buffer[index2++] = 0;
        writeIEEE754(buffer, value, index2, "little", 52, 8);
        index2 = index2 + 8;
      }
      return index2;
    };
    var serializeNull = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_NULL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeBoolean = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_BOOLEAN;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      buffer[index2++] = value ? 1 : 0;
      return index2;
    };
    var serializeDate = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_DATE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var dateInMilis = Long2.fromNumber(value.getTime());
      var lowBits = dateInMilis.getLowBits();
      var highBits = dateInMilis.getHighBits();
      buffer[index2++] = lowBits & 255;
      buffer[index2++] = lowBits >> 8 & 255;
      buffer[index2++] = lowBits >> 16 & 255;
      buffer[index2++] = lowBits >> 24 & 255;
      buffer[index2++] = highBits & 255;
      buffer[index2++] = highBits >> 8 & 255;
      buffer[index2++] = highBits >> 16 & 255;
      buffer[index2++] = highBits >> 24 & 255;
      return index2;
    };
    var serializeRegExp = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      if (value.source && value.source.match(regexp) != null) {
        throw Error("value " + value.source + " must not contain null bytes");
      }
      index2 = index2 + buffer.write(value.source, index2, "utf8");
      buffer[index2++] = 0;
      if (value.global)
        buffer[index2++] = 115;
      if (value.ignoreCase)
        buffer[index2++] = 105;
      if (value.multiline)
        buffer[index2++] = 109;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeBSONRegExp = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      if (value.pattern.match(regexp) != null) {
        throw Error("pattern " + value.pattern + " must not contain null bytes");
      }
      index2 = index2 + buffer.write(value.pattern, index2, "utf8");
      buffer[index2++] = 0;
      index2 = index2 + buffer.write(value.options.split("").sort().join(""), index2, "utf8");
      buffer[index2++] = 0;
      return index2;
    };
    var serializeMinMax = function(buffer, key, value, index2, isArray) {
      if (value === null) {
        buffer[index2++] = BSON2.BSON_DATA_NULL;
      } else if (value._bsontype === "MinKey") {
        buffer[index2++] = BSON2.BSON_DATA_MIN_KEY;
      } else {
        buffer[index2++] = BSON2.BSON_DATA_MAX_KEY;
      }
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeObjectId = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_OID;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      if (typeof value.id === "string") {
        buffer.write(value.id, index2, "binary");
      } else if (value.id && value.id.copy) {
        value.id.copy(buffer, index2, 0, 12);
      } else {
        throw new Error("object [" + JSON.stringify(value) + "] is not a valid ObjectId");
      }
      return index2 + 12;
    };
    var serializeBuffer = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var size = value.length;
      buffer[index2++] = size & 255;
      buffer[index2++] = size >> 8 & 255;
      buffer[index2++] = size >> 16 & 255;
      buffer[index2++] = size >> 24 & 255;
      buffer[index2++] = BSON2.BSON_BINARY_SUBTYPE_DEFAULT;
      value.copy(buffer, index2, 0, size);
      index2 = index2 + size;
      return index2;
    };
    var serializeObject = function(buffer, key, value, index2, checkKeys, depth2, serializeFunctions, ignoreUndefined, isArray, path) {
      for (var i = 0; i < path.length; i++) {
        if (path[i] === value)
          throw new Error("cyclic dependency detected");
      }
      path.push(value);
      buffer[index2++] = Array.isArray(value) ? BSON2.BSON_DATA_ARRAY : BSON2.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var endIndex = serializeInto(buffer, value, checkKeys, index2, depth2 + 1, serializeFunctions, ignoreUndefined, path);
      path.pop();
      return endIndex;
    };
    var serializeDecimal128 = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_DECIMAL128;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      value.bytes.copy(buffer, index2, 0, 16);
      return index2 + 16;
    };
    var serializeLong = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = value._bsontype === "Long" ? BSON2.BSON_DATA_LONG : BSON2.BSON_DATA_TIMESTAMP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var lowBits = value.getLowBits();
      var highBits = value.getHighBits();
      buffer[index2++] = lowBits & 255;
      buffer[index2++] = lowBits >> 8 & 255;
      buffer[index2++] = lowBits >> 16 & 255;
      buffer[index2++] = lowBits >> 24 & 255;
      buffer[index2++] = highBits & 255;
      buffer[index2++] = highBits >> 8 & 255;
      buffer[index2++] = highBits >> 16 & 255;
      buffer[index2++] = highBits >> 24 & 255;
      return index2;
    };
    var serializeInt32 = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_INT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      buffer[index2++] = value & 255;
      buffer[index2++] = value >> 8 & 255;
      buffer[index2++] = value >> 16 & 255;
      buffer[index2++] = value >> 24 & 255;
      return index2;
    };
    var serializeDouble = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_NUMBER;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      writeIEEE754(buffer, value, index2, "little", 52, 8);
      index2 = index2 + 8;
      return index2;
    };
    var serializeFunction = function(buffer, key, value, index2, checkKeys, depth2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_CODE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var functionString = normalizedFunctionString(value);
      var size = buffer.write(functionString, index2 + 4, "utf8") + 1;
      buffer[index2] = size & 255;
      buffer[index2 + 1] = size >> 8 & 255;
      buffer[index2 + 2] = size >> 16 & 255;
      buffer[index2 + 3] = size >> 24 & 255;
      index2 = index2 + 4 + size - 1;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeCode = function(buffer, key, value, index2, checkKeys, depth2, serializeFunctions, ignoreUndefined, isArray) {
      if (value.scope && typeof value.scope === "object") {
        buffer[index2++] = BSON2.BSON_DATA_CODE_W_SCOPE;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
        index2 = index2 + numberOfWrittenBytes;
        buffer[index2++] = 0;
        var startIndex = index2;
        var functionString = typeof value.code === "string" ? value.code : value.code.toString();
        index2 = index2 + 4;
        var codeSize = buffer.write(functionString, index2 + 4, "utf8") + 1;
        buffer[index2] = codeSize & 255;
        buffer[index2 + 1] = codeSize >> 8 & 255;
        buffer[index2 + 2] = codeSize >> 16 & 255;
        buffer[index2 + 3] = codeSize >> 24 & 255;
        buffer[index2 + 4 + codeSize - 1] = 0;
        index2 = index2 + codeSize + 4;
        var endIndex = serializeInto(buffer, value.scope, checkKeys, index2, depth2 + 1, serializeFunctions, ignoreUndefined);
        index2 = endIndex - 1;
        var totalSize = endIndex - startIndex;
        buffer[startIndex++] = totalSize & 255;
        buffer[startIndex++] = totalSize >> 8 & 255;
        buffer[startIndex++] = totalSize >> 16 & 255;
        buffer[startIndex++] = totalSize >> 24 & 255;
        buffer[index2++] = 0;
      } else {
        buffer[index2++] = BSON2.BSON_DATA_CODE;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
        index2 = index2 + numberOfWrittenBytes;
        buffer[index2++] = 0;
        functionString = value.code.toString();
        var size = buffer.write(functionString, index2 + 4, "utf8") + 1;
        buffer[index2] = size & 255;
        buffer[index2 + 1] = size >> 8 & 255;
        buffer[index2 + 2] = size >> 16 & 255;
        buffer[index2 + 3] = size >> 24 & 255;
        index2 = index2 + 4 + size - 1;
        buffer[index2++] = 0;
      }
      return index2;
    };
    var serializeBinary = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var data = value.value(true);
      var size = value.position;
      if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY)
        size = size + 4;
      buffer[index2++] = size & 255;
      buffer[index2++] = size >> 8 & 255;
      buffer[index2++] = size >> 16 & 255;
      buffer[index2++] = size >> 24 & 255;
      buffer[index2++] = value.sub_type;
      if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
        size = size - 4;
        buffer[index2++] = size & 255;
        buffer[index2++] = size >> 8 & 255;
        buffer[index2++] = size >> 16 & 255;
        buffer[index2++] = size >> 24 & 255;
      }
      data.copy(buffer, index2, 0, value.position);
      index2 = index2 + value.position;
      return index2;
    };
    var serializeSymbol = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_SYMBOL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var size = buffer.write(value.value, index2 + 4, "utf8") + 1;
      buffer[index2] = size & 255;
      buffer[index2 + 1] = size >> 8 & 255;
      buffer[index2 + 2] = size >> 16 & 255;
      buffer[index2 + 3] = size >> 24 & 255;
      index2 = index2 + 4 + size - 1;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeDBRef = function(buffer, key, value, index2, depth2, serializeFunctions, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var startIndex = index2;
      var endIndex;
      if (value.db != null) {
        endIndex = serializeInto(buffer, {
          $ref: value.namespace,
          $id: value.oid,
          $db: value.db
        }, false, index2, depth2 + 1, serializeFunctions);
      } else {
        endIndex = serializeInto(buffer, {
          $ref: value.namespace,
          $id: value.oid
        }, false, index2, depth2 + 1, serializeFunctions);
      }
      var size = endIndex - startIndex;
      buffer[startIndex++] = size & 255;
      buffer[startIndex++] = size >> 8 & 255;
      buffer[startIndex++] = size >> 16 & 255;
      buffer[startIndex++] = size >> 24 & 255;
      return endIndex;
    };
    var serializeInto = function serializeInto2(buffer, object, checkKeys, startingIndex, depth2, serializeFunctions, ignoreUndefined, path) {
      startingIndex = startingIndex || 0;
      path = path || [];
      path.push(object);
      var index2 = startingIndex + 4;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          var key = "" + i;
          var value = object[i];
          if (value && value.toBSON) {
            if (typeof value.toBSON !== "function")
              throw new Error("toBSON is not a function");
            value = value.toBSON();
          }
          var type = typeof value;
          if (type === "string") {
            index2 = serializeString(buffer, key, value, index2, true);
          } else if (type === "number") {
            index2 = serializeNumber(buffer, key, value, index2, true);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index2 = serializeBoolean(buffer, key, value, index2, true);
          } else if (value instanceof Date || isDate(value)) {
            index2 = serializeDate(buffer, key, value, index2, true);
          } else if (value === void 0) {
            index2 = serializeNull(buffer, key, value, index2, true);
          } else if (value === null) {
            index2 = serializeNull(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index2 = serializeObjectId(buffer, key, value, index2, true);
          } else if (Buffer.isBuffer(value)) {
            index2 = serializeBuffer(buffer, key, value, index2, true);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index2 = serializeRegExp(buffer, key, value, index2, true);
          } else if (type === "object" && value["_bsontype"] == null) {
            index2 = serializeObject(buffer, key, value, index2, checkKeys, depth2, serializeFunctions, ignoreUndefined, true, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index2 = serializeDecimal128(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index2 = serializeLong(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "Double") {
            index2 = serializeDouble(buffer, key, value, index2, true);
          } else if (typeof value === "function" && serializeFunctions) {
            index2 = serializeFunction(buffer, key, value, index2, checkKeys, depth2, serializeFunctions, true);
          } else if (value["_bsontype"] === "Code") {
            index2 = serializeCode(buffer, key, value, index2, checkKeys, depth2, serializeFunctions, ignoreUndefined, true);
          } else if (value["_bsontype"] === "Binary") {
            index2 = serializeBinary(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "Symbol") {
            index2 = serializeSymbol(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "DBRef") {
            index2 = serializeDBRef(buffer, key, value, index2, depth2, serializeFunctions, true);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index2 = serializeBSONRegExp(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "Int32") {
            index2 = serializeInt32(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index2 = serializeMinMax(buffer, key, value, index2, true);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      } else if (object instanceof Map2) {
        var iterator = object.entries();
        var done = false;
        while (!done) {
          var entry = iterator.next();
          done = entry.done;
          if (done)
            continue;
          key = entry.value[0];
          value = entry.value[1];
          type = typeof value;
          if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if (key[0] === "$") {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index2 = serializeString(buffer, key, value, index2);
          } else if (type === "number") {
            index2 = serializeNumber(buffer, key, value, index2);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index2 = serializeBoolean(buffer, key, value, index2);
          } else if (value instanceof Date || isDate(value)) {
            index2 = serializeDate(buffer, key, value, index2);
          } else if (value === null || value === void 0 && ignoreUndefined === false) {
            index2 = serializeNull(buffer, key, value, index2);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index2 = serializeObjectId(buffer, key, value, index2);
          } else if (Buffer.isBuffer(value)) {
            index2 = serializeBuffer(buffer, key, value, index2);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index2 = serializeRegExp(buffer, key, value, index2);
          } else if (type === "object" && value["_bsontype"] == null) {
            index2 = serializeObject(buffer, key, value, index2, checkKeys, depth2, serializeFunctions, ignoreUndefined, false, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index2 = serializeDecimal128(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index2 = serializeLong(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Double") {
            index2 = serializeDouble(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Code") {
            index2 = serializeCode(buffer, key, value, index2, checkKeys, depth2, serializeFunctions, ignoreUndefined);
          } else if (typeof value === "function" && serializeFunctions) {
            index2 = serializeFunction(buffer, key, value, index2, checkKeys, depth2, serializeFunctions);
          } else if (value["_bsontype"] === "Binary") {
            index2 = serializeBinary(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Symbol") {
            index2 = serializeSymbol(buffer, key, value, index2);
          } else if (value["_bsontype"] === "DBRef") {
            index2 = serializeDBRef(buffer, key, value, index2, depth2, serializeFunctions);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index2 = serializeBSONRegExp(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Int32") {
            index2 = serializeInt32(buffer, key, value, index2);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index2 = serializeMinMax(buffer, key, value, index2);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      } else {
        if (object.toBSON) {
          if (typeof object.toBSON !== "function")
            throw new Error("toBSON is not a function");
          object = object.toBSON();
          if (object != null && typeof object !== "object")
            throw new Error("toBSON function did not return an object");
        }
        for (key in object) {
          value = object[key];
          if (value && value.toBSON) {
            if (typeof value.toBSON !== "function")
              throw new Error("toBSON is not a function");
            value = value.toBSON();
          }
          type = typeof value;
          if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if (key[0] === "$") {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index2 = serializeString(buffer, key, value, index2);
          } else if (type === "number") {
            index2 = serializeNumber(buffer, key, value, index2);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index2 = serializeBoolean(buffer, key, value, index2);
          } else if (value instanceof Date || isDate(value)) {
            index2 = serializeDate(buffer, key, value, index2);
          } else if (value === void 0) {
            if (ignoreUndefined === false)
              index2 = serializeNull(buffer, key, value, index2);
          } else if (value === null) {
            index2 = serializeNull(buffer, key, value, index2);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index2 = serializeObjectId(buffer, key, value, index2);
          } else if (Buffer.isBuffer(value)) {
            index2 = serializeBuffer(buffer, key, value, index2);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index2 = serializeRegExp(buffer, key, value, index2);
          } else if (type === "object" && value["_bsontype"] == null) {
            index2 = serializeObject(buffer, key, value, index2, checkKeys, depth2, serializeFunctions, ignoreUndefined, false, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index2 = serializeDecimal128(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index2 = serializeLong(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Double") {
            index2 = serializeDouble(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Code") {
            index2 = serializeCode(buffer, key, value, index2, checkKeys, depth2, serializeFunctions, ignoreUndefined);
          } else if (typeof value === "function" && serializeFunctions) {
            index2 = serializeFunction(buffer, key, value, index2, checkKeys, depth2, serializeFunctions);
          } else if (value["_bsontype"] === "Binary") {
            index2 = serializeBinary(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Symbol") {
            index2 = serializeSymbol(buffer, key, value, index2);
          } else if (value["_bsontype"] === "DBRef") {
            index2 = serializeDBRef(buffer, key, value, index2, depth2, serializeFunctions);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index2 = serializeBSONRegExp(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Int32") {
            index2 = serializeInt32(buffer, key, value, index2);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index2 = serializeMinMax(buffer, key, value, index2);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      }
      path.pop();
      buffer[index2++] = 0;
      var size = index2 - startingIndex;
      buffer[startingIndex++] = size & 255;
      buffer[startingIndex++] = size >> 8 & 255;
      buffer[startingIndex++] = size >> 16 & 255;
      buffer[startingIndex++] = size >> 24 & 255;
      return index2;
    };
    var BSON2 = {};
    BSON2.BSON_DATA_NUMBER = 1;
    BSON2.BSON_DATA_STRING = 2;
    BSON2.BSON_DATA_OBJECT = 3;
    BSON2.BSON_DATA_ARRAY = 4;
    BSON2.BSON_DATA_BINARY = 5;
    BSON2.BSON_DATA_UNDEFINED = 6;
    BSON2.BSON_DATA_OID = 7;
    BSON2.BSON_DATA_BOOLEAN = 8;
    BSON2.BSON_DATA_DATE = 9;
    BSON2.BSON_DATA_NULL = 10;
    BSON2.BSON_DATA_REGEXP = 11;
    BSON2.BSON_DATA_CODE = 13;
    BSON2.BSON_DATA_SYMBOL = 14;
    BSON2.BSON_DATA_CODE_W_SCOPE = 15;
    BSON2.BSON_DATA_INT = 16;
    BSON2.BSON_DATA_TIMESTAMP = 17;
    BSON2.BSON_DATA_LONG = 18;
    BSON2.BSON_DATA_DECIMAL128 = 19;
    BSON2.BSON_DATA_MIN_KEY = 255;
    BSON2.BSON_DATA_MAX_KEY = 127;
    BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    module2.exports = serializeInto;
  }
});

// node_modules/bson/lib/bson/parser/calculate_size.js
var require_calculate_size = __commonJS({
  "node_modules/bson/lib/bson/parser/calculate_size.js"(exports2, module2) {
    "use strict";
    var Long2 = require_long().Long;
    var Double2 = require_double().Double;
    var Timestamp2 = require_timestamp().Timestamp;
    var ObjectID2 = require_objectid().ObjectID;
    var Symbol2 = require_symbol().Symbol;
    var BSONRegExp2 = require_regexp().BSONRegExp;
    var Code2 = require_code().Code;
    var Decimal1282 = require_decimal128();
    var MinKey2 = require_min_key().MinKey;
    var MaxKey2 = require_max_key().MaxKey;
    var DBRef2 = require_db_ref().DBRef;
    var Binary2 = require_binary().Binary;
    var normalizedFunctionString = require_utils().normalizedFunctionString;
    var isDate = function isDate2(d) {
      return typeof d === "object" && Object.prototype.toString.call(d) === "[object Date]";
    };
    var calculateObjectSize = function calculateObjectSize2(object, serializeFunctions, ignoreUndefined) {
      var totalLength = 4 + 1;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
        }
      } else {
        if (object.toBSON) {
          object = object.toBSON();
        }
        for (var key in object) {
          totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
        }
      }
      return totalLength;
    };
    function calculateElement(name2, value, serializeFunctions, isArray, ignoreUndefined) {
      if (value && value.toBSON) {
        value = value.toBSON();
      }
      switch (typeof value) {
        case "string":
          return 1 + Buffer.byteLength(name2, "utf8") + 1 + 4 + Buffer.byteLength(value, "utf8") + 1;
        case "number":
          if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
            if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (4 + 1);
            } else {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (8 + 1);
            }
          } else {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (8 + 1);
          }
        case "undefined":
          if (isArray || !ignoreUndefined)
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1;
          return 0;
        case "boolean":
          return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (1 + 1);
        case "object":
          if (value == null || value instanceof MinKey2 || value instanceof MaxKey2 || value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1;
          } else if (value instanceof ObjectID2 || value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (12 + 1);
          } else if (value instanceof Date || isDate(value)) {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (8 + 1);
          } else if (typeof Buffer !== "undefined" && Buffer.isBuffer(value)) {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (1 + 4 + 1) + value.length;
          } else if (value instanceof Long2 || value instanceof Double2 || value instanceof Timestamp2 || value["_bsontype"] === "Long" || value["_bsontype"] === "Double" || value["_bsontype"] === "Timestamp") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (8 + 1);
          } else if (value instanceof Decimal1282 || value["_bsontype"] === "Decimal128") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (16 + 1);
          } else if (value instanceof Code2 || value["_bsontype"] === "Code") {
            if (value.scope != null && Object.keys(value.scope).length > 0) {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1;
            }
          } else if (value instanceof Binary2 || value["_bsontype"] === "Binary") {
            if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1 + 4);
            } else {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1);
            }
          } else if (value instanceof Symbol2 || value["_bsontype"] === "Symbol") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + Buffer.byteLength(value.value, "utf8") + 4 + 1 + 1;
          } else if (value instanceof DBRef2 || value["_bsontype"] === "DBRef") {
            var ordered_values = {
              $ref: value.namespace,
              $id: value.oid
            };
            if (value.db != null) {
              ordered_values["$db"] = value.db;
            }
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
          } else if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else if (value instanceof BSONRegExp2 || value["_bsontype"] === "BSONRegExp") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.pattern, "utf8") + 1 + Buffer.byteLength(value.options, "utf8") + 1;
          } else {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + calculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
          }
        case "function":
          if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]" || String.call(value) === "[object RegExp]") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else {
            if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else if (serializeFunctions) {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1;
            }
          }
      }
      return 0;
    }
    var BSON2 = {};
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    module2.exports = calculateObjectSize;
  }
});

// node_modules/bson/lib/bson/bson.js
var require_bson = __commonJS({
  "node_modules/bson/lib/bson/bson.js"(exports2, module2) {
    "use strict";
    var Map2 = require_map();
    var Long2 = require_long();
    var Double2 = require_double();
    var Timestamp2 = require_timestamp();
    var ObjectID2 = require_objectid();
    var BSONRegExp2 = require_regexp();
    var Symbol2 = require_symbol();
    var Int322 = require_int_32();
    var Code2 = require_code();
    var Decimal1282 = require_decimal128();
    var MinKey2 = require_min_key();
    var MaxKey2 = require_max_key();
    var DBRef2 = require_db_ref();
    var Binary2 = require_binary();
    var deserialize2 = require_deserializer();
    var serializer = require_serializer();
    var calculateObjectSize = require_calculate_size();
    var utils2 = require_utils();
    var MAXSIZE = 1024 * 1024 * 17;
    var buffer = utils2.allocBuffer(MAXSIZE);
    var BSON2 = function() {
    };
    BSON2.prototype.serialize = function serialize(object, options2) {
      options2 = options2 || {};
      var checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
      var serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      var ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      var minInternalBufferSize = typeof options2.minInternalBufferSize === "number" ? options2.minInternalBufferSize : MAXSIZE;
      if (buffer.length < minInternalBufferSize) {
        buffer = utils2.allocBuffer(minInternalBufferSize);
      }
      var serializationIndex = serializer(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []);
      var finishedBuffer = utils2.allocBuffer(serializationIndex);
      buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
      return finishedBuffer;
    };
    BSON2.prototype.serializeWithBufferAndIndex = function(object, finalBuffer, options2) {
      options2 = options2 || {};
      var checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
      var serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      var ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      var startIndex = typeof options2.index === "number" ? options2.index : 0;
      var serializationIndex = serializer(finalBuffer, object, checkKeys, startIndex || 0, 0, serializeFunctions, ignoreUndefined);
      return serializationIndex - 1;
    };
    BSON2.prototype.deserialize = function(buffer2, options2) {
      return deserialize2(buffer2, options2);
    };
    BSON2.prototype.calculateObjectSize = function(object, options2) {
      options2 = options2 || {};
      var serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      var ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      return calculateObjectSize(object, serializeFunctions, ignoreUndefined);
    };
    BSON2.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options2) {
      options2 = options2 != null ? options2 : {};
      var index2 = startIndex;
      for (var i = 0; i < numberOfDocuments; i++) {
        var size = data[index2] | data[index2 + 1] << 8 | data[index2 + 2] << 16 | data[index2 + 3] << 24;
        options2["index"] = index2;
        documents[docStartIndex + i] = this.deserialize(data, options2);
        index2 = index2 + size;
      }
      return index2;
    };
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    BSON2.BSON_DATA_NUMBER = 1;
    BSON2.BSON_DATA_STRING = 2;
    BSON2.BSON_DATA_OBJECT = 3;
    BSON2.BSON_DATA_ARRAY = 4;
    BSON2.BSON_DATA_BINARY = 5;
    BSON2.BSON_DATA_OID = 7;
    BSON2.BSON_DATA_BOOLEAN = 8;
    BSON2.BSON_DATA_DATE = 9;
    BSON2.BSON_DATA_NULL = 10;
    BSON2.BSON_DATA_REGEXP = 11;
    BSON2.BSON_DATA_CODE = 13;
    BSON2.BSON_DATA_SYMBOL = 14;
    BSON2.BSON_DATA_CODE_W_SCOPE = 15;
    BSON2.BSON_DATA_INT = 16;
    BSON2.BSON_DATA_TIMESTAMP = 17;
    BSON2.BSON_DATA_LONG = 18;
    BSON2.BSON_DATA_MIN_KEY = 255;
    BSON2.BSON_DATA_MAX_KEY = 127;
    BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    module2.exports = BSON2;
    module2.exports.Code = Code2;
    module2.exports.Map = Map2;
    module2.exports.Symbol = Symbol2;
    module2.exports.BSON = BSON2;
    module2.exports.DBRef = DBRef2;
    module2.exports.Binary = Binary2;
    module2.exports.ObjectID = ObjectID2;
    module2.exports.Long = Long2;
    module2.exports.Timestamp = Timestamp2;
    module2.exports.Double = Double2;
    module2.exports.Int32 = Int322;
    module2.exports.MinKey = MinKey2;
    module2.exports.MaxKey = MaxKey2;
    module2.exports.BSONRegExp = BSONRegExp2;
    module2.exports.Decimal128 = Decimal1282;
  }
});

// node_modules/bson/index.js
var require_bson2 = __commonJS({
  "node_modules/bson/index.js"(exports2, module2) {
    var BSON2 = require_bson();
    var Binary2 = require_binary();
    var Code2 = require_code();
    var DBRef2 = require_db_ref();
    var Decimal1282 = require_decimal128();
    var Double2 = require_double();
    var Int322 = require_int_32();
    var Long2 = require_long();
    var Map2 = require_map();
    var MaxKey2 = require_max_key();
    var MinKey2 = require_min_key();
    var ObjectId = require_objectid();
    var BSONRegExp2 = require_regexp();
    var Symbol2 = require_symbol();
    var Timestamp2 = require_timestamp();
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    BSON2.Binary = Binary2;
    BSON2.Code = Code2;
    BSON2.DBRef = DBRef2;
    BSON2.Decimal128 = Decimal1282;
    BSON2.Double = Double2;
    BSON2.Int32 = Int322;
    BSON2.Long = Long2;
    BSON2.Map = Map2;
    BSON2.MaxKey = MaxKey2;
    BSON2.MinKey = MinKey2;
    BSON2.ObjectId = ObjectId;
    BSON2.ObjectID = ObjectId;
    BSON2.BSONRegExp = BSONRegExp2;
    BSON2.Symbol = Symbol2;
    BSON2.Timestamp = Timestamp2;
    module2.exports = BSON2;
  }
});

// node_modules/optional-require/index.js
var require_optional_require = __commonJS({
  "node_modules/optional-require/index.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    function findModuleNotFound(err, name2) {
      const msg = err.message.split("\n")[0];
      return msg && (msg.includes(`'${name2}'`) || msg.includes(` ${name2} `) || msg.includes(` ${name2}. `) || msg.includes(` ${name2}, `));
    }
    function _optionalRequire(callerRequire, resolve2, path, message) {
      let opts;
      if (typeof message === "object") {
        opts = message;
        assert(!(opts.hasOwnProperty("notFound") && opts.hasOwnProperty("default")), "optionalRequire: options set with both `notFound` and `default`");
      } else {
        opts = {message};
      }
      try {
        return resolve2 ? callerRequire.resolve(path) : callerRequire(path);
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND" || !findModuleNotFound(e, path)) {
          if (typeof opts.fail === "function") {
            return opts.fail(e);
          }
          throw e;
        }
        if (opts.message) {
          const message2 = typeof opts.message === "string" ? `${opts.message} - ` : "";
          const r = resolve2 ? "resolved" : "found";
          optionalRequire.log(`${message2}optional module not ${r}`, path);
        }
        if (typeof opts.notFound === "function") {
          return opts.notFound(e);
        }
        return opts.default;
      }
    }
    var tryRequire = (callerRequire, path, message) => _optionalRequire(callerRequire, false, path, message);
    var tryResolve = (callerRequire, path, message) => _optionalRequire(callerRequire, true, path, message);
    function optionalRequire(callerRequire) {
      const x = (path, message) => tryRequire(callerRequire, path, message);
      x.resolve = (path, message) => tryResolve(callerRequire, path, message);
      return x;
    }
    optionalRequire.try = tryRequire;
    optionalRequire.tryResolve = tryResolve;
    optionalRequire.resolve = tryResolve;
    optionalRequire.log = (message, path) => console.log(`Just FYI: ${message}; Path "${path}"`);
    module2.exports = optionalRequire;
  }
});

// node_modules/mongodb/package.json
var require_package = __commonJS({
  "node_modules/mongodb/package.json"(exports2, module2) {
    module2.exports = {
      _args: [
        [
          "mongodb@3.6.8",
          "D:\\TCC\\new\\TeilenFrontend"
        ]
      ],
      _from: "mongodb@3.6.8",
      _id: "mongodb@3.6.8",
      _inBundle: false,
      _integrity: "sha512-sDjJvI73WjON1vapcbyBD3Ao9/VN3TKYY8/QX9EPbs22KaCSrQ5rXo5ZZd44tWJ3wl3FlnrFZ+KyUtNH6+1ZPQ==",
      _location: "/mongodb",
      _phantomChildren: {},
      _requested: {
        type: "version",
        registry: true,
        raw: "mongodb@3.6.8",
        name: "mongodb",
        escapedName: "mongodb",
        rawSpec: "3.6.8",
        saveSpec: null,
        fetchSpec: "3.6.8"
      },
      _requiredBy: [
        "/"
      ],
      _resolved: "https://registry.npmjs.org/mongodb/-/mongodb-3.6.8.tgz",
      _spec: "3.6.8",
      _where: "D:\\TCC\\new\\TeilenFrontend",
      bugs: {
        url: "https://github.com/mongodb/node-mongodb-native/issues"
      },
      dependencies: {
        bl: "^2.2.1",
        bson: "^1.1.4",
        denque: "^1.4.1",
        "optional-require": "^1.0.3",
        "safe-buffer": "^5.1.2",
        saslprep: "^1.0.0"
      },
      description: "The official MongoDB driver for Node.js",
      devDependencies: {
        "@types/chai": "^4.2.16",
        "@types/mocha": "^8.2.2",
        "@types/node": "^14.14.37",
        "array-includes": "^3.1.3",
        chai: "^4.1.1",
        "chai-subset": "^1.6.0",
        chalk: "^2.4.2",
        co: "4.6.0",
        eslint: "^7.10.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-es": "^3.0.1",
        "eslint-plugin-prettier": "^3.1.3",
        jsdoc: "^3.5.5",
        "lodash.camelcase": "^4.3.0",
        mocha: "5.2.0",
        "mocha-sinon": "^2.1.0",
        "mongodb-extjson": "^2.1.1",
        "mongodb-mock-server": "^1.0.1",
        nyc: "^15.1.0",
        "object.entries": "^1.1.3",
        prettier: "^1.19.1",
        semver: "^5.5.0",
        sinon: "^4.3.0",
        "sinon-chai": "^3.2.0",
        snappy: "^6.3.4",
        "spec-xunit-file": "0.0.1-3",
        "standard-version": "^9.2.0",
        tslib: "^2.2.0",
        typescript: "^4.2.4",
        "util.promisify": "^1.0.1",
        "worker-farm": "^1.5.0",
        wtfnode: "^0.8.0",
        yargs: "^14.2.0"
      },
      engines: {
        node: ">=4"
      },
      files: [
        "index.js",
        "lib"
      ],
      homepage: "https://github.com/mongodb/node-mongodb-native",
      keywords: [
        "mongodb",
        "driver",
        "official"
      ],
      license: "Apache-2.0",
      main: "index.js",
      name: "mongodb",
      optionalDependencies: {
        saslprep: "^1.0.0"
      },
      peerDependenciesMeta: {
        kerberos: {
          optional: true
        },
        "mongodb-client-encryption": {
          optional: true
        },
        "mongodb-extjson": {
          optional: true
        },
        snappy: {
          optional: true
        },
        "bson-ext": {
          optional: true
        },
        aws4: {
          optional: true
        }
      },
      repository: {
        type: "git",
        url: "git+ssh://git@github.com/mongodb/node-mongodb-native.git"
      },
      scripts: {
        "build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
        "build:unified": "tsc -p test/functional/unified-spec-runner/tsconfig.unified.json",
        "check:atlas": "mocha --opts '{}' ./test/manual/atlas_connectivity.test.js",
        "check:bench": "node test/benchmarks/driverBench/",
        "check:coverage": "nyc npm run check:test",
        "check:kerberos": "mocha --opts '{}' -t 60000 test/manual/kerberos.test.js",
        "check:ldap": "mocha --opts '{}' test/manual/ldap.test.js",
        "check:lint": "eslint -v && eslint lib test",
        "check:test": "mocha --recursive test/functional test/unit",
        "check:tls": "mocha --opts '{}' test/manual/tls_support.test.js",
        format: "npm run check:lint -- --fix",
        release: "standard-version -i HISTORY.md",
        test: "npm run lint && mocha --recursive test/functional test/unit"
      },
      version: "3.6.8"
    };
  }
});

// node_modules/mongodb/lib/core/utils.js
var require_utils2 = __commonJS({
  "node_modules/mongodb/lib/core/utils.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var crypto = require("crypto");
    var requireOptional = require_optional_require()(require);
    var uuidV4 = () => {
      const result = crypto.randomBytes(16);
      result[6] = result[6] & 15 | 64;
      result[8] = result[8] & 63 | 128;
      return result;
    };
    function relayEvents(listener, emitter, events) {
      events.forEach((eventName) => listener.on(eventName, (event) => emitter.emit(eventName, event)));
    }
    function retrieveKerberos() {
      let kerberos;
      try {
        kerberos = requireOptional("kerberos");
      } catch (err) {
        if (err.code === "MODULE_NOT_FOUND") {
          throw new Error("The `kerberos` module was not found. Please install it and try again.");
        }
        throw err;
      }
      return kerberos;
    }
    var noEJSONError = function() {
      throw new Error("The `mongodb-extjson` module was not found. Please install it and try again.");
    };
    function retrieveEJSON() {
      let EJSON = requireOptional("mongodb-extjson");
      if (!EJSON) {
        EJSON = {
          parse: noEJSONError,
          deserialize: noEJSONError,
          serialize: noEJSONError,
          stringify: noEJSONError,
          setBSONModule: noEJSONError,
          BSON: noEJSONError
        };
      }
      return EJSON;
    }
    function maxWireVersion(topologyOrServer) {
      if (topologyOrServer) {
        if (topologyOrServer.ismaster) {
          return topologyOrServer.ismaster.maxWireVersion;
        }
        if (typeof topologyOrServer.lastIsMaster === "function") {
          const lastIsMaster = topologyOrServer.lastIsMaster();
          if (lastIsMaster) {
            return lastIsMaster.maxWireVersion;
          }
        }
        if (topologyOrServer.description) {
          return topologyOrServer.description.maxWireVersion;
        }
      }
      return 0;
    }
    function collationNotSupported(server, cmd2) {
      return cmd2 && cmd2.collation && maxWireVersion(server) < 5;
    }
    function isPromiseLike(maybePromise) {
      return maybePromise && typeof maybePromise.then === "function";
    }
    function eachAsync(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = 0;
      for (idx = 0; idx < arr.length; ++idx) {
        awaiting++;
        eachFn(arr[idx], eachCallback);
      }
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
        }
      }
    }
    function eachAsyncSeries(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = arr.length;
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        idx++;
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
          return;
        }
        eachFn(arr[idx], eachCallback);
      }
      eachFn(arr[idx], eachCallback);
    }
    function isUnifiedTopology(topology) {
      return topology.description != null;
    }
    function arrayStrictEqual(arr, arr2) {
      if (!Array.isArray(arr) || !Array.isArray(arr2)) {
        return false;
      }
      return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
    }
    function tagsStrictEqual(tags2, tags22) {
      const tagsKeys = Object.keys(tags2);
      const tags2Keys = Object.keys(tags22);
      return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags22[key] === tags2[key]);
    }
    function errorStrictEqual(lhs, rhs) {
      if (lhs === rhs) {
        return true;
      }
      if (lhs == null && rhs != null || lhs != null && rhs == null) {
        return false;
      }
      if (lhs.constructor.name !== rhs.constructor.name) {
        return false;
      }
      if (lhs.message !== rhs.message) {
        return false;
      }
      return true;
    }
    function makeStateMachine(stateTable) {
      return function stateTransition(target, newState) {
        const legalStates = stateTable[target.s.state];
        if (legalStates && legalStates.indexOf(newState) < 0) {
          throw new TypeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
        }
        target.emit("stateChanged", target.s.state, newState);
        target.s.state = newState;
      };
    }
    function makeClientMetadata(options2) {
      options2 = options2 || {};
      const metadata = {
        driver: {
          name: "nodejs",
          version: require_package().version
        },
        os: {
          type: os.type(),
          name: process.platform,
          architecture: process.arch,
          version: os.release()
        },
        platform: `'Node.js ${process.version}, ${os.endianness} (${options2.useUnifiedTopology ? "unified" : "legacy"})`
      };
      if (options2.driverInfo) {
        if (options2.driverInfo.name) {
          metadata.driver.name = `${metadata.driver.name}|${options2.driverInfo.name}`;
        }
        if (options2.driverInfo.version) {
          metadata.version = `${metadata.driver.version}|${options2.driverInfo.version}`;
        }
        if (options2.driverInfo.platform) {
          metadata.platform = `${metadata.platform}|${options2.driverInfo.platform}`;
        }
      }
      if (options2.appname) {
        const buffer = Buffer.from(options2.appname);
        metadata.application = {
          name: buffer.length > 128 ? buffer.slice(0, 128).toString("utf8") : options2.appname
        };
      }
      return metadata;
    }
    var noop3 = () => {
    };
    module2.exports = {
      uuidV4,
      relayEvents,
      collationNotSupported,
      retrieveEJSON,
      retrieveKerberos,
      maxWireVersion,
      isPromiseLike,
      eachAsync,
      eachAsyncSeries,
      isUnifiedTopology,
      arrayStrictEqual,
      tagsStrictEqual,
      errorStrictEqual,
      makeStateMachine,
      makeClientMetadata,
      noop: noop3
    };
  }
});

// node_modules/mongodb/lib/core/error.js
var require_error = __commonJS({
  "node_modules/mongodb/lib/core/error.js"(exports2, module2) {
    "use strict";
    var kErrorLabels = Symbol("errorLabels");
    var MongoError = class extends Error {
      constructor(message) {
        if (message instanceof Error) {
          super(message.message);
          this.stack = message.stack;
        } else {
          if (typeof message === "string") {
            super(message);
          } else {
            super(message.message || message.errmsg || message.$err || "n/a");
            if (message.errorLabels) {
              this[kErrorLabels] = new Set(message.errorLabels);
            }
            for (var name2 in message) {
              if (name2 === "errorLabels" || name2 === "errmsg") {
                continue;
              }
              this[name2] = message[name2];
            }
          }
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "MongoError";
      }
      get errmsg() {
        return this.message;
      }
      static create(options2) {
        return new MongoError(options2);
      }
      hasErrorLabel(label) {
        if (this[kErrorLabels] == null) {
          return false;
        }
        return this[kErrorLabels].has(label);
      }
      addErrorLabel(label) {
        if (this[kErrorLabels] == null) {
          this[kErrorLabels] = new Set();
        }
        this[kErrorLabels].add(label);
      }
      get errorLabels() {
        return this[kErrorLabels] ? Array.from(this[kErrorLabels]) : [];
      }
    };
    var kBeforeHandshake = Symbol("beforeHandshake");
    function isNetworkErrorBeforeHandshake(err) {
      return err[kBeforeHandshake] === true;
    }
    var MongoNetworkError = class extends MongoError {
      constructor(message, options2) {
        super(message);
        this.name = "MongoNetworkError";
        if (options2 && typeof options2.beforeHandshake === "boolean") {
          this[kBeforeHandshake] = options2.beforeHandshake;
        }
      }
    };
    var MongoNetworkTimeoutError = class extends MongoNetworkError {
      constructor(message, options2) {
        super(message, options2);
        this.name = "MongoNetworkTimeoutError";
      }
    };
    var MongoParseError = class extends MongoError {
      constructor(message) {
        super(message);
        this.name = "MongoParseError";
      }
    };
    var MongoTimeoutError = class extends MongoError {
      constructor(message, reason) {
        if (reason && reason.error) {
          super(reason.error.message || reason.error);
        } else {
          super(message);
        }
        this.name = "MongoTimeoutError";
        if (reason) {
          this.reason = reason;
        }
      }
    };
    var MongoServerSelectionError = class extends MongoTimeoutError {
      constructor(message, reason) {
        super(message, reason);
        this.name = "MongoServerSelectionError";
      }
    };
    function makeWriteConcernResultObject(input) {
      const output = Object.assign({}, input);
      if (output.ok === 0) {
        output.ok = 1;
        delete output.errmsg;
        delete output.code;
        delete output.codeName;
      }
      return output;
    }
    var MongoWriteConcernError = class extends MongoError {
      constructor(message, result) {
        super(message);
        this.name = "MongoWriteConcernError";
        if (result && Array.isArray(result.errorLabels)) {
          this[kErrorLabels] = new Set(result.errorLabels);
        }
        if (result != null) {
          this.result = makeWriteConcernResultObject(result);
        }
      }
    };
    var RETRYABLE_ERROR_CODES = new Set([
      6,
      7,
      89,
      91,
      189,
      9001,
      10107,
      11600,
      11602,
      13435,
      13436
    ]);
    var RETRYABLE_WRITE_ERROR_CODES = new Set([
      11600,
      11602,
      10107,
      13435,
      13436,
      189,
      91,
      7,
      6,
      89,
      9001,
      262
    ]);
    function isRetryableWriteError(error3) {
      if (error3 instanceof MongoWriteConcernError) {
        return RETRYABLE_WRITE_ERROR_CODES.has(error3.code) || RETRYABLE_WRITE_ERROR_CODES.has(error3.result.code);
      }
      return RETRYABLE_WRITE_ERROR_CODES.has(error3.code);
    }
    function isRetryableError(error3) {
      return RETRYABLE_ERROR_CODES.has(error3.code) || error3 instanceof MongoNetworkError || error3.message.match(/not master/) || error3.message.match(/node is recovering/);
    }
    var SDAM_RECOVERING_CODES = new Set([
      91,
      189,
      11600,
      11602,
      13436
    ]);
    var SDAM_NOTMASTER_CODES = new Set([
      10107,
      13435
    ]);
    var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([
      11600,
      91
    ]);
    function isRecoveringError(err) {
      if (err.code && SDAM_RECOVERING_CODES.has(err.code)) {
        return true;
      }
      return err.message.match(/not master or secondary/) || err.message.match(/node is recovering/);
    }
    function isNotMasterError(err) {
      if (err.code && SDAM_NOTMASTER_CODES.has(err.code)) {
        return true;
      }
      if (isRecoveringError(err)) {
        return false;
      }
      return err.message.match(/not master/);
    }
    function isNodeShuttingDownError(err) {
      return err.code && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code);
    }
    function isSDAMUnrecoverableError(error3) {
      if (error3 instanceof MongoParseError || error3 == null) {
        return true;
      }
      if (isRecoveringError(error3) || isNotMasterError(error3)) {
        return true;
      }
      return false;
    }
    module2.exports = {
      MongoError,
      MongoNetworkError,
      MongoNetworkTimeoutError,
      MongoParseError,
      MongoTimeoutError,
      MongoServerSelectionError,
      MongoWriteConcernError,
      isRetryableError,
      isSDAMUnrecoverableError,
      isNodeShuttingDownError,
      isRetryableWriteError,
      isNetworkErrorBeforeHandshake
    };
  }
});

// node_modules/mongodb/lib/core/connection/utils.js
var require_utils3 = __commonJS({
  "node_modules/mongodb/lib/core/connection/utils.js"(exports2, module2) {
    "use strict";
    var require_optional = require_optional_require()(require);
    function debugOptions(debugFields, options2) {
      const finaloptions = {};
      debugFields.forEach(function(n) {
        finaloptions[n] = options2[n];
      });
      return finaloptions;
    }
    function retrieveBSON() {
      const BSON2 = require_bson2();
      BSON2.native = false;
      const optionalBSON = require_optional("bson-ext");
      if (optionalBSON) {
        optionalBSON.native = true;
        return optionalBSON;
      }
      return BSON2;
    }
    function noSnappyWarning() {
      throw new Error("Attempted to use Snappy compression, but Snappy is not installed. Install or disable Snappy compression and try again.");
    }
    function retrieveSnappy() {
      let snappy = require_optional("snappy");
      if (!snappy) {
        snappy = {
          compress: noSnappyWarning,
          uncompress: noSnappyWarning,
          compressSync: noSnappyWarning,
          uncompressSync: noSnappyWarning
        };
      }
      return snappy;
    }
    module2.exports = {
      debugOptions,
      retrieveBSON,
      retrieveSnappy
    };
  }
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS({
  "node_modules/mongodb/lib/write_concern.js"(exports2, module2) {
    "use strict";
    var kWriteConcernKeys = new Set(["w", "wtimeout", "j", "journal", "fsync"]);
    var utils2;
    var WriteConcern = class {
      constructor(w, wtimeout, j, fsync) {
        if (w != null) {
          this.w = w;
        }
        if (wtimeout != null) {
          this.wtimeout = wtimeout;
        }
        if (j != null) {
          this.j = j;
        }
        if (fsync != null) {
          this.fsync = fsync;
        }
      }
      static fromOptions(options2) {
        if (options2 == null || options2.writeConcern == null && options2.w == null && options2.wtimeout == null && options2.j == null && options2.journal == null && options2.fsync == null) {
          return;
        }
        if (options2.writeConcern) {
          if (typeof options2.writeConcern === "string") {
            return new WriteConcern(options2.writeConcern);
          }
          if (!Object.keys(options2.writeConcern).some((key) => kWriteConcernKeys.has(key))) {
            return;
          }
          return new WriteConcern(options2.writeConcern.w, options2.writeConcern.wtimeout, options2.writeConcern.j || options2.writeConcern.journal, options2.writeConcern.fsync);
        }
        if (!utils2)
          utils2 = require_utils4();
        utils2.emitWarningOnce(`Top-level use of w, wtimeout, j, and fsync is deprecated. Use writeConcern instead.`);
        return new WriteConcern(options2.w, options2.wtimeout, options2.j || options2.journal, options2.fsync);
      }
    };
    module2.exports = WriteConcern;
  }
});

// node_modules/mongodb/lib/async/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/mongodb/lib/async/async_iterator.js"(exports2) {
    "use strict";
    function asyncIterator() {
      const cursor = this;
      return {
        next: function() {
          return Promise.resolve().then(() => cursor.next()).then((value) => {
            if (!value) {
              return cursor.close().then(() => ({value, done: true}));
            }
            return {value, done: false};
          });
        }
      };
    }
    exports2.asyncIterator = asyncIterator;
  }
});

// node_modules/mongodb/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/mongodb/lib/utils.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var WriteConcern = require_write_concern();
    var shallowClone = function(obj) {
      var copy = {};
      for (var name2 in obj)
        copy[name2] = obj[name2];
      return copy;
    };
    var getSingleProperty = function(obj, name2, value) {
      Object.defineProperty(obj, name2, {
        enumerable: true,
        get: function() {
          return value;
        }
      });
    };
    var formatSortValue = exports2.formatSortValue = function(sortDirection) {
      var value = ("" + sortDirection).toLowerCase();
      switch (value) {
        case "ascending":
        case "asc":
        case "1":
          return 1;
        case "descending":
        case "desc":
        case "-1":
          return -1;
        default:
          throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
      }
    };
    var formattedOrderClause = exports2.formattedOrderClause = function(sortValue) {
      var orderBy = new Map();
      if (sortValue == null)
        return null;
      if (Array.isArray(sortValue)) {
        if (sortValue.length === 0) {
          return null;
        }
        for (var i = 0; i < sortValue.length; i++) {
          if (sortValue[i].constructor === String) {
            orderBy.set(`${sortValue[i]}`, 1);
          } else {
            orderBy.set(`${sortValue[i][0]}`, formatSortValue(sortValue[i][1]));
          }
        }
      } else if (sortValue != null && typeof sortValue === "object") {
        if (sortValue instanceof Map) {
          orderBy = sortValue;
        } else {
          var sortKeys = Object.keys(sortValue);
          for (var k of sortKeys) {
            orderBy.set(k, sortValue[k]);
          }
        }
      } else if (typeof sortValue === "string") {
        orderBy.set(`${sortValue}`, 1);
      } else {
        throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
      }
      return orderBy;
    };
    var checkCollectionName = function checkCollectionName2(collectionName) {
      if (typeof collectionName !== "string") {
        throw new MongoError("collection name must be a String");
      }
      if (!collectionName || collectionName.indexOf("..") !== -1) {
        throw new MongoError("collection names cannot be empty");
      }
      if (collectionName.indexOf("$") !== -1 && collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
        throw new MongoError("collection names must not contain '$'");
      }
      if (collectionName.match(/^\.|\.$/) != null) {
        throw new MongoError("collection names must not start or end with '.'");
      }
      if (collectionName.indexOf("\0") !== -1) {
        throw new MongoError("collection names cannot contain a null character");
      }
    };
    var handleCallback = function(callback, err, value1, value2) {
      try {
        if (callback == null)
          return;
        if (callback) {
          return value2 ? callback(err, value1, value2) : callback(err, value1);
        }
      } catch (err2) {
        process.nextTick(function() {
          throw err2;
        });
        return false;
      }
      return true;
    };
    var toError = function(error3) {
      if (error3 instanceof Error)
        return error3;
      var msg = error3.err || error3.errmsg || error3.errMessage || error3;
      var e = MongoError.create({message: msg, driver: true});
      var keys = typeof error3 === "object" ? Object.keys(error3) : [];
      for (var i = 0; i < keys.length; i++) {
        try {
          e[keys[i]] = error3[keys[i]];
        } catch (err) {
        }
      }
      return e;
    };
    var normalizeHintField = function normalizeHintField2(hint) {
      var finalHint = null;
      if (typeof hint === "string") {
        finalHint = hint;
      } else if (Array.isArray(hint)) {
        finalHint = {};
        hint.forEach(function(param) {
          finalHint[param] = 1;
        });
      } else if (hint != null && typeof hint === "object") {
        finalHint = {};
        for (var name2 in hint) {
          finalHint[name2] = hint[name2];
        }
      }
      return finalHint;
    };
    var parseIndexOptions = function(fieldOrSpec) {
      var fieldHash = {};
      var indexes = [];
      var keys;
      if (typeof fieldOrSpec === "string") {
        indexes.push(fieldOrSpec + "_" + 1);
        fieldHash[fieldOrSpec] = 1;
      } else if (Array.isArray(fieldOrSpec)) {
        fieldOrSpec.forEach(function(f) {
          if (typeof f === "string") {
            indexes.push(f + "_" + 1);
            fieldHash[f] = 1;
          } else if (Array.isArray(f)) {
            indexes.push(f[0] + "_" + (f[1] || 1));
            fieldHash[f[0]] = f[1] || 1;
          } else if (isObject(f)) {
            keys = Object.keys(f);
            keys.forEach(function(k) {
              indexes.push(k + "_" + f[k]);
              fieldHash[k] = f[k];
            });
          } else {
          }
        });
      } else if (isObject(fieldOrSpec)) {
        keys = Object.keys(fieldOrSpec);
        keys.forEach(function(key) {
          indexes.push(key + "_" + fieldOrSpec[key]);
          fieldHash[key] = fieldOrSpec[key];
        });
      }
      return {
        name: indexes.join("_"),
        keys,
        fieldHash
      };
    };
    var isObject = exports2.isObject = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Object]";
    };
    var debugOptions = function(debugFields, options2) {
      var finaloptions = {};
      debugFields.forEach(function(n) {
        finaloptions[n] = options2[n];
      });
      return finaloptions;
    };
    var decorateCommand = function(command2, options2, exclude) {
      for (var name2 in options2) {
        if (exclude.indexOf(name2) === -1)
          command2[name2] = options2[name2];
      }
      return command2;
    };
    var mergeOptions = function(target, source) {
      for (var name2 in source) {
        target[name2] = source[name2];
      }
      return target;
    };
    var translateOptions = function(target, source) {
      var translations = {
        sslCA: "ca",
        sslCRL: "crl",
        sslValidate: "rejectUnauthorized",
        sslKey: "key",
        sslCert: "cert",
        sslPass: "passphrase",
        socketTimeoutMS: "socketTimeout",
        connectTimeoutMS: "connectionTimeout",
        replicaSet: "setName",
        rs_name: "setName",
        secondaryAcceptableLatencyMS: "acceptableLatency",
        connectWithNoPrimary: "secondaryOnlyConnectionAllowed",
        acceptableLatencyMS: "localThresholdMS"
      };
      for (var name2 in source) {
        if (translations[name2]) {
          target[translations[name2]] = source[name2];
        } else {
          target[name2] = source[name2];
        }
      }
      return target;
    };
    var filterOptions = function(options2, names) {
      var filterOptions2 = {};
      for (var name2 in options2) {
        if (names.indexOf(name2) !== -1)
          filterOptions2[name2] = options2[name2];
      }
      return filterOptions2;
    };
    var WRITE_CONCERN_KEYS = ["w", "j", "wtimeout", "fsync", "writeConcern"];
    function conditionallyMergeWriteConcern(target, source) {
      let found = false;
      for (const wcKey of WRITE_CONCERN_KEYS) {
        if (wcKey in target) {
          found = true;
          break;
        }
      }
      if (!found) {
        for (const wcKey of WRITE_CONCERN_KEYS) {
          if (source[wcKey]) {
            if (!("writeConcern" in target)) {
              target.writeConcern = {};
            }
            target.writeConcern[wcKey] = source[wcKey];
          }
        }
      }
      return target;
    }
    var executeLegacyOperation = (topology, operation, args, options2) => {
      if (topology == null) {
        throw new TypeError("This method requires a valid topology instance");
      }
      if (!Array.isArray(args)) {
        throw new TypeError("This method requires an array of arguments to apply");
      }
      options2 = options2 || {};
      const Promise2 = topology.s.promiseLibrary;
      let callback = args[args.length - 1];
      let session, opOptions, owner;
      if (!options2.skipSessions && topology.hasSessionSupport()) {
        opOptions = args[args.length - 2];
        if (opOptions == null || opOptions.session == null) {
          owner = Symbol();
          session = topology.startSession({owner});
          const optionsIndex = args.length - 2;
          args[optionsIndex] = Object.assign({}, args[optionsIndex], {session});
        } else if (opOptions.session && opOptions.session.hasEnded) {
          throw new MongoError("Use of expired sessions is not permitted");
        }
      }
      const makeExecuteCallback = (resolve2, reject) => function executeCallback(err, result) {
        if (session && session.owner === owner && !options2.returnsCursor) {
          session.endSession(() => {
            delete opOptions.session;
            if (err)
              return reject(err);
            resolve2(result);
          });
        } else {
          if (err)
            return reject(err);
          resolve2(result);
        }
      };
      if (typeof callback === "function") {
        callback = args.pop();
        const handler = makeExecuteCallback((result) => callback(null, result), (err) => callback(err, null));
        args.push(handler);
        try {
          return operation.apply(null, args);
        } catch (e) {
          handler(e);
          throw e;
        }
      }
      if (args[args.length - 1] != null) {
        throw new TypeError("final argument to `executeLegacyOperation` must be a callback");
      }
      return new Promise2(function(resolve2, reject) {
        const handler = makeExecuteCallback(resolve2, reject);
        args[args.length - 1] = handler;
        try {
          return operation.apply(null, args);
        } catch (e) {
          handler(e);
        }
      });
    };
    function applyRetryableWrites(target, db) {
      if (db && db.s.options.retryWrites) {
        target.retryWrites = true;
      }
      return target;
    }
    function applyWriteConcern(target, sources, options2) {
      options2 = options2 || {};
      const db = sources.db;
      const coll = sources.collection;
      if (options2.session && options2.session.inTransaction()) {
        if (target.writeConcern) {
          delete target.writeConcern;
        }
        return target;
      }
      const writeConcern = WriteConcern.fromOptions(options2);
      if (writeConcern) {
        return Object.assign(target, {writeConcern});
      }
      if (coll && coll.writeConcern) {
        return Object.assign(target, {writeConcern: Object.assign({}, coll.writeConcern)});
      }
      if (db && db.writeConcern) {
        return Object.assign(target, {writeConcern: Object.assign({}, db.writeConcern)});
      }
      return target;
    }
    function isPromiseLike(maybePromise2) {
      return maybePromise2 && typeof maybePromise2.then === "function";
    }
    function decorateWithCollation(command2, target, options2) {
      const topology = target.s && target.s.topology || target.topology;
      if (!topology) {
        throw new TypeError('parameter "target" is missing a topology');
      }
      const capabilities = topology.capabilities();
      if (options2.collation && typeof options2.collation === "object") {
        if (capabilities && capabilities.commandsTakeCollation) {
          command2.collation = options2.collation;
        } else {
          throw new MongoError(`Current topology does not support collation`);
        }
      }
    }
    function decorateWithReadConcern(command2, coll, options2) {
      if (options2 && options2.session && options2.session.inTransaction()) {
        return;
      }
      let readConcern = Object.assign({}, command2.readConcern || {});
      if (coll.s.readConcern) {
        Object.assign(readConcern, coll.s.readConcern);
      }
      if (Object.keys(readConcern).length > 0) {
        Object.assign(command2, {readConcern});
      }
    }
    function decorateWithExplain(command2, explain) {
      if (command2.explain) {
        return command2;
      }
      return {explain: command2, verbosity: explain.verbosity};
    }
    var nodejsMajorVersion = +process.version.split(".")[0].substring(1);
    var emitProcessWarning = (msg) => nodejsMajorVersion <= 6 ? process.emitWarning(msg, "DeprecationWarning", MONGODB_WARNING_CODE) : process.emitWarning(msg, {type: "DeprecationWarning", code: MONGODB_WARNING_CODE});
    var emitConsoleWarning = (msg) => console.error(msg);
    var emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;
    function defaultMsgHandler(name2, option) {
      return `${name2} option [${option}] is deprecated and will be removed in a later version.`;
    }
    function deprecateOptions(config2, fn) {
      if (process.noDeprecation === true) {
        return fn;
      }
      const msgHandler = config2.msgHandler ? config2.msgHandler : defaultMsgHandler;
      const optionsWarned = new Set();
      function deprecated() {
        const options2 = arguments[config2.optionsIndex];
        if (!isObject(options2) || Object.keys(options2).length === 0) {
          return fn.apply(this, arguments);
        }
        config2.deprecatedOptions.forEach((deprecatedOption) => {
          if (Object.prototype.hasOwnProperty.call(options2, deprecatedOption) && !optionsWarned.has(deprecatedOption)) {
            optionsWarned.add(deprecatedOption);
            const msg = msgHandler(config2.name, deprecatedOption);
            emitDeprecationWarning(msg);
            if (this && this.getLogger) {
              const logger = this.getLogger();
              if (logger) {
                logger.warn(msg);
              }
            }
          }
        });
        return fn.apply(this, arguments);
      }
      Object.setPrototypeOf(deprecated, fn);
      if (fn.prototype) {
        deprecated.prototype = fn.prototype;
      }
      return deprecated;
    }
    var SUPPORTS = {};
    try {
      require_async_iterator();
      SUPPORTS.ASYNC_ITERATOR = true;
    } catch (e) {
      SUPPORTS.ASYNC_ITERATOR = false;
    }
    var MongoDBNamespace = class {
      constructor(db, collection) {
        this.db = db;
        this.collection = collection;
      }
      toString() {
        return this.collection ? `${this.db}.${this.collection}` : this.db;
      }
      withCollection(collection) {
        return new MongoDBNamespace(this.db, collection);
      }
      static fromString(namespace) {
        if (!namespace) {
          throw new Error(`Cannot parse namespace from "${namespace}"`);
        }
        const index2 = namespace.indexOf(".");
        return new MongoDBNamespace(namespace.substring(0, index2), namespace.substring(index2 + 1));
      }
    };
    function* makeCounter(seed) {
      let count = seed || 0;
      while (true) {
        const newCount = count;
        count += 1;
        yield newCount;
      }
    }
    function maybePromise(parent, callback, fn) {
      const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;
      let result;
      if (typeof callback !== "function") {
        result = new PromiseLibrary((resolve2, reject) => {
          callback = (err, res) => {
            if (err)
              return reject(err);
            resolve2(res);
          };
        });
      }
      fn(function(err, res) {
        if (err != null) {
          try {
            callback(err);
          } catch (error3) {
            return process.nextTick(() => {
              throw error3;
            });
          }
          return;
        }
        callback(err, res);
      });
      return result;
    }
    function now() {
      const hrtime = process.hrtime();
      return Math.floor(hrtime[0] * 1e3 + hrtime[1] / 1e6);
    }
    function calculateDurationInMs(started) {
      if (typeof started !== "number") {
        throw TypeError("numeric value required to calculate duration");
      }
      const elapsed = now() - started;
      return elapsed < 0 ? 0 : elapsed;
    }
    function makeInterruptableAsyncInterval(fn, options2) {
      let timerId;
      let lastCallTime;
      let lastWakeTime;
      let stopped = false;
      options2 = options2 || {};
      const interval = options2.interval || 1e3;
      const minInterval = options2.minInterval || 500;
      const immediate = typeof options2.immediate === "boolean" ? options2.immediate : false;
      const clock = typeof options2.clock === "function" ? options2.clock : now;
      function wake() {
        const currentTime = clock();
        const timeSinceLastWake = currentTime - lastWakeTime;
        const timeSinceLastCall = currentTime - lastCallTime;
        const timeUntilNextCall = interval - timeSinceLastCall;
        lastWakeTime = currentTime;
        if (timeSinceLastWake < minInterval) {
          return;
        }
        if (timeUntilNextCall > minInterval) {
          reschedule(minInterval);
        }
        if (timeUntilNextCall < 0) {
          executeAndReschedule();
        }
      }
      function stop() {
        stopped = true;
        if (timerId) {
          clearTimeout(timerId);
          timerId = null;
        }
        lastCallTime = 0;
        lastWakeTime = 0;
      }
      function reschedule(ms) {
        if (stopped)
          return;
        clearTimeout(timerId);
        timerId = setTimeout(executeAndReschedule, ms || interval);
      }
      function executeAndReschedule() {
        lastWakeTime = 0;
        lastCallTime = clock();
        fn((err) => {
          if (err)
            throw err;
          reschedule(interval);
        });
      }
      if (immediate) {
        executeAndReschedule();
      } else {
        lastCallTime = clock();
        reschedule();
      }
      return {wake, stop};
    }
    function hasAtomicOperators(doc2) {
      if (Array.isArray(doc2)) {
        return doc2.reduce((err, u) => err || hasAtomicOperators(u), null);
      }
      return Object.keys(typeof doc2.toBSON !== "function" ? doc2 : doc2.toBSON()).map((k) => k[0]).indexOf("$") >= 0;
    }
    var MONGODB_WARNING_CODE = "MONGODB DRIVER";
    function emitWarning(message) {
      if (process.emitWarning) {
        return nodejsMajorVersion <= 6 ? process.emitWarning(message, void 0, MONGODB_WARNING_CODE) : process.emitWarning(message, {code: MONGODB_WARNING_CODE});
      } else {
        return console.error(`[${MONGODB_WARNING_CODE}] Warning:`, message);
      }
    }
    var emittedWarnings = new Set();
    function emitWarningOnce(message) {
      if (!emittedWarnings.has(message)) {
        emittedWarnings.add(message);
        return emitWarning(message);
      }
    }
    module2.exports = {
      filterOptions,
      mergeOptions,
      translateOptions,
      shallowClone,
      getSingleProperty,
      checkCollectionName,
      toError,
      formattedOrderClause,
      parseIndexOptions,
      normalizeHintField,
      handleCallback,
      decorateCommand,
      isObject,
      debugOptions,
      MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,
      conditionallyMergeWriteConcern,
      executeLegacyOperation,
      applyRetryableWrites,
      applyWriteConcern,
      isPromiseLike,
      decorateWithCollation,
      decorateWithReadConcern,
      decorateWithExplain,
      deprecateOptions,
      SUPPORTS,
      MongoDBNamespace,
      emitDeprecationWarning,
      makeCounter,
      maybePromise,
      now,
      calculateDurationInMs,
      makeInterruptableAsyncInterval,
      hasAtomicOperators,
      MONGODB_WARNING_CODE,
      emitWarning,
      emitWarningOnce
    };
  }
});

// node_modules/mongodb/lib/core/topologies/read_preference.js
var require_read_preference = __commonJS({
  "node_modules/mongodb/lib/core/topologies/read_preference.js"(exports2, module2) {
    "use strict";
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var ReadPreference = function(mode, tags2, options2) {
      if (!ReadPreference.isValid(mode)) {
        throw new TypeError(`Invalid read preference mode ${mode}`);
      }
      if (tags2 && !Array.isArray(tags2)) {
        emitWarningOnce("ReadPreference tags must be an array, this will change in the next major version");
        const tagsHasMaxStalenessSeconds = typeof tags2.maxStalenessSeconds !== "undefined";
        const tagsHasHedge = typeof tags2.hedge !== "undefined";
        const tagsHasOptions = tagsHasMaxStalenessSeconds || tagsHasHedge;
        if (tagsHasOptions) {
          options2 = tags2;
          tags2 = void 0;
        } else {
          tags2 = [tags2];
        }
      }
      this.mode = mode;
      this.tags = tags2;
      this.hedge = options2 && options2.hedge;
      options2 = options2 || {};
      if (options2.maxStalenessSeconds != null) {
        if (options2.maxStalenessSeconds <= 0) {
          throw new TypeError("maxStalenessSeconds must be a positive integer");
        }
        this.maxStalenessSeconds = options2.maxStalenessSeconds;
        this.minWireVersion = 5;
      }
      if (this.mode === ReadPreference.PRIMARY) {
        if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
          throw new TypeError("Primary read preference cannot be combined with tags");
        }
        if (this.maxStalenessSeconds) {
          throw new TypeError("Primary read preference cannot be combined with maxStalenessSeconds");
        }
        if (this.hedge) {
          throw new TypeError("Primary read preference cannot be combined with hedge");
        }
      }
    };
    Object.defineProperty(ReadPreference.prototype, "preference", {
      enumerable: true,
      get: function() {
        return this.mode;
      }
    });
    ReadPreference.PRIMARY = "primary";
    ReadPreference.PRIMARY_PREFERRED = "primaryPreferred";
    ReadPreference.SECONDARY = "secondary";
    ReadPreference.SECONDARY_PREFERRED = "secondaryPreferred";
    ReadPreference.NEAREST = "nearest";
    var VALID_MODES = [
      ReadPreference.PRIMARY,
      ReadPreference.PRIMARY_PREFERRED,
      ReadPreference.SECONDARY,
      ReadPreference.SECONDARY_PREFERRED,
      ReadPreference.NEAREST,
      null
    ];
    ReadPreference.fromOptions = function(options2) {
      if (!options2)
        return null;
      const readPreference = options2.readPreference;
      if (!readPreference)
        return null;
      const readPreferenceTags = options2.readPreferenceTags;
      const maxStalenessSeconds = options2.maxStalenessSeconds;
      if (typeof readPreference === "string") {
        return new ReadPreference(readPreference, readPreferenceTags);
      } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === "object") {
        const mode = readPreference.mode || readPreference.preference;
        if (mode && typeof mode === "string") {
          return new ReadPreference(mode, readPreference.tags, {
            maxStalenessSeconds: readPreference.maxStalenessSeconds || maxStalenessSeconds,
            hedge: readPreference.hedge
          });
        }
      }
      return readPreference;
    };
    ReadPreference.resolve = function(parent, options2) {
      options2 = options2 || {};
      const session = options2.session;
      const inheritedReadPreference = parent && parent.readPreference;
      let readPreference;
      if (options2.readPreference) {
        readPreference = ReadPreference.fromOptions(options2);
      } else if (session && session.inTransaction() && session.transaction.options.readPreference) {
        readPreference = session.transaction.options.readPreference;
      } else if (inheritedReadPreference != null) {
        readPreference = inheritedReadPreference;
      } else {
        readPreference = ReadPreference.primary;
      }
      return typeof readPreference === "string" ? new ReadPreference(readPreference) : readPreference;
    };
    ReadPreference.translate = function(options2) {
      if (options2.readPreference == null)
        return options2;
      const r = options2.readPreference;
      if (typeof r === "string") {
        options2.readPreference = new ReadPreference(r);
      } else if (r && !(r instanceof ReadPreference) && typeof r === "object") {
        const mode = r.mode || r.preference;
        if (mode && typeof mode === "string") {
          options2.readPreference = new ReadPreference(mode, r.tags, {
            maxStalenessSeconds: r.maxStalenessSeconds
          });
        }
      } else if (!(r instanceof ReadPreference)) {
        throw new TypeError("Invalid read preference: " + r);
      }
      return options2;
    };
    ReadPreference.isValid = function(mode) {
      return VALID_MODES.indexOf(mode) !== -1;
    };
    ReadPreference.prototype.isValid = function(mode) {
      return ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
    };
    var needSlaveOk = ["primaryPreferred", "secondary", "secondaryPreferred", "nearest"];
    ReadPreference.prototype.slaveOk = function() {
      return needSlaveOk.indexOf(this.mode) !== -1;
    };
    ReadPreference.prototype.equals = function(readPreference) {
      return readPreference.mode === this.mode;
    };
    ReadPreference.prototype.toJSON = function() {
      const readPreference = {mode: this.mode};
      if (Array.isArray(this.tags))
        readPreference.tags = this.tags;
      if (this.maxStalenessSeconds)
        readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
      if (this.hedge)
        readPreference.hedge = this.hedge;
      return readPreference;
    };
    ReadPreference.primary = new ReadPreference("primary");
    ReadPreference.primaryPreferred = new ReadPreference("primaryPreferred");
    ReadPreference.secondary = new ReadPreference("secondary");
    ReadPreference.secondaryPreferred = new ReadPreference("secondaryPreferred");
    ReadPreference.nearest = new ReadPreference("nearest");
    module2.exports = ReadPreference;
  }
});

// node_modules/mongodb/lib/core/sdam/common.js
var require_common = __commonJS({
  "node_modules/mongodb/lib/core/sdam/common.js"(exports2, module2) {
    "use strict";
    var STATE_CLOSING = "closing";
    var STATE_CLOSED = "closed";
    var STATE_CONNECTING = "connecting";
    var STATE_CONNECTED = "connected";
    var TopologyType = {
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown"
    };
    var ServerType = {
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown"
    };
    function serverType(server) {
      let description = server.s.description || server.s.serverDescription;
      if (description.topologyType === TopologyType.Single)
        return description.servers[0].type;
      return description.type;
    }
    var TOPOLOGY_DEFAULTS = {
      useUnifiedTopology: true,
      localThresholdMS: 15,
      serverSelectionTimeoutMS: 3e4,
      heartbeatFrequencyMS: 1e4,
      minHeartbeatFrequencyMS: 500
    };
    function drainTimerQueue(queue) {
      queue.forEach(clearTimeout);
      queue.clear();
    }
    function clearAndRemoveTimerFrom(timer, timers) {
      clearTimeout(timer);
      return timers.delete(timer);
    }
    module2.exports = {
      STATE_CLOSING,
      STATE_CLOSED,
      STATE_CONNECTING,
      STATE_CONNECTED,
      TOPOLOGY_DEFAULTS,
      TopologyType,
      ServerType,
      serverType,
      drainTimerQueue,
      clearAndRemoveTimerFrom
    };
  }
});

// node_modules/mongodb/lib/core/sdam/server_description.js
var require_server_description = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server_description.js"(exports2, module2) {
    "use strict";
    var arrayStrictEqual = require_utils2().arrayStrictEqual;
    var tagsStrictEqual = require_utils2().tagsStrictEqual;
    var errorStrictEqual = require_utils2().errorStrictEqual;
    var ServerType = require_common().ServerType;
    var now = require_utils4().now;
    var WRITABLE_SERVER_TYPES = new Set([
      ServerType.RSPrimary,
      ServerType.Standalone,
      ServerType.Mongos
    ]);
    var DATA_BEARING_SERVER_TYPES = new Set([
      ServerType.RSPrimary,
      ServerType.RSSecondary,
      ServerType.Mongos,
      ServerType.Standalone
    ]);
    var ISMASTER_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "compression",
      "me",
      "hosts",
      "passives",
      "arbiters",
      "tags",
      "setName",
      "setVersion",
      "electionId",
      "primary",
      "logicalSessionTimeoutMinutes",
      "saslSupportedMechs",
      "__nodejs_mock_server__",
      "$clusterTime"
    ];
    var ServerDescription = class {
      constructor(address, ismaster, options2) {
        options2 = options2 || {};
        ismaster = Object.assign({
          minWireVersion: 0,
          maxWireVersion: 0,
          hosts: [],
          passives: [],
          arbiters: [],
          tags: []
        }, ismaster);
        this.address = address;
        this.error = options2.error;
        this.roundTripTime = options2.roundTripTime || -1;
        this.lastUpdateTime = now();
        this.lastWriteDate = ismaster.lastWrite ? ismaster.lastWrite.lastWriteDate : null;
        this.opTime = ismaster.lastWrite ? ismaster.lastWrite.opTime : null;
        this.type = parseServerType(ismaster);
        this.topologyVersion = options2.topologyVersion || ismaster.topologyVersion;
        ISMASTER_FIELDS.forEach((field) => {
          if (typeof ismaster[field] !== "undefined")
            this[field] = ismaster[field];
        });
        if (this.me)
          this.me = this.me.toLowerCase();
        this.hosts = this.hosts.map((host) => host.toLowerCase());
        this.passives = this.passives.map((host) => host.toLowerCase());
        this.arbiters = this.arbiters.map((host) => host.toLowerCase());
      }
      get allHosts() {
        return this.hosts.concat(this.arbiters).concat(this.passives);
      }
      get isReadable() {
        return this.type === ServerType.RSSecondary || this.isWritable;
      }
      get isDataBearing() {
        return DATA_BEARING_SERVER_TYPES.has(this.type);
      }
      get isWritable() {
        return WRITABLE_SERVER_TYPES.has(this.type);
      }
      get host() {
        const chopLength = `:${this.port}`.length;
        return this.address.slice(0, -chopLength);
      }
      get port() {
        const port = this.address.split(":").pop();
        return port ? Number.parseInt(port, 10) : port;
      }
      equals(other) {
        const topologyVersionsEqual = this.topologyVersion === other.topologyVersion || compareTopologyVersion(this.topologyVersion, other.topologyVersion) === 0;
        return other != null && errorStrictEqual(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && this.me === other.me && arrayStrictEqual(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && (this.electionId ? other.electionId && this.electionId.equals(other.electionId) : this.electionId === other.electionId) && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
      }
    };
    function parseServerType(ismaster) {
      if (!ismaster || !ismaster.ok) {
        return ServerType.Unknown;
      }
      if (ismaster.isreplicaset) {
        return ServerType.RSGhost;
      }
      if (ismaster.msg && ismaster.msg === "isdbgrid") {
        return ServerType.Mongos;
      }
      if (ismaster.setName) {
        if (ismaster.hidden) {
          return ServerType.RSOther;
        } else if (ismaster.ismaster) {
          return ServerType.RSPrimary;
        } else if (ismaster.secondary) {
          return ServerType.RSSecondary;
        } else if (ismaster.arbiterOnly) {
          return ServerType.RSArbiter;
        } else {
          return ServerType.RSOther;
        }
      }
      return ServerType.Standalone;
    }
    function compareTopologyVersion(lhs, rhs) {
      if (lhs == null || rhs == null) {
        return -1;
      }
      if (lhs.processId.equals(rhs.processId)) {
        if (lhs.counter === rhs.counter) {
          return 0;
        } else if (lhs.counter < rhs.counter) {
          return -1;
        }
        return 1;
      }
      return -1;
    }
    module2.exports = {
      ServerDescription,
      parseServerType,
      compareTopologyVersion
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/constants.js
var require_constants = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/constants.js"(exports2, module2) {
    "use strict";
    var MIN_SUPPORTED_SERVER_VERSION = "2.6";
    var MAX_SUPPORTED_SERVER_VERSION = "4.4";
    var MIN_SUPPORTED_WIRE_VERSION = 2;
    var MAX_SUPPORTED_WIRE_VERSION = 9;
    module2.exports = {
      MIN_SUPPORTED_SERVER_VERSION,
      MAX_SUPPORTED_SERVER_VERSION,
      MIN_SUPPORTED_WIRE_VERSION,
      MAX_SUPPORTED_WIRE_VERSION
    };
  }
});

// node_modules/mongodb/lib/core/sdam/topology_description.js
var require_topology_description = __commonJS({
  "node_modules/mongodb/lib/core/sdam/topology_description.js"(exports2, module2) {
    "use strict";
    var ServerType = require_common().ServerType;
    var ServerDescription = require_server_description().ServerDescription;
    var WIRE_CONSTANTS = require_constants();
    var TopologyType = require_common().TopologyType;
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var TopologyDescription = class {
      constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options2) {
        options2 = options2 || {};
        this.type = topologyType || TopologyType.Unknown;
        this.setName = setName || null;
        this.maxSetVersion = maxSetVersion || null;
        this.maxElectionId = maxElectionId || null;
        this.servers = serverDescriptions || new Map();
        this.stale = false;
        this.compatible = true;
        this.compatibilityError = null;
        this.logicalSessionTimeoutMinutes = null;
        this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS || 0;
        this.localThresholdMS = options2.localThresholdMS || 0;
        this.commonWireVersion = commonWireVersion || null;
        Object.defineProperty(this, "options", {value: options2, enumberable: false});
        for (const serverDescription of this.servers.values()) {
          if (serverDescription.type === ServerType.Unknown)
            continue;
          if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
          }
          if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
            break;
          }
        }
        this.logicalSessionTimeoutMinutes = null;
        for (const addressServerTuple of this.servers) {
          const server = addressServerTuple[1];
          if (server.isReadable) {
            if (server.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = null;
              break;
            }
            if (this.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
              continue;
            }
            this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
          }
        }
      }
      updateFromSrvPollingEvent(ev) {
        const newAddresses = ev.addresses();
        const serverDescriptions = new Map(this.servers);
        for (const server of this.servers) {
          if (newAddresses.has(server[0])) {
            newAddresses.delete(server[0]);
          } else {
            serverDescriptions.delete(server[0]);
          }
        }
        if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {
          return this;
        }
        for (const address of newAddresses) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
        return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, this.options, null);
      }
      update(serverDescription) {
        const address = serverDescription.address;
        let topologyType = this.type;
        let setName = this.setName;
        let maxSetVersion = this.maxSetVersion;
        let maxElectionId = this.maxElectionId;
        let commonWireVersion = this.commonWireVersion;
        if (serverDescription.setName && setName && serverDescription.setName !== setName) {
          serverDescription = new ServerDescription(address, null);
        }
        const serverType = serverDescription.type;
        let serverDescriptions = new Map(this.servers);
        if (serverDescription.maxWireVersion !== 0) {
          if (commonWireVersion == null) {
            commonWireVersion = serverDescription.maxWireVersion;
          } else {
            commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
          }
        }
        serverDescriptions.set(address, serverDescription);
        if (topologyType === TopologyType.Single) {
          return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
        }
        if (topologyType === TopologyType.Unknown) {
          if (serverType === ServerType.Standalone && this.servers.size !== 1) {
            serverDescriptions.delete(address);
          } else {
            topologyType = topologyTypeForServerType(serverType);
          }
        }
        if (topologyType === TopologyType.Sharded) {
          if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {
            serverDescriptions.delete(address);
          }
        }
        if (topologyType === TopologyType.ReplicaSetNoPrimary) {
          if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
            serverDescriptions.delete(address);
          }
          if (serverType === ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
            topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
          } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
            const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);
            topologyType = result[0], setName = result[1];
          }
        }
        if (topologyType === TopologyType.ReplicaSetWithPrimary) {
          if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
            serverDescriptions.delete(address);
            topologyType = checkHasPrimary(serverDescriptions);
          } else if (serverType === ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
            topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
          } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
            topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);
          } else {
            topologyType = checkHasPrimary(serverDescriptions);
          }
        }
        return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
      }
      get error() {
        const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
        if (descriptionsWithError.length > 0) {
          return descriptionsWithError[0].error;
        }
        return void 0;
      }
      get hasKnownServers() {
        return Array.from(this.servers.values()).some((sd) => sd.type !== ServerType.Unknown);
      }
      get hasDataBearingServers() {
        return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
      }
      hasServer(address) {
        return this.servers.has(address);
      }
    };
    function topologyTypeForServerType(serverType) {
      if (serverType === ServerType.Standalone) {
        return TopologyType.Single;
      }
      if (serverType === ServerType.Mongos) {
        return TopologyType.Sharded;
      }
      if (serverType === ServerType.RSPrimary) {
        return TopologyType.ReplicaSetWithPrimary;
      }
      if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {
        return TopologyType.Unknown;
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    function compareObjectId(oid1, oid2) {
      if (oid1 == null) {
        return -1;
      }
      if (oid2 == null) {
        return 1;
      }
      if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {
        const oid1Buffer = oid1.id;
        const oid2Buffer = oid2.id;
        return oid1Buffer.compare(oid2Buffer);
      }
      const oid1String = oid1.toString();
      const oid2String = oid2.toString();
      return oid1String.localeCompare(oid2String);
    }
    function updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
      const electionId = serverDescription.electionId ? serverDescription.electionId : null;
      if (serverDescription.setVersion && electionId) {
        if (maxSetVersion && maxElectionId) {
          if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {
            serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));
            return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
          }
        }
        maxElectionId = serverDescription.electionId;
      }
      if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
        maxSetVersion = serverDescription.setVersion;
      }
      for (const address of serverDescriptions.keys()) {
        const server = serverDescriptions.get(address);
        if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {
          serverDescriptions.set(address, new ServerDescription(server.address));
          break;
        }
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
      });
      const currentAddresses = Array.from(serverDescriptions.keys());
      const responseAddresses = serverDescription.allHosts;
      currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
        serverDescriptions.delete(address);
      });
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    function updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {
      if (setName == null) {
        throw new TypeError("setName is required");
      }
      if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return checkHasPrimary(serverDescriptions);
    }
    function updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {
      let topologyType = TopologyType.ReplicaSetNoPrimary;
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [topologyType, setName];
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
      });
      if (serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return [topologyType, setName];
    }
    function checkHasPrimary(serverDescriptions) {
      for (const addr of serverDescriptions.keys()) {
        if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {
          return TopologyType.ReplicaSetWithPrimary;
        }
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    module2.exports = {
      TopologyDescription
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/shared.js
var require_shared = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/shared.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var ServerType = require_common().ServerType;
    var TopologyDescription = require_topology_description().TopologyDescription;
    var MESSAGE_HEADER_SIZE = 16;
    var COMPRESSION_DETAILS_SIZE = 9;
    var opcodes = {
      OP_REPLY: 1,
      OP_UPDATE: 2001,
      OP_INSERT: 2002,
      OP_QUERY: 2004,
      OP_GETMORE: 2005,
      OP_DELETE: 2006,
      OP_KILL_CURSORS: 2007,
      OP_COMPRESSED: 2012,
      OP_MSG: 2013
    };
    var getReadPreference = function(cmd2, options2) {
      var readPreference = cmd2.readPreference || new ReadPreference("primary");
      if (options2.readPreference) {
        readPreference = options2.readPreference;
      }
      if (typeof readPreference === "string") {
        readPreference = new ReadPreference(readPreference);
      }
      if (!(readPreference instanceof ReadPreference)) {
        throw new MongoError("read preference must be a ReadPreference instance");
      }
      return readPreference;
    };
    var parseHeader = function(message) {
      return {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
    };
    function applyCommonQueryOptions(queryOptions, options2) {
      Object.assign(queryOptions, {
        raw: typeof options2.raw === "boolean" ? options2.raw : false,
        promoteLongs: typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true,
        promoteValues: typeof options2.promoteValues === "boolean" ? options2.promoteValues : true,
        promoteBuffers: typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false,
        monitoring: typeof options2.monitoring === "boolean" ? options2.monitoring : false,
        fullResult: typeof options2.fullResult === "boolean" ? options2.fullResult : false
      });
      if (typeof options2.socketTimeout === "number") {
        queryOptions.socketTimeout = options2.socketTimeout;
      }
      if (options2.session) {
        queryOptions.session = options2.session;
      }
      if (typeof options2.documentsReturnedIn === "string") {
        queryOptions.documentsReturnedIn = options2.documentsReturnedIn;
      }
      return queryOptions;
    }
    function isSharded(topologyOrServer) {
      if (topologyOrServer.type === "mongos")
        return true;
      if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {
        return true;
      }
      if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {
        const servers = Array.from(topologyOrServer.description.servers.values());
        return servers.some((server) => server.type === ServerType.Mongos);
      }
      return false;
    }
    function databaseNamespace(ns) {
      return ns.split(".")[0];
    }
    function collectionNamespace(ns) {
      return ns.split(".").slice(1).join(".");
    }
    module2.exports = {
      getReadPreference,
      MESSAGE_HEADER_SIZE,
      COMPRESSION_DETAILS_SIZE,
      opcodes,
      parseHeader,
      applyCommonQueryOptions,
      isSharded,
      databaseNamespace,
      collectionNamespace
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/compression.js
var require_compression = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/compression.js"(exports2, module2) {
    "use strict";
    var Snappy = require_utils3().retrieveSnappy();
    var zlib2 = require("zlib");
    var compressorIDs = {
      snappy: 1,
      zlib: 2
    };
    var uncompressibleCommands = new Set([
      "ismaster",
      "saslStart",
      "saslContinue",
      "getnonce",
      "authenticate",
      "createUser",
      "updateUser",
      "copydbSaslStart",
      "copydbgetnonce",
      "copydb"
    ]);
    function compress(self2, dataToBeCompressed, callback) {
      switch (self2.options.agreedCompressor) {
        case "snappy":
          Snappy.compress(dataToBeCompressed, callback);
          break;
        case "zlib":
          var zlibOptions = {};
          if (self2.options.zlibCompressionLevel) {
            zlibOptions.level = self2.options.zlibCompressionLevel;
          }
          zlib2.deflate(dataToBeCompressed, zlibOptions, callback);
          break;
        default:
          throw new Error('Attempt to compress message using unknown compressor "' + self2.options.agreedCompressor + '".');
      }
    }
    function decompress(compressorID, compressedData, callback) {
      if (compressorID < 0 || compressorID > compressorIDs.length) {
        throw new Error("Server sent message compressed using an unsupported compressor. (Received compressor ID " + compressorID + ")");
      }
      switch (compressorID) {
        case compressorIDs.snappy:
          Snappy.uncompress(compressedData, callback);
          break;
        case compressorIDs.zlib:
          zlib2.inflate(compressedData, callback);
          break;
        default:
          callback(null, compressedData);
      }
    }
    module2.exports = {
      compressorIDs,
      uncompressibleCommands,
      compress,
      decompress
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/mongodb/lib/core/connection/commands.js
var require_commands = __commonJS({
  "node_modules/mongodb/lib/core/connection/commands.js"(exports2, module2) {
    "use strict";
    var retrieveBSON = require_utils3().retrieveBSON;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var Buffer2 = require_safe_buffer().Buffer;
    var _requestId = 0;
    var opcodes = require_shared().opcodes;
    var OPTS_TAILABLE_CURSOR = 2;
    var OPTS_SLAVE = 4;
    var OPTS_OPLOG_REPLAY = 8;
    var OPTS_NO_CURSOR_TIMEOUT = 16;
    var OPTS_AWAIT_DATA = 32;
    var OPTS_EXHAUST = 64;
    var OPTS_PARTIAL = 128;
    var CURSOR_NOT_FOUND = 1;
    var QUERY_FAILURE = 2;
    var SHARD_CONFIG_STALE = 4;
    var AWAIT_CAPABLE = 8;
    var Query2 = function(bson, ns, query, options2) {
      var self2 = this;
      if (ns == null)
        throw new Error("ns must be specified for query");
      if (query == null)
        throw new Error("query must be specified for query");
      if (ns.indexOf("\0") !== -1) {
        throw new Error("namespace cannot contain a null character");
      }
      this.bson = bson;
      this.ns = ns;
      this.query = query;
      this.numberToSkip = options2.numberToSkip || 0;
      this.numberToReturn = options2.numberToReturn || 0;
      this.returnFieldSelector = options2.returnFieldSelector || null;
      this.requestId = Query2.getRequestId();
      this.pre32Limit = options2.pre32Limit;
      this.serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      this.ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
      this.maxBsonSize = options2.maxBsonSize || 1024 * 1024 * 16;
      this.checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : true;
      this.batchSize = self2.numberToReturn;
      this.tailable = false;
      this.slaveOk = typeof options2.slaveOk === "boolean" ? options2.slaveOk : false;
      this.oplogReplay = false;
      this.noCursorTimeout = false;
      this.awaitData = false;
      this.exhaust = false;
      this.partial = false;
    };
    Query2.prototype.incRequestId = function() {
      this.requestId = _requestId++;
    };
    Query2.nextRequestId = function() {
      return _requestId + 1;
    };
    Query2.prototype.toBin = function() {
      var self2 = this;
      var buffers = [];
      var projection = null;
      var flags = 0;
      if (this.tailable) {
        flags |= OPTS_TAILABLE_CURSOR;
      }
      if (this.slaveOk) {
        flags |= OPTS_SLAVE;
      }
      if (this.oplogReplay) {
        flags |= OPTS_OPLOG_REPLAY;
      }
      if (this.noCursorTimeout) {
        flags |= OPTS_NO_CURSOR_TIMEOUT;
      }
      if (this.awaitData) {
        flags |= OPTS_AWAIT_DATA;
      }
      if (this.exhaust) {
        flags |= OPTS_EXHAUST;
      }
      if (this.partial) {
        flags |= OPTS_PARTIAL;
      }
      if (self2.batchSize !== self2.numberToReturn)
        self2.numberToReturn = self2.batchSize;
      var header = Buffer2.alloc(4 * 4 + 4 + Buffer2.byteLength(self2.ns) + 1 + 4 + 4);
      buffers.push(header);
      var query = self2.bson.serialize(this.query, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
      buffers.push(query);
      if (self2.returnFieldSelector && Object.keys(self2.returnFieldSelector).length > 0) {
        projection = self2.bson.serialize(this.returnFieldSelector, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
        buffers.push(projection);
      }
      var totalLength = header.length + query.length + (projection ? projection.length : 0);
      var index2 = 4;
      header[3] = totalLength >> 24 & 255;
      header[2] = totalLength >> 16 & 255;
      header[1] = totalLength >> 8 & 255;
      header[0] = totalLength & 255;
      header[index2 + 3] = this.requestId >> 24 & 255;
      header[index2 + 2] = this.requestId >> 16 & 255;
      header[index2 + 1] = this.requestId >> 8 & 255;
      header[index2] = this.requestId & 255;
      index2 = index2 + 4;
      header[index2 + 3] = 0 >> 24 & 255;
      header[index2 + 2] = 0 >> 16 & 255;
      header[index2 + 1] = 0 >> 8 & 255;
      header[index2] = 0 & 255;
      index2 = index2 + 4;
      header[index2 + 3] = opcodes.OP_QUERY >> 24 & 255;
      header[index2 + 2] = opcodes.OP_QUERY >> 16 & 255;
      header[index2 + 1] = opcodes.OP_QUERY >> 8 & 255;
      header[index2] = opcodes.OP_QUERY & 255;
      index2 = index2 + 4;
      header[index2 + 3] = flags >> 24 & 255;
      header[index2 + 2] = flags >> 16 & 255;
      header[index2 + 1] = flags >> 8 & 255;
      header[index2] = flags & 255;
      index2 = index2 + 4;
      index2 = index2 + header.write(this.ns, index2, "utf8") + 1;
      header[index2 - 1] = 0;
      header[index2 + 3] = this.numberToSkip >> 24 & 255;
      header[index2 + 2] = this.numberToSkip >> 16 & 255;
      header[index2 + 1] = this.numberToSkip >> 8 & 255;
      header[index2] = this.numberToSkip & 255;
      index2 = index2 + 4;
      header[index2 + 3] = this.numberToReturn >> 24 & 255;
      header[index2 + 2] = this.numberToReturn >> 16 & 255;
      header[index2 + 1] = this.numberToReturn >> 8 & 255;
      header[index2] = this.numberToReturn & 255;
      index2 = index2 + 4;
      return buffers;
    };
    Query2.getRequestId = function() {
      return ++_requestId;
    };
    var GetMore = function(bson, ns, cursorId, opts) {
      opts = opts || {};
      this.numberToReturn = opts.numberToReturn || 0;
      this.requestId = _requestId++;
      this.bson = bson;
      this.ns = ns;
      this.cursorId = cursorId;
    };
    GetMore.prototype.toBin = function() {
      var length = 4 + Buffer2.byteLength(this.ns) + 1 + 4 + 8 + 4 * 4;
      var index2 = 0;
      var _buffer = Buffer2.alloc(length);
      _buffer[index2 + 3] = length >> 24 & 255;
      _buffer[index2 + 2] = length >> 16 & 255;
      _buffer[index2 + 1] = length >> 8 & 255;
      _buffer[index2] = length & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.requestId >> 24 & 255;
      _buffer[index2 + 2] = this.requestId >> 16 & 255;
      _buffer[index2 + 1] = this.requestId >> 8 & 255;
      _buffer[index2] = this.requestId & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = opcodes.OP_GETMORE >> 24 & 255;
      _buffer[index2 + 2] = opcodes.OP_GETMORE >> 16 & 255;
      _buffer[index2 + 1] = opcodes.OP_GETMORE >> 8 & 255;
      _buffer[index2] = opcodes.OP_GETMORE & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      index2 = index2 + _buffer.write(this.ns, index2, "utf8") + 1;
      _buffer[index2 - 1] = 0;
      _buffer[index2 + 3] = this.numberToReturn >> 24 & 255;
      _buffer[index2 + 2] = this.numberToReturn >> 16 & 255;
      _buffer[index2 + 1] = this.numberToReturn >> 8 & 255;
      _buffer[index2] = this.numberToReturn & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.cursorId.getLowBits() >> 24 & 255;
      _buffer[index2 + 2] = this.cursorId.getLowBits() >> 16 & 255;
      _buffer[index2 + 1] = this.cursorId.getLowBits() >> 8 & 255;
      _buffer[index2] = this.cursorId.getLowBits() & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.cursorId.getHighBits() >> 24 & 255;
      _buffer[index2 + 2] = this.cursorId.getHighBits() >> 16 & 255;
      _buffer[index2 + 1] = this.cursorId.getHighBits() >> 8 & 255;
      _buffer[index2] = this.cursorId.getHighBits() & 255;
      index2 = index2 + 4;
      return _buffer;
    };
    var KillCursor = function(bson, ns, cursorIds) {
      this.ns = ns;
      this.requestId = _requestId++;
      this.cursorIds = cursorIds;
    };
    KillCursor.prototype.toBin = function() {
      var length = 4 + 4 + 4 * 4 + this.cursorIds.length * 8;
      var index2 = 0;
      var _buffer = Buffer2.alloc(length);
      _buffer[index2 + 3] = length >> 24 & 255;
      _buffer[index2 + 2] = length >> 16 & 255;
      _buffer[index2 + 1] = length >> 8 & 255;
      _buffer[index2] = length & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.requestId >> 24 & 255;
      _buffer[index2 + 2] = this.requestId >> 16 & 255;
      _buffer[index2 + 1] = this.requestId >> 8 & 255;
      _buffer[index2] = this.requestId & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = opcodes.OP_KILL_CURSORS >> 24 & 255;
      _buffer[index2 + 2] = opcodes.OP_KILL_CURSORS >> 16 & 255;
      _buffer[index2 + 1] = opcodes.OP_KILL_CURSORS >> 8 & 255;
      _buffer[index2] = opcodes.OP_KILL_CURSORS & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.cursorIds.length >> 24 & 255;
      _buffer[index2 + 2] = this.cursorIds.length >> 16 & 255;
      _buffer[index2 + 1] = this.cursorIds.length >> 8 & 255;
      _buffer[index2] = this.cursorIds.length & 255;
      index2 = index2 + 4;
      for (var i = 0; i < this.cursorIds.length; i++) {
        _buffer[index2 + 3] = this.cursorIds[i].getLowBits() >> 24 & 255;
        _buffer[index2 + 2] = this.cursorIds[i].getLowBits() >> 16 & 255;
        _buffer[index2 + 1] = this.cursorIds[i].getLowBits() >> 8 & 255;
        _buffer[index2] = this.cursorIds[i].getLowBits() & 255;
        index2 = index2 + 4;
        _buffer[index2 + 3] = this.cursorIds[i].getHighBits() >> 24 & 255;
        _buffer[index2 + 2] = this.cursorIds[i].getHighBits() >> 16 & 255;
        _buffer[index2 + 1] = this.cursorIds[i].getHighBits() >> 8 & 255;
        _buffer[index2] = this.cursorIds[i].getHighBits() & 255;
        index2 = index2 + 4;
      }
      return _buffer;
    };
    var Response3 = function(bson, message, msgHeader, msgBody, opts) {
      opts = opts || {promoteLongs: true, promoteValues: true, promoteBuffers: false};
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.bson = bson;
      this.opts = opts;
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.responseFlags = msgBody.readInt32LE(0);
      this.cursorId = new Long2(msgBody.readInt32LE(4), msgBody.readInt32LE(8));
      this.startingFrom = msgBody.readInt32LE(12);
      this.numberReturned = msgBody.readInt32LE(16);
      this.documents = new Array(this.numberReturned);
      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
      this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
      this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
      this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
    };
    Response3.prototype.isParsed = function() {
      return this.parsed;
    };
    Response3.prototype.parse = function(options2) {
      if (this.parsed)
        return;
      options2 = options2 || {};
      var raw = options2.raw || false;
      var documentsReturnedIn = options2.documentsReturnedIn || null;
      var promoteLongs = typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : this.opts.promoteLongs;
      var promoteValues = typeof options2.promoteValues === "boolean" ? options2.promoteValues : this.opts.promoteValues;
      var promoteBuffers = typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : this.opts.promoteBuffers;
      var bsonSize, _options;
      _options = {
        promoteLongs,
        promoteValues,
        promoteBuffers
      };
      this.index = 20;
      for (var i = 0; i < this.numberReturned; i++) {
        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
        if (raw) {
          this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
        } else {
          this.documents[i] = this.bson.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
        }
        this.index = this.index + bsonSize;
      }
      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        const fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        _options.fieldsAsRaw = fieldsAsRaw;
        const doc2 = this.bson.deserialize(this.documents[0], _options);
        this.documents = [doc2];
      }
      this.parsed = true;
    };
    module2.exports = {
      Query: Query2,
      GetMore,
      Response: Response3,
      KillCursor
    };
  }
});

// node_modules/mongodb/lib/core/connection/msg.js
var require_msg = __commonJS({
  "node_modules/mongodb/lib/core/connection/msg.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var opcodes = require_shared().opcodes;
    var databaseNamespace = require_shared().databaseNamespace;
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var _requestId = 0;
    var OPTS_CHECKSUM_PRESENT = 1;
    var OPTS_MORE_TO_COME = 2;
    var OPTS_EXHAUST_ALLOWED = 1 << 16;
    var Msg = class {
      constructor(bson, ns, command2, options2) {
        if (command2 == null)
          throw new Error("query must be specified for query");
        this.bson = bson;
        this.ns = ns;
        this.command = command2;
        this.command.$db = databaseNamespace(ns);
        if (options2.readPreference && options2.readPreference.mode !== ReadPreference.PRIMARY) {
          this.command.$readPreference = options2.readPreference.toJSON();
        }
        this.options = options2 || {};
        this.requestId = options2.requestId ? options2.requestId : Msg.getRequestId();
        this.serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
        this.ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
        this.checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
        this.maxBsonSize = options2.maxBsonSize || 1024 * 1024 * 16;
        this.checksumPresent = false;
        this.moreToCome = options2.moreToCome || false;
        this.exhaustAllowed = typeof options2.exhaustAllowed === "boolean" ? options2.exhaustAllowed : false;
      }
      toBin() {
        const buffers = [];
        let flags = 0;
        if (this.checksumPresent) {
          flags |= OPTS_CHECKSUM_PRESENT;
        }
        if (this.moreToCome) {
          flags |= OPTS_MORE_TO_COME;
        }
        if (this.exhaustAllowed) {
          flags |= OPTS_EXHAUST_ALLOWED;
        }
        const header = Buffer2.alloc(4 * 4 + 4);
        buffers.push(header);
        let totalLength = header.length;
        const command2 = this.command;
        totalLength += this.makeDocumentSegment(buffers, command2);
        header.writeInt32LE(totalLength, 0);
        header.writeInt32LE(this.requestId, 4);
        header.writeInt32LE(0, 8);
        header.writeInt32LE(opcodes.OP_MSG, 12);
        header.writeUInt32LE(flags, 16);
        return buffers;
      }
      makeDocumentSegment(buffers, document2) {
        const payloadTypeBuffer = Buffer2.alloc(1);
        payloadTypeBuffer[0] = 0;
        const documentBuffer = this.serializeBson(document2);
        buffers.push(payloadTypeBuffer);
        buffers.push(documentBuffer);
        return payloadTypeBuffer.length + documentBuffer.length;
      }
      serializeBson(document2) {
        return this.bson.serialize(document2, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
      }
    };
    Msg.getRequestId = function() {
      _requestId = _requestId + 1 & 2147483647;
      return _requestId;
    };
    var BinMsg = class {
      constructor(bson, message, msgHeader, msgBody, opts) {
        opts = opts || {promoteLongs: true, promoteValues: true, promoteBuffers: false};
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.bson = bson;
        this.opts = opts;
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        this.responseFlags = msgBody.readInt32LE(0);
        this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
        this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
        this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
        this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
        this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
        this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
        this.documents = [];
      }
      isParsed() {
        return this.parsed;
      }
      parse(options2) {
        if (this.parsed)
          return;
        options2 = options2 || {};
        this.index = 4;
        const raw = options2.raw || false;
        const documentsReturnedIn = options2.documentsReturnedIn || null;
        const promoteLongs = typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : this.opts.promoteLongs;
        const promoteValues = typeof options2.promoteValues === "boolean" ? options2.promoteValues : this.opts.promoteValues;
        const promoteBuffers = typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : this.opts.promoteBuffers;
        const _options = {
          promoteLongs,
          promoteValues,
          promoteBuffers
        };
        while (this.index < this.data.length) {
          const payloadType = this.data.readUInt8(this.index++);
          if (payloadType === 1) {
            throw new MongoError("OP_MSG Payload Type 1 detected unsupported protocol");
          } else if (payloadType === 0) {
            const bsonSize = this.data.readUInt32LE(this.index);
            const bin = this.data.slice(this.index, this.index + bsonSize);
            this.documents.push(raw ? bin : this.bson.deserialize(bin, _options));
            this.index += bsonSize;
          }
        }
        if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
          const fieldsAsRaw = {};
          fieldsAsRaw[documentsReturnedIn] = true;
          _options.fieldsAsRaw = fieldsAsRaw;
          const doc2 = this.bson.deserialize(this.documents[0], _options);
          this.documents = [doc2];
        }
        this.parsed = true;
      }
    };
    module2.exports = {Msg, BinMsg};
  }
});

// node_modules/mongodb/lib/core/connection/logger.js
var require_logger = __commonJS({
  "node_modules/mongodb/lib/core/connection/logger.js"(exports2, module2) {
    "use strict";
    var f = require("util").format;
    var MongoError = require_error().MongoError;
    var classFilters = {};
    var filteredClasses = {};
    var level = null;
    var pid = process.pid;
    var currentLogger = null;
    var Logger = function(className, options2) {
      if (!(this instanceof Logger))
        return new Logger(className, options2);
      options2 = options2 || {};
      this.className = className;
      if (options2.logger) {
        currentLogger = options2.logger;
      } else if (currentLogger == null) {
        currentLogger = console.log;
      }
      if (options2.loggerLevel) {
        level = options2.loggerLevel || "error";
      }
      if (filteredClasses[this.className] == null)
        classFilters[this.className] = true;
    };
    Logger.prototype.debug = function(message, object) {
      if (this.isDebug() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "DEBUG", this.className, pid, dateTime, message);
        var state = {
          type: "debug",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    };
    Logger.prototype.warn = function(message, object) {
      if (this.isWarn() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "WARN", this.className, pid, dateTime, message);
        var state = {
          type: "warn",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.info = function(message, object) {
      if (this.isInfo() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "INFO", this.className, pid, dateTime, message);
        var state = {
          type: "info",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.error = function(message, object) {
      if (this.isError() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "ERROR", this.className, pid, dateTime, message);
        var state = {
          type: "error",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.isInfo = function() {
      return level === "info" || level === "debug";
    }, Logger.prototype.isError = function() {
      return level === "error" || level === "info" || level === "debug";
    }, Logger.prototype.isWarn = function() {
      return level === "error" || level === "warn" || level === "info" || level === "debug";
    }, Logger.prototype.isDebug = function() {
      return level === "debug";
    };
    Logger.reset = function() {
      level = "error";
      filteredClasses = {};
    };
    Logger.currentLogger = function() {
      return currentLogger;
    };
    Logger.setCurrentLogger = function(logger) {
      if (typeof logger !== "function")
        throw new MongoError("current logger must be a function");
      currentLogger = logger;
    };
    Logger.filter = function(type, values) {
      if (type === "class" && Array.isArray(values)) {
        filteredClasses = {};
        values.forEach(function(x) {
          filteredClasses[x] = true;
        });
      }
    };
    Logger.setLevel = function(_level) {
      if (_level !== "info" && _level !== "error" && _level !== "debug" && _level !== "warn") {
        throw new Error(f("%s is an illegal logging level", _level));
      }
      level = _level;
    };
    module2.exports = Logger;
  }
});

// node_modules/mongodb/lib/core/connection/command_result.js
var require_command_result = __commonJS({
  "node_modules/mongodb/lib/core/connection/command_result.js"(exports2, module2) {
    "use strict";
    var CommandResult = function(result, connection, message) {
      this.result = result;
      this.connection = connection;
      this.message = message;
    };
    CommandResult.prototype.toJSON = function() {
      let result = Object.assign({}, this, this.result);
      delete result.message;
      return result;
    };
    CommandResult.prototype.toString = function() {
      return JSON.stringify(this.toJSON());
    };
    module2.exports = CommandResult;
  }
});

// node_modules/mongodb/lib/core/connection/connection.js
var require_connection = __commonJS({
  "node_modules/mongodb/lib/core/connection/connection.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var crypto = require("crypto");
    var debugOptions = require_utils3().debugOptions;
    var parseHeader = require_shared().parseHeader;
    var decompress = require_compression().decompress;
    var Response3 = require_commands().Response;
    var BinMsg = require_msg().BinMsg;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var MongoError = require_error().MongoError;
    var Logger = require_logger();
    var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
    var OP_MSG = require_shared().opcodes.OP_MSG;
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var Buffer2 = require_safe_buffer().Buffer;
    var Query2 = require_commands().Query;
    var CommandResult = require_command_result();
    var _id = 0;
    var DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;
    var DEBUG_FIELDS = [
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "checkServerIdentity"
    ];
    var connectionAccountingSpy = void 0;
    var connectionAccounting = false;
    var connections = {};
    var Connection = class extends EventEmitter {
      constructor(socket, options2) {
        super();
        options2 = options2 || {};
        if (!options2.bson) {
          throw new TypeError("must pass in valid bson parser");
        }
        this.id = _id++;
        this.options = options2;
        this.logger = Logger("Connection", options2);
        this.bson = options2.bson;
        this.tag = options2.tag;
        this.maxBsonMessageSize = options2.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;
        this.port = options2.port || 27017;
        this.host = options2.host || "localhost";
        this.socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
        this.keepAlive = typeof options2.keepAlive === "boolean" ? options2.keepAlive : true;
        this.keepAliveInitialDelay = typeof options2.keepAliveInitialDelay === "number" ? options2.keepAliveInitialDelay : 12e4;
        this.connectionTimeout = typeof options2.connectionTimeout === "number" ? options2.connectionTimeout : 3e4;
        if (this.keepAliveInitialDelay > this.socketTimeout) {
          this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);
        }
        if (this.logger.isDebug()) {
          this.logger.debug(`creating connection ${this.id} with options [${JSON.stringify(debugOptions(DEBUG_FIELDS, options2))}]`);
        }
        this.responseOptions = {
          promoteLongs: typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true,
          promoteValues: typeof options2.promoteValues === "boolean" ? options2.promoteValues : true,
          promoteBuffers: typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false
        };
        this.flushing = false;
        this.queue = [];
        this.writeStream = null;
        this.destroyed = false;
        this.timedOut = false;
        const hash2 = crypto.createHash("sha1");
        hash2.update(this.address);
        this.hashedName = hash2.digest("hex");
        this.workItems = [];
        this.socket = socket;
        this.socket.once("error", errorHandler(this));
        this.socket.once("timeout", timeoutHandler(this));
        this.socket.once("close", closeHandler(this));
        this.socket.on("data", dataHandler(this));
        if (connectionAccounting) {
          addConnection(this.id, this);
        }
      }
      setSocketTimeout(value) {
        if (this.socket) {
          this.socket.setTimeout(value);
        }
      }
      resetSocketTimeout() {
        if (this.socket) {
          this.socket.setTimeout(this.socketTimeout);
        }
      }
      static enableConnectionAccounting(spy) {
        if (spy) {
          connectionAccountingSpy = spy;
        }
        connectionAccounting = true;
        connections = {};
      }
      static disableConnectionAccounting() {
        connectionAccounting = false;
        connectionAccountingSpy = void 0;
      }
      static connections() {
        return connections;
      }
      get address() {
        return `${this.host}:${this.port}`;
      }
      unref() {
        if (this.socket == null) {
          this.once("connect", () => this.socket.unref());
          return;
        }
        this.socket.unref();
      }
      flush(err) {
        while (this.workItems.length > 0) {
          const workItem = this.workItems.shift();
          if (workItem.cb) {
            workItem.cb(err);
          }
        }
      }
      destroy(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = Object.assign({force: false}, options2);
        if (connectionAccounting) {
          deleteConnection(this.id);
        }
        if (this.socket == null) {
          this.destroyed = true;
          return;
        }
        if (options2.force || this.timedOut) {
          this.socket.destroy();
          this.destroyed = true;
          if (typeof callback === "function")
            callback(null, null);
          return;
        }
        this.socket.end((err) => {
          this.destroyed = true;
          if (typeof callback === "function")
            callback(err, null);
        });
      }
      write(buffer) {
        if (this.logger.isDebug()) {
          if (!Array.isArray(buffer)) {
            this.logger.debug(`writing buffer [${buffer.toString("hex")}] to ${this.address}`);
          } else {
            for (let i = 0; i < buffer.length; i++)
              this.logger.debug(`writing buffer [${buffer[i].toString("hex")}] to ${this.address}`);
          }
        }
        if (this.socket.destroyed === false) {
          if (!Array.isArray(buffer)) {
            this.socket.write(buffer, "binary");
            return true;
          }
          for (let i = 0; i < buffer.length; i++) {
            this.socket.write(buffer[i], "binary");
          }
          return true;
        }
        return false;
      }
      toString() {
        return "" + this.id;
      }
      toJSON() {
        return {id: this.id, host: this.host, port: this.port};
      }
      isConnected() {
        if (this.destroyed)
          return false;
        return !this.socket.destroyed && this.socket.writable;
      }
      command(ns, command2, options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        const conn = this;
        const socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
        const bson = conn.options.bson;
        const query = new Query2(bson, ns, command2, {
          numberToSkip: 0,
          numberToReturn: 1
        });
        const noop3 = () => {
        };
        function _callback(err, result) {
          callback(err, result);
          callback = noop3;
        }
        function errorHandler2(err) {
          conn.resetSocketTimeout();
          CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
          conn.removeListener("message", messageHandler);
          if (err == null) {
            err = new MongoError(`runCommand failed for connection to '${conn.address}'`);
          }
          conn.on("error", noop3);
          _callback(err);
        }
        function messageHandler(msg) {
          if (msg.responseTo !== query.requestId) {
            return;
          }
          conn.resetSocketTimeout();
          CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
          conn.removeListener("message", messageHandler);
          msg.parse({promoteValues: true});
          const response = msg.documents[0];
          if (response.ok === 0 || response.$err || response.errmsg || response.code) {
            _callback(new MongoError(response));
            return;
          }
          _callback(void 0, new CommandResult(response, this, msg));
        }
        conn.setSocketTimeout(socketTimeout);
        CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.once(eventName, errorHandler2));
        conn.on("message", messageHandler);
        conn.write(query.toBin());
      }
    };
    var CONNECTION_ERROR_EVENTS = ["error", "close", "timeout", "parseError"];
    function deleteConnection(id) {
      delete connections[id];
      if (connectionAccountingSpy) {
        connectionAccountingSpy.deleteConnection(id);
      }
    }
    function addConnection(id, connection) {
      connections[id] = connection;
      if (connectionAccountingSpy) {
        connectionAccountingSpy.addConnection(id, connection);
      }
    }
    function errorHandler(conn) {
      return function(err) {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`);
        }
        conn.emit("error", new MongoNetworkError(err), conn);
      };
    }
    function timeoutHandler(conn) {
      return function() {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);
        }
        conn.timedOut = true;
        conn.emit("timeout", new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {
          beforeHandshake: conn.ismaster == null
        }), conn);
      };
    }
    function closeHandler(conn) {
      return function(hadError) {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);
        }
        if (!hadError) {
          conn.emit("close", new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`), conn);
        }
      };
    }
    function processMessage(conn, message) {
      const msgHeader = parseHeader(message);
      if (msgHeader.opCode !== OP_COMPRESSED) {
        const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response3;
        conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);
        return;
      }
      msgHeader.fromCompressed = true;
      let index2 = MESSAGE_HEADER_SIZE;
      msgHeader.opCode = message.readInt32LE(index2);
      index2 += 4;
      msgHeader.length = message.readInt32LE(index2);
      index2 += 4;
      const compressorID = message[index2];
      index2++;
      decompress(compressorID, message.slice(index2), (err, decompressedMsgBody) => {
        if (err) {
          conn.emit("error", err);
          return;
        }
        if (decompressedMsgBody.length !== msgHeader.length) {
          conn.emit("error", new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
          return;
        }
        const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response3;
        conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);
      });
    }
    function dataHandler(conn) {
      return function(data) {
        while (data.length > 0) {
          if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {
            const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;
            if (remainingBytesToRead > data.length) {
              data.copy(conn.buffer, conn.bytesRead);
              conn.bytesRead = conn.bytesRead + data.length;
              data = Buffer2.alloc(0);
            } else {
              data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);
              data = data.slice(remainingBytesToRead);
              const emitBuffer = conn.buffer;
              conn.buffer = null;
              conn.sizeOfMessage = 0;
              conn.bytesRead = 0;
              conn.stubBuffer = null;
              processMessage(conn, emitBuffer);
            }
          } else {
            if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {
              if (conn.stubBuffer.length + data.length > 4) {
                const newData = Buffer2.alloc(conn.stubBuffer.length + data.length);
                conn.stubBuffer.copy(newData, 0);
                data.copy(newData, conn.stubBuffer.length);
                data = newData;
                conn.buffer = null;
                conn.sizeOfMessage = 0;
                conn.bytesRead = 0;
                conn.stubBuffer = null;
              } else {
                const newStubBuffer = Buffer2.alloc(conn.stubBuffer.length + data.length);
                conn.stubBuffer.copy(newStubBuffer, 0);
                data.copy(newStubBuffer, conn.stubBuffer.length);
                data = Buffer2.alloc(0);
              }
            } else {
              if (data.length > 4) {
                const sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;
                if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {
                  const errorObject = {
                    err: "socketHandler",
                    trace: "",
                    bin: conn.buffer,
                    parseState: {
                      sizeOfMessage,
                      bytesRead: conn.bytesRead,
                      stubBuffer: conn.stubBuffer
                    }
                  };
                  conn.emit("parseError", errorObject, conn);
                  return;
                }
                if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {
                  conn.buffer = Buffer2.alloc(sizeOfMessage);
                  data.copy(conn.buffer, 0);
                  conn.bytesRead = data.length;
                  conn.sizeOfMessage = sizeOfMessage;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {
                  const emitBuffer = data;
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                  processMessage(conn, emitBuffer);
                } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {
                  const errorObject = {
                    err: "socketHandler",
                    trace: null,
                    bin: data,
                    parseState: {
                      sizeOfMessage,
                      bytesRead: 0,
                      buffer: null,
                      stubBuffer: null
                    }
                  };
                  conn.emit("parseError", errorObject, conn);
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                } else {
                  const emitBuffer = data.slice(0, sizeOfMessage);
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = data.slice(sizeOfMessage);
                  processMessage(conn, emitBuffer);
                }
              } else {
                conn.stubBuffer = Buffer2.alloc(data.length);
                data.copy(conn.stubBuffer, 0);
                data = Buffer2.alloc(0);
              }
            }
          }
        }
      };
    }
    module2.exports = Connection;
  }
});

// node_modules/mongodb/lib/core/connection/apm.js
var require_apm = __commonJS({
  "node_modules/mongodb/lib/core/connection/apm.js"(exports2, module2) {
    "use strict";
    var Msg = require_msg().Msg;
    var KillCursor = require_commands().KillCursor;
    var GetMore = require_commands().GetMore;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var SENSITIVE_COMMANDS = new Set([
      "authenticate",
      "saslStart",
      "saslContinue",
      "getnonce",
      "createUser",
      "updateUser",
      "copydbgetnonce",
      "copydbsaslstart",
      "copydb"
    ]);
    var extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];
    var namespace = (command2) => command2.ns;
    var databaseName = (command2) => command2.ns.split(".")[0];
    var collectionName = (command2) => command2.ns.split(".")[1];
    var generateConnectionId = (pool) => pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;
    var maybeRedact = (commandName, result) => SENSITIVE_COMMANDS.has(commandName) ? {} : result;
    var isLegacyPool = (pool) => pool.s && pool.queue;
    var LEGACY_FIND_QUERY_MAP = {
      $query: "filter",
      $orderby: "sort",
      $hint: "hint",
      $comment: "comment",
      $maxScan: "maxScan",
      $max: "max",
      $min: "min",
      $returnKey: "returnKey",
      $showDiskLoc: "showRecordId",
      $maxTimeMS: "maxTimeMS",
      $snapshot: "snapshot"
    };
    var LEGACY_FIND_OPTIONS_MAP = {
      numberToSkip: "skip",
      numberToReturn: "batchSize",
      returnFieldsSelector: "projection"
    };
    var OP_QUERY_KEYS = [
      "tailable",
      "oplogReplay",
      "noCursorTimeout",
      "awaitData",
      "partial",
      "exhaust"
    ];
    var extractCommand = (command2) => {
      if (command2 instanceof GetMore) {
        return {
          getMore: command2.cursorId,
          collection: collectionName(command2),
          batchSize: command2.numberToReturn
        };
      }
      if (command2 instanceof KillCursor) {
        return {
          killCursors: collectionName(command2),
          cursors: command2.cursorIds
        };
      }
      if (command2 instanceof Msg) {
        return command2.command;
      }
      if (command2.query && command2.query.$query) {
        let result;
        if (command2.ns === "admin.$cmd") {
          result = Object.assign({}, command2.query.$query);
        } else {
          result = {find: collectionName(command2)};
          Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
            if (typeof command2.query[key] !== "undefined")
              result[LEGACY_FIND_QUERY_MAP[key]] = command2.query[key];
          });
        }
        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
          if (typeof command2[key] !== "undefined")
            result[LEGACY_FIND_OPTIONS_MAP[key]] = command2[key];
        });
        OP_QUERY_KEYS.forEach((key) => {
          if (command2[key])
            result[key] = command2[key];
        });
        if (typeof command2.pre32Limit !== "undefined") {
          result.limit = command2.pre32Limit;
        }
        if (command2.query.$explain) {
          return {explain: result};
        }
        return result;
      }
      return command2.query ? command2.query : command2;
    };
    var extractReply = (command2, reply) => {
      if (command2 instanceof GetMore) {
        return {
          ok: 1,
          cursor: {
            id: reply.message.cursorId,
            ns: namespace(command2),
            nextBatch: reply.message.documents
          }
        };
      }
      if (command2 instanceof KillCursor) {
        return {
          ok: 1,
          cursorsUnknown: command2.cursorIds
        };
      }
      if (command2.query && typeof command2.query.$query !== "undefined") {
        return {
          ok: 1,
          cursor: {
            id: reply.message.cursorId,
            ns: namespace(command2),
            firstBatch: reply.message.documents
          }
        };
      }
      return reply && reply.result ? reply.result : reply;
    };
    var extractConnectionDetails = (pool) => {
      if (isLegacyPool(pool)) {
        return {
          connectionId: generateConnectionId(pool)
        };
      }
      const connection = pool;
      return {
        address: connection.address,
        connectionId: connection.id
      };
    };
    var CommandStartedEvent = class {
      constructor(pool, command2) {
        const cmd2 = extractCommand(command2);
        const commandName = extractCommandName(cmd2);
        const connectionDetails = extractConnectionDetails(pool);
        if (SENSITIVE_COMMANDS.has(commandName)) {
          this.commandObj = {};
          this.commandObj[commandName] = true;
        }
        Object.assign(this, connectionDetails, {
          requestId: command2.requestId,
          databaseName: databaseName(command2),
          commandName,
          command: cmd2
        });
      }
    };
    var CommandSucceededEvent = class {
      constructor(pool, command2, reply, started) {
        const cmd2 = extractCommand(command2);
        const commandName = extractCommandName(cmd2);
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command2.requestId,
          commandName,
          duration: calculateDurationInMs(started),
          reply: maybeRedact(commandName, extractReply(command2, reply))
        });
      }
    };
    var CommandFailedEvent = class {
      constructor(pool, command2, error3, started) {
        const cmd2 = extractCommand(command2);
        const commandName = extractCommandName(cmd2);
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command2.requestId,
          commandName,
          duration: calculateDurationInMs(started),
          failure: maybeRedact(commandName, error3)
        });
      }
    };
    module2.exports = {
      CommandStartedEvent,
      CommandSucceededEvent,
      CommandFailedEvent
    };
  }
});

// node_modules/mongodb/lib/core/auth/auth_provider.js
var require_auth_provider = __commonJS({
  "node_modules/mongodb/lib/core/auth/auth_provider.js"(exports2, module2) {
    "use strict";
    var AuthContext = class {
      constructor(connection, credentials, options2) {
        this.connection = connection;
        this.credentials = credentials;
        this.options = options2;
      }
    };
    var AuthProvider = class {
      constructor(bson) {
        this.bson = bson;
      }
      prepare(handshakeDoc, context, callback) {
        callback(void 0, handshakeDoc);
      }
      auth(context, callback) {
        callback(new TypeError("`auth` method must be overridden by subclass"));
      }
    };
    module2.exports = {AuthContext, AuthProvider};
  }
});

// node_modules/mongodb/lib/core/auth/mongocr.js
var require_mongocr = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongocr.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    var AuthProvider = require_auth_provider().AuthProvider;
    var MongoCR = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const username = credentials.username;
        const password = credentials.password;
        const source = credentials.source;
        connection.command(`${source}.$cmd`, {getnonce: 1}, (err, result) => {
          let nonce = null;
          let key = null;
          if (err == null) {
            const r = result.result;
            nonce = r.nonce;
            let md5 = crypto.createHash("md5");
            md5.update(username + ":mongo:" + password, "utf8");
            const hash_password = md5.digest("hex");
            md5 = crypto.createHash("md5");
            md5.update(nonce + username + hash_password, "utf8");
            key = md5.digest("hex");
          }
          const authenticateCommand = {
            authenticate: 1,
            user: username,
            nonce,
            key
          };
          connection.command(`${source}.$cmd`, authenticateCommand, callback);
        });
      }
    };
    module2.exports = MongoCR;
  }
});

// node_modules/mongodb/lib/core/auth/x509.js
var require_x509 = __commonJS({
  "node_modules/mongodb/lib/core/auth/x509.js"(exports2, module2) {
    "use strict";
    var AuthProvider = require_auth_provider().AuthProvider;
    var X509 = class extends AuthProvider {
      prepare(handshakeDoc, authContext, callback) {
        const credentials = authContext.credentials;
        Object.assign(handshakeDoc, {
          speculativeAuthenticate: x509AuthenticateCommand(credentials)
        });
        callback(void 0, handshakeDoc);
      }
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const response = authContext.response;
        if (response.speculativeAuthenticate) {
          return callback();
        }
        connection.command("$external.$cmd", x509AuthenticateCommand(credentials), callback);
      }
    };
    function x509AuthenticateCommand(credentials) {
      const command2 = {authenticate: 1, mechanism: "MONGODB-X509"};
      if (credentials.username) {
        Object.assign(command2, {user: credentials.username});
      }
      return command2;
    }
    module2.exports = X509;
  }
});

// node_modules/mongodb/lib/core/auth/plain.js
var require_plain = __commonJS({
  "node_modules/mongodb/lib/core/auth/plain.js"(exports2, module2) {
    "use strict";
    var retrieveBSON = require_utils3().retrieveBSON;
    var AuthProvider = require_auth_provider().AuthProvider;
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var Plain = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const username = credentials.username;
        const password = credentials.password;
        const payload = new Binary2(`\0${username}\0${password}`);
        const command2 = {
          saslStart: 1,
          mechanism: "PLAIN",
          payload,
          autoAuthorize: 1
        };
        connection.command("$external.$cmd", command2, callback);
      }
    };
    module2.exports = Plain;
  }
});

// node_modules/mongodb/lib/core/auth/gssapi.js
var require_gssapi = __commonJS({
  "node_modules/mongodb/lib/core/auth/gssapi.js"(exports2, module2) {
    "use strict";
    var dns = require("dns");
    var AuthProvider = require_auth_provider().AuthProvider;
    var retrieveKerberos = require_utils2().retrieveKerberos;
    var MongoError = require_error().MongoError;
    var kerberos;
    var GSSAPI = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        if (credentials == null)
          return callback(new MongoError("credentials required"));
        const username = credentials.username;
        function externalCommand(command2, cb) {
          return connection.command("$external.$cmd", command2, cb);
        }
        makeKerberosClient(authContext, (err, client) => {
          if (err)
            return callback(err);
          if (client == null)
            return callback(new MongoError("gssapi client missing"));
          client.step("", (err2, payload) => {
            if (err2)
              return callback(err2);
            externalCommand(saslStart(payload), (err3, response) => {
              if (err3)
                return callback(err3);
              const result = response.result;
              negotiate(client, 10, result.payload, (err4, payload2) => {
                if (err4)
                  return callback(err4);
                externalCommand(saslContinue(payload2, result.conversationId), (err5, response2) => {
                  if (err5)
                    return callback(err5);
                  const result2 = response2.result;
                  finalize(client, username, result2.payload, (err6, payload3) => {
                    if (err6)
                      return callback(err6);
                    externalCommand({
                      saslContinue: 1,
                      conversationId: result2.conversationId,
                      payload: payload3
                    }, (err7, result3) => {
                      if (err7)
                        return callback(err7);
                      callback(void 0, result3);
                    });
                  });
                });
              });
            });
          });
        });
      }
    };
    module2.exports = GSSAPI;
    function makeKerberosClient(authContext, callback) {
      const host = authContext.options.host;
      const port = authContext.options.port;
      const credentials = authContext.credentials;
      if (!host || !port || !credentials) {
        return callback(new MongoError(`Connection must specify: ${host ? "host" : ""}, ${port ? "port" : ""}, ${credentials ? "host" : "credentials"}.`));
      }
      if (kerberos == null) {
        try {
          kerberos = retrieveKerberos();
        } catch (e) {
          return callback(e);
        }
      }
      const username = credentials.username;
      const password = credentials.password;
      const mechanismProperties = credentials.mechanismProperties;
      const serviceName = mechanismProperties["gssapiservicename"] || mechanismProperties["gssapiServiceName"] || "mongodb";
      performGssapiCanonicalizeHostName(host, mechanismProperties, (err, host2) => {
        if (err)
          return callback(err);
        const initOptions = {};
        if (password != null) {
          Object.assign(initOptions, {user: username, password});
        }
        kerberos.initializeClient(`${serviceName}${process.platform === "win32" ? "/" : "@"}${host2}`, initOptions, (err2, client) => {
          if (err2)
            return callback(new MongoError(err2));
          callback(null, client);
        });
      });
    }
    function saslStart(payload) {
      return {
        saslStart: 1,
        mechanism: "GSSAPI",
        payload,
        autoAuthorize: 1
      };
    }
    function saslContinue(payload, conversationId) {
      return {
        saslContinue: 1,
        conversationId,
        payload
      };
    }
    function negotiate(client, retries, payload, callback) {
      client.step(payload, (err, response) => {
        if (err && retries === 0)
          return callback(err);
        if (err)
          return negotiate(client, retries - 1, payload, callback);
        callback(void 0, response || "");
      });
    }
    function finalize(client, user, payload, callback) {
      client.unwrap(payload, (err, response) => {
        if (err)
          return callback(err);
        client.wrap(response || "", {user}, (err2, wrapped) => {
          if (err2)
            return callback(err2);
          callback(void 0, wrapped);
        });
      });
    }
    function performGssapiCanonicalizeHostName(host, mechanismProperties, callback) {
      const canonicalizeHostName = typeof mechanismProperties.gssapiCanonicalizeHostName === "boolean" ? mechanismProperties.gssapiCanonicalizeHostName : false;
      if (!canonicalizeHostName)
        return callback(void 0, host);
      dns.resolveCname(host, (err, r) => {
        if (err)
          return callback(err);
        if (Array.isArray(r) && r.length > 0) {
          return callback(void 0, r[0]);
        }
        callback(void 0, host);
      });
    }
  }
});

// node_modules/memory-pager/index.js
var require_memory_pager = __commonJS({
  "node_modules/memory-pager/index.js"(exports2, module2) {
    module2.exports = Pager;
    function Pager(pageSize, opts) {
      if (!(this instanceof Pager))
        return new Pager(pageSize, opts);
      this.length = 0;
      this.updates = [];
      this.path = new Uint16Array(4);
      this.pages = new Array(32768);
      this.maxPages = this.pages.length;
      this.level = 0;
      this.pageSize = pageSize || 1024;
      this.deduplicate = opts ? opts.deduplicate : null;
      this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
    }
    Pager.prototype.updated = function(page) {
      while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
        page.deduplicate++;
        if (page.deduplicate === this.deduplicate.length) {
          page.deduplicate = 0;
          if (page.buffer.equals && page.buffer.equals(this.deduplicate))
            page.buffer = this.deduplicate;
          break;
        }
      }
      if (page.updated || !this.updates)
        return;
      page.updated = true;
      this.updates.push(page);
    };
    Pager.prototype.lastUpdate = function() {
      if (!this.updates || !this.updates.length)
        return null;
      var page = this.updates.pop();
      page.updated = false;
      return page;
    };
    Pager.prototype._array = function(i, noAllocate) {
      if (i >= this.maxPages) {
        if (noAllocate)
          return;
        grow(this, i);
      }
      factor(i, this.path);
      var arr = this.pages;
      for (var j = this.level; j > 0; j--) {
        var p = this.path[j];
        var next = arr[p];
        if (!next) {
          if (noAllocate)
            return;
          next = arr[p] = new Array(32768);
        }
        arr = next;
      }
      return arr;
    };
    Pager.prototype.get = function(i, noAllocate) {
      var arr = this._array(i, noAllocate);
      var first = this.path[0];
      var page = arr && arr[first];
      if (!page && !noAllocate) {
        page = arr[first] = new Page(i, alloc(this.pageSize));
        if (i >= this.length)
          this.length = i + 1;
      }
      if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
        page.buffer = copy(page.buffer);
        page.deduplicate = 0;
      }
      return page;
    };
    Pager.prototype.set = function(i, buf) {
      var arr = this._array(i, false);
      var first = this.path[0];
      if (i >= this.length)
        this.length = i + 1;
      if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
        arr[first] = void 0;
        return;
      }
      if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
        buf = this.deduplicate;
      }
      var page = arr[first];
      var b = truncate(buf, this.pageSize);
      if (page)
        page.buffer = b;
      else
        arr[first] = new Page(i, b);
    };
    Pager.prototype.toBuffer = function() {
      var list = new Array(this.length);
      var empty3 = alloc(this.pageSize);
      var ptr = 0;
      while (ptr < list.length) {
        var arr = this._array(ptr, true);
        for (var i = 0; i < 32768 && ptr < list.length; i++) {
          list[ptr++] = arr && arr[i] ? arr[i].buffer : empty3;
        }
      }
      return Buffer.concat(list);
    };
    function grow(pager, index2) {
      while (pager.maxPages < index2) {
        var old = pager.pages;
        pager.pages = new Array(32768);
        pager.pages[0] = old;
        pager.level++;
        pager.maxPages *= 32768;
      }
    }
    function truncate(buf, len) {
      if (buf.length === len)
        return buf;
      if (buf.length > len)
        return buf.slice(0, len);
      var cpy = alloc(len);
      buf.copy(cpy);
      return cpy;
    }
    function alloc(size) {
      if (Buffer.alloc)
        return Buffer.alloc(size);
      var buf = new Buffer(size);
      buf.fill(0);
      return buf;
    }
    function copy(buf) {
      var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
      buf.copy(cpy);
      return cpy;
    }
    function Page(i, buf) {
      this.offset = i * buf.length;
      this.buffer = buf;
      this.updated = false;
      this.deduplicate = 0;
    }
    function factor(n, out) {
      n = (n - (out[0] = n & 32767)) / 32768;
      n = (n - (out[1] = n & 32767)) / 32768;
      out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
    }
  }
});

// node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS({
  "node_modules/sparse-bitfield/index.js"(exports2, module2) {
    var pager = require_memory_pager();
    module2.exports = Bitfield;
    function Bitfield(opts) {
      if (!(this instanceof Bitfield))
        return new Bitfield(opts);
      if (!opts)
        opts = {};
      if (Buffer.isBuffer(opts))
        opts = {buffer: opts};
      this.pageOffset = opts.pageOffset || 0;
      this.pageSize = opts.pageSize || 1024;
      this.pages = opts.pages || pager(this.pageSize);
      this.byteLength = this.pages.length * this.pageSize;
      this.length = 8 * this.byteLength;
      if (!powerOfTwo(this.pageSize))
        throw new Error("The page size should be a power of two");
      this._trackUpdates = !!opts.trackUpdates;
      this._pageMask = this.pageSize - 1;
      if (opts.buffer) {
        for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
          this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
        }
        this.byteLength = opts.buffer.length;
        this.length = 8 * this.byteLength;
      }
    }
    Bitfield.prototype.get = function(i) {
      var o = i & 7;
      var j = (i - o) / 8;
      return !!(this.getByte(j) & 128 >> o);
    };
    Bitfield.prototype.getByte = function(i) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, true);
      return page ? page.buffer[o + this.pageOffset] : 0;
    };
    Bitfield.prototype.set = function(i, v) {
      var o = i & 7;
      var j = (i - o) / 8;
      var b = this.getByte(j);
      return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
    };
    Bitfield.prototype.toBuffer = function() {
      var all = alloc(this.pages.length * this.pageSize);
      for (var i = 0; i < this.pages.length; i++) {
        var next = this.pages.get(i, true);
        var allOffset = i * this.pageSize;
        if (next)
          next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
      }
      return all;
    };
    Bitfield.prototype.setByte = function(i, b) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, false);
      o += this.pageOffset;
      if (page.buffer[o] === b)
        return false;
      page.buffer[o] = b;
      if (i >= this.byteLength) {
        this.byteLength = i + 1;
        this.length = this.byteLength * 8;
      }
      if (this._trackUpdates)
        this.pages.updated(page);
      return true;
    };
    function alloc(n) {
      if (Buffer.alloc)
        return Buffer.alloc(n);
      var b = new Buffer(n);
      b.fill(0);
      return b;
    }
    function powerOfTwo(x) {
      return !(x & x - 1);
    }
  }
});

// node_modules/saslprep/lib/memory-code-points.js
var require_memory_code_points = __commonJS({
  "node_modules/saslprep/lib/memory-code-points.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var bitfield = require_sparse_bitfield();
    var memory = fs.readFileSync(path.resolve(__dirname, "../code-points.mem"));
    var offset = 0;
    function read2() {
      const size = memory.readUInt32BE(offset);
      offset += 4;
      const codepoints = memory.slice(offset, offset + size);
      offset += size;
      return bitfield({buffer: codepoints});
    }
    var unassigned_code_points = read2();
    var commonly_mapped_to_nothing = read2();
    var non_ASCII_space_characters = read2();
    var prohibited_characters = read2();
    var bidirectional_r_al = read2();
    var bidirectional_l = read2();
    module2.exports = {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    };
  }
});

// node_modules/saslprep/index.js
var require_saslprep = __commonJS({
  "node_modules/saslprep/index.js"(exports2, module2) {
    "use strict";
    var {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    } = require_memory_code_points();
    module2.exports = saslprep;
    var mapping2space = non_ASCII_space_characters;
    var mapping2nothing = commonly_mapped_to_nothing;
    var getCodePoint = (character) => character.codePointAt(0);
    var first = (x) => x[0];
    var last = (x) => x[x.length - 1];
    function toCodePoints(input) {
      const codepoints = [];
      const size = input.length;
      for (let i = 0; i < size; i += 1) {
        const before = input.charCodeAt(i);
        if (before >= 55296 && before <= 56319 && size > i + 1) {
          const next = input.charCodeAt(i + 1);
          if (next >= 56320 && next <= 57343) {
            codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
            i += 1;
            continue;
          }
        }
        codepoints.push(before);
      }
      return codepoints;
    }
    function saslprep(input, opts = {}) {
      if (typeof input !== "string") {
        throw new TypeError("Expected string.");
      }
      if (input.length === 0) {
        return "";
      }
      const mapped_input = toCodePoints(input).map((character) => mapping2space.get(character) ? 32 : character).filter((character) => !mapping2nothing.get(character));
      const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
      const normalized_map = toCodePoints(normalized_input);
      const hasProhibited = normalized_map.some((character) => prohibited_characters.get(character));
      if (hasProhibited) {
        throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
      }
      if (opts.allowUnassigned !== true) {
        const hasUnassigned = normalized_map.some((character) => unassigned_code_points.get(character));
        if (hasUnassigned) {
          throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
        }
      }
      const hasBidiRAL = normalized_map.some((character) => bidirectional_r_al.get(character));
      const hasBidiL = normalized_map.some((character) => bidirectional_l.get(character));
      if (hasBidiRAL && hasBidiL) {
        throw new Error("String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      const isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));
      const isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));
      if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
        throw new Error("Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      return normalized_input;
    }
  }
});

// node_modules/mongodb/lib/core/auth/scram.js
var require_scram = __commonJS({
  "node_modules/mongodb/lib/core/auth/scram.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    var Buffer2 = require_safe_buffer().Buffer;
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var AuthProvider = require_auth_provider().AuthProvider;
    var emitWarningOnce = require_utils4().emitWarning;
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var saslprep;
    try {
      saslprep = require_saslprep();
    } catch (e) {
    }
    var ScramSHA = class extends AuthProvider {
      constructor(bson, cryptoMethod) {
        super(bson);
        this.cryptoMethod = cryptoMethod || "sha1";
      }
      prepare(handshakeDoc, authContext, callback) {
        const cryptoMethod = this.cryptoMethod;
        if (cryptoMethod === "sha256" && saslprep == null) {
          emitWarningOnce("Warning: no saslprep library specified. Passwords will not be sanitized");
        }
        crypto.randomBytes(24, (err, nonce) => {
          if (err) {
            return callback(err);
          }
          Object.assign(authContext, {nonce});
          const credentials = authContext.credentials;
          const request = Object.assign({}, handshakeDoc, {
            speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {
              db: credentials.source
            })
          });
          callback(void 0, request);
        });
      }
      auth(authContext, callback) {
        const response = authContext.response;
        if (response && response.speculativeAuthenticate) {
          continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);
          return;
        }
        executeScram(this.cryptoMethod, authContext, callback);
      }
    };
    function cleanUsername(username) {
      return username.replace("=", "=3D").replace(",", "=2C");
    }
    function clientFirstMessageBare(username, nonce) {
      return Buffer2.concat([
        Buffer2.from("n=", "utf8"),
        Buffer2.from(username, "utf8"),
        Buffer2.from(",r=", "utf8"),
        Buffer2.from(nonce.toString("base64"), "utf8")
      ]);
    }
    function makeFirstMessage(cryptoMethod, credentials, nonce) {
      const username = cleanUsername(credentials.username);
      const mechanism = cryptoMethod === "sha1" ? "SCRAM-SHA-1" : "SCRAM-SHA-256";
      return {
        saslStart: 1,
        mechanism,
        payload: new Binary2(Buffer2.concat([Buffer2.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
        autoAuthorize: 1,
        options: {skipEmptyExchange: true}
      };
    }
    function executeScram(cryptoMethod, authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const nonce = authContext.nonce;
      const db = credentials.source;
      const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
      connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {
        const err = resolveError(_err, result);
        if (err) {
          return callback(err);
        }
        continueScramConversation(cryptoMethod, result.result, authContext, callback);
      });
    }
    function continueScramConversation(cryptoMethod, response, authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const nonce = authContext.nonce;
      const db = credentials.source;
      const username = cleanUsername(credentials.username);
      const password = credentials.password;
      let processedPassword;
      if (cryptoMethod === "sha256") {
        processedPassword = saslprep ? saslprep(password) : password;
      } else {
        try {
          processedPassword = passwordDigest(username, password);
        } catch (e) {
          return callback(e);
        }
      }
      const payload = Buffer2.isBuffer(response.payload) ? new Binary2(response.payload) : response.payload;
      const dict = parsePayload(payload.value());
      const iterations = parseInt(dict.i, 10);
      if (iterations && iterations < 4096) {
        callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);
        return;
      }
      const salt = dict.s;
      const rnonce = dict.r;
      if (rnonce.startsWith("nonce")) {
        callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);
        return;
      }
      const withoutProof = `c=biws,r=${rnonce}`;
      const saltedPassword = HI(processedPassword, Buffer2.from(salt, "base64"), iterations, cryptoMethod);
      const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
      const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
      const storedKey = H(cryptoMethod, clientKey);
      const authMessage = [
        clientFirstMessageBare(username, nonce),
        payload.value().toString("base64"),
        withoutProof
      ].join(",");
      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
      const clientProof = `p=${xor(clientKey, clientSignature)}`;
      const clientFinal = [withoutProof, clientProof].join(",");
      const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
      const saslContinueCmd = {
        saslContinue: 1,
        conversationId: response.conversationId,
        payload: new Binary2(Buffer2.from(clientFinal))
      };
      connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {
        const err = resolveError(_err, result);
        if (err) {
          return callback(err);
        }
        const r = result.result;
        const parsedResponse = parsePayload(r.payload.value());
        if (!compareDigest(Buffer2.from(parsedResponse.v, "base64"), serverSignature)) {
          callback(new MongoError("Server returned an invalid signature"));
          return;
        }
        if (!r || r.done !== false) {
          return callback(err, r);
        }
        const retrySaslContinueCmd = {
          saslContinue: 1,
          conversationId: r.conversationId,
          payload: Buffer2.alloc(0)
        };
        connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);
      });
    }
    function parsePayload(payload) {
      const dict = {};
      const parts = payload.split(",");
      for (let i = 0; i < parts.length; i++) {
        const valueParts = parts[i].split("=");
        dict[valueParts[0]] = valueParts[1];
      }
      return dict;
    }
    function passwordDigest(username, password) {
      if (typeof username !== "string") {
        throw new MongoError("username must be a string");
      }
      if (typeof password !== "string") {
        throw new MongoError("password must be a string");
      }
      if (password.length === 0) {
        throw new MongoError("password cannot be empty");
      }
      const md5 = crypto.createHash("md5");
      md5.update(`${username}:mongo:${password}`, "utf8");
      return md5.digest("hex");
    }
    function xor(a, b) {
      if (!Buffer2.isBuffer(a)) {
        a = Buffer2.from(a);
      }
      if (!Buffer2.isBuffer(b)) {
        b = Buffer2.from(b);
      }
      const length = Math.max(a.length, b.length);
      const res = [];
      for (let i = 0; i < length; i += 1) {
        res.push(a[i] ^ b[i]);
      }
      return Buffer2.from(res).toString("base64");
    }
    function H(method, text) {
      return crypto.createHash(method).update(text).digest();
    }
    function HMAC(method, key, text) {
      return crypto.createHmac(method, key).update(text).digest();
    }
    var _hiCache = {};
    var _hiCacheCount = 0;
    function _hiCachePurge() {
      _hiCache = {};
      _hiCacheCount = 0;
    }
    var hiLengthMap = {
      sha256: 32,
      sha1: 20
    };
    function HI(data, salt, iterations, cryptoMethod) {
      const key = [data, salt.toString("base64"), iterations].join("_");
      if (_hiCache[key] !== void 0) {
        return _hiCache[key];
      }
      const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
      if (_hiCacheCount >= 200) {
        _hiCachePurge();
      }
      _hiCache[key] = saltedData;
      _hiCacheCount += 1;
      return saltedData;
    }
    function compareDigest(lhs, rhs) {
      if (lhs.length !== rhs.length) {
        return false;
      }
      if (typeof crypto.timingSafeEqual === "function") {
        return crypto.timingSafeEqual(lhs, rhs);
      }
      let result = 0;
      for (let i = 0; i < lhs.length; i++) {
        result |= lhs[i] ^ rhs[i];
      }
      return result === 0;
    }
    function resolveError(err, result) {
      if (err)
        return err;
      const r = result.result;
      if (r.$err || r.errmsg)
        return new MongoError(r);
    }
    var ScramSHA1 = class extends ScramSHA {
      constructor(bson) {
        super(bson, "sha1");
      }
    };
    var ScramSHA256 = class extends ScramSHA {
      constructor(bson) {
        super(bson, "sha256");
      }
    };
    module2.exports = {ScramSHA1, ScramSHA256};
  }
});

// node_modules/mongodb/lib/core/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongo_credentials.js"(exports2, module2) {
    "use strict";
    function getDefaultAuthMechanism(ismaster) {
      if (ismaster) {
        if (Array.isArray(ismaster.saslSupportedMechs)) {
          return ismaster.saslSupportedMechs.indexOf("SCRAM-SHA-256") >= 0 ? "scram-sha-256" : "scram-sha-1";
        }
        if (ismaster.maxWireVersion >= 3) {
          return "scram-sha-1";
        }
      }
      return "mongocr";
    }
    var MongoCredentials = class {
      constructor(options2) {
        options2 = options2 || {};
        this.username = options2.username;
        this.password = options2.password;
        this.source = options2.source || options2.db;
        this.mechanism = options2.mechanism || "default";
        this.mechanismProperties = options2.mechanismProperties || {};
        if (/MONGODB-AWS/i.test(this.mechanism)) {
          if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
            this.username = process.env.AWS_ACCESS_KEY_ID;
          }
          if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
            this.password = process.env.AWS_SECRET_ACCESS_KEY;
          }
          if (!this.mechanismProperties.AWS_SESSION_TOKEN && process.env.AWS_SESSION_TOKEN) {
            this.mechanismProperties.AWS_SESSION_TOKEN = process.env.AWS_SESSION_TOKEN;
          }
        }
        Object.freeze(this.mechanismProperties);
        Object.freeze(this);
      }
      equals(other) {
        return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
      }
      resolveAuthMechanism(ismaster) {
        if (/DEFAULT/i.test(this.mechanism)) {
          return new MongoCredentials({
            username: this.username,
            password: this.password,
            source: this.source,
            mechanism: getDefaultAuthMechanism(ismaster),
            mechanismProperties: this.mechanismProperties
          });
        }
        return this;
      }
    };
    module2.exports = {MongoCredentials};
  }
});

// node_modules/mongodb/lib/core/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongodb_aws.js"(exports2, module2) {
    "use strict";
    var AuthProvider = require_auth_provider().AuthProvider;
    var MongoCredentials = require_mongo_credentials().MongoCredentials;
    var MongoError = require_error().MongoError;
    var crypto = require("crypto");
    var http2 = require("http");
    var maxWireVersion = require_utils2().maxWireVersion;
    var url = require("url");
    var aws4;
    try {
      aws4 = require("aws4");
    } catch (e) {
    }
    var ASCII_N = 110;
    var AWS_RELATIVE_URI = "http://169.254.170.2";
    var AWS_EC2_URI = "http://169.254.169.254";
    var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";
    var MongoDBAWS = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        if (maxWireVersion(connection) < 9) {
          callback(new MongoError("MONGODB-AWS authentication requires MongoDB version 4.4 or later"));
          return;
        }
        if (aws4 == null) {
          callback(new MongoError("MONGODB-AWS authentication requires the `aws4` module, please install it as a dependency of your project"));
          return;
        }
        if (credentials.username == null) {
          makeTempCredentials(credentials, (err, tempCredentials) => {
            if (err)
              return callback(err);
            authContext.credentials = tempCredentials;
            this.auth(authContext, callback);
          });
          return;
        }
        const username = credentials.username;
        const password = credentials.password;
        const db = credentials.source;
        const token = credentials.mechanismProperties.AWS_SESSION_TOKEN;
        const bson = this.bson;
        crypto.randomBytes(32, (err, nonce) => {
          if (err) {
            callback(err);
            return;
          }
          const saslStart = {
            saslStart: 1,
            mechanism: "MONGODB-AWS",
            payload: bson.serialize({r: nonce, p: ASCII_N})
          };
          connection.command(`${db}.$cmd`, saslStart, (err2, result) => {
            if (err2)
              return callback(err2);
            const res = result.result;
            const serverResponse = bson.deserialize(res.payload.buffer);
            const host = serverResponse.h;
            const serverNonce = serverResponse.s.buffer;
            if (serverNonce.length !== 64) {
              callback(new MongoError(`Invalid server nonce length ${serverNonce.length}, expected 64`));
              return;
            }
            if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {
              callback(new MongoError("Server nonce does not begin with client nonce"));
              return;
            }
            if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
              callback(new MongoError(`Server returned an invalid host: "${host}"`));
              return;
            }
            const body = "Action=GetCallerIdentity&Version=2011-06-15";
            const options2 = aws4.sign({
              method: "POST",
              host,
              region: deriveRegion(serverResponse.h),
              service: "sts",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Content-Length": body.length,
                "X-MongoDB-Server-Nonce": serverNonce.toString("base64"),
                "X-MongoDB-GS2-CB-Flag": "n"
              },
              path: "/",
              body
            }, {
              accessKeyId: username,
              secretAccessKey: password,
              token
            });
            const authorization = options2.headers.Authorization;
            const date = options2.headers["X-Amz-Date"];
            const payload = {a: authorization, d: date};
            if (token) {
              payload.t = token;
            }
            const saslContinue = {
              saslContinue: 1,
              conversationId: 1,
              payload: bson.serialize(payload)
            };
            connection.command(`${db}.$cmd`, saslContinue, (err3) => {
              if (err3)
                return callback(err3);
              callback();
            });
          });
        });
      }
    };
    function makeTempCredentials(credentials, callback) {
      function done(creds) {
        if (creds.AccessKeyId == null || creds.SecretAccessKey == null || creds.Token == null) {
          callback(new MongoError("Could not obtain temporary MONGODB-AWS credentials"));
          return;
        }
        callback(void 0, new MongoCredentials({
          username: creds.AccessKeyId,
          password: creds.SecretAccessKey,
          source: credentials.source,
          mechanism: "MONGODB-AWS",
          mechanismProperties: {
            AWS_SESSION_TOKEN: creds.Token
          }
        }));
      }
      if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
        request(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`, (err, res) => {
          if (err)
            return callback(err);
          done(res);
        });
        return;
      }
      request(`${AWS_EC2_URI}/latest/api/token`, {method: "PUT", json: false, headers: {"X-aws-ec2-metadata-token-ttl-seconds": 30}}, (err, token) => {
        if (err)
          return callback(err);
        request(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {json: false, headers: {"X-aws-ec2-metadata-token": token}}, (err2, roleName) => {
          if (err2)
            return callback(err2);
          request(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {headers: {"X-aws-ec2-metadata-token": token}}, (err3, creds) => {
            if (err3)
              return callback(err3);
            done(creds);
          });
        });
      });
    }
    function deriveRegion(host) {
      const parts = host.split(".");
      if (parts.length === 1 || parts[1] === "amazonaws") {
        return "us-east-1";
      }
      return parts[1];
    }
    function request(uri, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = Object.assign({
        method: "GET",
        timeout: 1e4,
        json: true
      }, url.parse(uri), options2);
      const req = http2.request(options2, (res) => {
        res.setEncoding("utf8");
        let data = "";
        res.on("data", (d) => data += d);
        res.on("end", () => {
          if (options2.json === false) {
            callback(void 0, data);
            return;
          }
          try {
            const parsed = JSON.parse(data);
            callback(void 0, parsed);
          } catch (err) {
            callback(new MongoError(`Invalid JSON response: "${data}"`));
          }
        });
      });
      req.on("error", (err) => callback(err));
      req.end();
    }
    module2.exports = MongoDBAWS;
  }
});

// node_modules/mongodb/lib/core/auth/defaultAuthProviders.js
var require_defaultAuthProviders = __commonJS({
  "node_modules/mongodb/lib/core/auth/defaultAuthProviders.js"(exports2, module2) {
    "use strict";
    var MongoCR = require_mongocr();
    var X509 = require_x509();
    var Plain = require_plain();
    var GSSAPI = require_gssapi();
    var ScramSHA1 = require_scram().ScramSHA1;
    var ScramSHA256 = require_scram().ScramSHA256;
    var MongoDBAWS = require_mongodb_aws();
    function defaultAuthProviders(bson) {
      return {
        "mongodb-aws": new MongoDBAWS(bson),
        mongocr: new MongoCR(bson),
        x509: new X509(bson),
        plain: new Plain(bson),
        gssapi: new GSSAPI(bson),
        "scram-sha-1": new ScramSHA1(bson),
        "scram-sha-256": new ScramSHA256(bson)
      };
    }
    module2.exports = {defaultAuthProviders};
  }
});

// node_modules/mongodb/lib/core/connection/connect.js
var require_connect = __commonJS({
  "node_modules/mongodb/lib/core/connection/connect.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var Connection = require_connection();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var defaultAuthProviders = require_defaultAuthProviders().defaultAuthProviders;
    var AuthContext = require_auth_provider().AuthContext;
    var WIRE_CONSTANTS = require_constants();
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var AUTH_PROVIDERS;
    function connect(options2, cancellationToken, callback) {
      if (typeof cancellationToken === "function") {
        callback = cancellationToken;
        cancellationToken = void 0;
      }
      const ConnectionType = options2 && options2.connectionType ? options2.connectionType : Connection;
      if (AUTH_PROVIDERS == null) {
        AUTH_PROVIDERS = defaultAuthProviders(options2.bson);
      }
      const family = options2.family !== void 0 ? options2.family : 0;
      makeConnection(family, options2, cancellationToken, (err, socket) => {
        if (err) {
          callback(err, socket);
          return;
        }
        performInitialHandshake(new ConnectionType(socket, options2), options2, callback);
      });
    }
    function isModernConnectionType(conn) {
      return !(conn instanceof Connection);
    }
    function checkSupportedServer(ismaster, options2) {
      const serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === "number" && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;
      const serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === "number" && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;
      if (serverVersionHighEnough) {
        if (serverVersionLowEnough) {
          return null;
        }
        const message2 = `Server at ${options2.host}:${options2.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
        return new MongoError(message2);
      }
      const message = `Server at ${options2.host}:${options2.port} reports maximum wire version ${ismaster.maxWireVersion || 0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;
      return new MongoError(message);
    }
    function performInitialHandshake(conn, options2, _callback) {
      const callback = function(err, ret) {
        if (err && conn) {
          conn.destroy();
        }
        _callback(err, ret);
      };
      const credentials = options2.credentials;
      if (credentials) {
        if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {
          callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));
          return;
        }
      }
      const authContext = new AuthContext(conn, credentials, options2);
      prepareHandshakeDocument(authContext, (err, handshakeDoc) => {
        if (err) {
          return callback(err);
        }
        const handshakeOptions = Object.assign({}, options2);
        if (options2.connectTimeoutMS || options2.connectionTimeout) {
          handshakeOptions.socketTimeout = options2.connectTimeoutMS || options2.connectionTimeout;
        }
        const start = new Date().getTime();
        conn.command("admin.$cmd", handshakeDoc, handshakeOptions, (err2, result) => {
          if (err2) {
            callback(err2);
            return;
          }
          const response = result.result;
          if (response.ok === 0) {
            callback(new MongoError(response));
            return;
          }
          const supportedServerErr = checkSupportedServer(response, options2);
          if (supportedServerErr) {
            callback(supportedServerErr);
            return;
          }
          if (!isModernConnectionType(conn)) {
            if (response.compression) {
              const agreedCompressors = handshakeDoc.compression.filter((compressor) => response.compression.indexOf(compressor) !== -1);
              if (agreedCompressors.length) {
                conn.agreedCompressor = agreedCompressors[0];
              }
              if (options2.compression && options2.compression.zlibCompressionLevel) {
                conn.zlibCompressionLevel = options2.compression.zlibCompressionLevel;
              }
            }
          }
          conn.ismaster = response;
          conn.lastIsMasterMS = new Date().getTime() - start;
          if (!response.arbiterOnly && credentials) {
            Object.assign(authContext, {response});
            const resolvedCredentials = credentials.resolveAuthMechanism(response);
            const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];
            authProvider.auth(authContext, (err3) => {
              if (err3)
                return callback(err3);
              callback(void 0, conn);
            });
            return;
          }
          callback(void 0, conn);
        });
      });
    }
    function prepareHandshakeDocument(authContext, callback) {
      const options2 = authContext.options;
      const compressors = options2.compression && options2.compression.compressors ? options2.compression.compressors : [];
      const handshakeDoc = {
        ismaster: true,
        client: options2.metadata || makeClientMetadata(options2),
        compression: compressors
      };
      const credentials = authContext.credentials;
      if (credentials) {
        if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {
          Object.assign(handshakeDoc, {
            saslSupportedMechs: `${credentials.source}.${credentials.username}`
          });
          AUTH_PROVIDERS["scram-sha-256"].prepare(handshakeDoc, authContext, callback);
          return;
        }
        const authProvider = AUTH_PROVIDERS[credentials.mechanism];
        authProvider.prepare(handshakeDoc, authContext, callback);
        return;
      }
      callback(void 0, handshakeDoc);
    }
    var LEGAL_SSL_SOCKET_OPTIONS = [
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "NPNProtocols",
      "ALPNProtocols",
      "servername",
      "ecdhCurve",
      "secureProtocol",
      "secureContext",
      "session",
      "minDHSize",
      "crl",
      "rejectUnauthorized"
    ];
    function parseConnectOptions(family, options2) {
      const host = typeof options2.host === "string" ? options2.host : "localhost";
      if (host.indexOf("/") !== -1) {
        return {path: host};
      }
      const result = {
        family,
        host,
        port: typeof options2.port === "number" ? options2.port : 27017,
        rejectUnauthorized: false
      };
      return result;
    }
    function parseSslOptions(family, options2) {
      const result = parseConnectOptions(family, options2);
      for (const name2 in options2) {
        if (options2[name2] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name2) !== -1) {
          result[name2] = options2[name2];
        }
      }
      if (options2.checkServerIdentity === false) {
        result.checkServerIdentity = function() {
          return void 0;
        };
      } else if (typeof options2.checkServerIdentity === "function") {
        result.checkServerIdentity = options2.checkServerIdentity;
      }
      if (result.servername == null && !net.isIP(result.host)) {
        result.servername = result.host;
      }
      return result;
    }
    var SOCKET_ERROR_EVENTS = new Set(["error", "close", "timeout", "parseError"]);
    function makeConnection(family, options2, cancellationToken, _callback) {
      const useSsl = typeof options2.ssl === "boolean" ? options2.ssl : false;
      const keepAlive = typeof options2.keepAlive === "boolean" ? options2.keepAlive : true;
      let keepAliveInitialDelay = typeof options2.keepAliveInitialDelay === "number" ? options2.keepAliveInitialDelay : 12e4;
      const noDelay = typeof options2.noDelay === "boolean" ? options2.noDelay : true;
      const connectionTimeout = typeof options2.connectionTimeout === "number" ? options2.connectionTimeout : typeof options2.connectTimeoutMS === "number" ? options2.connectTimeoutMS : 3e4;
      const socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
      const rejectUnauthorized = typeof options2.rejectUnauthorized === "boolean" ? options2.rejectUnauthorized : true;
      if (keepAliveInitialDelay > socketTimeout) {
        keepAliveInitialDelay = Math.round(socketTimeout / 2);
      }
      let socket;
      const callback = function(err, ret) {
        if (err && socket) {
          socket.destroy();
        }
        _callback(err, ret);
      };
      try {
        if (useSsl) {
          socket = tls.connect(parseSslOptions(family, options2));
          if (typeof socket.disableRenegotiation === "function") {
            socket.disableRenegotiation();
          }
        } else {
          socket = net.createConnection(parseConnectOptions(family, options2));
        }
      } catch (err) {
        return callback(err);
      }
      socket.setKeepAlive(keepAlive, keepAliveInitialDelay);
      socket.setTimeout(connectionTimeout);
      socket.setNoDelay(noDelay);
      const connectEvent = useSsl ? "secureConnect" : "connect";
      let cancellationHandler;
      function errorHandler(eventName) {
        return (err) => {
          SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
          if (cancellationHandler) {
            cancellationToken.removeListener("cancel", cancellationHandler);
          }
          socket.removeListener(connectEvent, connectHandler);
          callback(connectionFailureError(eventName, err));
        };
      }
      function connectHandler() {
        SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
        if (cancellationHandler) {
          cancellationToken.removeListener("cancel", cancellationHandler);
        }
        if (socket.authorizationError && rejectUnauthorized) {
          return callback(socket.authorizationError);
        }
        socket.setTimeout(socketTimeout);
        callback(null, socket);
      }
      SOCKET_ERROR_EVENTS.forEach((event) => socket.once(event, errorHandler(event)));
      if (cancellationToken) {
        cancellationHandler = errorHandler("cancel");
        cancellationToken.once("cancel", cancellationHandler);
      }
      socket.once(connectEvent, connectHandler);
    }
    function connectionFailureError(type, err) {
      switch (type) {
        case "error":
          return new MongoNetworkError(err);
        case "timeout":
          return new MongoNetworkTimeoutError(`connection timed out`);
        case "close":
          return new MongoNetworkError(`connection closed`);
        case "cancel":
          return new MongoNetworkError(`connection establishment was cancelled`);
        default:
          return new MongoNetworkError(`unknown network error`);
      }
    }
    module2.exports = connect;
  }
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS({
  "node_modules/mongodb/lib/read_concern.js"(exports2, module2) {
    "use strict";
    var ReadConcern = class {
      constructor(level) {
        if (level != null) {
          this.level = level;
        }
      }
      static fromOptions(options2) {
        if (options2 == null) {
          return;
        }
        if (options2.readConcern) {
          if (options2.readConcern instanceof ReadConcern) {
            return options2.readConcern;
          }
          return new ReadConcern(options2.readConcern.level);
        }
        if (options2.level) {
          return new ReadConcern(options2.level);
        }
      }
      static get MAJORITY() {
        return "majority";
      }
      static get AVAILABLE() {
        return "available";
      }
      static get LINEARIZABLE() {
        return "linearizable";
      }
      static get SNAPSHOT() {
        return "snapshot";
      }
    };
    module2.exports = ReadConcern;
  }
});

// node_modules/mongodb/lib/core/transactions.js
var require_transactions = __commonJS({
  "node_modules/mongodb/lib/core/transactions.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var ReadPreference = require_read_preference();
    var ReadConcern = require_read_concern();
    var WriteConcern = require_write_concern();
    var TxnState;
    var stateMachine;
    (() => {
      const NO_TRANSACTION = "NO_TRANSACTION";
      const STARTING_TRANSACTION = "STARTING_TRANSACTION";
      const TRANSACTION_IN_PROGRESS = "TRANSACTION_IN_PROGRESS";
      const TRANSACTION_COMMITTED = "TRANSACTION_COMMITTED";
      const TRANSACTION_COMMITTED_EMPTY = "TRANSACTION_COMMITTED_EMPTY";
      const TRANSACTION_ABORTED = "TRANSACTION_ABORTED";
      TxnState = {
        NO_TRANSACTION,
        STARTING_TRANSACTION,
        TRANSACTION_IN_PROGRESS,
        TRANSACTION_COMMITTED,
        TRANSACTION_COMMITTED_EMPTY,
        TRANSACTION_ABORTED
      };
      stateMachine = {
        [NO_TRANSACTION]: [NO_TRANSACTION, STARTING_TRANSACTION],
        [STARTING_TRANSACTION]: [
          TRANSACTION_IN_PROGRESS,
          TRANSACTION_COMMITTED,
          TRANSACTION_COMMITTED_EMPTY,
          TRANSACTION_ABORTED
        ],
        [TRANSACTION_IN_PROGRESS]: [
          TRANSACTION_IN_PROGRESS,
          TRANSACTION_COMMITTED,
          TRANSACTION_ABORTED
        ],
        [TRANSACTION_COMMITTED]: [
          TRANSACTION_COMMITTED,
          TRANSACTION_COMMITTED_EMPTY,
          STARTING_TRANSACTION,
          NO_TRANSACTION
        ],
        [TRANSACTION_ABORTED]: [STARTING_TRANSACTION, NO_TRANSACTION],
        [TRANSACTION_COMMITTED_EMPTY]: [TRANSACTION_COMMITTED_EMPTY, NO_TRANSACTION]
      };
    })();
    var Transaction2 = class {
      constructor(options2) {
        options2 = options2 || {};
        this.state = TxnState.NO_TRANSACTION;
        this.options = {};
        const writeConcern = WriteConcern.fromOptions(options2);
        if (writeConcern) {
          if (writeConcern.w <= 0) {
            throw new MongoError("Transactions do not support unacknowledged write concern");
          }
          this.options.writeConcern = writeConcern;
        }
        if (options2.readConcern) {
          this.options.readConcern = ReadConcern.fromOptions(options2);
        }
        if (options2.readPreference) {
          this.options.readPreference = ReadPreference.fromOptions(options2);
        }
        if (options2.maxCommitTimeMS) {
          this.options.maxTimeMS = options2.maxCommitTimeMS;
        }
        this._pinnedServer = void 0;
        this._recoveryToken = void 0;
      }
      get server() {
        return this._pinnedServer;
      }
      get recoveryToken() {
        return this._recoveryToken;
      }
      get isPinned() {
        return !!this.server;
      }
      get isActive() {
        return [TxnState.STARTING_TRANSACTION, TxnState.TRANSACTION_IN_PROGRESS].indexOf(this.state) !== -1;
      }
      transition(nextState) {
        const nextStates = stateMachine[this.state];
        if (nextStates && nextStates.indexOf(nextState) !== -1) {
          this.state = nextState;
          if (this.state === TxnState.NO_TRANSACTION || this.state === TxnState.STARTING_TRANSACTION) {
            this.unpinServer();
          }
          return;
        }
        throw new MongoError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
      }
      pinServer(server) {
        if (this.isActive) {
          this._pinnedServer = server;
        }
      }
      unpinServer() {
        this._pinnedServer = void 0;
      }
    };
    function isTransactionCommand(command2) {
      return !!(command2.commitTransaction || command2.abortTransaction);
    }
    module2.exports = {TxnState, Transaction: Transaction2, isTransactionCommand};
  }
});

// node_modules/mongodb/lib/core/topologies/shared.js
var require_shared2 = __commonJS({
  "node_modules/mongodb/lib/core/topologies/shared.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_read_preference();
    var TopologyType = require_common().TopologyType;
    var MongoError = require_error().MongoError;
    var isRetryableWriteError = require_error().isRetryableWriteError;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MMAPv1_RETRY_WRITES_ERROR_CODE = 20;
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    function createCompressionInfo(options2) {
      if (!options2.compression || !options2.compression.compressors) {
        return [];
      }
      options2.compression.compressors.forEach(function(compressor) {
        if (compressor !== "snappy" && compressor !== "zlib") {
          throw new Error("compressors must be at least one of snappy or zlib");
        }
      });
      return options2.compression.compressors;
    }
    function clone2(object) {
      return JSON.parse(JSON.stringify(object));
    }
    var getPreviousDescription = function(self2) {
      if (!self2.s.serverDescription) {
        self2.s.serverDescription = {
          address: self2.name,
          arbiters: [],
          hosts: [],
          passives: [],
          type: "Unknown"
        };
      }
      return self2.s.serverDescription;
    };
    var emitServerDescriptionChanged = function(self2, description) {
      if (self2.listeners("serverDescriptionChanged").length > 0) {
        self2.emit("serverDescriptionChanged", {
          topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
          address: self2.name,
          previousDescription: getPreviousDescription(self2),
          newDescription: description
        });
        self2.s.serverDescription = description;
      }
    };
    var getPreviousTopologyDescription = function(self2) {
      if (!self2.s.topologyDescription) {
        self2.s.topologyDescription = {
          topologyType: "Unknown",
          servers: [
            {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: "Unknown"
            }
          ]
        };
      }
      return self2.s.topologyDescription;
    };
    var emitTopologyDescriptionChanged = function(self2, description) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        self2.emit("topologyDescriptionChanged", {
          topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
          address: self2.name,
          previousDescription: getPreviousTopologyDescription(self2),
          newDescription: description
        });
        self2.s.serverDescription = description;
      }
    };
    var changedIsMaster = function(self2, currentIsmaster, ismaster) {
      var currentType = getTopologyType(self2, currentIsmaster);
      var newType = getTopologyType(self2, ismaster);
      if (newType !== currentType)
        return true;
      return false;
    };
    var getTopologyType = function(self2, ismaster) {
      if (!ismaster) {
        ismaster = self2.ismaster;
      }
      if (!ismaster)
        return "Unknown";
      if (ismaster.ismaster && ismaster.msg === "isdbgrid")
        return "Mongos";
      if (ismaster.ismaster && !ismaster.hosts)
        return "Standalone";
      if (ismaster.ismaster)
        return "RSPrimary";
      if (ismaster.secondary)
        return "RSSecondary";
      if (ismaster.arbiterOnly)
        return "RSArbiter";
      return "Unknown";
    };
    var inquireServerState = function(self2) {
      return function(callback) {
        if (self2.s.state === "destroyed")
          return;
        var start = new Date().getTime();
        emitSDAMEvent(self2, "serverHeartbeatStarted", {connectionId: self2.name});
        self2.command("admin.$cmd", {ismaster: true}, {monitoring: true}, function(err, r) {
          if (!err) {
            self2.emit("ismaster", r, self2);
            var latencyMS = new Date().getTime() - start;
            emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
              durationMS: latencyMS,
              reply: r.result,
              connectionId: self2.name
            });
            if (changedIsMaster(self2, self2.s.ismaster, r.result)) {
              emitServerDescriptionChanged(self2, {
                address: self2.name,
                arbiters: [],
                hosts: [],
                passives: [],
                type: !self2.s.inTopology ? "Standalone" : getTopologyType(self2)
              });
            }
            self2.s.ismaster = r.result;
            self2.s.isMasterLatencyMS = latencyMS;
          } else {
            emitSDAMEvent(self2, "serverHeartbeatFailed", {
              durationMS: latencyMS,
              failure: err,
              connectionId: self2.name
            });
          }
          if (typeof callback === "function") {
            return callback(err, r);
          }
          self2.s.inquireServerStateTimeout = setTimeout(inquireServerState(self2), self2.s.haInterval);
        });
      };
    };
    var cloneOptions = function(options2) {
      var opts = {};
      for (var name2 in options2) {
        opts[name2] = options2[name2];
      }
      return opts;
    };
    function Interval(fn, time) {
      var timer = false;
      this.start = function() {
        if (!this.isRunning()) {
          timer = setInterval(fn, time);
        }
        return this;
      };
      this.stop = function() {
        clearInterval(timer);
        timer = false;
        return this;
      };
      this.isRunning = function() {
        return timer !== false;
      };
    }
    function Timeout(fn, time) {
      var timer = false;
      var func = () => {
        if (timer) {
          clearTimeout(timer);
          timer = false;
          fn();
        }
      };
      this.start = function() {
        if (!this.isRunning()) {
          timer = setTimeout(func, time);
        }
        return this;
      };
      this.stop = function() {
        clearTimeout(timer);
        timer = false;
        return this;
      };
      this.isRunning = function() {
        return timer !== false;
      };
    }
    function diff(previous, current) {
      var diff2 = {
        servers: []
      };
      if (!previous) {
        previous = {servers: []};
      }
      for (var i = 0; i < previous.servers.length; i++) {
        var found = false;
        for (var j = 0; j < current.servers.length; j++) {
          if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {
            found = true;
            break;
          }
        }
        if (!found) {
          diff2.servers.push({
            address: previous.servers[i].address,
            from: previous.servers[i].type,
            to: "Unknown"
          });
        }
      }
      for (j = 0; j < current.servers.length; j++) {
        found = false;
        for (i = 0; i < previous.servers.length; i++) {
          if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {
            found = true;
            break;
          }
        }
        if (!found) {
          diff2.servers.push({
            address: current.servers[j].address,
            from: "Unknown",
            to: current.servers[j].type
          });
        }
      }
      for (i = 0; i < previous.servers.length; i++) {
        var prevServer = previous.servers[i];
        for (j = 0; j < current.servers.length; j++) {
          var currServer = current.servers[j];
          if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {
            if (prevServer.type !== currServer.type) {
              diff2.servers.push({
                address: prevServer.address,
                from: prevServer.type,
                to: currServer.type
              });
            }
          }
        }
      }
      return diff2;
    }
    function resolveClusterTime(topology, $clusterTime) {
      if (topology.clusterTime == null) {
        topology.clusterTime = $clusterTime;
      } else {
        if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {
          topology.clusterTime = $clusterTime;
        }
      }
    }
    var SessionMixins = {
      endSessions: function(sessions, callback) {
        if (!Array.isArray(sessions)) {
          sessions = [sessions];
        }
        this.command("admin.$cmd", {endSessions: sessions}, {readPreference: ReadPreference.primaryPreferred}, () => {
          if (typeof callback === "function")
            callback();
        });
      }
    };
    function topologyType(topology) {
      if (topology.description) {
        return topology.description.type;
      }
      if (topology.type === "mongos") {
        return TopologyType.Sharded;
      } else if (topology.type === "replset") {
        return TopologyType.ReplicaSetWithPrimary;
      }
      return TopologyType.Single;
    }
    var RETRYABLE_WIRE_VERSION = 6;
    var isRetryableWritesSupported = function(topology) {
      const maxWireVersion2 = topology.lastIsMaster().maxWireVersion;
      if (maxWireVersion2 < RETRYABLE_WIRE_VERSION) {
        return false;
      }
      if (!topology.logicalSessionTimeoutMinutes) {
        return false;
      }
      if (topologyType(topology) === TopologyType.Single) {
        return false;
      }
      return true;
    };
    var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
    function getMMAPError(err) {
      if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes("Transaction numbers")) {
        return err;
      }
      const newErr = new MongoError({
        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        originalError: err
      });
      return newErr;
    }
    function legacyIsRetryableWriteError(err, topology) {
      if (!(err instanceof MongoError)) {
        return false;
      }
      if (isRetryableWritesSupported(topology) && (err instanceof MongoNetworkError || maxWireVersion(topology) < 9 && isRetryableWriteError(err))) {
        err.addErrorLabel("RetryableWriteError");
      }
      return err.hasErrorLabel("RetryableWriteError");
    }
    module2.exports = {
      SessionMixins,
      resolveClusterTime,
      inquireServerState,
      getTopologyType,
      emitServerDescriptionChanged,
      emitTopologyDescriptionChanged,
      cloneOptions,
      createCompressionInfo,
      clone: clone2,
      diff,
      Interval,
      Timeout,
      isRetryableWritesSupported,
      getMMAPError,
      topologyType,
      legacyIsRetryableWriteError
    };
  }
});

// node_modules/mongodb/lib/core/sessions.js
var require_sessions = __commonJS({
  "node_modules/mongodb/lib/core/sessions.js"(exports2, module2) {
    "use strict";
    var retrieveBSON = require_utils3().retrieveBSON;
    var EventEmitter = require("events");
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var uuidV4 = require_utils2().uuidV4;
    var MongoError = require_error().MongoError;
    var isRetryableError = require_error().isRetryableError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var Transaction2 = require_transactions().Transaction;
    var TxnState = require_transactions().TxnState;
    var isPromiseLike = require_utils2().isPromiseLike;
    var ReadPreference = require_read_preference();
    var maybePromise = require_utils4().maybePromise;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var isSharded = require_shared().isSharded;
    var maxWireVersion = require_utils2().maxWireVersion;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var minWireVersionForShardedTransactions = 8;
    function assertAlive(session, callback) {
      if (session.serverSession == null) {
        const error3 = new MongoError("Cannot use a session that has ended");
        if (typeof callback === "function") {
          callback(error3, null);
          return false;
        }
        throw error3;
      }
      return true;
    }
    var kServerSession = Symbol("serverSession");
    var ClientSession = class extends EventEmitter {
      constructor(topology, sessionPool, options2, clientOptions) {
        super();
        if (topology == null) {
          throw new Error("ClientSession requires a topology");
        }
        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
          throw new Error("ClientSession requires a ServerSessionPool");
        }
        options2 = options2 || {};
        clientOptions = clientOptions || {};
        this.topology = topology;
        this.sessionPool = sessionPool;
        this.hasEnded = false;
        this.clientOptions = clientOptions;
        this[kServerSession] = void 0;
        this.supports = {
          causalConsistency: typeof options2.causalConsistency !== "undefined" ? options2.causalConsistency : true
        };
        this.clusterTime = options2.initialClusterTime;
        this.operationTime = null;
        this.explicit = !!options2.explicit;
        this.owner = options2.owner;
        this.defaultTransactionOptions = Object.assign({}, options2.defaultTransactionOptions);
        this.transaction = new Transaction2();
      }
      get id() {
        return this.serverSession.id;
      }
      get serverSession() {
        if (this[kServerSession] == null) {
          this[kServerSession] = this.sessionPool.acquire();
        }
        return this[kServerSession];
      }
      endSession(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = options2 || {};
        const session = this;
        return maybePromise(this, callback, (done) => {
          if (session.hasEnded) {
            return done();
          }
          function completeEndSession() {
            session.sessionPool.release(session.serverSession);
            session[kServerSession] = void 0;
            session.hasEnded = true;
            session.emit("ended", session);
            done();
          }
          if (session.serverSession && session.inTransaction()) {
            session.abortTransaction((err) => {
              if (err)
                return done(err);
              completeEndSession();
            });
            return;
          }
          completeEndSession();
        });
      }
      advanceOperationTime(operationTime) {
        if (this.operationTime == null) {
          this.operationTime = operationTime;
          return;
        }
        if (operationTime.greaterThan(this.operationTime)) {
          this.operationTime = operationTime;
        }
      }
      equals(session) {
        if (!(session instanceof ClientSession)) {
          return false;
        }
        return this.id.id.buffer.equals(session.id.id.buffer);
      }
      incrementTransactionNumber() {
        this.serverSession.txnNumber++;
      }
      inTransaction() {
        return this.transaction.isActive;
      }
      startTransaction(options2) {
        assertAlive(this);
        if (this.inTransaction()) {
          throw new MongoError("Transaction already in progress");
        }
        const topologyMaxWireVersion = maxWireVersion(this.topology);
        if (isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
          throw new MongoError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
        }
        this.incrementTransactionNumber();
        this.transaction = new Transaction2(Object.assign({}, this.clientOptions, options2 || this.defaultTransactionOptions));
        this.transaction.transition(TxnState.STARTING_TRANSACTION);
      }
      commitTransaction(callback) {
        return maybePromise(this, callback, (done) => endTransaction(this, "commitTransaction", done));
      }
      abortTransaction(callback) {
        return maybePromise(this, callback, (done) => endTransaction(this, "abortTransaction", done));
      }
      toBSON() {
        throw new Error("ClientSession cannot be serialized to BSON.");
      }
      withTransaction(fn, options2) {
        const startTime = now();
        return attemptTransaction(this, startTime, fn, options2);
      }
    };
    var MAX_WITH_TRANSACTION_TIMEOUT = 12e4;
    var UNSATISFIABLE_WRITE_CONCERN_CODE = 100;
    var UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;
    var MAX_TIME_MS_EXPIRED_CODE = 50;
    var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
      "CannotSatisfyWriteConcern",
      "UnknownReplWriteConcern",
      "UnsatisfiableWriteConcern"
    ]);
    function hasNotTimedOut(startTime, max) {
      return calculateDurationInMs(startTime) < max;
    }
    function isUnknownTransactionCommitResult(err) {
      return isMaxTimeMSExpiredError(err) || !NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) && err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE && err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE;
    }
    function isMaxTimeMSExpiredError(err) {
      if (err == null)
        return false;
      return err.code === MAX_TIME_MS_EXPIRED_CODE || err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE;
    }
    function attemptTransactionCommit(session, startTime, fn, options2) {
      return session.commitTransaction().catch((err) => {
        if (err instanceof MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {
          if (err.hasErrorLabel("UnknownTransactionCommitResult")) {
            return attemptTransactionCommit(session, startTime, fn, options2);
          }
          if (err.hasErrorLabel("TransientTransactionError")) {
            return attemptTransaction(session, startTime, fn, options2);
          }
        }
        throw err;
      });
    }
    var USER_EXPLICIT_TXN_END_STATES = new Set([
      TxnState.NO_TRANSACTION,
      TxnState.TRANSACTION_COMMITTED,
      TxnState.TRANSACTION_ABORTED
    ]);
    function userExplicitlyEndedTransaction(session) {
      return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
    }
    function attemptTransaction(session, startTime, fn, options2) {
      session.startTransaction(options2);
      let promise;
      try {
        promise = fn(session);
      } catch (err) {
        promise = Promise.reject(err);
      }
      if (!isPromiseLike(promise)) {
        session.abortTransaction();
        throw new TypeError("Function provided to `withTransaction` must return a Promise");
      }
      return promise.then(() => {
        if (userExplicitlyEndedTransaction(session)) {
          return;
        }
        return attemptTransactionCommit(session, startTime, fn, options2);
      }).catch((err) => {
        function maybeRetryOrThrow(err2) {
          if (err2 instanceof MongoError && err2.hasErrorLabel("TransientTransactionError") && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
            return attemptTransaction(session, startTime, fn, options2);
          }
          if (isMaxTimeMSExpiredError(err2)) {
            err2.addErrorLabel("UnknownTransactionCommitResult");
          }
          throw err2;
        }
        if (session.transaction.isActive) {
          return session.abortTransaction().then(() => maybeRetryOrThrow(err));
        }
        return maybeRetryOrThrow(err);
      });
    }
    function endTransaction(session, commandName, callback) {
      if (!assertAlive(session, callback)) {
        return;
      }
      let txnState = session.transaction.state;
      if (txnState === TxnState.NO_TRANSACTION) {
        callback(new MongoError("No transaction started"));
        return;
      }
      if (commandName === "commitTransaction") {
        if (txnState === TxnState.STARTING_TRANSACTION || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
          session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);
          callback(null, null);
          return;
        }
        if (txnState === TxnState.TRANSACTION_ABORTED) {
          callback(new MongoError("Cannot call commitTransaction after calling abortTransaction"));
          return;
        }
      } else {
        if (txnState === TxnState.STARTING_TRANSACTION) {
          session.transaction.transition(TxnState.TRANSACTION_ABORTED);
          callback(null, null);
          return;
        }
        if (txnState === TxnState.TRANSACTION_ABORTED) {
          callback(new MongoError("Cannot call abortTransaction twice"));
          return;
        }
        if (txnState === TxnState.TRANSACTION_COMMITTED || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
          callback(new MongoError("Cannot call abortTransaction after calling commitTransaction"));
          return;
        }
      }
      const command2 = {[commandName]: 1};
      let writeConcern;
      if (session.transaction.options.writeConcern) {
        writeConcern = Object.assign({}, session.transaction.options.writeConcern);
      } else if (session.clientOptions && session.clientOptions.w) {
        writeConcern = {w: session.clientOptions.w};
      }
      if (txnState === TxnState.TRANSACTION_COMMITTED) {
        writeConcern = Object.assign({wtimeout: 1e4}, writeConcern, {w: "majority"});
      }
      if (writeConcern) {
        Object.assign(command2, {writeConcern});
      }
      if (commandName === "commitTransaction" && session.transaction.options.maxTimeMS) {
        Object.assign(command2, {maxTimeMS: session.transaction.options.maxTimeMS});
      }
      function commandHandler(e, r) {
        if (commandName === "commitTransaction") {
          session.transaction.transition(TxnState.TRANSACTION_COMMITTED);
          if (e && (e instanceof MongoNetworkError || e instanceof MongoWriteConcernError || isRetryableError(e) || isMaxTimeMSExpiredError(e))) {
            if (isUnknownTransactionCommitResult(e)) {
              e.addErrorLabel("UnknownTransactionCommitResult");
              session.transaction.unpinServer();
            }
          }
        } else {
          session.transaction.transition(TxnState.TRANSACTION_ABORTED);
        }
        callback(e, r);
      }
      function transactionError(err) {
        return commandName === "commitTransaction" ? err : null;
      }
      if (session.transaction.recoveryToken && supportsRecoveryToken(session)) {
        command2.recoveryToken = session.transaction.recoveryToken;
      }
      session.topology.command("admin.$cmd", command2, {session}, (err, reply) => {
        if (err && isRetryableError(err)) {
          if (command2.commitTransaction) {
            session.transaction.unpinServer();
            command2.writeConcern = Object.assign({wtimeout: 1e4}, command2.writeConcern, {
              w: "majority"
            });
          }
          return session.topology.command("admin.$cmd", command2, {session}, (_err, _reply) => commandHandler(transactionError(_err), _reply));
        }
        commandHandler(transactionError(err), reply);
      });
    }
    function supportsRecoveryToken(session) {
      const topology = session.topology;
      return !!topology.s.options.useRecoveryToken;
    }
    var ServerSession = class {
      constructor() {
        this.id = {id: new Binary2(uuidV4(), Binary2.SUBTYPE_UUID)};
        this.lastUse = now();
        this.txnNumber = 0;
        this.isDirty = false;
      }
      hasTimedOut(sessionTimeoutMinutes) {
        const idleTimeMinutes = Math.round(calculateDurationInMs(this.lastUse) % 864e5 % 36e5 / 6e4);
        return idleTimeMinutes > sessionTimeoutMinutes - 1;
      }
    };
    var ServerSessionPool = class {
      constructor(topology) {
        if (topology == null) {
          throw new Error("ServerSessionPool requires a topology");
        }
        this.topology = topology;
        this.sessions = [];
      }
      endAllPooledSessions(callback) {
        if (this.sessions.length) {
          this.topology.endSessions(this.sessions.map((session) => session.id), () => {
            this.sessions = [];
            if (typeof callback === "function") {
              callback();
            }
          });
          return;
        }
        if (typeof callback === "function") {
          callback();
        }
      }
      acquire() {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
        while (this.sessions.length) {
          const session = this.sessions.shift();
          if (!session.hasTimedOut(sessionTimeoutMinutes)) {
            return session;
          }
        }
        return new ServerSession();
      }
      release(session) {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
        while (this.sessions.length) {
          const pooledSession = this.sessions[this.sessions.length - 1];
          if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {
            this.sessions.pop();
          } else {
            break;
          }
        }
        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
          if (session.isDirty) {
            return;
          }
          this.sessions.unshift(session);
        }
      }
    };
    function commandSupportsReadConcern(command2, options2) {
      if (command2.aggregate || command2.count || command2.distinct || command2.find || command2.parallelCollectionScan || command2.geoNear || command2.geoSearch) {
        return true;
      }
      if (command2.mapReduce && options2 && options2.out && (options2.out.inline === 1 || options2.out === "inline")) {
        return true;
      }
      return false;
    }
    function applySession(session, command2, options2) {
      if (session.hasEnded) {
        return new MongoError("Cannot use a session that has ended");
      }
      if (options2 && options2.writeConcern && options2.writeConcern.w === 0) {
        return;
      }
      const serverSession = session.serverSession;
      serverSession.lastUse = now();
      command2.lsid = serverSession.id;
      const inTransaction = session.inTransaction() || isTransactionCommand(command2);
      const isRetryableWrite = options2.willRetryWrite;
      const shouldApplyReadConcern = commandSupportsReadConcern(command2, options2);
      if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {
        command2.txnNumber = BSON2.Long.fromNumber(serverSession.txnNumber);
      }
      if (!inTransaction) {
        if (session.transaction.state !== TxnState.NO_TRANSACTION) {
          session.transaction.transition(TxnState.NO_TRANSACTION);
        }
        if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {
          command2.readConcern = command2.readConcern || {};
          Object.assign(command2.readConcern, {afterClusterTime: session.operationTime});
        }
        return;
      }
      if (options2.readPreference && !options2.readPreference.equals(ReadPreference.primary)) {
        return new MongoError(`Read preference in a transaction must be primary, not: ${options2.readPreference.mode}`);
      }
      command2.autocommit = false;
      if (session.transaction.state === TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);
        command2.startTransaction = true;
        const readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;
        if (readConcern) {
          command2.readConcern = readConcern;
        }
        if (session.supports.causalConsistency && session.operationTime) {
          command2.readConcern = command2.readConcern || {};
          Object.assign(command2.readConcern, {afterClusterTime: session.operationTime});
        }
      }
    }
    function updateSessionFromResponse(session, document2) {
      if (document2.$clusterTime) {
        resolveClusterTime(session, document2.$clusterTime);
      }
      if (document2.operationTime && session && session.supports.causalConsistency) {
        session.advanceOperationTime(document2.operationTime);
      }
      if (document2.recoveryToken && session && session.inTransaction()) {
        session.transaction._recoveryToken = document2.recoveryToken;
      }
    }
    module2.exports = {
      ClientSession,
      ServerSession,
      ServerSessionPool,
      TxnState,
      applySession,
      updateSessionFromResponse,
      commandSupportsReadConcern
    };
  }
});

// node_modules/mongodb/lib/core/connection/pool.js
var require_pool = __commonJS({
  "node_modules/mongodb/lib/core/connection/pool.js"(exports2, module2) {
    "use strict";
    var inherits = require("util").inherits;
    var EventEmitter = require("events").EventEmitter;
    var MongoError = require_error().MongoError;
    var MongoTimeoutError = require_error().MongoTimeoutError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var Logger = require_logger();
    var f = require("util").format;
    var Msg = require_msg().Msg;
    var CommandResult = require_command_result();
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
    var opcodes = require_shared().opcodes;
    var compress = require_compression().compress;
    var compressorIDs = require_compression().compressorIDs;
    var uncompressibleCommands = require_compression().uncompressibleCommands;
    var apm = require_apm();
    var Buffer2 = require_safe_buffer().Buffer;
    var connect = require_connect();
    var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
    var eachAsync = require_utils2().eachAsync;
    var makeStateMachine = require_utils2().makeStateMachine;
    var now = require_utils4().now;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var DRAINING = "draining";
    var DESTROYING = "destroying";
    var DESTROYED = "destroyed";
    var stateTransition = makeStateMachine({
      [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],
      [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],
      [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],
      [DRAINING]: [DRAINING, DESTROYING, DESTROYED],
      [DESTROYING]: [DESTROYING, DESTROYED],
      [DESTROYED]: [DESTROYED]
    });
    var CONNECTION_EVENTS = new Set([
      "error",
      "close",
      "timeout",
      "parseError",
      "connect",
      "message"
    ]);
    var _id = 0;
    var Pool = function(topology, options2) {
      EventEmitter.call(this);
      this.topology = topology;
      this.s = {
        state: DISCONNECTED,
        cancellationToken: new EventEmitter()
      };
      this.s.cancellationToken.setMaxListeners(Infinity);
      this.options = Object.assign({
        host: "localhost",
        port: 27017,
        size: 5,
        minSize: 0,
        connectionTimeout: 3e4,
        socketTimeout: 0,
        keepAlive: true,
        keepAliveInitialDelay: 12e4,
        noDelay: true,
        ssl: false,
        checkServerIdentity: true,
        ca: null,
        crl: null,
        cert: null,
        key: null,
        passphrase: null,
        rejectUnauthorized: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        reconnect: true,
        reconnectInterval: 1e3,
        reconnectTries: 30,
        domainsEnabled: false,
        legacyCompatMode: true
      }, options2);
      this.id = _id++;
      this.retriesLeft = this.options.reconnectTries;
      this.reconnectId = null;
      this.reconnectError = null;
      if (!options2.bson || options2.bson && (typeof options2.bson.serialize !== "function" || typeof options2.bson.deserialize !== "function")) {
        throw new Error("must pass in valid bson parser");
      }
      this.logger = Logger("Pool", options2);
      this.availableConnections = [];
      this.inUseConnections = [];
      this.connectingConnections = 0;
      this.executing = false;
      this.queue = [];
      this.numberOfConsecutiveTimeouts = 0;
      this.connectionIndex = 0;
      const pool = this;
      this._messageHandler = messageHandler(this);
      this._connectionCloseHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "close", err, connection);
      };
      this._connectionErrorHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "error", err, connection);
      };
      this._connectionTimeoutHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "timeout", err, connection);
      };
      this._connectionParseErrorHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "parseError", err, connection);
      };
    };
    inherits(Pool, EventEmitter);
    Object.defineProperty(Pool.prototype, "size", {
      enumerable: true,
      get: function() {
        return this.options.size;
      }
    });
    Object.defineProperty(Pool.prototype, "minSize", {
      enumerable: true,
      get: function() {
        return this.options.minSize;
      }
    });
    Object.defineProperty(Pool.prototype, "connectionTimeout", {
      enumerable: true,
      get: function() {
        return this.options.connectionTimeout;
      }
    });
    Object.defineProperty(Pool.prototype, "socketTimeout", {
      enumerable: true,
      get: function() {
        return this.options.socketTimeout;
      }
    });
    Object.defineProperty(Pool.prototype, "state", {
      enumerable: true,
      get: function() {
        return this.s.state;
      }
    });
    function resetPoolState(pool) {
      pool.inUseConnections = [];
      pool.availableConnections = [];
      pool.connectingConnections = 0;
      pool.executing = false;
      pool.numberOfConsecutiveTimeouts = 0;
      pool.connectionIndex = 0;
      pool.retriesLeft = pool.options.reconnectTries;
      pool.reconnectId = null;
    }
    function connectionFailureHandler(pool, event, err, conn) {
      if (conn) {
        if (conn._connectionFailHandled) {
          return;
        }
        conn._connectionFailHandled = true;
        conn.destroy();
        removeConnection(pool, conn);
        conn.flush(err);
      }
      if (event === "timeout") {
        pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;
        if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {
          pool.numberOfConsecutiveTimeouts = 0;
          pool.destroy(true);
          return pool.emit("close", pool);
        }
      }
      if (pool.socketCount() === 0) {
        if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {
          if (pool.options.reconnect) {
            stateTransition(pool, DISCONNECTED);
          }
        }
        event = event === "error" ? "close" : event;
        pool.emit(event, err);
      }
      if (!pool.reconnectId && pool.options.reconnect) {
        pool.reconnectError = err;
        pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);
      }
      const totalConnections = totalConnectionCount(pool);
      if (totalConnections < pool.minSize) {
        createConnection(pool);
      }
    }
    function attemptReconnect(pool, callback) {
      return function() {
        pool.emit("attemptReconnect", pool);
        if (pool.state === DESTROYED || pool.state === DESTROYING) {
          if (typeof callback === "function") {
            callback(new MongoError("Cannot create connection when pool is destroyed"));
          }
          return;
        }
        pool.retriesLeft = pool.retriesLeft - 1;
        if (pool.retriesLeft <= 0) {
          pool.destroy();
          const error3 = new MongoTimeoutError(`failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`, pool.reconnectError);
          pool.emit("reconnectFailed", error3);
          if (typeof callback === "function") {
            callback(error3);
          }
          return;
        }
        pool.reconnectId = null;
        createConnection(pool, (err, conn) => {
          if (err == null) {
            pool.reconnectId = null;
            pool.retriesLeft = pool.options.reconnectTries;
            pool.emit("reconnect", pool);
          }
          if (typeof callback === "function") {
            callback(err, conn);
          }
        });
      };
    }
    function moveConnectionBetween(connection, from, to) {
      var index2 = from.indexOf(connection);
      if (index2 !== -1) {
        from.splice(index2, 1);
        to.push(connection);
      }
    }
    function messageHandler(self2) {
      return function(message, connection) {
        var workItem = null;
        for (var i = 0; i < connection.workItems.length; i++) {
          if (connection.workItems[i].requestId === message.responseTo) {
            workItem = connection.workItems[i];
            connection.workItems.splice(i, 1);
          }
        }
        if (workItem && workItem.monitoring) {
          moveConnectionBetween(connection, self2.inUseConnections, self2.availableConnections);
        }
        self2.numberOfConsecutiveTimeouts = 0;
        if (workItem && workItem.socketTimeout) {
          connection.resetSocketTimeout();
        }
        if (self2.logger.isDebug()) {
          self2.logger.debug(f("message [%s] received from %s:%s", message.raw.toString("hex"), self2.options.host, self2.options.port));
        }
        function handleOperationCallback(self3, cb, err, result) {
          if (!self3.options.domainsEnabled) {
            return process.nextTick(function() {
              return cb(err, result);
            });
          }
          cb(err, result);
        }
        if (!self2.executing) {
          process.nextTick(function() {
            _execute(self2)();
          });
        }
        if (workItem && !workItem.immediateRelease) {
          try {
            message.parse(workItem);
          } catch (err) {
            return handleOperationCallback(self2, workItem.cb, new MongoError(err));
          }
          if (message.documents[0]) {
            const document2 = message.documents[0];
            const session = workItem.session;
            if (session) {
              updateSessionFromResponse(session, document2);
            }
            if (self2.topology && document2.$clusterTime) {
              self2.topology.clusterTime = document2.$clusterTime;
            }
          }
          if (workItem.command && message.documents[0]) {
            const responseDoc = message.documents[0];
            if (responseDoc.writeConcernError) {
              const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);
              return handleOperationCallback(self2, workItem.cb, err);
            }
            if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {
              return handleOperationCallback(self2, workItem.cb, new MongoError(responseDoc));
            }
          }
          message.hashedName = connection.hashedName;
          handleOperationCallback(self2, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));
        }
      };
    }
    Pool.prototype.socketCount = function() {
      return this.availableConnections.length + this.inUseConnections.length;
    };
    function totalConnectionCount(pool) {
      return pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections;
    }
    Pool.prototype.allConnections = function() {
      return this.availableConnections.concat(this.inUseConnections);
    };
    Pool.prototype.get = function() {
      return this.allConnections()[0];
    };
    Pool.prototype.isConnected = function() {
      if (this.state === DESTROYED || this.state === DESTROYING) {
        return false;
      }
      var connections = this.availableConnections.concat(this.inUseConnections);
      for (var i = 0; i < connections.length; i++) {
        if (connections[i].isConnected())
          return true;
      }
      return false;
    };
    Pool.prototype.isDestroyed = function() {
      return this.state === DESTROYED || this.state === DESTROYING;
    };
    Pool.prototype.isDisconnected = function() {
      return this.state === DISCONNECTED;
    };
    Pool.prototype.connect = function(callback) {
      if (this.state !== DISCONNECTED) {
        throw new MongoError("connection in unlawful state " + this.state);
      }
      stateTransition(this, CONNECTING);
      createConnection(this, (err, conn) => {
        if (err) {
          if (typeof callback === "function") {
            this.destroy();
            callback(err);
            return;
          }
          if (this.state === CONNECTING) {
            this.emit("error", err);
          }
          this.destroy();
          return;
        }
        stateTransition(this, CONNECTED);
        if (this.minSize) {
          for (let i = 0; i < this.minSize; i++) {
            createConnection(this);
          }
        }
        if (typeof callback === "function") {
          callback(null, conn);
        } else {
          this.emit("connect", this, conn);
        }
      });
    };
    Pool.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Pool.prototype.logout = function(dbName, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Pool.prototype.unref = function() {
      var connections = this.availableConnections.concat(this.inUseConnections);
      connections.forEach(function(c) {
        c.unref();
      });
    };
    function destroy(self2, connections, options2, callback) {
      stateTransition(self2, DESTROYING);
      self2.s.cancellationToken.emit("cancel");
      eachAsync(connections, (conn, cb) => {
        for (const eventName of CONNECTION_EVENTS) {
          conn.removeAllListeners(eventName);
        }
        conn.on("error", () => {
        });
        conn.destroy(options2, cb);
      }, (err) => {
        if (err) {
          if (typeof callback === "function")
            callback(err, null);
          return;
        }
        resetPoolState(self2);
        self2.queue = [];
        stateTransition(self2, DESTROYED);
        if (typeof callback === "function")
          callback(null, null);
      });
    }
    Pool.prototype.destroy = function(force, callback) {
      var self2 = this;
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      if (this.state === DESTROYED || self2.state === DESTROYING) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      stateTransition(this, DRAINING);
      if (force) {
        var connections = self2.availableConnections.concat(self2.inUseConnections);
        while (self2.queue.length > 0) {
          var workItem = self2.queue.shift();
          if (typeof workItem.cb === "function") {
            workItem.cb(new MongoError("Pool was force destroyed"));
          }
        }
        return destroy(self2, connections, {force: true}, callback);
      }
      if (this.reconnectId) {
        clearTimeout(this.reconnectId);
      }
      function checkStatus() {
        if (self2.state === DESTROYED || self2.state === DESTROYING) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        flushMonitoringOperations(self2.queue);
        if (self2.queue.length === 0) {
          var connections2 = self2.availableConnections.concat(self2.inUseConnections);
          for (var i = 0; i < connections2.length; i++) {
            if (connections2[i].workItems.length > 0) {
              return setTimeout(checkStatus, 1);
            }
          }
          destroy(self2, connections2, {force: false}, callback);
        } else {
          _execute(self2)();
          setTimeout(checkStatus, 1);
        }
      }
      checkStatus();
    };
    Pool.prototype.reset = function(callback) {
      if (this.s.state !== CONNECTED) {
        if (typeof callback === "function") {
          callback(new MongoError("pool is not connected, reset aborted"));
        }
        return;
      }
      this.s.cancellationToken.emit("cancel");
      const connections = this.availableConnections.concat(this.inUseConnections);
      eachAsync(connections, (conn, cb) => {
        for (const eventName of CONNECTION_EVENTS) {
          conn.removeAllListeners(eventName);
        }
        conn.destroy({force: true}, cb);
      }, (err) => {
        if (err) {
          if (typeof callback === "function") {
            callback(err, null);
            return;
          }
        }
        resetPoolState(this);
        createConnection(this, () => {
          if (typeof callback === "function") {
            callback(null, null);
          }
        });
      });
    };
    function serializeCommand(self2, command2, callback) {
      const originalCommandBuffer = command2.toBin();
      const shouldCompress = !!self2.options.agreedCompressor;
      if (!shouldCompress || !canCompress(command2)) {
        return callback(null, originalCommandBuffer);
      }
      const concatenatedOriginalCommandBuffer = Buffer2.concat(originalCommandBuffer);
      const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
      const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      compress(self2, messageToBeCompressed, function(err, compressedMessage) {
        if (err)
          return callback(err, null);
        const msgHeader = Buffer2.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
        msgHeader.writeInt32LE(command2.requestId, 4);
        msgHeader.writeInt32LE(0, 8);
        msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
        const compressionDetails = Buffer2.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0);
        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
        compressionDetails.writeUInt8(compressorIDs[self2.options.agreedCompressor], 8);
        return callback(null, [msgHeader, compressionDetails, compressedMessage]);
      });
    }
    Pool.prototype.write = function(command2, options2, cb) {
      var self2 = this;
      if (typeof options2 === "function") {
        cb = options2;
      }
      options2 = options2 || {};
      if (!(typeof cb === "function") && !options2.noResponse) {
        throw new MongoError("write method must provide a callback");
      }
      if (this.state === DESTROYED || this.state === DESTROYING) {
        cb(new MongoError("pool destroyed"));
        return;
      }
      if (this.state === DRAINING) {
        cb(new MongoError("pool is draining, new operations prohibited"));
        return;
      }
      if (this.options.domainsEnabled && process.domain && typeof cb === "function") {
        var oldCb = cb;
        cb = process.domain.bind(function() {
          var args = new Array(arguments.length);
          for (var i = 0; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
          process.nextTick(function() {
            oldCb.apply(null, args);
          });
        });
      }
      var operation = {
        cb,
        raw: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        fullResult: false
      };
      operation.promoteLongs = typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true;
      operation.promoteValues = typeof options2.promoteValues === "boolean" ? options2.promoteValues : true;
      operation.promoteBuffers = typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false;
      operation.raw = typeof options2.raw === "boolean" ? options2.raw : false;
      operation.immediateRelease = typeof options2.immediateRelease === "boolean" ? options2.immediateRelease : false;
      operation.documentsReturnedIn = options2.documentsReturnedIn;
      operation.command = typeof options2.command === "boolean" ? options2.command : false;
      operation.fullResult = typeof options2.fullResult === "boolean" ? options2.fullResult : false;
      operation.noResponse = typeof options2.noResponse === "boolean" ? options2.noResponse : false;
      operation.session = options2.session || null;
      operation.socketTimeout = options2.socketTimeout;
      operation.monitoring = options2.monitoring;
      operation.requestId = command2.requestId;
      if (self2.options.monitorCommands) {
        this.emit("commandStarted", new apm.CommandStartedEvent(this, command2));
        operation.started = now();
        operation.cb = (err, reply) => {
          if (err) {
            self2.emit("commandFailed", new apm.CommandFailedEvent(this, command2, err, operation.started));
          } else {
            if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
              self2.emit("commandFailed", new apm.CommandFailedEvent(this, command2, reply.result, operation.started));
            } else {
              self2.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command2, reply, operation.started));
            }
          }
          if (typeof cb === "function")
            cb(err, reply);
        };
      }
      serializeCommand(self2, command2, (err, serializedBuffers) => {
        if (err)
          throw err;
        operation.buffer = serializedBuffers;
        if (options2.monitoring) {
          self2.queue.unshift(operation);
        } else {
          self2.queue.push(operation);
        }
        if (!self2.executing) {
          process.nextTick(function() {
            _execute(self2)();
          });
        }
      });
    };
    function canCompress(command2) {
      const commandDoc = command2 instanceof Msg ? command2.command : command2.query;
      const commandName = Object.keys(commandDoc)[0];
      return !uncompressibleCommands.has(commandName);
    }
    function remove2(connection, connections) {
      for (var i = 0; i < connections.length; i++) {
        if (connections[i] === connection) {
          connections.splice(i, 1);
          return true;
        }
      }
    }
    function removeConnection(self2, connection) {
      if (remove2(connection, self2.availableConnections))
        return;
      if (remove2(connection, self2.inUseConnections))
        return;
    }
    function createConnection(pool, callback) {
      if (pool.state === DESTROYED || pool.state === DESTROYING) {
        if (typeof callback === "function") {
          callback(new MongoError("Cannot create connection when pool is destroyed"));
        }
        return;
      }
      pool.connectingConnections++;
      connect(pool.options, pool.s.cancellationToken, (err, connection) => {
        pool.connectingConnections--;
        if (err) {
          if (pool.logger.isDebug()) {
            pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
          }
          if (!pool.reconnectId && pool.options.reconnect) {
            if (pool.state === CONNECTING && pool.options.legacyCompatMode) {
              callback(err);
              return;
            }
            pool.reconnectError = err;
            pool.reconnectId = setTimeout(attemptReconnect(pool, callback), pool.options.reconnectInterval);
            return;
          }
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        if (pool.state === DESTROYED || pool.state === DESTROYING) {
          if (typeof callback === "function") {
            callback(new MongoError("Pool was destroyed after connection creation"));
          }
          connection.destroy();
          return;
        }
        connection.on("error", pool._connectionErrorHandler);
        connection.on("close", pool._connectionCloseHandler);
        connection.on("timeout", pool._connectionTimeoutHandler);
        connection.on("parseError", pool._connectionParseErrorHandler);
        connection.on("message", pool._messageHandler);
        pool.availableConnections.push(connection);
        if (typeof callback === "function") {
          callback(null, connection);
        }
        _execute(pool)();
      });
    }
    function flushMonitoringOperations(queue) {
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].monitoring) {
          var workItem = queue[i];
          queue.splice(i, 1);
          workItem.cb(new MongoError({message: "no connection available for monitoring", driver: true}));
        }
      }
    }
    function _execute(self2) {
      return function() {
        if (self2.state === DESTROYED)
          return;
        if (self2.executing)
          return;
        self2.executing = true;
        if (self2.connectingConnections > 0) {
          self2.executing = false;
          return;
        }
        while (true) {
          const totalConnections = totalConnectionCount(self2);
          if (self2.availableConnections.length === 0) {
            flushMonitoringOperations(self2.queue);
            if (totalConnections < self2.options.size && self2.queue.length > 0) {
              createConnection(self2);
            }
            break;
          }
          if (self2.queue.length === 0) {
            break;
          }
          var connection = null;
          const connections = self2.availableConnections.filter((conn) => conn.workItems.length === 0);
          if (connections.length === 0) {
            connection = self2.availableConnections[self2.connectionIndex++ % self2.availableConnections.length];
          } else {
            connection = connections[self2.connectionIndex++ % connections.length];
          }
          if (!connection.isConnected()) {
            removeConnection(self2, connection);
            flushMonitoringOperations(self2.queue);
            break;
          }
          var workItem = self2.queue.shift();
          if (workItem.monitoring) {
            var foundValidConnection = false;
            for (let i = 0; i < self2.availableConnections.length; i++) {
              if (self2.availableConnections[i].isConnected() && self2.availableConnections[i].workItems.length === 0) {
                foundValidConnection = true;
                connection = self2.availableConnections[i];
                break;
              }
            }
            if (!foundValidConnection) {
              self2.queue.unshift(workItem);
              if (totalConnections < self2.options.size && self2.queue.length > 0) {
                createConnection(self2);
              }
              setTimeout(() => _execute(self2)(), 10);
              break;
            }
          }
          if (totalConnections < self2.options.size) {
            if (connection.workItems.length > 0) {
              self2.queue.unshift(workItem);
              createConnection(self2);
              break;
            }
          }
          var buffer = workItem.buffer;
          if (workItem.monitoring) {
            moveConnectionBetween(connection, self2.availableConnections, self2.inUseConnections);
          }
          if (!workItem.noResponse) {
            connection.workItems.push(workItem);
          }
          if (!workItem.immediateRelease && typeof workItem.socketTimeout === "number") {
            connection.setSocketTimeout(workItem.socketTimeout);
          }
          var writeSuccessful = true;
          if (Array.isArray(buffer)) {
            for (let i = 0; i < buffer.length; i++) {
              writeSuccessful = connection.write(buffer[i]);
            }
          } else {
            writeSuccessful = connection.write(buffer);
          }
          if (workItem.noResponse && typeof workItem.cb === "function") {
            workItem.cb(null, null);
          }
          if (writeSuccessful === false) {
            self2.queue.unshift(workItem);
            removeConnection(self2, connection);
            flushMonitoringOperations(self2.queue);
            break;
          }
        }
        self2.executing = false;
      };
    }
    Pool._execute = _execute;
    module2.exports = Pool;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/command.js
var require_command = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/command.js"(exports2, module2) {
    "use strict";
    var Query2 = require_commands().Query;
    var Msg = require_msg().Msg;
    var MongoError = require_error().MongoError;
    var getReadPreference = require_shared().getReadPreference;
    var isSharded = require_shared().isSharded;
    var databaseNamespace = require_shared().databaseNamespace;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var applySession = require_sessions().applySession;
    var MongoNetworkError = require_error().MongoNetworkError;
    var maxWireVersion = require_utils2().maxWireVersion;
    function isClientEncryptionEnabled(server) {
      const wireVersion = maxWireVersion(server);
      return wireVersion && server.autoEncrypter;
    }
    function command2(server, ns, cmd2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (cmd2 == null) {
        return callback(new MongoError(`command ${JSON.stringify(cmd2)} does not return a cursor`));
      }
      if (!isClientEncryptionEnabled(server)) {
        _command(server, ns, cmd2, options2, callback);
        return;
      }
      const wireVersion = maxWireVersion(server);
      if (typeof wireVersion !== "number" || wireVersion < 8) {
        callback(new MongoError("Auto-encryption requires a minimum MongoDB version of 4.2"));
        return;
      }
      _cryptCommand(server, ns, cmd2, options2, callback);
    }
    function _command(server, ns, cmd2, options2, callback) {
      const bson = server.s.bson;
      const pool = server.s.pool;
      const readPreference = getReadPreference(cmd2, options2);
      const shouldUseOpMsg = supportsOpMsg(server);
      const session = options2.session;
      const serverClusterTime = server.clusterTime;
      let clusterTime = serverClusterTime;
      let finalCmd = Object.assign({}, cmd2);
      if (hasSessionSupport(server) && session) {
        const sessionClusterTime = session.clusterTime;
        if (serverClusterTime && serverClusterTime.clusterTime && sessionClusterTime && sessionClusterTime.clusterTime && sessionClusterTime.clusterTime.greaterThan(serverClusterTime.clusterTime)) {
          clusterTime = sessionClusterTime;
        }
        const err = applySession(session, finalCmd, options2);
        if (err) {
          return callback(err);
        }
      }
      if (clusterTime) {
        finalCmd.$clusterTime = clusterTime;
      }
      if (isSharded(server) && !shouldUseOpMsg && readPreference && readPreference.mode !== "primary") {
        finalCmd = {
          $query: finalCmd,
          $readPreference: readPreference.toJSON()
        };
      }
      const commandOptions = Object.assign({
        command: true,
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: false
      }, options2);
      commandOptions.slaveOk = readPreference.slaveOk();
      const cmdNs = `${databaseNamespace(ns)}.$cmd`;
      const message = shouldUseOpMsg ? new Msg(bson, cmdNs, finalCmd, commandOptions) : new Query2(bson, cmdNs, finalCmd, commandOptions);
      const inTransaction = session && (session.inTransaction() || isTransactionCommand(finalCmd));
      const commandResponseHandler = inTransaction ? function(err) {
        if (err && err instanceof MongoNetworkError && !err.hasErrorLabel("TransientTransactionError")) {
          err.addErrorLabel("TransientTransactionError");
        }
        if (!cmd2.commitTransaction && err && err instanceof MongoError && err.hasErrorLabel("TransientTransactionError")) {
          session.transaction.unpinServer();
        }
        return callback.apply(null, arguments);
      } : callback;
      try {
        pool.write(message, commandOptions, commandResponseHandler);
      } catch (err) {
        commandResponseHandler(err);
      }
    }
    function hasSessionSupport(topology) {
      if (topology == null)
        return false;
      if (topology.description) {
        return topology.description.maxWireVersion >= 6;
      }
      return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;
    }
    function supportsOpMsg(topologyOrServer) {
      const description = topologyOrServer.ismaster ? topologyOrServer.ismaster : topologyOrServer.description;
      if (description == null) {
        return false;
      }
      return description.maxWireVersion >= 6 && description.__nodejs_mock_server__ == null;
    }
    function _cryptCommand(server, ns, cmd2, options2, callback) {
      const autoEncrypter = server.autoEncrypter;
      function commandResponseHandler(err, response) {
        if (err || response == null) {
          callback(err, response);
          return;
        }
        autoEncrypter.decrypt(response.result, options2, (err2, decrypted) => {
          if (err2) {
            callback(err2, null);
            return;
          }
          response.result = decrypted;
          response.message.documents = [decrypted];
          callback(null, response);
        });
      }
      autoEncrypter.encrypt(ns, cmd2, options2, (err, encrypted) => {
        if (err) {
          callback(err, null);
          return;
        }
        _command(server, ns, encrypted, options2, commandResponseHandler);
      });
    }
    module2.exports = command2;
  }
});

// node_modules/mongodb/lib/explain.js
var require_explain = __commonJS({
  "node_modules/mongodb/lib/explain.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var ExplainVerbosity = {
      queryPlanner: "queryPlanner",
      queryPlannerExtended: "queryPlannerExtended",
      executionStats: "executionStats",
      allPlansExecution: "allPlansExecution"
    };
    var Explain = class {
      constructor(verbosity) {
        if (typeof verbosity === "boolean") {
          this.verbosity = verbosity ? "allPlansExecution" : "queryPlanner";
        } else {
          this.verbosity = verbosity;
        }
      }
      static fromOptions(options2) {
        if (options2 == null || options2.explain === void 0) {
          return;
        }
        const explain = options2.explain;
        if (typeof explain === "boolean" || explain in ExplainVerbosity) {
          return new Explain(options2.explain);
        }
        throw new MongoError(`explain must be one of ${Object.keys(ExplainVerbosity)} or a boolean`);
      }
    };
    module2.exports = {Explain};
  }
});

// node_modules/mongodb/lib/core/wireprotocol/write_command.js
var require_write_command = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/write_command.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var collectionNamespace = require_shared().collectionNamespace;
    var command2 = require_command();
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var Explain = require_explain().Explain;
    function writeCommand(server, type, opsField, ns, ops, options2, callback) {
      if (ops.length === 0)
        throw new MongoError(`${type} must contain at least one document`);
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      const ordered = typeof options2.ordered === "boolean" ? options2.ordered : true;
      const writeConcern = options2.writeConcern;
      let writeCommand2 = {};
      writeCommand2[type] = collectionNamespace(ns);
      writeCommand2[opsField] = ops;
      writeCommand2.ordered = ordered;
      if (writeConcern && Object.keys(writeConcern).length > 0) {
        writeCommand2.writeConcern = writeConcern;
      }
      if (options2.collation) {
        for (let i = 0; i < writeCommand2[opsField].length; i++) {
          if (!writeCommand2[opsField][i].collation) {
            writeCommand2[opsField][i].collation = options2.collation;
          }
        }
      }
      if (options2.bypassDocumentValidation === true) {
        writeCommand2.bypassDocumentValidation = options2.bypassDocumentValidation;
      }
      const explain = Explain.fromOptions(options2);
      if (explain) {
        writeCommand2 = decorateWithExplain(writeCommand2, explain);
      }
      const commandOptions = Object.assign({
        checkKeys: type === "insert",
        numberToReturn: 1
      }, options2);
      command2(server, ns, writeCommand2, commandOptions, callback);
    }
    module2.exports = writeCommand;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js
var require_kill_cursors = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js"(exports2, module2) {
    "use strict";
    var KillCursor = require_commands().KillCursor;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var collectionNamespace = require_shared().collectionNamespace;
    var maxWireVersion = require_utils2().maxWireVersion;
    var emitWarning = require_utils2().emitWarning;
    var command2 = require_command();
    function killCursors(server, ns, cursorState, callback) {
      callback = typeof callback === "function" ? callback : () => {
      };
      const cursorId = cursorState.cursorId;
      if (maxWireVersion(server) < 4) {
        const bson = server.s.bson;
        const pool = server.s.pool;
        const killCursor = new KillCursor(bson, ns, [cursorId]);
        const options3 = {
          immediateRelease: true,
          noResponse: true
        };
        if (typeof cursorState.session === "object") {
          options3.session = cursorState.session;
        }
        if (pool && pool.isConnected()) {
          try {
            pool.write(killCursor, options3, callback);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err, null);
            } else {
              emitWarning(err);
            }
          }
        }
        return;
      }
      const killCursorCmd = {
        killCursors: collectionNamespace(ns),
        cursors: [cursorId]
      };
      const options2 = {};
      if (typeof cursorState.session === "object")
        options2.session = cursorState.session;
      command2(server, ns, killCursorCmd, options2, (err, result) => {
        if (err) {
          return callback(err);
        }
        const response = result.message;
        if (response.cursorNotFound) {
          return callback(new MongoNetworkError("cursor killed or timed out"), null);
        }
        if (!Array.isArray(response.documents) || response.documents.length === 0) {
          return callback(new MongoError(`invalid killCursors result returned for cursor id ${cursorId}`));
        }
        callback(null, response.documents[0]);
      });
    }
    module2.exports = killCursors;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/get_more.js
var require_get_more = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/get_more.js"(exports2, module2) {
    "use strict";
    var GetMore = require_commands().GetMore;
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var collectionNamespace = require_shared().collectionNamespace;
    var maxWireVersion = require_utils2().maxWireVersion;
    var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
    var command2 = require_command();
    function getMore(server, ns, cursorState, batchSize, options2, callback) {
      options2 = options2 || {};
      const wireVersion = maxWireVersion(server);
      function queryCallback(err, result) {
        if (err)
          return callback(err);
        const response = result.message;
        if (response.cursorNotFound) {
          return callback(new MongoNetworkError("cursor killed or timed out"), null);
        }
        if (wireVersion < 4) {
          const cursorId3 = typeof response.cursorId === "number" ? Long2.fromNumber(response.cursorId) : response.cursorId;
          cursorState.documents = response.documents;
          cursorState.cursorId = cursorId3;
          callback(null, null, response.connection);
          return;
        }
        if (response.documents[0].ok === 0) {
          return callback(new MongoError(response.documents[0]));
        }
        const cursorId2 = typeof response.documents[0].cursor.id === "number" ? Long2.fromNumber(response.documents[0].cursor.id) : response.documents[0].cursor.id;
        cursorState.documents = response.documents[0].cursor.nextBatch;
        cursorState.cursorId = cursorId2;
        callback(null, response.documents[0], response.connection);
      }
      if (wireVersion < 4) {
        const bson = server.s.bson;
        const getMoreOp = new GetMore(bson, ns, cursorState.cursorId, {numberToReturn: batchSize});
        const queryOptions = applyCommonQueryOptions({}, cursorState);
        server.s.pool.write(getMoreOp, queryOptions, queryCallback);
        return;
      }
      const cursorId = cursorState.cursorId instanceof Long2 ? cursorState.cursorId : Long2.fromNumber(cursorState.cursorId);
      const getMoreCmd = {
        getMore: cursorId,
        collection: collectionNamespace(ns),
        batchSize: Math.abs(batchSize)
      };
      if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS === "number") {
        getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;
      }
      const commandOptions = Object.assign({
        returnFieldSelector: null,
        documentsReturnedIn: "nextBatch"
      }, options2);
      if (cursorState.session) {
        commandOptions.session = cursorState.session;
      }
      command2(server, ns, getMoreCmd, commandOptions, queryCallback);
    }
    module2.exports = getMore;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/query.js
var require_query = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/query.js"(exports2, module2) {
    "use strict";
    var Query2 = require_commands().Query;
    var MongoError = require_error().MongoError;
    var getReadPreference = require_shared().getReadPreference;
    var collectionNamespace = require_shared().collectionNamespace;
    var isSharded = require_shared().isSharded;
    var maxWireVersion = require_utils2().maxWireVersion;
    var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
    var command2 = require_command();
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var Explain = require_explain().Explain;
    function query(server, ns, cmd2, cursorState, options2, callback) {
      options2 = options2 || {};
      if (cursorState.cursorId != null) {
        return callback();
      }
      if (cmd2 == null) {
        return callback(new MongoError(`command ${JSON.stringify(cmd2)} does not return a cursor`));
      }
      if (maxWireVersion(server) < 4) {
        const query2 = prepareLegacyFindQuery(server, ns, cmd2, cursorState, options2);
        const queryOptions = applyCommonQueryOptions({}, cursorState);
        if (typeof query2.documentsReturnedIn === "string") {
          queryOptions.documentsReturnedIn = query2.documentsReturnedIn;
        }
        server.s.pool.write(query2, queryOptions, callback);
        return;
      }
      const readPreference = getReadPreference(cmd2, options2);
      let findCmd = prepareFindCommand(server, ns, cmd2, cursorState, options2);
      const explain = Explain.fromOptions(options2);
      if (explain) {
        findCmd = decorateWithExplain(findCmd, explain);
      }
      cmd2.virtual = false;
      const commandOptions = Object.assign({
        documentsReturnedIn: "firstBatch",
        numberToReturn: 1,
        slaveOk: readPreference.slaveOk()
      }, options2);
      if (cmd2.readPreference) {
        commandOptions.readPreference = readPreference;
      }
      if (cursorState.session) {
        commandOptions.session = cursorState.session;
      }
      command2(server, ns, findCmd, commandOptions, callback);
    }
    function prepareFindCommand(server, ns, cmd2, cursorState) {
      cursorState.batchSize = cmd2.batchSize || cursorState.batchSize;
      const findCmd = {
        find: collectionNamespace(ns)
      };
      if (cmd2.query) {
        if (cmd2.query["$query"]) {
          findCmd.filter = cmd2.query["$query"];
        } else {
          findCmd.filter = cmd2.query;
        }
      }
      let sortValue = cmd2.sort;
      if (Array.isArray(sortValue)) {
        const sortObject = {};
        if (sortValue.length > 0 && !Array.isArray(sortValue[0])) {
          let sortDirection = sortValue[1];
          if (sortDirection === "asc") {
            sortDirection = 1;
          } else if (sortDirection === "desc") {
            sortDirection = -1;
          }
          sortObject[sortValue[0]] = sortDirection;
        } else {
          for (let i = 0; i < sortValue.length; i++) {
            let sortDirection = sortValue[i][1];
            if (sortDirection === "asc") {
              sortDirection = 1;
            } else if (sortDirection === "desc") {
              sortDirection = -1;
            }
            sortObject[sortValue[i][0]] = sortDirection;
          }
        }
        sortValue = sortObject;
      }
      if (typeof cmd2.allowDiskUse === "boolean") {
        findCmd.allowDiskUse = cmd2.allowDiskUse;
      }
      if (cmd2.sort)
        findCmd.sort = sortValue;
      if (cmd2.fields)
        findCmd.projection = cmd2.fields;
      if (cmd2.hint)
        findCmd.hint = cmd2.hint;
      if (cmd2.skip)
        findCmd.skip = cmd2.skip;
      if (cmd2.limit)
        findCmd.limit = cmd2.limit;
      if (cmd2.limit < 0) {
        findCmd.limit = Math.abs(cmd2.limit);
        findCmd.singleBatch = true;
      }
      if (typeof cmd2.batchSize === "number") {
        if (cmd2.batchSize < 0) {
          if (cmd2.limit !== 0 && Math.abs(cmd2.batchSize) < Math.abs(cmd2.limit)) {
            findCmd.limit = Math.abs(cmd2.batchSize);
          }
          findCmd.singleBatch = true;
        }
        findCmd.batchSize = Math.abs(cmd2.batchSize);
      }
      if (cmd2.comment)
        findCmd.comment = cmd2.comment;
      if (cmd2.maxScan)
        findCmd.maxScan = cmd2.maxScan;
      if (cmd2.maxTimeMS)
        findCmd.maxTimeMS = cmd2.maxTimeMS;
      if (cmd2.min)
        findCmd.min = cmd2.min;
      if (cmd2.max)
        findCmd.max = cmd2.max;
      findCmd.returnKey = cmd2.returnKey ? cmd2.returnKey : false;
      findCmd.showRecordId = cmd2.showDiskLoc ? cmd2.showDiskLoc : false;
      if (cmd2.snapshot)
        findCmd.snapshot = cmd2.snapshot;
      if (cmd2.tailable)
        findCmd.tailable = cmd2.tailable;
      if (cmd2.oplogReplay)
        findCmd.oplogReplay = cmd2.oplogReplay;
      if (cmd2.noCursorTimeout)
        findCmd.noCursorTimeout = cmd2.noCursorTimeout;
      if (cmd2.awaitData)
        findCmd.awaitData = cmd2.awaitData;
      if (cmd2.awaitdata)
        findCmd.awaitData = cmd2.awaitdata;
      if (cmd2.partial)
        findCmd.partial = cmd2.partial;
      if (cmd2.collation)
        findCmd.collation = cmd2.collation;
      if (cmd2.readConcern)
        findCmd.readConcern = cmd2.readConcern;
      return findCmd;
    }
    function prepareLegacyFindQuery(server, ns, cmd2, cursorState, options2) {
      options2 = options2 || {};
      const bson = server.s.bson;
      const readPreference = getReadPreference(cmd2, options2);
      cursorState.batchSize = cmd2.batchSize || cursorState.batchSize;
      let numberToReturn = 0;
      if (cursorState.limit < 0 || cursorState.limit !== 0 && cursorState.limit < cursorState.batchSize || cursorState.limit > 0 && cursorState.batchSize === 0) {
        numberToReturn = cursorState.limit;
      } else {
        numberToReturn = cursorState.batchSize;
      }
      const numberToSkip = cursorState.skip || 0;
      const findCmd = {};
      if (isSharded(server) && readPreference) {
        findCmd["$readPreference"] = readPreference.toJSON();
      }
      if (cmd2.sort)
        findCmd["$orderby"] = cmd2.sort;
      if (cmd2.hint)
        findCmd["$hint"] = cmd2.hint;
      if (cmd2.snapshot)
        findCmd["$snapshot"] = cmd2.snapshot;
      if (typeof cmd2.returnKey !== "undefined")
        findCmd["$returnKey"] = cmd2.returnKey;
      if (cmd2.maxScan)
        findCmd["$maxScan"] = cmd2.maxScan;
      if (cmd2.min)
        findCmd["$min"] = cmd2.min;
      if (cmd2.max)
        findCmd["$max"] = cmd2.max;
      if (typeof cmd2.showDiskLoc !== "undefined")
        findCmd["$showDiskLoc"] = cmd2.showDiskLoc;
      if (cmd2.comment)
        findCmd["$comment"] = cmd2.comment;
      if (cmd2.maxTimeMS)
        findCmd["$maxTimeMS"] = cmd2.maxTimeMS;
      if (options2.explain !== void 0) {
        numberToReturn = -Math.abs(cmd2.limit || 0);
        findCmd["$explain"] = true;
      }
      findCmd["$query"] = cmd2.query;
      if (cmd2.readConcern && cmd2.readConcern.level !== "local") {
        throw new MongoError(`server find command does not support a readConcern level of ${cmd2.readConcern.level}`);
      }
      if (cmd2.readConcern) {
        cmd2 = Object.assign({}, cmd2);
        delete cmd2["readConcern"];
      }
      const serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      const ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
      const query2 = new Query2(bson, ns, findCmd, {
        numberToSkip,
        numberToReturn,
        pre32Limit: typeof cmd2.limit !== "undefined" ? cmd2.limit : void 0,
        checkKeys: false,
        returnFieldSelector: cmd2.fields,
        serializeFunctions,
        ignoreUndefined
      });
      if (typeof cmd2.tailable === "boolean")
        query2.tailable = cmd2.tailable;
      if (typeof cmd2.oplogReplay === "boolean")
        query2.oplogReplay = cmd2.oplogReplay;
      if (typeof cmd2.noCursorTimeout === "boolean")
        query2.noCursorTimeout = cmd2.noCursorTimeout;
      if (typeof cmd2.awaitData === "boolean")
        query2.awaitData = cmd2.awaitData;
      if (typeof cmd2.partial === "boolean")
        query2.partial = cmd2.partial;
      query2.slaveOk = readPreference.slaveOk();
      return query2;
    }
    module2.exports = query;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/index.js
var require_wireprotocol = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/index.js"(exports2, module2) {
    "use strict";
    var writeCommand = require_write_command();
    module2.exports = {
      insert: function insert2(server, ns, ops, options2, callback) {
        writeCommand(server, "insert", "documents", ns, ops, options2, callback);
      },
      update: function update(server, ns, ops, options2, callback) {
        writeCommand(server, "update", "updates", ns, ops, options2, callback);
      },
      remove: function remove2(server, ns, ops, options2, callback) {
        writeCommand(server, "delete", "deletes", ns, ops, options2, callback);
      },
      killCursors: require_kill_cursors(),
      getMore: require_get_more(),
      query: require_query(),
      command: require_command()
    };
  }
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS({
  "node_modules/mongodb/lib/operations/operation.js"(exports2, module2) {
    "use strict";
    var Explain = require_explain().Explain;
    var MongoError = require_error().MongoError;
    var Aspect = {
      READ_OPERATION: Symbol("READ_OPERATION"),
      WRITE_OPERATION: Symbol("WRITE_OPERATION"),
      RETRYABLE: Symbol("RETRYABLE"),
      EXECUTE_WITH_SELECTION: Symbol("EXECUTE_WITH_SELECTION"),
      NO_INHERIT_OPTIONS: Symbol("NO_INHERIT_OPTIONS"),
      EXPLAINABLE: Symbol("EXPLAINABLE")
    };
    var OperationBase = class {
      constructor(options2) {
        this.options = Object.assign({}, options2);
        if (this.hasAspect(Aspect.EXPLAINABLE)) {
          this.explain = Explain.fromOptions(options2);
        } else if (this.options.explain !== void 0) {
          throw new MongoError(`explain is not supported on this command`);
        }
      }
      hasAspect(aspect) {
        if (this.constructor.aspects == null) {
          return false;
        }
        return this.constructor.aspects.has(aspect);
      }
      set session(session) {
        Object.assign(this.options, {session});
      }
      get session() {
        return this.options.session;
      }
      clearSession() {
        delete this.options.session;
      }
      get canRetryRead() {
        return true;
      }
      execute() {
        throw new TypeError("`execute` must be implemented for OperationBase subclasses");
      }
    };
    function defineAspects(operation, aspects) {
      if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
        aspects = [aspects];
      }
      aspects = new Set(aspects);
      Object.defineProperty(operation, "aspects", {
        value: aspects,
        writable: false
      });
      return aspects;
    }
    module2.exports = {
      Aspect,
      defineAspects,
      OperationBase
    };
  }
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS({
  "node_modules/mongodb/lib/operations/execute_operation.js"(exports2, module2) {
    "use strict";
    var maybePromise = require_utils4().maybePromise;
    var MongoError = require_error().MongoError;
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_read_preference();
    var isRetryableError = require_error().isRetryableError;
    var maxWireVersion = require_utils2().maxWireVersion;
    var isUnifiedTopology = require_utils2().isUnifiedTopology;
    function executeOperation(topology, operation, cb) {
      if (topology == null) {
        throw new TypeError("This method requires a valid topology instance");
      }
      if (!(operation instanceof OperationBase)) {
        throw new TypeError("This method requires a valid operation instance");
      }
      return maybePromise(topology, cb, (callback) => {
        if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {
          return selectServerForSessionSupport(topology, operation, callback);
        }
        let session, owner;
        if (topology.hasSessionSupport()) {
          if (operation.session == null) {
            owner = Symbol();
            session = topology.startSession({owner});
            operation.session = session;
          } else if (operation.session.hasEnded) {
            return callback(new MongoError("Use of expired sessions is not permitted"));
          }
        } else if (operation.session) {
          return callback(new MongoError("Current topology does not support sessions"));
        }
        function executeCallback(err, result) {
          if (session && session.owner === owner) {
            session.endSession();
            if (operation.session === session) {
              operation.clearSession();
            }
          }
          callback(err, result);
        }
        try {
          if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {
            executeWithServerSelection(topology, operation, executeCallback);
          } else {
            operation.execute(executeCallback);
          }
        } catch (error3) {
          if (session && session.owner === owner) {
            session.endSession();
            if (operation.session === session) {
              operation.clearSession();
            }
          }
          callback(error3);
        }
      });
    }
    function supportsRetryableReads(server) {
      return maxWireVersion(server) >= 6;
    }
    function executeWithServerSelection(topology, operation, callback) {
      const readPreference = operation.readPreference || ReadPreference.primary;
      const inTransaction = operation.session && operation.session.inTransaction();
      if (inTransaction && !readPreference.equals(ReadPreference.primary)) {
        callback(new MongoError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));
        return;
      }
      const serverSelectionOptions = {
        readPreference,
        session: operation.session
      };
      function callbackWithRetry(err, result) {
        if (err == null) {
          return callback(null, result);
        }
        if (!isRetryableError(err)) {
          return callback(err);
        }
        topology.selectServer(serverSelectionOptions, (err2, server) => {
          if (err2 || !supportsRetryableReads(server)) {
            callback(err2, null);
            return;
          }
          operation.execute(server, callback);
        });
      }
      topology.selectServer(serverSelectionOptions, (err, server) => {
        if (err) {
          callback(err, null);
          return;
        }
        const shouldRetryReads = topology.s.options.retryReads !== false && operation.session && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;
        if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {
          operation.execute(server, callbackWithRetry);
          return;
        }
        operation.execute(server, callback);
      });
    }
    function selectServerForSessionSupport(topology, operation, callback) {
      topology.selectServer(ReadPreference.primaryPreferred, (err) => {
        if (err) {
          return callback(err);
        }
        executeOperation(topology, operation, callback);
      });
    }
    module2.exports = executeOperation;
  }
});

// node_modules/mongodb/lib/core/cursor.js
var require_cursor = __commonJS({
  "node_modules/mongodb/lib/core/cursor.js"(exports2, module2) {
    "use strict";
    var Logger = require_logger();
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var collationNotSupported = require_utils2().collationNotSupported;
    var ReadPreference = require_read_preference();
    var isUnifiedTopology = require_utils2().isUnifiedTopology;
    var executeOperation = require_execute_operation();
    var Readable2 = require("stream").Readable;
    var SUPPORTS = require_utils4().SUPPORTS;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var mergeOptions = require_utils4().mergeOptions;
    var OperationBase = require_operation().OperationBase;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var CursorState = {
      INIT: 0,
      OPEN: 1,
      CLOSED: 2,
      GET_MORE: 3
    };
    function handleCallback(callback, err, result) {
      try {
        callback(err, result);
      } catch (err2) {
        process.nextTick(function() {
          throw err2;
        });
      }
    }
    var CoreCursor = class extends Readable2 {
      constructor(topology, ns, cmd2, options2) {
        super({objectMode: true});
        options2 = options2 || {};
        if (ns instanceof OperationBase) {
          this.operation = ns;
          ns = this.operation.ns.toString();
          options2 = this.operation.options;
          cmd2 = this.operation.cmd ? this.operation.cmd : {};
        }
        this.pool = null;
        this.server = null;
        this.disconnectHandler = options2.disconnectHandler;
        this.bson = topology.s.bson;
        this.ns = ns;
        this.namespace = MongoDBNamespace.fromString(ns);
        this.cmd = cmd2;
        this.options = options2;
        this.topology = topology;
        this.cursorState = {
          cursorId: null,
          cmd: cmd2,
          documents: options2.documents || [],
          cursorIndex: 0,
          dead: false,
          killed: false,
          init: false,
          notified: false,
          limit: options2.limit || cmd2.limit || 0,
          skip: options2.skip || cmd2.skip || 0,
          batchSize: options2.batchSize || cmd2.batchSize || 1e3,
          currentLimit: 0,
          transforms: options2.transforms,
          raw: options2.raw || cmd2 && cmd2.raw
        };
        if (typeof options2.session === "object") {
          this.cursorState.session = options2.session;
        }
        const topologyOptions = topology.s.options;
        if (typeof topologyOptions.promoteLongs === "boolean") {
          this.cursorState.promoteLongs = topologyOptions.promoteLongs;
        } else if (typeof options2.promoteLongs === "boolean") {
          this.cursorState.promoteLongs = options2.promoteLongs;
        }
        if (typeof topologyOptions.promoteValues === "boolean") {
          this.cursorState.promoteValues = topologyOptions.promoteValues;
        } else if (typeof options2.promoteValues === "boolean") {
          this.cursorState.promoteValues = options2.promoteValues;
        }
        if (typeof topologyOptions.promoteBuffers === "boolean") {
          this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;
        } else if (typeof options2.promoteBuffers === "boolean") {
          this.cursorState.promoteBuffers = options2.promoteBuffers;
        }
        if (topologyOptions.reconnect) {
          this.cursorState.reconnect = topologyOptions.reconnect;
        }
        this.logger = Logger("Cursor", topologyOptions);
        if (typeof cmd2 === "number") {
          this.cursorState.cursorId = Long2.fromNumber(cmd2);
          this.cursorState.lastCursorId = this.cursorState.cursorId;
        } else if (cmd2 instanceof Long2) {
          this.cursorState.cursorId = cmd2;
          this.cursorState.lastCursorId = cmd2;
        }
        if (this.operation) {
          this.operation.cursorState = this.cursorState;
        }
      }
      setCursorBatchSize(value) {
        this.cursorState.batchSize = value;
      }
      cursorBatchSize() {
        return this.cursorState.batchSize;
      }
      setCursorLimit(value) {
        this.cursorState.limit = value;
      }
      cursorLimit() {
        return this.cursorState.limit;
      }
      setCursorSkip(value) {
        this.cursorState.skip = value;
      }
      cursorSkip() {
        return this.cursorState.skip;
      }
      _next(callback) {
        nextFunction(this, callback);
      }
      clone() {
        const clonedOptions = mergeOptions({}, this.options);
        delete clonedOptions.session;
        return this.topology.cursor(this.ns, this.cmd, clonedOptions);
      }
      isDead() {
        return this.cursorState.dead === true;
      }
      isKilled() {
        return this.cursorState.killed === true;
      }
      isNotified() {
        return this.cursorState.notified === true;
      }
      bufferedCount() {
        return this.cursorState.documents.length - this.cursorState.cursorIndex;
      }
      readBufferedDocuments(number2) {
        const unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
        const length = number2 < unreadDocumentsLength ? number2 : unreadDocumentsLength;
        let elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length);
        if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === "function") {
          for (let i = 0; i < elements.length; i++) {
            elements[i] = this.cursorState.transforms.doc(elements[i]);
          }
        }
        if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {
          elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);
          this.kill();
        }
        this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
        this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;
        return elements;
      }
      kill(callback) {
        this.cursorState.dead = true;
        this.cursorState.killed = true;
        this.cursorState.documents = [];
        if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init === false) {
          if (callback)
            callback(null, null);
          return;
        }
        this.server.killCursors(this.ns, this.cursorState, callback);
      }
      rewind() {
        if (this.cursorState.init) {
          if (!this.cursorState.dead) {
            this.kill();
          }
          this.cursorState.currentLimit = 0;
          this.cursorState.init = false;
          this.cursorState.dead = false;
          this.cursorState.killed = false;
          this.cursorState.notified = false;
          this.cursorState.documents = [];
          this.cursorState.cursorId = null;
          this.cursorState.cursorIndex = 0;
        }
      }
      _read() {
        if (this.s && this.s.state === CursorState.CLOSED || this.isDead()) {
          return this.push(null);
        }
        this._next((err, result) => {
          if (err) {
            if (this.listeners("error") && this.listeners("error").length > 0) {
              this.emit("error", err);
            }
            if (!this.isDead())
              this.close();
            this.emit("end");
            return this.emit("finish");
          }
          if (this.cursorState.streamOptions && typeof this.cursorState.streamOptions.transform === "function" && result != null) {
            return this.push(this.cursorState.streamOptions.transform(result));
          }
          this.push(result);
          if (result === null && this.isDead()) {
            this.once("end", () => {
              this.close();
              this.emit("finish");
            });
          }
        });
      }
      _endSession(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = options2 || {};
        const session = this.cursorState.session;
        if (session && (options2.force || session.owner === this)) {
          this.cursorState.session = void 0;
          if (this.operation) {
            this.operation.clearSession();
          }
          session.endSession(callback);
          return true;
        }
        if (callback) {
          callback();
        }
        return false;
      }
      _getMore(callback) {
        if (this.logger.isDebug()) {
          this.logger.debug(`schedule getMore call for query [${JSON.stringify(this.query)}]`);
        }
        let batchSize = this.cursorState.batchSize;
        if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {
          batchSize = this.cursorState.limit - this.cursorState.currentLimit;
        }
        const cursorState = this.cursorState;
        this.server.getMore(this.ns, cursorState, batchSize, this.options, (err, result, conn) => {
          if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
            this._endSession();
          }
          callback(err, result, conn);
        });
      }
      _initializeCursor(callback) {
        const cursor = this;
        if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {
          cursor.topology.selectServer(ReadPreference.primaryPreferred, (err) => {
            if (err) {
              callback(err);
              return;
            }
            this._initializeCursor(callback);
          });
          return;
        }
        function done(err, result) {
          const cursorState = cursor.cursorState;
          if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
            cursor._endSession();
          }
          if (cursorState.documents.length === 0 && cursorState.cursorId && cursorState.cursorId.isZero() && !cursor.cmd.tailable && !cursor.cmd.awaitData) {
            return setCursorNotified(cursor, callback);
          }
          callback(err, result);
        }
        const queryCallback = (err, r) => {
          if (err) {
            return done(err);
          }
          const result = r.message;
          if (Array.isArray(result.documents) && result.documents.length === 1) {
            const document2 = result.documents[0];
            if (result.queryFailure) {
              return done(new MongoError(document2), null);
            }
            if (!cursor.cmd.find || cursor.cmd.find && cursor.cmd.virtual === false) {
              if (document2.$err || document2.errmsg) {
                return done(new MongoError(document2), null);
              }
              if (document2.cursor != null && typeof document2.cursor !== "string") {
                const id = document2.cursor.id;
                if (document2.cursor.ns) {
                  cursor.ns = document2.cursor.ns;
                }
                cursor.cursorState.cursorId = typeof id === "number" ? Long2.fromNumber(id) : id;
                cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;
                cursor.cursorState.operationTime = document2.operationTime;
                if (Array.isArray(document2.cursor.firstBatch)) {
                  cursor.cursorState.documents = document2.cursor.firstBatch;
                }
                return done(null, result);
              }
            }
          }
          const cursorId = result.cursorId || 0;
          cursor.cursorState.cursorId = cursorId instanceof Long2 ? cursorId : Long2.fromNumber(cursorId);
          cursor.cursorState.documents = result.documents;
          cursor.cursorState.lastCursorId = result.cursorId;
          if (cursor.cursorState.transforms && typeof cursor.cursorState.transforms.query === "function") {
            cursor.cursorState.documents = cursor.cursorState.transforms.query(result);
          }
          done(null, result);
        };
        if (cursor.operation) {
          if (cursor.logger.isDebug()) {
            cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
          }
          executeOperation(cursor.topology, cursor.operation, (err, result) => {
            if (err) {
              done(err);
              return;
            }
            cursor.server = cursor.operation.server;
            cursor.cursorState.init = true;
            if (cursor.cursorState.cursorId != null) {
              return done();
            }
            queryCallback(err, result);
          });
          return;
        }
        const serverSelectOptions = {};
        if (cursor.cursorState.session) {
          serverSelectOptions.session = cursor.cursorState.session;
        }
        if (cursor.operation) {
          serverSelectOptions.readPreference = cursor.operation.readPreference;
        } else if (cursor.options.readPreference) {
          serverSelectOptions.readPreference = cursor.options.readPreference;
        }
        return cursor.topology.selectServer(serverSelectOptions, (err, server) => {
          if (err) {
            const disconnectHandler = cursor.disconnectHandler;
            if (disconnectHandler != null) {
              return disconnectHandler.addObjectAndMethod("cursor", cursor, "next", [callback], callback);
            }
            return callback(err);
          }
          cursor.server = server;
          cursor.cursorState.init = true;
          if (collationNotSupported(cursor.server, cursor.cmd)) {
            return callback(new MongoError(`server ${cursor.server.name} does not support collation`));
          }
          if (cursor.cursorState.cursorId != null) {
            return done();
          }
          if (cursor.logger.isDebug()) {
            cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
          }
          if (cursor.cmd.find != null) {
            server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);
            return;
          }
          const commandOptions = Object.assign({session: cursor.cursorState.session}, cursor.options);
          server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);
        });
      }
    };
    if (SUPPORTS.ASYNC_ITERATOR) {
      CoreCursor.prototype[Symbol.asyncIterator] = require_async_iterator().asyncIterator;
    }
    function isConnectionDead(self2, callback) {
      if (self2.pool && self2.pool.isDestroyed()) {
        self2.cursorState.killed = true;
        const err = new MongoNetworkError(`connection to host ${self2.pool.host}:${self2.pool.port} was destroyed`);
        _setCursorNotifiedImpl(self2, () => callback(err));
        return true;
      }
      return false;
    }
    function isCursorDeadButNotkilled(self2, callback) {
      if (self2.cursorState.dead && !self2.cursorState.killed) {
        self2.cursorState.killed = true;
        setCursorNotified(self2, callback);
        return true;
      }
      return false;
    }
    function isCursorDeadAndKilled(self2, callback) {
      if (self2.cursorState.dead && self2.cursorState.killed) {
        handleCallback(callback, new MongoError("cursor is dead"));
        return true;
      }
      return false;
    }
    function isCursorKilled(self2, callback) {
      if (self2.cursorState.killed) {
        setCursorNotified(self2, callback);
        return true;
      }
      return false;
    }
    function setCursorDeadAndNotified(self2, callback) {
      self2.cursorState.dead = true;
      setCursorNotified(self2, callback);
    }
    function setCursorNotified(self2, callback) {
      _setCursorNotifiedImpl(self2, () => handleCallback(callback, null, null));
    }
    function _setCursorNotifiedImpl(self2, callback) {
      self2.cursorState.notified = true;
      self2.cursorState.documents = [];
      self2.cursorState.cursorIndex = 0;
      if (self2.cursorState.session) {
        self2._endSession(callback);
        return;
      }
      return callback();
    }
    function nextFunction(self2, callback) {
      if (self2.cursorState.notified) {
        return callback(new Error("cursor is exhausted"));
      }
      if (isCursorKilled(self2, callback))
        return;
      if (isCursorDeadButNotkilled(self2, callback))
        return;
      if (isCursorDeadAndKilled(self2, callback))
        return;
      if (!self2.cursorState.init) {
        if (!self2.topology.isConnected(self2.options)) {
          if (self2.topology._type === "server" && !self2.topology.s.options.reconnect) {
            return callback(new MongoError("no connection available"));
          }
          if (self2.disconnectHandler != null) {
            if (self2.topology.isDestroyed()) {
              return callback(new MongoError("Topology was destroyed"));
            }
            self2.disconnectHandler.addObjectAndMethod("cursor", self2, "next", [callback], callback);
            return;
          }
        }
        self2._initializeCursor((err, result) => {
          if (err || result === null) {
            callback(err, result);
            return;
          }
          nextFunction(self2, callback);
        });
        return;
      }
      if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
        self2.kill(() => setCursorDeadAndNotified(self2, callback));
      } else if (self2.cursorState.cursorIndex === self2.cursorState.documents.length && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
        self2.cursorState.documents = [];
        self2.cursorState.cursorIndex = 0;
        if (self2.topology.isDestroyed())
          return callback(new MongoNetworkError("connection destroyed, not possible to instantiate cursor"));
        if (isConnectionDead(self2, callback))
          return;
        self2._getMore(function(err, doc2, connection) {
          if (err) {
            return handleCallback(callback, err);
          }
          self2.connection = connection;
          if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
            return handleCallback(callback, new MongoError({
              message: "No more documents in tailed cursor",
              tailable: self2.cmd.tailable,
              awaitData: self2.cmd.awaitData
            }));
          } else if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
            return nextFunction(self2, callback);
          }
          if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
            return setCursorDeadAndNotified(self2, callback);
          }
          nextFunction(self2, callback);
        });
      } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
        return handleCallback(callback, new MongoError({
          message: "No more documents in tailed cursor",
          tailable: self2.cmd.tailable,
          awaitData: self2.cmd.awaitData
        }));
      } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && Long2.ZERO.equals(self2.cursorState.cursorId)) {
        setCursorDeadAndNotified(self2, callback);
      } else {
        if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
          self2.kill(() => setCursorDeadAndNotified(self2, callback));
          return;
        }
        self2.cursorState.currentLimit += 1;
        let doc2 = self2.cursorState.documents[self2.cursorState.cursorIndex++];
        if (!doc2 || doc2.$err) {
          self2.kill(() => setCursorDeadAndNotified(self2, function() {
            handleCallback(callback, new MongoError(doc2 ? doc2.$err : void 0));
          }));
          return;
        }
        if (self2.cursorState.transforms && typeof self2.cursorState.transforms.doc === "function") {
          doc2 = self2.cursorState.transforms.doc(doc2);
        }
        handleCallback(callback, null, doc2);
      }
    }
    module2.exports = {
      CursorState,
      CoreCursor
    };
  }
});

// node_modules/mongodb/lib/core/topologies/server.js
var require_server = __commonJS({
  "node_modules/mongodb/lib/core/topologies/server.js"(exports2, module2) {
    "use strict";
    var inherits = require("util").inherits;
    var f = require("util").format;
    var EventEmitter = require("events").EventEmitter;
    var ReadPreference = require_read_preference();
    var Logger = require_logger();
    var debugOptions = require_utils3().debugOptions;
    var retrieveBSON = require_utils3().retrieveBSON;
    var Pool = require_pool();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var wireProtocol = require_wireprotocol();
    var CoreCursor = require_cursor().CoreCursor;
    var sdam = require_shared2();
    var createCompressionInfo = require_shared2().createCompressionInfo;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var SessionMixins = require_shared2().SessionMixins;
    var relayEvents = require_utils2().relayEvents;
    var collationNotSupported = require_utils2().collationNotSupported;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var debugFields = [
      "reconnect",
      "reconnectTries",
      "reconnectInterval",
      "emitError",
      "cursorFactory",
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "checkServerIdentity",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "key",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "servername"
    ];
    var id = 0;
    var serverAccounting = false;
    var servers = {};
    var BSON2 = retrieveBSON();
    function topologyId(server) {
      return server.s.parent == null ? server.id : server.s.parent.id;
    }
    var Server = function(options2) {
      options2 = options2 || {};
      EventEmitter.call(this);
      this.id = id++;
      this.s = {
        options: Object.assign({metadata: makeClientMetadata(options2)}, options2),
        logger: Logger("Server", options2),
        Cursor: options2.cursorFactory || CoreCursor,
        bson: options2.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        pool: null,
        disconnectHandler: options2.disconnectHandler,
        monitoring: typeof options2.monitoring === "boolean" ? options2.monitoring : true,
        inTopology: !!options2.parent,
        monitoringInterval: typeof options2.monitoringInterval === "number" ? options2.monitoringInterval : 5e3,
        compression: {compressors: createCompressionInfo(options2)},
        parent: options2.parent
      };
      if (!this.s.parent) {
        this.s.clusterTime = null;
      }
      this.ismaster = null;
      this.lastIsMasterMS = -1;
      this.monitoringProcessId = null;
      this.initialConnect = true;
      this._type = "server";
      this.lastUpdateTime = 0;
      this.lastWriteDate = 0;
      this.staleness = 0;
    };
    inherits(Server, EventEmitter);
    Object.assign(Server.prototype, SessionMixins);
    Object.defineProperty(Server.prototype, "type", {
      enumerable: true,
      get: function() {
        return this._type;
      }
    });
    Object.defineProperty(Server.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(Server.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        if (!this.ismaster)
          return null;
        return this.ismaster.logicalSessionTimeoutMinutes || null;
      }
    });
    Object.defineProperty(Server.prototype, "clientMetadata", {
      enumerable: true,
      get: function() {
        return this.s.options.metadata;
      }
    });
    Object.defineProperty(Server.prototype, "clusterTime", {
      enumerable: true,
      set: function(clusterTime) {
        const settings = this.s.parent ? this.s.parent : this.s;
        resolveClusterTime(settings, clusterTime);
      },
      get: function() {
        const settings = this.s.parent ? this.s.parent : this.s;
        return settings.clusterTime || null;
      }
    });
    Server.enableServerAccounting = function() {
      serverAccounting = true;
      servers = {};
    };
    Server.disableServerAccounting = function() {
      serverAccounting = false;
    };
    Server.servers = function() {
      return servers;
    };
    Object.defineProperty(Server.prototype, "name", {
      enumerable: true,
      get: function() {
        return this.s.options.host + ":" + this.s.options.port;
      }
    });
    function disconnectHandler(self2, type, ns, cmd2, options2, callback) {
      if (!self2.s.pool.isConnected() && self2.s.options.reconnect && self2.s.disconnectHandler != null && !options2.monitoring) {
        self2.s.disconnectHandler.add(type, ns, cmd2, options2, callback);
        return true;
      }
      if (!self2.s.pool.isConnected()) {
        callback(new MongoError(f("no connection available to server %s", self2.name)));
        return true;
      }
    }
    function monitoringProcess(self2) {
      return function() {
        if (self2.s.pool.isDestroyed())
          return;
        self2.emit("monitoring", self2);
        var start = new Date().getTime();
        self2.command("admin.$cmd", {ismaster: true}, {
          socketTimeout: typeof self2.s.options.connectionTimeout !== "number" ? 2e3 : self2.s.options.connectionTimeout,
          monitoring: true
        }, (err, result) => {
          self2.lastIsMasterMS = new Date().getTime() - start;
          if (self2.s.pool.isDestroyed())
            return;
          if (result) {
            self2.ismaster = result.result;
          }
          self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
        });
      };
    }
    var eventHandler = function(self2, event) {
      return function(err, conn) {
        if (self2.s.logger.isInfo()) {
          var object = err instanceof MongoError ? JSON.stringify(err) : {};
          self2.s.logger.info(f("server %s fired event %s out with message %s", self2.name, event, object));
        }
        if (event === "connect") {
          self2.initialConnect = false;
          self2.ismaster = conn.ismaster;
          self2.lastIsMasterMS = conn.lastIsMasterMS;
          if (conn.agreedCompressor) {
            self2.s.pool.options.agreedCompressor = conn.agreedCompressor;
          }
          if (conn.zlibCompressionLevel) {
            self2.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;
          }
          if (conn.ismaster.$clusterTime) {
            const $clusterTime = conn.ismaster.$clusterTime;
            self2.clusterTime = $clusterTime;
          }
          if (self2.ismaster.msg === "isdbgrid") {
            self2._type = "mongos";
          }
          if (self2.s.monitoring) {
            self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
          }
          sdam.emitServerDescriptionChanged(self2, {
            address: self2.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: sdam.getTopologyType(self2)
          });
          if (!self2.s.inTopology) {
            sdam.emitTopologyDescriptionChanged(self2, {
              topologyType: "Single",
              servers: [
                {
                  address: self2.name,
                  arbiters: [],
                  hosts: [],
                  passives: [],
                  type: sdam.getTopologyType(self2)
                }
              ]
            });
          }
          if (self2.s.logger.isInfo()) {
            self2.s.logger.info(f("server %s connected with ismaster [%s]", self2.name, JSON.stringify(self2.ismaster)));
          }
          self2.emit("connect", self2);
        } else if (event === "error" || event === "parseError" || event === "close" || event === "timeout" || event === "reconnect" || event === "attemptReconnect" || event === "reconnectFailed") {
          if (serverAccounting && ["close", "timeout", "error", "parseError", "reconnectFailed"].indexOf(event) !== -1) {
            if (!self2.s.inTopology) {
              self2.emit("topologyOpening", {topologyId: self2.id});
            }
            delete servers[self2.id];
          }
          if (event === "close") {
            sdam.emitServerDescriptionChanged(self2, {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: "Unknown"
            });
          }
          if (event === "reconnectFailed") {
            self2.emit("reconnectFailed", err);
            if (self2.listeners("error").length > 0) {
              self2.emit("error", err);
            }
            return;
          }
          if (["disconnected", "connecting"].indexOf(self2.s.pool.state) !== -1 && self2.initialConnect && ["close", "timeout", "error", "parseError"].indexOf(event) !== -1) {
            self2.initialConnect = false;
            return self2.emit("error", new MongoNetworkError(f("failed to connect to server [%s] on first connect [%s]", self2.name, err)));
          }
          if (event === "reconnect") {
            sdam.emitServerDescriptionChanged(self2, {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: sdam.getTopologyType(self2)
            });
            return self2.emit(event, self2);
          }
          self2.emit(event, err);
        }
      };
    };
    Server.prototype.connect = function(options2) {
      var self2 = this;
      options2 = options2 || {};
      if (serverAccounting)
        servers[this.id] = this;
      if (self2.s.pool && !self2.s.pool.isDisconnected() && !self2.s.pool.isDestroyed()) {
        throw new MongoError(f("server instance in invalid state %s", self2.s.pool.state));
      }
      self2.s.pool = new Pool(this, Object.assign(self2.s.options, options2, {bson: this.s.bson}));
      self2.s.pool.on("close", eventHandler(self2, "close"));
      self2.s.pool.on("error", eventHandler(self2, "error"));
      self2.s.pool.on("timeout", eventHandler(self2, "timeout"));
      self2.s.pool.on("parseError", eventHandler(self2, "parseError"));
      self2.s.pool.on("connect", eventHandler(self2, "connect"));
      self2.s.pool.on("reconnect", eventHandler(self2, "reconnect"));
      self2.s.pool.on("reconnectFailed", eventHandler(self2, "reconnectFailed"));
      relayEvents(self2.s.pool, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
      if (!self2.s.inTopology) {
        this.emit("topologyOpening", {topologyId: topologyId(self2)});
      }
      self2.emit("serverOpening", {topologyId: topologyId(self2), address: self2.name});
      self2.s.pool.connect();
    };
    Server.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Server.prototype.getDescription = function() {
      var ismaster = this.ismaster || {};
      var description = {
        type: sdam.getTopologyType(this),
        address: this.name
      };
      if (ismaster.hosts)
        description.hosts = ismaster.hosts;
      if (ismaster.arbiters)
        description.arbiters = ismaster.arbiters;
      if (ismaster.passives)
        description.passives = ismaster.passives;
      if (ismaster.setName)
        description.setName = ismaster.setName;
      return description;
    };
    Server.prototype.lastIsMaster = function() {
      return this.ismaster;
    };
    Server.prototype.unref = function() {
      this.s.pool.unref();
    };
    Server.prototype.isConnected = function() {
      if (!this.s.pool)
        return false;
      return this.s.pool.isConnected();
    };
    Server.prototype.isDestroyed = function() {
      if (!this.s.pool)
        return false;
      return this.s.pool.isDestroyed();
    };
    function basicWriteValidations(self2) {
      if (!self2.s.pool)
        return new MongoError("server instance is not connected");
      if (self2.s.pool.isDestroyed())
        return new MongoError("server instance pool was destroyed");
    }
    function basicReadValidations(self2, options2) {
      basicWriteValidations(self2, options2);
      if (options2.readPreference && !(options2.readPreference instanceof ReadPreference)) {
        throw new Error("readPreference must be an instance of ReadPreference");
      }
    }
    Server.prototype.command = function(ns, cmd2, options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicReadValidations(self2, options2);
      if (result)
        return callback(result);
      options2 = Object.assign({}, options2, {wireProtocolCommand: false});
      if (self2.s.logger.isDebug())
        self2.s.logger.debug(f("executing command [%s] against %s", JSON.stringify({
          ns,
          cmd: cmd2,
          options: debugOptions(debugFields, options2)
        }), self2.name));
      if (disconnectHandler(self2, "command", ns, cmd2, options2, callback))
        return;
      if (collationNotSupported(this, cmd2)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      wireProtocol.command(self2, ns, cmd2, options2, callback);
    };
    Server.prototype.query = function(ns, cmd2, cursorState, options2, callback) {
      wireProtocol.query(this, ns, cmd2, cursorState, options2, callback);
    };
    Server.prototype.getMore = function(ns, cursorState, batchSize, options2, callback) {
      wireProtocol.getMore(this, ns, cursorState, batchSize, options2, callback);
    };
    Server.prototype.killCursors = function(ns, cursorState, callback) {
      wireProtocol.killCursors(this, ns, cursorState, callback);
    };
    Server.prototype.insert = function(ns, ops, options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicWriteValidations(self2, options2);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "insert", ns, ops, options2, callback))
        return;
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.insert(self2, ns, ops, options2, callback);
    };
    Server.prototype.update = function(ns, ops, options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicWriteValidations(self2, options2);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "update", ns, ops, options2, callback))
        return;
      if (collationNotSupported(this, options2)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.update(self2, ns, ops, options2, callback);
    };
    Server.prototype.remove = function(ns, ops, options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicWriteValidations(self2, options2);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "remove", ns, ops, options2, callback))
        return;
      if (collationNotSupported(this, options2)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.remove(self2, ns, ops, options2, callback);
    };
    Server.prototype.cursor = function(ns, cmd2, options2) {
      options2 = options2 || {};
      const topology = options2.topology || this;
      var FinalCursor = options2.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd2, options2);
    };
    Server.prototype.equals = function(server) {
      if (typeof server === "string")
        return this.name.toLowerCase() === server.toLowerCase();
      if (server.name)
        return this.name.toLowerCase() === server.name.toLowerCase();
      return false;
    };
    Server.prototype.connections = function() {
      return this.s.pool.allConnections();
    };
    Server.prototype.selectServer = function(selector, options2, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = selector, selector = void 0;
      callback(null, this);
    };
    var listeners = ["close", "error", "timeout", "parseError", "connect"];
    Server.prototype.destroy = function(options2, callback) {
      if (this._destroyed) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      var self2 = this;
      if (serverAccounting)
        delete servers[this.id];
      if (this.monitoringProcessId) {
        clearTimeout(this.monitoringProcessId);
      }
      if (!self2.s.pool || this._destroyed) {
        this._destroyed = true;
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      this._destroyed = true;
      if (options2.emitClose) {
        self2.emit("close", self2);
      }
      if (options2.emitDestroy) {
        self2.emit("destroy", self2);
      }
      listeners.forEach(function(event) {
        self2.s.pool.removeAllListeners(event);
      });
      if (self2.listeners("serverClosed").length > 0)
        self2.emit("serverClosed", {topologyId: topologyId(self2), address: self2.name});
      if (self2.listeners("topologyClosed").length > 0 && !self2.s.inTopology) {
        self2.emit("topologyClosed", {topologyId: topologyId(self2)});
      }
      if (self2.s.logger.isDebug()) {
        self2.s.logger.debug(f("destroy called on server %s", self2.name));
      }
      this.s.pool.destroy(options2.force, callback);
    };
    module2.exports = Server;
  }
});

// node_modules/mongodb/lib/core/topologies/replset_state.js
var require_replset_state = __commonJS({
  "node_modules/mongodb/lib/core/topologies/replset_state.js"(exports2, module2) {
    "use strict";
    var inherits = require("util").inherits;
    var f = require("util").format;
    var diff = require_shared2().diff;
    var EventEmitter = require("events").EventEmitter;
    var Logger = require_logger();
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var Buffer2 = require_safe_buffer().Buffer;
    var TopologyType = {
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown"
    };
    var ServerType = {
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown"
    };
    var ReplSetState = function(options2) {
      options2 = options2 || {};
      EventEmitter.call(this);
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
      this.setName = options2.setName;
      this.set = {};
      this.id = options2.id;
      this.setName = options2.setName;
      this.logger = options2.logger || Logger("ReplSet", options2);
      this.index = 0;
      this.acceptableLatency = options2.acceptableLatency || 15;
      this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS || 1e4;
      this.primary = null;
      this.secondaries = [];
      this.arbiters = [];
      this.passives = [];
      this.ghosts = [];
      this.unknownServers = [];
      this.set = {};
      this.maxElectionId = null;
      this.maxSetVersion = 0;
      this.replicasetDescription = {
        topologyType: "Unknown",
        servers: []
      };
      this.logicalSessionTimeoutMinutes = void 0;
    };
    inherits(ReplSetState, EventEmitter);
    ReplSetState.prototype.hasPrimaryAndSecondary = function() {
      return this.primary != null && this.secondaries.length > 0;
    };
    ReplSetState.prototype.hasPrimaryOrSecondary = function() {
      return this.hasPrimary() || this.hasSecondary();
    };
    ReplSetState.prototype.hasPrimary = function() {
      return this.primary != null;
    };
    ReplSetState.prototype.hasSecondary = function() {
      return this.secondaries.length > 0;
    };
    ReplSetState.prototype.get = function(host) {
      var servers = this.allServers();
      for (var i = 0; i < servers.length; i++) {
        if (servers[i].name.toLowerCase() === host.toLowerCase()) {
          return servers[i];
        }
      }
      return null;
    };
    ReplSetState.prototype.allServers = function(options2) {
      options2 = options2 || {};
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      if (!options2.ignoreArbiters)
        servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      return servers;
    };
    ReplSetState.prototype.destroy = function(options2, callback) {
      const serversToDestroy = this.secondaries.concat(this.arbiters).concat(this.passives).concat(this.ghosts);
      if (this.primary)
        serversToDestroy.push(this.primary);
      let serverCount = serversToDestroy.length;
      const serverDestroyed = () => {
        serverCount--;
        if (serverCount > 0) {
          return;
        }
        this.secondaries = [];
        this.arbiters = [];
        this.passives = [];
        this.ghosts = [];
        this.unknownServers = [];
        this.set = {};
        this.primary = null;
        emitTopologyDescriptionChanged(this);
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (serverCount === 0) {
        serverDestroyed();
        return;
      }
      serversToDestroy.forEach((server) => server.destroy(options2, serverDestroyed));
    };
    ReplSetState.prototype.remove = function(server, options2) {
      options2 = options2 || {};
      var serverName = server.name.toLowerCase();
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      for (var i = 0; i < servers.length; i++) {
        if (!options2.force && servers[i].equals(server) && servers[i].isConnected && servers[i].isConnected()) {
          return;
        }
      }
      if (this.set[serverName]) {
        this.set[serverName].type = ServerType.Unknown;
        this.set[serverName].electionId = null;
        this.set[serverName].setName = null;
        this.set[serverName].setVersion = null;
      }
      var removeType = null;
      if (this.primary && this.primary.equals(server)) {
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        removeType = "primary";
      }
      removeType = removeFrom(server, this.secondaries) ? "secondary" : removeType;
      removeType = removeFrom(server, this.arbiters) ? "arbiter" : removeType;
      removeType = removeFrom(server, this.passives) ? "secondary" : removeType;
      removeFrom(server, this.ghosts);
      removeFrom(server, this.unknownServers);
      this.unknownServers.push(serverName);
      if (removeType) {
        this.emit("left", removeType, server);
      }
    };
    var isArbiter = (ismaster) => ismaster.arbiterOnly && ismaster.setName;
    ReplSetState.prototype.update = function(server) {
      var self2 = this;
      var ismaster = server.lastIsMaster();
      var serverName = server.name.toLowerCase();
      if (ismaster) {
        var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];
        hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);
        hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);
        hosts = hosts.map(function(s2) {
          return s2.toLowerCase();
        });
        for (var i = 0; i < hosts.length; i++) {
          if (this.unknownServers.indexOf(hosts[i]) === -1 && (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)) {
            this.unknownServers.push(hosts[i].toLowerCase());
          }
          if (!this.set[hosts[i]]) {
            this.set[hosts[i]] = {
              type: ServerType.Unknown,
              electionId: null,
              setName: null,
              setVersion: null
            };
          }
        }
      }
      if (!ismaster && !inList(ismaster, server, this.unknownServers)) {
        self2.set[serverName] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self2.set[serverName].type = ServerType.Unknown;
        self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
        self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
        self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
        if (self2.unknownServers.indexOf(server.name) === -1) {
          self2.unknownServers.push(serverName);
        }
        return false;
      }
      if (ismaster.logicalSessionTimeoutMinutes !== void 0 && !isArbiter(ismaster)) {
        if (self2.logicalSessionTimeoutMinutes === void 0 || ismaster.logicalSessionTimeoutMinutes === null) {
          self2.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;
        } else {
          self2.logicalSessionTimeoutMinutes = Math.min(self2.logicalSessionTimeoutMinutes, ismaster.logicalSessionTimeoutMinutes);
        }
      }
      if (ismaster && ismaster.msg === "isdbgrid") {
        if (this.primary && this.primary.name === serverName) {
          this.primary = null;
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        return false;
      }
      if (ismaster.isreplicaset) {
        self2.set[serverName] = {
          type: ServerType.RSGhost,
          setVersion: null,
          electionId: null,
          setName: ismaster.setName
        };
        if (this.primary && this.primary.name === serverName) {
          this.primary = null;
        }
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        return false;
      }
      if (ismaster.setName && ismaster.hidden || ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive) {
        self2.set[serverName] = {
          type: ServerType.RSOther,
          setVersion: null,
          electionId: null,
          setName: ismaster.setName
        };
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        return false;
      }
      if (ismaster && ismaster.ismaster && !ismaster.setName) {
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;
        this.remove(server, {force: true});
        return false;
      }
      if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {
        this.remove(server, {force: true});
        return false;
      }
      if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {
        if (this.logger.isWarn()) {
          this.logger.warn(f("the seedlist server was removed due to its address %s not matching its ismaster.me address %s", server.name, ismaster.me));
        }
        delete this.set[serverName];
        removeFrom(server, self2.unknownServers);
        server.destroy({force: true});
        if (this.primary && !this.primary.equals(server)) {
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        if (!this.primary && ismaster.primary) {
          this.set[ismaster.primary.toLowerCase()] = {
            type: ServerType.PossiblePrimary,
            setName: null,
            electionId: null,
            setVersion: null
          };
        }
        return false;
      }
      if (!this.primary && ismaster.ismaster && ismaster.setName) {
        var ismasterElectionId = server.lastIsMaster().electionId;
        if (this.setName && this.setName !== ismaster.setName) {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
          return new MongoError(f("setName from ismaster does not match provided connection setName [%s] != [%s]", ismaster.setName, this.setName));
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          var result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          var ismasterSetVersion = server.lastIsMaster().setVersion;
          if (result === 1) {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
            return false;
          } else if (result === 0 && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              this.topologyType = TopologyType.ReplicaSetNoPrimary;
              return false;
            }
          }
          this.maxSetVersion = ismasterSetVersion;
          this.maxElectionId = ismasterElectionId;
        }
        var normalizedHosts = ismaster.hosts.map(function(x) {
          return x.toLowerCase();
        });
        var locationIndex = normalizedHosts.indexOf(serverName);
        if (locationIndex !== -1) {
          self2.primary = server;
          self2.set[serverName] = {
            type: ServerType.RSPrimary,
            setVersion: ismaster.setVersion,
            electionId: ismaster.electionId,
            setName: ismaster.setName
          };
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
          if (ismaster.setName)
            this.setName = ismaster.setName;
          removeFrom(server, self2.unknownServers);
          removeFrom(server, self2.secondaries);
          removeFrom(server, self2.passives);
          self2.emit("joined", "primary", server);
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        emitTopologyDescriptionChanged(self2);
        return true;
      } else if (ismaster.ismaster && ismaster.setName) {
        var currentElectionId = self2.set[self2.primary.name.toLowerCase()].electionId;
        var currentSetVersion = self2.set[self2.primary.name.toLowerCase()].setVersion;
        var currentSetName = self2.set[self2.primary.name.toLowerCase()].setName;
        ismasterElectionId = server.lastIsMaster().electionId;
        ismasterSetVersion = server.lastIsMaster().setVersion;
        var ismasterSetName = server.lastIsMaster().setName;
        if (this.primary.equals(server) && currentSetName === ismasterSetName) {
          return false;
        }
        if (currentSetName && currentSetName !== ismasterSetName) {
          if (!this.primary.equals(server)) {
            this.topologyType = TopologyType.ReplicaSetWithPrimary;
          } else {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
          }
          return false;
        }
        if (currentElectionId && ismasterElectionId) {
          result = compareObjectIds(currentElectionId, ismasterElectionId);
          if (result === 1) {
            return false;
          } else if (result === 0 && currentSetVersion > ismasterSetVersion) {
            return false;
          }
        } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {
          if (ismasterSetVersion < this.maxSetVersion) {
            return false;
          }
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          if (result === 1) {
            return false;
          } else if (result === 0 && currentSetVersion && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          } else {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          }
          this.maxElectionId = ismasterElectionId;
          this.maxSetVersion = ismasterSetVersion;
        } else {
          this.maxSetVersion = ismasterSetVersion;
        }
        self2.set[self2.primary.name.toLowerCase()] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self2.emit("left", "primary", this.primary);
        self2.primary.destroy({force: true});
        self2.primary = server;
        self2.set[serverName] = {
          type: ServerType.RSPrimary,
          setVersion: ismaster.setVersion,
          electionId: ismaster.electionId,
          setName: ismaster.setName
        };
        this.topologyType = TopologyType.ReplicaSetWithPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        removeFrom(server, self2.secondaries);
        removeFrom(server, self2.passives);
        self2.emit("joined", "primary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (!this.primary && ismaster.primary) {
        self2.set[ismaster.primary.toLowerCase()] = {
          type: ServerType.PossiblePrimary,
          setVersion: null,
          electionId: null,
          setName: null
        };
      }
      if (ismaster.secondary && ismaster.setName && !inList(ismaster, server, this.secondaries) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSSecondary, ismaster, server, this.secondaries);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        if (this.primary && this.primary.name.toLowerCase() === serverName) {
          server.destroy({force: true});
          this.primary = null;
          self2.emit("left", "primary", server);
        }
        self2.emit("joined", "secondary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (isArbiter(ismaster) && !inList(ismaster, server, this.arbiters) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSArbiter, ismaster, server, this.arbiters);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        self2.emit("joined", "arbiter", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (ismaster.passive && ismaster.setName && !inList(ismaster, server, this.passives) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSSecondary, ismaster, server, this.passives);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        if (this.primary && this.primary.name.toLowerCase() === serverName) {
          server.destroy({force: true});
          this.primary = null;
          self2.emit("left", "primary", server);
        }
        self2.emit("joined", "secondary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {
        self2.emit("left", "primary", this.primary);
        this.primary.destroy({force: true});
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        return false;
      }
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      return false;
    };
    ReplSetState.prototype.updateServerMaxStaleness = function(server, haInterval) {
      var max = 0;
      for (var i = 0; i < this.secondaries.length; i++) {
        max = Math.max(max, this.secondaries[i].lastWriteDate);
      }
      if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {
        server.staleness = server.lastUpdateTime - server.lastWriteDate - (this.primary.lastUpdateTime - this.primary.lastWriteDate) + haInterval;
      } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {
        server.staleness = max - server.lastWriteDate + haInterval;
      }
    };
    ReplSetState.prototype.updateSecondariesMaxStaleness = function(haInterval) {
      for (var i = 0; i < this.secondaries.length; i++) {
        this.updateServerMaxStaleness(this.secondaries[i], haInterval);
      }
    };
    ReplSetState.prototype.pickServer = function(readPreference) {
      readPreference = readPreference || ReadPreference.primary;
      if (readPreference.preference === "primary" && readPreference.maxStalenessSeconds != null) {
        return new MongoError("primary readPreference incompatible with maxStalenessSeconds");
      }
      var allservers = this.primary ? [this.primary] : [];
      allservers = allservers.concat(this.secondaries);
      if (readPreference.maxStalenessSeconds != null) {
        for (var i = 0; i < allservers.length; i++) {
          if (allservers[i].ismaster.maxWireVersion < 5) {
            return new MongoError("maxStalenessSeconds not supported by at least one of the replicaset members");
          }
        }
      }
      if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds == null) {
        return pickNearest(this, readPreference);
      } else if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds != null) {
        return pickNearestMaxStalenessSeconds(this, readPreference);
      }
      var secondaries = this.secondaries;
      if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {
        return new MongoError("no secondary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) && secondaries.length === 0 && this.primary == null) {
        return new MongoError("no secondary or primary server available");
      }
      if (readPreference.equals(ReadPreference.primary) && this.primary == null) {
        return new MongoError("no primary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) || readPreference.equals(ReadPreference.secondary)) {
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          var server = pickNearest(this, readPreference);
          if (server) {
            return server;
          }
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
          if (server) {
            return server;
          }
        }
        if (readPreference.equals(ReadPreference.secondaryPreferred)) {
          return this.primary;
        }
        return null;
      }
      if (readPreference.equals(ReadPreference.primaryPreferred)) {
        server = null;
        if (this.primary) {
          return this.primary;
        }
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          server = pickNearest(this, readPreference);
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
        }
        if (server)
          return server;
      }
      return this.primary;
    };
    var filterByTags = function(readPreference, servers) {
      if (readPreference.tags == null)
        return servers;
      var filteredServers = [];
      var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];
      for (var j = 0; j < tagsArray.length; j++) {
        var tags2 = tagsArray[j];
        for (var i = 0; i < servers.length; i++) {
          var serverTag = servers[i].lastIsMaster().tags || {};
          var found = true;
          for (var name2 in tags2) {
            if (serverTag[name2] !== tags2[name2]) {
              found = false;
            }
          }
          if (found) {
            filteredServers.push(servers[i]);
          }
        }
      }
      return filteredServers;
    };
    function pickNearestMaxStalenessSeconds(self2, readPreference) {
      var servers = [];
      var maxStalenessMS = readPreference.maxStalenessSeconds * 1e3;
      if (maxStalenessMS < 90 * 1e3) {
        return new MongoError("maxStalenessSeconds must be set to at least 90 seconds");
      }
      if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      for (var i = 0; i < self2.secondaries.length; i++) {
        servers.push(self2.secondaries[i]);
      }
      if (self2.primary && servers.length === 0 && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      servers = filterByTags(readPreference, servers);
      servers = servers.filter(function(s2) {
        return s2.staleness <= maxStalenessMS;
      });
      servers.sort(function(a, b) {
        return a.lastIsMasterMS - b.lastIsMasterMS;
      });
      if (servers.length === 0) {
        return null;
      }
      self2.index = self2.index % servers.length;
      var server = servers[self2.index];
      self2.index = self2.index + 1;
      return server;
    }
    function pickNearest(self2, readPreference) {
      var servers = [];
      if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      for (var i = 0; i < self2.secondaries.length; i++) {
        servers.push(self2.secondaries[i]);
      }
      if (servers.length === 0 && self2.primary && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      servers = filterByTags(readPreference, servers);
      servers.sort(function(a, b) {
        return a.lastIsMasterMS - b.lastIsMasterMS;
      });
      var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;
      servers = servers.filter(function(s2) {
        return s2.lastIsMasterMS <= lowest + self2.acceptableLatency;
      });
      if (servers.length === 0) {
        return null;
      }
      self2.index = self2.index % servers.length;
      var server = servers[self2.index];
      self2.index = self2.index + 1;
      return server;
    }
    function inList(ismaster, server, list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i] && list[i].name && list[i].name.toLowerCase() === server.name.toLowerCase())
          return true;
      }
      return false;
    }
    function addToList(self2, type, ismaster, server, list) {
      var serverName = server.name.toLowerCase();
      self2.set[serverName].type = type;
      self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
      self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
      self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
      list.push(server);
    }
    function compareObjectIds(id1, id2) {
      var a = Buffer2.from(id1.toHexString(), "hex");
      var b = Buffer2.from(id2.toHexString(), "hex");
      if (a === b) {
        return 0;
      }
      if (typeof Buffer2.compare === "function") {
        return Buffer2.compare(a, b);
      }
      var x = a.length;
      var y = b.length;
      var len = Math.min(x, y);
      for (var i = 0; i < len; i++) {
        if (a[i] !== b[i]) {
          break;
        }
      }
      if (i !== len) {
        x = a[i];
        y = b[i];
      }
      return x < y ? -1 : y < x ? 1 : 0;
    }
    function removeFrom(server, list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].equals && list[i].equals(server)) {
          list.splice(i, 1);
          return true;
        } else if (typeof list[i] === "string" && list[i].toLowerCase() === server.name.toLowerCase()) {
          list.splice(i, 1);
          return true;
        }
      }
      return false;
    }
    function emitTopologyDescriptionChanged(self2) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        var topology = "Unknown";
        var setName = self2.setName;
        if (self2.hasPrimaryAndSecondary()) {
          topology = "ReplicaSetWithPrimary";
        } else if (!self2.hasPrimary() && self2.hasSecondary()) {
          topology = "ReplicaSetNoPrimary";
        }
        var description = {
          topologyType: topology,
          setName,
          servers: []
        };
        if (self2.hasPrimary()) {
          var desc = self2.primary.getDescription();
          desc.type = "RSPrimary";
          description.servers.push(desc);
        }
        description.servers = description.servers.concat(self2.secondaries.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSSecondary";
          return description2;
        }));
        description.servers = description.servers.concat(self2.arbiters.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSArbiter";
          return description2;
        }));
        description.servers = description.servers.concat(self2.passives.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSSecondary";
          return description2;
        }));
        var diffResult = diff(self2.replicasetDescription, description);
        var result = {
          topologyId: self2.id,
          previousDescription: self2.replicasetDescription,
          newDescription: description,
          diff: diffResult
        };
        self2.emit("topologyDescriptionChanged", result);
        self2.replicasetDescription = description;
      }
    }
    module2.exports = ReplSetState;
  }
});

// node_modules/mongodb/lib/core/topologies/replset.js
var require_replset = __commonJS({
  "node_modules/mongodb/lib/core/topologies/replset.js"(exports2, module2) {
    "use strict";
    var inherits = require("util").inherits;
    var f = require("util").format;
    var EventEmitter = require("events").EventEmitter;
    var ReadPreference = require_read_preference();
    var CoreCursor = require_cursor().CoreCursor;
    var retrieveBSON = require_utils3().retrieveBSON;
    var Logger = require_logger();
    var MongoError = require_error().MongoError;
    var Server = require_server();
    var ReplSetState = require_replset_state();
    var Timeout = require_shared2().Timeout;
    var Interval = require_shared2().Interval;
    var SessionMixins = require_shared2().SessionMixins;
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var relayEvents = require_utils2().relayEvents;
    var BSON2 = retrieveBSON();
    var getMMAPError = require_shared2().getMMAPError;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var UNREFERENCED = "unreferenced";
    var DESTROYED = "destroyed";
    function stateTransition(self2, newState) {
      var legalTransitions = {
        disconnected: [CONNECTING, DESTROYED, DISCONNECTED],
        connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
        connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],
        unreferenced: [UNREFERENCED, DESTROYED],
        destroyed: [DESTROYED]
      };
      var legalStates = legalTransitions[self2.state];
      if (legalStates && legalStates.indexOf(newState) !== -1) {
        self2.state = newState;
      } else {
        self2.s.logger.error(f("Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self2.id, self2.state, newState, legalStates));
      }
    }
    var id = 1;
    var handlers2 = ["connect", "close", "error", "timeout", "parseError"];
    var ReplSet = function(seedlist, options2) {
      var self2 = this;
      options2 = options2 || {};
      if (!Array.isArray(seedlist))
        throw new MongoError("seedlist must be an array");
      if (seedlist.length === 0)
        throw new MongoError("seedlist must contain at least one entry");
      seedlist.forEach(function(e) {
        if (typeof e.host !== "string" || typeof e.port !== "number")
          throw new MongoError("seedlist entry must contain a host and port");
      });
      EventEmitter.call(this);
      this.id = id++;
      var localThresholdMS = options2.localThresholdMS || 15;
      if (options2.acceptableLatency)
        localThresholdMS = options2.acceptableLatency;
      var logger = Logger("ReplSet", options2);
      this.s = {
        options: Object.assign({metadata: makeClientMetadata(options2)}, options2),
        bson: options2.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        Cursor: options2.cursorFactory || CoreCursor,
        logger,
        seedlist,
        replicaSetState: new ReplSetState({
          id: this.id,
          setName: options2.setName,
          acceptableLatency: localThresholdMS,
          heartbeatFrequencyMS: options2.haInterval ? options2.haInterval : 1e4,
          logger
        }),
        connectingServers: [],
        haInterval: options2.haInterval ? options2.haInterval : 1e4,
        minHeartbeatFrequencyMS: 500,
        disconnectHandler: options2.disconnectHandler,
        index: 0,
        connectOptions: {},
        debug: typeof options2.debug === "boolean" ? options2.debug : false
      };
      this.s.replicaSetState.on("topologyDescriptionChanged", function(r) {
        self2.emit("topologyDescriptionChanged", r);
      });
      if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
      }
      var types3 = ["joined", "left"];
      types3.forEach(function(x) {
        self2.s.replicaSetState.on(x, function(t2, s2) {
          self2.emit(x, t2, s2);
        });
      });
      this.initialConnectState = {
        connect: false,
        fullsetup: false,
        all: false
      };
      this.state = DISCONNECTED;
      this.haTimeoutId = null;
      this.ismaster = null;
      this.intervalIds = [];
      this.clusterTime = null;
    };
    inherits(ReplSet, EventEmitter);
    Object.assign(ReplSet.prototype, SessionMixins);
    Object.defineProperty(ReplSet.prototype, "type", {
      enumerable: true,
      get: function() {
        return "replset";
      }
    });
    Object.defineProperty(ReplSet.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(ReplSet.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;
      }
    });
    function rexecuteOperations(self2) {
      if (self2.s.replicaSetState.hasPrimaryAndSecondary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute();
      } else if (self2.s.replicaSetState.hasPrimary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute({executePrimary: true});
      } else if (self2.s.replicaSetState.hasSecondary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute({executeSecondary: true});
      }
    }
    function connectNewServers(self2, servers, callback) {
      if (servers.length === 0) {
        return callback();
      }
      var count = servers.length;
      var error3 = null;
      function done() {
        count = count - 1;
        if (count === 0) {
          callback(error3);
        }
      }
      var _handleEvent = function(self3, event) {
        return function(err) {
          var _self = this;
          if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
            this.destroy({force: true});
            return done();
          }
          if (event === "connect") {
            var result = self3.s.replicaSetState.update(_self);
            if (result) {
              if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {
                self3.ismaster = _self.lastIsMaster();
              }
              for (let i2 = 0; i2 < handlers2.length; i2++) {
                _self.removeAllListeners(handlers2[i2]);
              }
              _self.on("error", handleEvent(self3, "error"));
              _self.on("close", handleEvent(self3, "close"));
              _self.on("timeout", handleEvent(self3, "timeout"));
              _self.on("parseError", handleEvent(self3, "parseError"));
              monitorServer(_self.lastIsMaster().me, self3, {});
              rexecuteOperations(self3);
            } else {
              _self.destroy({force: true});
            }
          } else if (event === "error") {
            error3 = err;
          }
          rexecuteOperations(self3);
          done();
        };
      };
      function execute(_server, i2) {
        setTimeout(function() {
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            return;
          }
          const existingServerIdx = self2.s.connectingServers.findIndex((s2) => s2.name === _server);
          if (existingServerIdx >= 0) {
            const connectingServer = self2.s.connectingServers[existingServerIdx];
            connectingServer.destroy({force: true});
            self2.s.connectingServers.splice(existingServerIdx, 1);
            return done();
          }
          var server = new Server(Object.assign({}, self2.s.options, {
            host: _server.split(":")[0],
            port: parseInt(_server.split(":")[1], 10),
            reconnect: false,
            monitoring: false,
            parent: self2
          }));
          server.once("connect", _handleEvent(self2, "connect"));
          server.once("close", _handleEvent(self2, "close"));
          server.once("timeout", _handleEvent(self2, "timeout"));
          server.once("error", _handleEvent(self2, "error"));
          server.once("parseError", _handleEvent(self2, "parseError"));
          server.on("serverOpening", (e) => self2.emit("serverOpening", e));
          server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
          server.on("serverClosed", (e) => self2.emit("serverClosed", e));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          self2.s.connectingServers.push(server);
          server.connect(self2.s.connectOptions);
        }, i2);
      }
      for (var i = 0; i < servers.length; i++) {
        execute(servers[i], i);
      }
    }
    var pingServer = function(self2, server, cb) {
      var start = new Date().getTime();
      emitSDAMEvent(self2, "serverHeartbeatStarted", {connectionId: server.name});
      server.command("admin.$cmd", {
        ismaster: true
      }, {
        monitoring: true,
        socketTimeout: self2.s.options.connectionTimeout || 2e3
      }, function(err, r) {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          server.destroy({force: true});
          return cb(err, r);
        }
        var latencyMS = new Date().getTime() - start;
        server.lastUpdateTime = now();
        if (err) {
          emitSDAMEvent(self2, "serverHeartbeatFailed", {
            durationMS: latencyMS,
            failure: err,
            connectionId: server.name
          });
          self2.s.replicaSetState.remove(server);
        } else {
          server.ismaster = r.result;
          if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {
            server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();
          }
          if (server.lastIsMasterMS === -1) {
            server.lastIsMasterMS = latencyMS;
          } else if (server.lastIsMasterMS) {
            server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;
          }
          if (self2.s.replicaSetState.update(server)) {
            if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
              self2.ismaster = server.lastIsMaster();
            }
          }
          emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
            durationMS: latencyMS,
            reply: r.result,
            connectionId: server.name
          });
        }
        self2.s.replicaSetState.updateServerMaxStaleness(server, self2.s.haInterval);
        cb(err, r);
      });
    };
    var monitorServer = function(host, self2, options2) {
      if (!options2.haInterval) {
        for (var i = 0; i < self2.intervalIds.length; i++) {
          if (self2.intervalIds[i].__host === host) {
            return;
          }
        }
      }
      var _process = options2.haInterval ? Timeout : Interval;
      var _haInterval = options2.haInterval ? options2.haInterval : self2.s.haInterval;
      var intervalId = new _process(function() {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          intervalId.stop();
          return;
        }
        var _server = self2.s.replicaSetState.get(host);
        if (_server) {
          return pingServer(self2, _server, function(err) {
            if (err) {
              return;
            }
            if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
              intervalId.stop();
              return;
            }
            self2.intervalIds = self2.intervalIds.filter(function(intervalId2) {
              return intervalId2.isRunning();
            });
            if (_process === Timeout) {
              if (self2.state === CONNECTING && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
                stateTransition(self2, CONNECTED);
                process.nextTick(function() {
                  self2.emit("connect", self2);
                });
                topologyMonitor(self2, {});
              }
            } else {
              if (self2.state === DISCONNECTED && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
                stateTransition(self2, CONNECTING);
                rexecuteOperations(self2);
                process.nextTick(function() {
                  self2.emit("reconnect", self2);
                });
              }
            }
            if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
              self2.initialConnectState.fullsetup = true;
              self2.initialConnectState.all = true;
              process.nextTick(function() {
                self2.emit("fullsetup", self2);
                self2.emit("all", self2);
              });
            }
          });
        }
      }, _haInterval);
      intervalId.start();
      intervalId.__host = host;
      self2.intervalIds.push(intervalId);
    };
    function topologyMonitor(self2, options2) {
      if (self2.state === DESTROYED || self2.state === UNREFERENCED)
        return;
      options2 = options2 || {};
      var servers = Object.keys(self2.s.replicaSetState.set);
      var _process = options2.haInterval ? Timeout : Interval;
      var _haInterval = options2.haInterval ? options2.haInterval : self2.s.haInterval;
      if (_process === Timeout) {
        return connectNewServers(self2, self2.s.replicaSetState.unknownServers, function(err) {
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            return;
          }
          if (!self2.s.replicaSetState.hasPrimary() && !self2.s.options.secondaryOnlyConnectionAllowed) {
            if (err) {
              return self2.emit("error", err);
            }
            self2.emit("error", new MongoError("no primary found in replicaset or invalid replica set name"));
            return self2.destroy({force: true});
          } else if (!self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
            if (err) {
              return self2.emit("error", err);
            }
            self2.emit("error", new MongoError("no secondary found in replicaset or invalid replica set name"));
            return self2.destroy({force: true});
          }
          for (var i2 = 0; i2 < servers.length; i2++) {
            monitorServer(servers[i2], self2, options2);
          }
        });
      } else {
        for (var i = 0; i < servers.length; i++) {
          monitorServer(servers[i], self2, options2);
        }
      }
      function executeReconnect(self3) {
        return function() {
          if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
            return;
          }
          connectNewServers(self3, self3.s.replicaSetState.unknownServers, function() {
            var monitoringFrequencey = self3.s.replicaSetState.hasPrimary() ? _haInterval : self3.s.minHeartbeatFrequencyMS;
            self3.intervalIds.push(new Timeout(executeReconnect(self3), monitoringFrequencey).start());
          });
        };
      }
      var intervalTime = !self2.s.replicaSetState.hasPrimary() ? self2.s.minHeartbeatFrequencyMS : _haInterval;
      self2.intervalIds.push(new Timeout(executeReconnect(self2), intervalTime).start());
    }
    function addServerToList(list, server) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].name.toLowerCase() === server.name.toLowerCase())
          return true;
      }
      list.push(server);
    }
    function handleEvent(self2, event) {
      return function() {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED)
          return;
        if (self2.s.logger.isDebug()) {
          self2.s.logger.debug(f("handleEvent %s from server %s in replset with id %s", event, this.name, self2.id));
        }
        self2.s.replicaSetState.remove(this);
        if (self2.state === DESTROYED || self2.state === UNREFERENCED)
          return;
        if (!self2.s.replicaSetState.hasPrimary() && !self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
          stateTransition(self2, DISCONNECTED);
        } else if (!self2.s.replicaSetState.hasPrimary()) {
          stateTransition(self2, DISCONNECTED);
        }
        addServerToList(self2.s.connectingServers, this);
      };
    }
    function shouldTriggerConnect(self2) {
      const isConnecting = self2.state === CONNECTING;
      const hasPrimary = self2.s.replicaSetState.hasPrimary();
      const hasSecondary = self2.s.replicaSetState.hasSecondary();
      const secondaryOnlyConnectionAllowed = self2.s.options.secondaryOnlyConnectionAllowed;
      const readPreferenceSecondary = self2.s.connectOptions.readPreference && self2.s.connectOptions.readPreference.equals(ReadPreference.secondary);
      return isConnecting && (readPreferenceSecondary && hasSecondary || !readPreferenceSecondary && hasPrimary) || hasSecondary && secondaryOnlyConnectionAllowed;
    }
    function handleInitialConnectEvent(self2, event) {
      return function() {
        var _this = this;
        if (self2.s.logger.isDebug()) {
          self2.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s", event, this.name, self2.id));
        }
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          return this.destroy({force: true});
        }
        if (event === "connect") {
          var result = self2.s.replicaSetState.update(_this);
          if (result === true) {
            if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {
              self2.ismaster = _this.lastIsMaster();
            }
            if (self2.s.logger.isDebug()) {
              self2.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]", event, _this.name, self2.id, JSON.stringify(self2.s.replicaSetState.set)));
            }
            for (let i2 = 0; i2 < handlers2.length; i2++) {
              _this.removeAllListeners(handlers2[i2]);
            }
            _this.on("error", handleEvent(self2, "error"));
            _this.on("close", handleEvent(self2, "close"));
            _this.on("timeout", handleEvent(self2, "timeout"));
            _this.on("parseError", handleEvent(self2, "parseError"));
            if (shouldTriggerConnect(self2)) {
              stateTransition(self2, CONNECTED);
              self2.initialConnectState.connect = true;
              process.nextTick(function() {
                self2.emit("connect", self2);
              });
              topologyMonitor(self2, {});
            }
          } else if (result instanceof MongoError) {
            _this.destroy({force: true});
            self2.destroy({force: true});
            return self2.emit("error", result);
          } else {
            _this.destroy({force: true});
          }
        } else {
          self2.emit("failed", this);
          addServerToList(self2.s.connectingServers, this);
          self2.s.replicaSetState.remove(this);
        }
        if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
          self2.initialConnectState.fullsetup = true;
          self2.initialConnectState.all = true;
          process.nextTick(function() {
            self2.emit("fullsetup", self2);
            self2.emit("all", self2);
          });
        }
        for (var i = 0; i < self2.s.connectingServers.length; i++) {
          if (self2.s.connectingServers[i].equals(this)) {
            self2.s.connectingServers.splice(i, 1);
          }
        }
        if (self2.s.connectingServers.length === 0 && self2.state === CONNECTING) {
          topologyMonitor(self2, {haInterval: 1});
        }
      };
    }
    function connectServers(self2, servers) {
      self2.s.connectingServers = self2.s.connectingServers.concat(servers);
      var timeoutInterval = 0;
      function connect(server, timeoutInterval2) {
        setTimeout(function() {
          if (self2.s.replicaSetState.update(server)) {
            if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
              self2.ismaster = server.lastIsMaster();
            }
          }
          server.once("close", handleInitialConnectEvent(self2, "close"));
          server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
          server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
          server.once("error", handleInitialConnectEvent(self2, "error"));
          server.once("connect", handleInitialConnectEvent(self2, "connect"));
          server.on("serverOpening", (e) => self2.emit("serverOpening", e));
          server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
          server.on("serverClosed", (e) => self2.emit("serverClosed", e));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          server.connect(self2.s.connectOptions);
        }, timeoutInterval2);
      }
      while (servers.length > 0) {
        connect(servers.shift(), timeoutInterval++);
      }
    }
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    ReplSet.prototype.connect = function(options2) {
      var self2 = this;
      this.s.connectOptions = options2 || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function(x) {
        return new Server(Object.assign({}, self2.s.options, x, options2, {
          reconnect: false,
          monitoring: false,
          parent: self2
        }));
      });
      if (this.s.options.socketTimeout > 0 && this.s.options.socketTimeout <= this.s.options.haInterval) {
        return self2.emit("error", new MongoError(f("haInterval [%s] MS must be set to less than socketTimeout [%s] MS", this.s.options.haInterval, this.s.options.socketTimeout)));
      }
      emitSDAMEvent(this, "topologyOpening", {topologyId: this.id});
      connectServers(self2, servers);
    };
    ReplSet.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    ReplSet.prototype.destroy = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      let destroyCount = this.s.connectingServers.length + 1;
      const serverDestroyed = () => {
        destroyCount--;
        if (destroyCount > 0) {
          return;
        }
        emitSDAMEvent(this, "topologyClosed", {topologyId: this.id});
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (this.state === DESTROYED) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      stateTransition(this, DESTROYED);
      if (this.haTimeoutId)
        clearTimeout(this.haTimeoutId);
      for (var i = 0; i < this.intervalIds.length; i++) {
        this.intervalIds[i].stop();
      }
      this.intervalIds = [];
      if (destroyCount === 0) {
        serverDestroyed();
        return;
      }
      this.s.replicaSetState.destroy(options2, serverDestroyed);
      this.s.connectingServers.forEach(function(x) {
        x.destroy(options2, serverDestroyed);
      });
    };
    ReplSet.prototype.unref = function() {
      stateTransition(this, UNREFERENCED);
      this.s.replicaSetState.allServers().forEach(function(x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    ReplSet.prototype.lastIsMaster = function() {
      if (this.s.options.secondaryOnlyConnectionAllowed && !this.s.replicaSetState.hasPrimary() && this.s.replicaSetState.hasSecondary()) {
        return this.s.replicaSetState.secondaries[0].lastIsMaster();
      }
      return this.s.replicaSetState.primary ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;
    };
    ReplSet.prototype.connections = function() {
      var servers = this.s.replicaSetState.allServers();
      var connections = [];
      for (var i = 0; i < servers.length; i++) {
        connections = connections.concat(servers[i].connections());
      }
      return connections;
    };
    ReplSet.prototype.isConnected = function(options2) {
      options2 = options2 || {};
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.secondary)) {
        return this.s.replicaSetState.hasSecondary();
      }
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.primary)) {
        return this.s.replicaSetState.hasPrimary();
      }
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.primaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.secondaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {
        return true;
      }
      return this.s.replicaSetState.hasPrimary();
    };
    ReplSet.prototype.isDestroyed = function() {
      return this.state === DESTROYED;
    };
    var SERVER_SELECTION_TIMEOUT_MS = 1e4;
    var SERVER_SELECTION_INTERVAL_MS = 1e3;
    ReplSet.prototype.selectServer = function(selector, options2, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = selector;
      options2 = options2 || {};
      let readPreference;
      if (selector instanceof ReadPreference) {
        readPreference = selector;
      } else {
        readPreference = options2.readPreference || ReadPreference.primary;
      }
      let lastError;
      const start = now();
      const _selectServer = () => {
        if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {
          if (lastError != null) {
            callback(lastError, null);
          } else {
            callback(new MongoError("Server selection timed out"));
          }
          return;
        }
        const server = this.s.replicaSetState.pickServer(readPreference);
        if (server == null) {
          setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
          return;
        }
        if (!(server instanceof Server)) {
          lastError = server;
          setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
          return;
        }
        if (this.s.debug)
          this.emit("pickedServer", options2.readPreference, server);
        callback(null, server);
      };
      _selectServer();
    };
    ReplSet.prototype.getServers = function() {
      return this.s.replicaSetState.allServers();
    };
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const self2 = args.self;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      if (self2.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      const willRetryWrite = !args.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(self2) && !options2.session.inTransaction() && options2.explain === void 0;
      if (!self2.s.replicaSetState.hasPrimary()) {
        if (self2.s.disconnectHandler) {
          return self2.s.disconnectHandler.add(op, ns, ops, options2, callback);
        } else if (!willRetryWrite) {
          return callback(new MongoError("no primary server found"));
        }
      }
      const handler = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          err = getMMAPError(err);
          return callback(err);
        }
        if (willRetryWrite) {
          const newArgs = Object.assign({}, args, {retrying: true});
          return executeWriteOperation(newArgs, options2, callback);
        }
        if (self2.s.replicaSetState.primary) {
          self2.s.replicaSetState.primary.destroy();
          self2.s.replicaSetState.remove(self2.s.replicaSetState.primary, {force: true});
        }
        return callback(err);
      };
      if (callback.operationId) {
        handler.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options2.session.incrementTransactionNumber();
        options2.willRetryWrite = willRetryWrite;
      }
      self2.s.replicaSetState.primary[op](ns, ops, options2, handler);
    }
    ReplSet.prototype.insert = function(ns, ops, options2, callback) {
      executeWriteOperation({self: this, op: "insert", ns, ops}, options2, callback);
    };
    ReplSet.prototype.update = function(ns, ops, options2, callback) {
      executeWriteOperation({self: this, op: "update", ns, ops}, options2, callback);
    };
    ReplSet.prototype.remove = function(ns, ops, options2, callback) {
      executeWriteOperation({self: this, op: "remove", ns, ops}, options2, callback);
    };
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command2) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command2[op]);
    }
    ReplSet.prototype.command = function(ns, cmd2, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED)
        return callback(new MongoError(f("topology was destroyed")));
      var self2 = this;
      var readPreference = options2.readPreference ? options2.readPreference : ReadPreference.primary;
      if (readPreference.preference === "primary" && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd2, options2, callback);
      } else if (readPreference.preference === "secondary" && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd2, options2, callback);
      } else if (readPreference.preference !== "primary" && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd2, options2, callback);
      }
      var server = this.s.replicaSetState.pickServer(readPreference);
      if (!(server instanceof Server))
        return callback(server);
      if (self2.s.debug)
        self2.emit("pickedServer", ReadPreference.primary, server);
      if (server == null) {
        return callback(new MongoError(f("no server found that matches the provided readPreference %s", readPreference)));
      }
      const willRetryWrite = !options2.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(self2) && !options2.session.inTransaction() && isWriteCommand(cmd2);
      const cb = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          return callback(err);
        }
        if (willRetryWrite) {
          const newOptions = Object.assign({}, options2, {retrying: true});
          return this.command(ns, cmd2, newOptions, callback);
        }
        if (this.s.replicaSetState.primary) {
          this.s.replicaSetState.primary.destroy();
          this.s.replicaSetState.remove(this.s.replicaSetState.primary, {force: true});
        }
        return callback(err);
      };
      if (willRetryWrite) {
        options2.session.incrementTransactionNumber();
        options2.willRetryWrite = willRetryWrite;
      }
      server.command(ns, cmd2, options2, cb);
    };
    ReplSet.prototype.cursor = function(ns, cmd2, options2) {
      options2 = options2 || {};
      const topology = options2.topology || this;
      var FinalCursor = options2.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd2, options2);
    };
    module2.exports = ReplSet;
  }
});

// node_modules/mongodb/lib/core/topologies/mongos.js
var require_mongos = __commonJS({
  "node_modules/mongodb/lib/core/topologies/mongos.js"(exports2, module2) {
    "use strict";
    var inherits = require("util").inherits;
    var f = require("util").format;
    var EventEmitter = require("events").EventEmitter;
    var CoreCursor = require_cursor().CoreCursor;
    var Logger = require_logger();
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var Server = require_server();
    var diff = require_shared2().diff;
    var cloneOptions = require_shared2().cloneOptions;
    var SessionMixins = require_shared2().SessionMixins;
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var relayEvents = require_utils2().relayEvents;
    var BSON2 = retrieveBSON();
    var getMMAPError = require_shared2().getMMAPError;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var UNREFERENCED = "unreferenced";
    var DESTROYING = "destroying";
    var DESTROYED = "destroyed";
    function stateTransition(self2, newState) {
      var legalTransitions = {
        disconnected: [CONNECTING, DESTROYING, DESTROYED, DISCONNECTED],
        connecting: [CONNECTING, DESTROYING, DESTROYED, CONNECTED, DISCONNECTED],
        connected: [CONNECTED, DISCONNECTED, DESTROYING, DESTROYED, UNREFERENCED],
        unreferenced: [UNREFERENCED, DESTROYING, DESTROYED],
        destroyed: [DESTROYED]
      };
      var legalStates = legalTransitions[self2.state];
      if (legalStates && legalStates.indexOf(newState) !== -1) {
        self2.state = newState;
      } else {
        self2.s.logger.error(f("Mongos with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self2.id, self2.state, newState, legalStates));
      }
    }
    var id = 1;
    var handlers2 = ["connect", "close", "error", "timeout", "parseError"];
    var Mongos = function(seedlist, options2) {
      options2 = options2 || {};
      this.id = id++;
      if (Array.isArray(seedlist)) {
        seedlist = seedlist.reduce((seeds, seed) => {
          if (seeds.find((s2) => s2.host === seed.host && s2.port === seed.port)) {
            return seeds;
          }
          seeds.push(seed);
          return seeds;
        }, []);
      }
      this.s = {
        options: Object.assign({metadata: makeClientMetadata(options2)}, options2),
        bson: options2.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        Cursor: options2.cursorFactory || CoreCursor,
        logger: Logger("Mongos", options2),
        seedlist,
        haInterval: options2.haInterval ? options2.haInterval : 1e4,
        disconnectHandler: options2.disconnectHandler,
        index: 0,
        connectOptions: {},
        debug: typeof options2.debug === "boolean" ? options2.debug : false,
        localThresholdMS: options2.localThresholdMS || 15
      };
      if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
      }
      this.state = DISCONNECTED;
      this.connectingProxies = [];
      this.connectedProxies = [];
      this.disconnectedProxies = [];
      this.index = 0;
      this.haTimeoutId = null;
      this.ismaster = null;
      this.topologyDescription = {
        topologyType: "Unknown",
        servers: []
      };
      this.clusterTime = null;
      EventEmitter.call(this);
    };
    inherits(Mongos, EventEmitter);
    Object.assign(Mongos.prototype, SessionMixins);
    Object.defineProperty(Mongos.prototype, "type", {
      enumerable: true,
      get: function() {
        return "mongos";
      }
    });
    Object.defineProperty(Mongos.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(Mongos.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        if (!this.ismaster)
          return null;
        return this.ismaster.logicalSessionTimeoutMinutes || null;
      }
    });
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    var SERVER_EVENTS = ["serverDescriptionChanged", "error", "close", "timeout", "parseError"];
    function destroyServer(server, options2, callback) {
      options2 = options2 || {};
      SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
      server.destroy(options2, callback);
    }
    Mongos.prototype.connect = function(options2) {
      var self2 = this;
      this.s.connectOptions = options2 || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function(x) {
        const server = new Server(Object.assign({}, self2.s.options, x, options2, {
          reconnect: false,
          monitoring: false,
          parent: self2
        }));
        relayEvents(server, self2, ["serverDescriptionChanged"]);
        return server;
      });
      emitSDAMEvent(this, "topologyOpening", {topologyId: this.id});
      connectProxies(self2, servers);
    };
    Mongos.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    function handleEvent(self2) {
      return function() {
        if (self2.state === DESTROYED || self2.state === DESTROYING) {
          return;
        }
        moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, this);
        emitTopologyDescriptionChanged(self2);
        self2.emit("left", "mongos", this);
        self2.emit("serverClosed", {
          topologyId: self2.id,
          address: this.name
        });
      };
    }
    function handleInitialConnectEvent(self2, event) {
      return function() {
        var _this = this;
        if (self2.state === DESTROYED) {
          emitTopologyDescriptionChanged(self2);
          moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
          return this.destroy();
        }
        if (event === "connect") {
          self2.ismaster = _this.lastIsMaster();
          if (self2.ismaster.msg === "isdbgrid") {
            for (let i = 0; i < self2.connectedProxies.length; i++) {
              if (self2.connectedProxies[i].name === _this.name) {
                moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, _this);
                emitTopologyDescriptionChanged(self2);
                _this.destroy();
                return self2.emit("failed", _this);
              }
            }
            for (let i = 0; i < handlers2.length; i++) {
              _this.removeAllListeners(handlers2[i]);
            }
            _this.on("error", handleEvent(self2, "error"));
            _this.on("close", handleEvent(self2, "close"));
            _this.on("timeout", handleEvent(self2, "timeout"));
            _this.on("parseError", handleEvent(self2, "parseError"));
            moveServerFrom(self2.connectingProxies, self2.connectedProxies, _this);
            self2.emit("joined", "mongos", _this);
          } else {
            if (self2.s.logger.isWarn()) {
              var message = "expected mongos proxy, but found replicaset member mongod for server %s";
              if (!self2.ismaster.hosts) {
                message = "expected mongos proxy, but found standalone mongod for server %s";
              }
              self2.s.logger.warn(f(message, _this.name));
            }
            _this.destroy(true);
            removeProxyFrom(self2.connectingProxies, _this);
            self2.emit("left", "server", _this);
            self2.emit("failed", _this);
          }
        } else {
          moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
          self2.emit("left", "mongos", this);
          self2.emit("failed", this);
        }
        emitTopologyDescriptionChanged(self2);
        if (self2.connectingProxies.length === 0) {
          if (self2.connectedProxies.length > 0 && self2.state === CONNECTING) {
            stateTransition(self2, CONNECTED);
            self2.emit("connect", self2);
            self2.emit("fullsetup", self2);
            self2.emit("all", self2);
          } else if (self2.disconnectedProxies.length === 0) {
            if (self2.s.logger.isWarn()) {
              self2.s.logger.warn(f("no mongos proxies found in seed list, did you mean to connect to a replicaset"));
            }
            return self2.emit("error", new MongoError("no mongos proxies found in seed list"));
          }
          topologyMonitor(self2, {firstConnect: true});
        }
      };
    }
    function connectProxies(self2, servers) {
      self2.connectingProxies = self2.connectingProxies.concat(servers);
      var timeoutInterval = 0;
      function connect(server, timeoutInterval2) {
        setTimeout(function() {
          self2.emit("serverOpening", {
            topologyId: self2.id,
            address: server.name
          });
          emitTopologyDescriptionChanged(self2);
          server.once("close", handleInitialConnectEvent(self2, "close"));
          server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
          server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
          server.once("error", handleInitialConnectEvent(self2, "error"));
          server.once("connect", handleInitialConnectEvent(self2, "connect"));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          server.connect(self2.s.connectOptions);
        }, timeoutInterval2);
      }
      servers.forEach((server) => connect(server, timeoutInterval++));
    }
    function pickProxy(self2, session) {
      const transaction = session && session.transaction;
      if (transaction && transaction.server) {
        if (transaction.server.isConnected()) {
          return transaction.server;
        } else {
          transaction.unpinServer();
        }
      }
      var connectedProxies = self2.connectedProxies.slice(0);
      var lowerBoundLatency = Number.MAX_VALUE;
      for (var i = 0; i < connectedProxies.length; i++) {
        if (connectedProxies[i].lastIsMasterMS < lowerBoundLatency) {
          lowerBoundLatency = connectedProxies[i].lastIsMasterMS;
        }
      }
      connectedProxies = connectedProxies.filter(function(server) {
        if (server.lastIsMasterMS <= lowerBoundLatency + self2.s.localThresholdMS && server.isConnected()) {
          return true;
        }
      });
      let proxy;
      if (connectedProxies.length === 0) {
        proxy = self2.connectedProxies[0];
      } else {
        proxy = connectedProxies[self2.index % connectedProxies.length];
        self2.index = (self2.index + 1) % connectedProxies.length;
      }
      if (transaction && transaction.isActive && proxy && proxy.isConnected()) {
        transaction.pinServer(proxy);
      }
      return proxy;
    }
    function moveServerFrom(from, to, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name === proxy.name) {
          from.splice(i, 1);
        }
      }
      for (i = 0; i < to.length; i++) {
        if (to[i].name === proxy.name) {
          to.splice(i, 1);
        }
      }
      to.push(proxy);
    }
    function removeProxyFrom(from, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name === proxy.name) {
          from.splice(i, 1);
        }
      }
    }
    function reconnectProxies(self2, proxies, callback) {
      var count = proxies.length;
      var _handleEvent = function(self3, event) {
        return function() {
          var _self = this;
          count = count - 1;
          if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
            moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
            return this.destroy();
          }
          if (event === "connect") {
            if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
              moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
              return _self.destroy();
            }
            for (var i2 = 0; i2 < handlers2.length; i2++) {
              _self.removeAllListeners(handlers2[i2]);
            }
            _self.on("error", handleEvent(self3, "error"));
            _self.on("close", handleEvent(self3, "close"));
            _self.on("timeout", handleEvent(self3, "timeout"));
            _self.on("parseError", handleEvent(self3, "parseError"));
            moveServerFrom(self3.connectingProxies, self3.connectedProxies, _self);
            emitTopologyDescriptionChanged(self3);
            self3.emit("joined", "mongos", _self);
          } else {
            moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
            this.destroy();
          }
          if (count === 0) {
            callback();
          }
        };
      };
      if (count === 0) {
        return callback();
      }
      function execute(_server, i2) {
        setTimeout(function() {
          if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
            return;
          }
          var server = new Server(Object.assign({}, self2.s.options, {
            host: _server.name.split(":")[0],
            port: parseInt(_server.name.split(":")[1], 10),
            reconnect: false,
            monitoring: false,
            parent: self2
          }));
          destroyServer(_server, {force: true});
          removeProxyFrom(self2.disconnectedProxies, _server);
          relayEvents(server, self2, ["serverDescriptionChanged"]);
          self2.emit("serverOpening", {
            topologyId: server.s.topologyId !== -1 ? server.s.topologyId : self2.id,
            address: server.name
          });
          server.once("connect", _handleEvent(self2, "connect"));
          server.once("close", _handleEvent(self2, "close"));
          server.once("timeout", _handleEvent(self2, "timeout"));
          server.once("error", _handleEvent(self2, "error"));
          server.once("parseError", _handleEvent(self2, "parseError"));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          self2.connectingProxies.push(server);
          server.connect(self2.s.connectOptions);
        }, i2);
      }
      for (var i = 0; i < proxies.length; i++) {
        execute(proxies[i], i);
      }
    }
    function topologyMonitor(self2, options2) {
      options2 = options2 || {};
      if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
        return;
      }
      self2.haTimeoutId = setTimeout(function() {
        if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
          return;
        }
        if (self2.isConnected() && self2.s.disconnectHandler) {
          self2.s.disconnectHandler.execute();
        }
        var proxies = self2.connectedProxies.slice(0);
        var count = proxies.length;
        function pingServer(_self, _server, cb) {
          var start = new Date().getTime();
          emitSDAMEvent(self2, "serverHeartbeatStarted", {connectionId: _server.name});
          _server.command("admin.$cmd", {
            ismaster: true
          }, {
            monitoring: true,
            socketTimeout: self2.s.options.connectionTimeout || 2e3
          }, function(err, r) {
            if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
              moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
              _server.destroy();
              return cb(err, r);
            }
            var latencyMS = new Date().getTime() - start;
            if (err) {
              emitSDAMEvent(self2, "serverHeartbeatFailed", {
                durationMS: latencyMS,
                failure: err,
                connectionId: _server.name
              });
              moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
            } else {
              _server.ismaster = r.result;
              _server.lastIsMasterMS = latencyMS;
              emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
                durationMS: latencyMS,
                reply: r.result,
                connectionId: _server.name
              });
            }
            cb(err, r);
          });
        }
        if (proxies.length === 0) {
          if (self2.listeners("close").length > 0 && self2.state === CONNECTING) {
            self2.emit("error", new MongoError("no mongos proxy available"));
          } else {
            self2.emit("close", self2);
          }
          return reconnectProxies(self2, self2.disconnectedProxies, function() {
            if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
              return;
            }
            if (self2.state === CONNECTING && options2.firstConnect) {
              self2.emit("connect", self2);
              self2.emit("fullsetup", self2);
              self2.emit("all", self2);
            } else if (self2.isConnected()) {
              self2.emit("reconnect", self2);
            } else if (!self2.isConnected() && self2.listeners("close").length > 0) {
              self2.emit("close", self2);
            }
            topologyMonitor(self2);
          });
        }
        for (var i = 0; i < proxies.length; i++) {
          pingServer(self2, proxies[i], function() {
            count = count - 1;
            if (count === 0) {
              if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
                return;
              }
              reconnectProxies(self2, self2.disconnectedProxies, function() {
                if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
                  return;
                }
                topologyMonitor(self2);
              });
            }
          });
        }
      }, self2.s.haInterval);
    }
    Mongos.prototype.lastIsMaster = function() {
      return this.ismaster;
    };
    Mongos.prototype.unref = function() {
      stateTransition(this, UNREFERENCED);
      var proxies = this.connectedProxies.concat(this.connectingProxies);
      proxies.forEach(function(x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    Mongos.prototype.destroy = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      stateTransition(this, DESTROYING);
      if (this.haTimeoutId) {
        clearTimeout(this.haTimeoutId);
      }
      const proxies = this.connectedProxies.concat(this.connectingProxies);
      let serverCount = proxies.length;
      const serverDestroyed = () => {
        serverCount--;
        if (serverCount > 0) {
          return;
        }
        emitTopologyDescriptionChanged(this);
        emitSDAMEvent(this, "topologyClosed", {topologyId: this.id});
        stateTransition(this, DESTROYED);
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (serverCount === 0) {
        serverDestroyed();
        return;
      }
      proxies.forEach((server) => {
        this.emit("serverClosed", {
          topologyId: this.id,
          address: server.name
        });
        destroyServer(server, options2, serverDestroyed);
        moveServerFrom(this.connectedProxies, this.disconnectedProxies, server);
      });
    };
    Mongos.prototype.isConnected = function() {
      return this.connectedProxies.length > 0;
    };
    Mongos.prototype.isDestroyed = function() {
      return this.state === DESTROYED;
    };
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const self2 = args.self;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      let server = pickProxy(self2, options2.session);
      if (!server)
        return callback(new MongoError("no mongos proxy available"));
      const willRetryWrite = !args.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(self2) && !options2.session.inTransaction() && options2.explain === void 0;
      const handler = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2) || !willRetryWrite) {
          err = getMMAPError(err);
          return callback(err);
        }
        server = pickProxy(self2, options2.session);
        if (!server) {
          return callback(err);
        }
        const newArgs = Object.assign({}, args, {retrying: true});
        return executeWriteOperation(newArgs, options2, callback);
      };
      if (callback.operationId) {
        handler.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options2.session.incrementTransactionNumber();
        options2.willRetryWrite = willRetryWrite;
      }
      server[op](ns, ops, options2, handler);
    }
    Mongos.prototype.insert = function(ns, ops, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("insert", ns, ops, options2, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({self: this, op: "insert", ns, ops}, options2, callback);
    };
    Mongos.prototype.update = function(ns, ops, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("update", ns, ops, options2, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({self: this, op: "update", ns, ops}, options2, callback);
    };
    Mongos.prototype.remove = function(ns, ops, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("remove", ns, ops, options2, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({self: this, op: "remove", ns, ops}, options2, callback);
    };
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command2) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command2[op]);
    }
    Mongos.prototype.command = function(ns, cmd2, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      var self2 = this;
      var server = pickProxy(self2, options2.session);
      if ((server == null || !server.isConnected()) && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd2, options2, callback);
      }
      if (server == null) {
        return callback(new MongoError("no mongos proxy available"));
      }
      var clonedOptions = cloneOptions(options2);
      clonedOptions.topology = self2;
      const willRetryWrite = !options2.retrying && options2.retryWrites && options2.session && isRetryableWritesSupported(self2) && !options2.session.inTransaction() && isWriteCommand(cmd2);
      const cb = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          return callback(err);
        }
        if (willRetryWrite) {
          const newOptions = Object.assign({}, clonedOptions, {retrying: true});
          return this.command(ns, cmd2, newOptions, callback);
        }
        return callback(err);
      };
      if (willRetryWrite) {
        clonedOptions.session.incrementTransactionNumber();
        clonedOptions.willRetryWrite = willRetryWrite;
      }
      server.command(ns, cmd2, clonedOptions, cb);
    };
    Mongos.prototype.cursor = function(ns, cmd2, options2) {
      options2 = options2 || {};
      const topology = options2.topology || this;
      var FinalCursor = options2.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd2, options2);
    };
    Mongos.prototype.selectServer = function(selector, options2, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = selector, selector = void 0;
      options2 = options2 || {};
      const server = pickProxy(this, options2.session);
      if (server == null) {
        callback(new MongoError("server selection failed"));
        return;
      }
      if (this.s.debug)
        this.emit("pickedServer", null, server);
      callback(null, server);
    };
    Mongos.prototype.connections = function() {
      var connections = [];
      for (var i = 0; i < this.connectedProxies.length; i++) {
        connections = connections.concat(this.connectedProxies[i].connections());
      }
      return connections;
    };
    function emitTopologyDescriptionChanged(self2) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        var topology = "Unknown";
        if (self2.connectedProxies.length > 0) {
          topology = "Sharded";
        }
        var description = {
          topologyType: topology,
          servers: []
        };
        var proxies = self2.disconnectedProxies.concat(self2.connectingProxies);
        description.servers = description.servers.concat(proxies.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "Unknown";
          return description2;
        }));
        description.servers = description.servers.concat(self2.connectedProxies.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "Mongos";
          return description2;
        }));
        var diffResult = diff(self2.topologyDescription, description);
        var result = {
          topologyId: self2.id,
          previousDescription: self2.topologyDescription,
          newDescription: description,
          diff: diffResult
        };
        if (diffResult.servers.length > 0) {
          self2.emit("topologyDescriptionChanged", result);
        }
        self2.topologyDescription = description;
      }
    }
    module2.exports = Mongos;
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports2, module2) {
    "use strict";
    function Denque(array, options2) {
      var options2 = options2 || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options2.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    Denque.prototype.peekAt = function peekAt(index2) {
      var i = index2;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque.prototype.get = function get2(i) {
      return this.peekAt(i);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift2() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index2) {
      var i = index2;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index2 < size / 2) {
        for (k = index2; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index2; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove2(index2, count) {
      var i = index2;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index2 + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index2 === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index2 + count + len & this._capacityMask;
        for (k = index2; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index2 < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index2); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index2, count) {
      var i = index2;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array) {
      for (var i = 0; i < array.length; i++)
        this.push(array[i]);
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < len; i++)
          newArray.push(list[i]);
        for (i = 0; i < this._tail; i++)
          newArray.push(list[i]);
      } else {
        for (i = this._head; i < this._tail; i++)
          newArray.push(list[i]);
      }
      return newArray;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length *= 2;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module2.exports = Denque;
  }
});

// node_modules/mongodb/lib/core/sdam/events.js
var require_events = __commonJS({
  "node_modules/mongodb/lib/core/sdam/events.js"(exports2, module2) {
    "use strict";
    var ServerDescriptionChangedEvent = class {
      constructor(topologyId, address, previousDescription, newDescription) {
        Object.assign(this, {topologyId, address, previousDescription, newDescription});
      }
    };
    var ServerOpeningEvent = class {
      constructor(topologyId, address) {
        Object.assign(this, {topologyId, address});
      }
    };
    var ServerClosedEvent = class {
      constructor(topologyId, address) {
        Object.assign(this, {topologyId, address});
      }
    };
    var TopologyDescriptionChangedEvent = class {
      constructor(topologyId, previousDescription, newDescription) {
        Object.assign(this, {topologyId, previousDescription, newDescription});
      }
    };
    var TopologyOpeningEvent = class {
      constructor(topologyId) {
        Object.assign(this, {topologyId});
      }
    };
    var TopologyClosedEvent = class {
      constructor(topologyId) {
        Object.assign(this, {topologyId});
      }
    };
    var ServerHeartbeatStartedEvent = class {
      constructor(connectionId) {
        Object.assign(this, {connectionId});
      }
    };
    var ServerHeartbeatSucceededEvent = class {
      constructor(duration, reply, connectionId) {
        Object.assign(this, {connectionId, duration, reply});
      }
    };
    var ServerHeartbeatFailedEvent = class {
      constructor(duration, failure, connectionId) {
        Object.assign(this, {connectionId, duration, failure});
      }
    };
    module2.exports = {
      ServerDescriptionChangedEvent,
      ServerOpeningEvent,
      ServerClosedEvent,
      TopologyDescriptionChangedEvent,
      TopologyOpeningEvent,
      TopologyClosedEvent,
      ServerHeartbeatStartedEvent,
      ServerHeartbeatSucceededEvent,
      ServerHeartbeatFailedEvent
    };
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = {nextTick};
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/readable-stream/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive2;
    exports2.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer2().Buffer;
    var util = require("util");
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = {data: v, next: null};
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = {data: v, next: this.head};
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift2() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s2) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s2 + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({length: this.length});
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream2 = require_stream();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream2);
    function nop() {
    }
    function WritableState(options2, stream) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.writableObjectMode;
      var hwm = options2.highWaterMark;
      var writableHwm = options2.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options2.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options2) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options2);
      }
      this._writableState = new WritableState(options2, this);
      this.writable = true;
      if (options2) {
        if (typeof options2.write === "function")
          this._write = options2.write;
        if (typeof options2.writev === "function")
          this._writev = options2.writev;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
        if (typeof options2.final === "function")
          this._final = options2.final;
      }
      Stream2.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable2 = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable2);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options2) {
      if (!(this instanceof Duplex))
        return new Duplex(options2);
      Readable2.call(this, options2);
      Writable.call(this, options2);
      if (options2 && options2.readable === false)
        this.readable = false;
      if (options2 && options2.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options2 && options2.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable2;
    var isArray = require_isarray();
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream2 = require_stream();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable2, Stream2);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options2, stream) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.readableObjectMode;
      var hwm = options2.highWaterMark;
      var readableHwm = options2.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options2.encoding) {
        if (!StringDecoder)
          StringDecoder = require("string_decoder/").StringDecoder;
        this.decoder = new StringDecoder(options2.encoding);
        this.encoding = options2.encoding;
      }
    }
    function Readable2(options2) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable2))
        return new Readable2(options2);
      this._readableState = new ReadableState(options2, this);
      this.readable = true;
      if (options2) {
        if (typeof options2.read === "function")
          this._read = options2.read;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src2 = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src2.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src2) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src2);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src2.removeListener("end", onend);
        src2.removeListener("end", unpipe);
        src2.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src2.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src2._readableState.awaitDrain);
            src2._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src2.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src2.unpipe(dest);
      }
      dest.emit("pipe", src2);
      if (!state.flowing) {
        debug("pipe resume");
        src2.resume();
      }
      return dest;
    };
    function pipeOnDrain(src2) {
      return function() {
        var state = src2._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src2, "data")) {
          state.flowing = true;
          flow(src2);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {hasUnpiped: false};
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index2 = indexOf(state.pipes, dest);
      if (index2 === -1)
        return this;
      state.pipes.splice(index2, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options2) {
      if (!(this instanceof Transform))
        return new Transform(options2);
      Duplex.call(this, options2);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options2) {
        if (typeof options2.transform === "function")
          this._transform = options2.transform;
        if (typeof options2.flush === "function")
          this._flush = options2.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough2;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough2, Transform);
    function PassThrough2(options2) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options2);
      Transform.call(this, options2);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream2 = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream2) {
      module2.exports = Stream2;
      exports2 = module2.exports = Stream2.Readable;
      exports2.Readable = Stream2.Readable;
      exports2.Writable = Stream2.Writable;
      exports2.Duplex = Stream2.Duplex;
      exports2.Transform = Stream2.Transform;
      exports2.PassThrough = Stream2.PassThrough;
      exports2.Stream = Stream2;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream2 || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
    }
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports2, module2) {
    "use strict";
    var DuplexStream = require_readable().Duplex;
    var util = require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    function BufferList(callback) {
      if (!(this instanceof BufferList))
        return new BufferList(callback);
      this._bufs = [];
      this.length = 0;
      if (typeof callback == "function") {
        this._callback = callback;
        var piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src2) {
          src2.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src2) {
          src2.removeListener("error", piper);
        });
      } else {
        this.append(callback);
      }
      DuplexStream.call(this);
    }
    util.inherits(BufferList, DuplexStream);
    BufferList.prototype._offset = function _offset(offset) {
      var tot = 0, i = 0, _t;
      if (offset === 0)
        return [0, 0];
      for (; i < this._bufs.length; i++) {
        _t = tot + this._bufs[i].length;
        if (offset < _t || i == this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      var bufferId = blOffset[0];
      var offset = blOffset[1];
      for (var i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.append = function append(buf) {
      var i = 0;
      if (Buffer2.isBuffer(buf)) {
        this._appendBuffer(buf);
      } else if (Array.isArray(buf)) {
        for (; i < buf.length; i++)
          this.append(buf[i]);
      } else if (buf instanceof BufferList) {
        for (; i < buf._bufs.length; i++)
          this.append(buf._bufs[i]);
      } else if (buf != null) {
        if (typeof buf == "number")
          buf = buf.toString();
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback == "function")
        callback();
    };
    BufferList.prototype._read = function _read(size) {
      if (!this.length)
        return this.push(null);
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferList.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferList.prototype.get = function get2(index2) {
      if (index2 > this.length || index2 < 0) {
        return void 0;
      }
      var offset = this._offset(index2);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start == "number" && start < 0)
        start += this.length;
      if (typeof end == "number" && end < 0)
        end += this.length;
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart != "number" || srcStart < 0)
        srcStart = 0;
      if (typeof srcEnd != "number" || srcEnd > this.length)
        srcEnd = this.length;
      if (srcStart >= this.length)
        return dst || Buffer2.alloc(0);
      if (srcEnd <= 0)
        return dst || Buffer2.alloc(0);
      var copy2 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy2 && dstStart || 0, start = off[1], l, i;
      if (srcStart === 0 && srcEnd == this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2)
        dst = Buffer2.allocUnsafe(len);
      for (i = off[0]; i < this._bufs.length; i++) {
        l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start)
          start = 0;
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0)
        start += this.length;
      if (end < 0)
        end += this.length;
      if (start === end) {
        return new BufferList();
      }
      var startOffset = this._offset(start), endOffset = this._offset(end), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] == 0)
        buffers.pop();
      else
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      if (startOffset[1] != 0)
        buffers[0] = buffers[0].slice(startOffset[1]);
      return new BufferList(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      var i = 0, copy = new BufferList();
      for (; i < this._bufs.length; i++)
        copy.append(this._bufs[i]);
      return copy;
    };
    BufferList.prototype.destroy = function destroy() {
      this._bufs.length = 0;
      this.length = 0;
      this.push(null);
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (search instanceof BufferList) {
        search = search.slice();
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      var blOffset = this._offset(offset);
      var blIndex = blOffset[0];
      var buffOffset = blOffset[1];
      for (blIndex; blIndex < this._bufs.length; blIndex++) {
        var buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          var availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            var nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            var revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (var searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      var methods = {
        "readDoubleBE": 8,
        "readDoubleLE": 8,
        "readFloatBE": 4,
        "readFloatLE": 4,
        "readInt32BE": 4,
        "readInt32LE": 4,
        "readUInt32BE": 4,
        "readUInt32LE": 4,
        "readInt16BE": 2,
        "readInt16LE": 2,
        "readUInt16BE": 2,
        "readUInt16LE": 2,
        "readInt8": 1,
        "readUInt8": 1,
        "readIntBE": null,
        "readIntLE": null,
        "readUIntBE": null,
        "readUIntLE": null
      };
      for (var m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    module2.exports = BufferList;
  }
});

// node_modules/mongodb/lib/cmap/message_stream.js
var require_message_stream = __commonJS({
  "node_modules/mongodb/lib/cmap/message_stream.js"(exports2, module2) {
    "use strict";
    var Duplex = require("stream").Duplex;
    var BufferList = require_bl();
    var MongoParseError = require_error().MongoParseError;
    var decompress = require_compression().decompress;
    var Response3 = require_commands().Response;
    var BinMsg = require_msg().BinMsg;
    var MongoError = require_error().MongoError;
    var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
    var OP_MSG = require_shared().opcodes.OP_MSG;
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
    var opcodes = require_shared().opcodes;
    var compress = require_compression().compress;
    var compressorIDs = require_compression().compressorIDs;
    var uncompressibleCommands = require_compression().uncompressibleCommands;
    var Msg = require_msg().Msg;
    var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
    var kBuffer = Symbol("buffer");
    var MessageStream = class extends Duplex {
      constructor(options2) {
        options2 = options2 || {};
        super(options2);
        this.bson = options2.bson;
        this.maxBsonMessageSize = options2.maxBsonMessageSize || kDefaultMaxBsonMessageSize;
        this[kBuffer] = new BufferList();
      }
      _write(chunk, _, callback) {
        const buffer = this[kBuffer];
        buffer.append(chunk);
        processIncomingData(this, callback);
      }
      _read() {
        return;
      }
      writeCommand(command2, operationDescription) {
        const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;
        if (!shouldCompress || !canCompress(command2)) {
          const data = command2.toBin();
          this.push(Array.isArray(data) ? Buffer.concat(data) : data);
          return;
        }
        const concatenatedOriginalCommandBuffer = Buffer.concat(command2.toBin());
        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
        compress({options: operationDescription}, messageToBeCompressed, (err, compressedMessage) => {
          if (err) {
            operationDescription.cb(err, null);
            return;
          }
          const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
          msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
          msgHeader.writeInt32LE(command2.requestId, 4);
          msgHeader.writeInt32LE(0, 8);
          msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
          const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
          compressionDetails.writeInt32LE(originalCommandOpCode, 0);
          compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
          compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8);
          this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));
        });
      }
    };
    function canCompress(command2) {
      const commandDoc = command2 instanceof Msg ? command2.command : command2.query;
      const commandName = Object.keys(commandDoc)[0];
      return !uncompressibleCommands.has(commandName);
    }
    function processIncomingData(stream, callback) {
      const buffer = stream[kBuffer];
      if (buffer.length < 4) {
        callback();
        return;
      }
      const sizeOfMessage = buffer.readInt32LE(0);
      if (sizeOfMessage < 0) {
        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));
        return;
      }
      if (sizeOfMessage > stream.maxBsonMessageSize) {
        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));
        return;
      }
      if (sizeOfMessage > buffer.length) {
        callback();
        return;
      }
      const message = buffer.slice(0, sizeOfMessage);
      buffer.consume(sizeOfMessage);
      const messageHeader = {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
      let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response3;
      const responseOptions = stream.responseOptions;
      if (messageHeader.opCode !== OP_COMPRESSED) {
        const messageBody = message.slice(MESSAGE_HEADER_SIZE);
        stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
        if (buffer.length >= 4) {
          processIncomingData(stream, callback);
        } else {
          callback();
        }
        return;
      }
      messageHeader.fromCompressed = true;
      messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);
      messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);
      const compressorID = message[MESSAGE_HEADER_SIZE + 8];
      const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
      ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response3;
      decompress(compressorID, compressedBuffer, (err, messageBody) => {
        if (err) {
          callback(err);
          return;
        }
        if (messageBody.length !== messageHeader.length) {
          callback(new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
          return;
        }
        stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
        if (buffer.length >= 4) {
          processIncomingData(stream, callback);
        } else {
          callback();
        }
      });
    }
    module2.exports = MessageStream;
  }
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS({
  "node_modules/mongodb/lib/cmap/stream_description.js"(exports2, module2) {
    "use strict";
    var parseServerType = require_server_description().parseServerType;
    var RESPONSE_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "__nodejs_mock_server__"
    ];
    var StreamDescription = class {
      constructor(address, options2) {
        this.address = address;
        this.type = parseServerType(null);
        this.minWireVersion = void 0;
        this.maxWireVersion = void 0;
        this.maxBsonObjectSize = 16777216;
        this.maxMessageSizeBytes = 48e6;
        this.maxWriteBatchSize = 1e5;
        this.compressors = options2 && options2.compression && Array.isArray(options2.compression.compressors) ? options2.compression.compressors : [];
      }
      receiveResponse(response) {
        this.type = parseServerType(response);
        RESPONSE_FIELDS.forEach((field) => {
          if (typeof response[field] !== "undefined") {
            this[field] = response[field];
          }
        });
        if (response.compression) {
          this.compressor = this.compressors.filter((c) => response.compression.indexOf(c) !== -1)[0];
        }
      }
    };
    module2.exports = {
      StreamDescription
    };
  }
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection2 = __commonJS({
  "node_modules/mongodb/lib/cmap/connection.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var MessageStream = require_message_stream();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var CommandResult = require_command_result();
    var StreamDescription = require_stream_description().StreamDescription;
    var wp = require_wireprotocol();
    var apm = require_apm();
    var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
    var uuidV4 = require_utils2().uuidV4;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var kStream = Symbol("stream");
    var kQueue = Symbol("queue");
    var kMessageStream = Symbol("messageStream");
    var kGeneration = Symbol("generation");
    var kLastUseTime = Symbol("lastUseTime");
    var kClusterTime = Symbol("clusterTime");
    var kDescription = Symbol("description");
    var kIsMaster = Symbol("ismaster");
    var kAutoEncrypter = Symbol("autoEncrypter");
    var Connection = class extends EventEmitter {
      constructor(stream, options2) {
        super(options2);
        this.id = options2.id;
        this.address = streamIdentifier(stream);
        this.bson = options2.bson;
        this.socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
        this.host = options2.host || "localhost";
        this.port = options2.port || 27017;
        this.monitorCommands = typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false;
        this.closed = false;
        this.destroyed = false;
        this[kDescription] = new StreamDescription(this.address, options2);
        this[kGeneration] = options2.generation;
        this[kLastUseTime] = now();
        if (options2.autoEncrypter) {
          this[kAutoEncrypter] = options2.autoEncrypter;
        }
        this[kQueue] = new Map();
        this[kMessageStream] = new MessageStream(options2);
        this[kMessageStream].on("message", messageHandler(this));
        this[kStream] = stream;
        stream.on("error", () => {
        });
        this[kMessageStream].on("error", (error3) => this.handleIssue({destroy: error3}));
        stream.on("close", () => this.handleIssue({isClose: true}));
        stream.on("timeout", () => this.handleIssue({isTimeout: true, destroy: true}));
        stream.pipe(this[kMessageStream]);
        this[kMessageStream].pipe(stream);
      }
      get description() {
        return this[kDescription];
      }
      get ismaster() {
        return this[kIsMaster];
      }
      set ismaster(response) {
        this[kDescription].receiveResponse(response);
        this[kIsMaster] = response;
      }
      get generation() {
        return this[kGeneration] || 0;
      }
      get idleTime() {
        return calculateDurationInMs(this[kLastUseTime]);
      }
      get clusterTime() {
        return this[kClusterTime];
      }
      get stream() {
        return this[kStream];
      }
      markAvailable() {
        this[kLastUseTime] = now();
      }
      handleIssue(issue) {
        if (this.closed) {
          return;
        }
        if (issue.destroy) {
          this[kStream].destroy(typeof issue.destroy === "boolean" ? void 0 : issue.destroy);
        }
        this.closed = true;
        for (const idAndOp of this[kQueue]) {
          const op = idAndOp[1];
          if (issue.isTimeout) {
            op.cb(new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {
              beforeHandshake: this.ismaster == null
            }));
          } else if (issue.isClose) {
            op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`));
          } else {
            op.cb(typeof issue.destroy === "boolean" ? void 0 : issue.destroy);
          }
        }
        this[kQueue].clear();
        this.emit("close");
      }
      destroy(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = Object.assign({force: false}, options2);
        if (this[kStream] == null || this.destroyed) {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        if (options2.force) {
          this[kStream].destroy();
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        this[kStream].end((err) => {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback(err);
          }
        });
      }
      command(ns, cmd2, options2, callback) {
        wp.command(makeServerTrampoline(this), ns, cmd2, options2, callback);
      }
      query(ns, cmd2, cursorState, options2, callback) {
        wp.query(makeServerTrampoline(this), ns, cmd2, cursorState, options2, callback);
      }
      getMore(ns, cursorState, batchSize, options2, callback) {
        wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options2, callback);
      }
      killCursors(ns, cursorState, callback) {
        wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);
      }
      insert(ns, ops, options2, callback) {
        wp.insert(makeServerTrampoline(this), ns, ops, options2, callback);
      }
      update(ns, ops, options2, callback) {
        wp.update(makeServerTrampoline(this), ns, ops, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        wp.remove(makeServerTrampoline(this), ns, ops, options2, callback);
      }
    };
    function makeServerTrampoline(connection) {
      const server = {
        description: connection.description,
        clusterTime: connection[kClusterTime],
        s: {
          bson: connection.bson,
          pool: {write: write.bind(connection), isConnected: () => true}
        }
      };
      if (connection[kAutoEncrypter]) {
        server.autoEncrypter = connection[kAutoEncrypter];
      }
      return server;
    }
    function messageHandler(conn) {
      return function messageHandler2(message) {
        conn.emit("message", message);
        if (!conn[kQueue].has(message.responseTo)) {
          return;
        }
        const operationDescription = conn[kQueue].get(message.responseTo);
        const callback = operationDescription.cb;
        conn[kQueue].delete(message.responseTo);
        if (message.moreToCome) {
          conn[kQueue].set(message.requestId, operationDescription);
        } else if (operationDescription.socketTimeoutOverride) {
          conn[kStream].setTimeout(conn.socketTimeout);
        }
        try {
          message.parse(operationDescription);
        } catch (err) {
          callback(new MongoError(err));
          return;
        }
        if (message.documents[0]) {
          const document2 = message.documents[0];
          const session = operationDescription.session;
          if (session) {
            updateSessionFromResponse(session, document2);
          }
          if (document2.$clusterTime) {
            conn[kClusterTime] = document2.$clusterTime;
            conn.emit("clusterTimeReceived", document2.$clusterTime);
          }
          if (operationDescription.command) {
            if (document2.writeConcernError) {
              callback(new MongoWriteConcernError(document2.writeConcernError, document2));
              return;
            }
            if (document2.ok === 0 || document2.$err || document2.errmsg || document2.code) {
              callback(new MongoError(document2));
              return;
            }
          }
        }
        callback(void 0, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));
      };
    }
    function streamIdentifier(stream) {
      if (typeof stream.address === "function") {
        return `${stream.remoteAddress}:${stream.remotePort}`;
      }
      return uuidV4().toString("hex");
    }
    function write(command2, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
      }
      options2 = options2 || {};
      const operationDescription = {
        requestId: command2.requestId,
        cb: callback,
        session: options2.session,
        fullResult: typeof options2.fullResult === "boolean" ? options2.fullResult : false,
        noResponse: typeof options2.noResponse === "boolean" ? options2.noResponse : false,
        documentsReturnedIn: options2.documentsReturnedIn,
        command: !!options2.command,
        promoteLongs: typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true,
        promoteValues: typeof options2.promoteValues === "boolean" ? options2.promoteValues : true,
        promoteBuffers: typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false,
        raw: typeof options2.raw === "boolean" ? options2.raw : false
      };
      if (this[kDescription] && this[kDescription].compressor) {
        operationDescription.agreedCompressor = this[kDescription].compressor;
        if (this[kDescription].zlibCompressionLevel) {
          operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;
        }
      }
      if (typeof options2.socketTimeout === "number") {
        operationDescription.socketTimeoutOverride = true;
        this[kStream].setTimeout(options2.socketTimeout);
      }
      if (this.monitorCommands) {
        this.emit("commandStarted", new apm.CommandStartedEvent(this, command2));
        operationDescription.started = now();
        operationDescription.cb = (err, reply) => {
          if (err) {
            this.emit("commandFailed", new apm.CommandFailedEvent(this, command2, err, operationDescription.started));
          } else {
            if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
              this.emit("commandFailed", new apm.CommandFailedEvent(this, command2, reply.result, operationDescription.started));
            } else {
              this.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command2, reply, operationDescription.started));
            }
          }
          if (typeof callback === "function") {
            callback(err, reply);
          }
        };
      }
      if (!operationDescription.noResponse) {
        this[kQueue].set(operationDescription.requestId, operationDescription);
      }
      try {
        this[kMessageStream].writeCommand(command2, operationDescription);
      } catch (e) {
        if (!operationDescription.noResponse) {
          this[kQueue].delete(operationDescription.requestId);
          operationDescription.cb(e);
          return;
        }
      }
      if (operationDescription.noResponse) {
        operationDescription.cb();
      }
    }
    module2.exports = {
      Connection
    };
  }
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors = __commonJS({
  "node_modules/mongodb/lib/cmap/errors.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var PoolClosedError = class extends MongoError {
      constructor(pool) {
        super("Attempted to check out a connection from closed connection pool");
        this.name = "MongoPoolClosedError";
        this.address = pool.address;
      }
    };
    var WaitQueueTimeoutError = class extends MongoError {
      constructor(pool) {
        super("Timed out while checking out a connection from connection pool");
        this.name = "MongoWaitQueueTimeoutError";
        this.address = pool.address;
      }
    };
    module2.exports = {
      PoolClosedError,
      WaitQueueTimeoutError
    };
  }
});

// node_modules/mongodb/lib/cmap/events.js
var require_events2 = __commonJS({
  "node_modules/mongodb/lib/cmap/events.js"(exports2, module2) {
    "use strict";
    var ConnectionPoolMonitoringEvent = class {
      constructor(pool) {
        this.time = new Date();
        this.address = pool.address;
      }
    };
    var ConnectionPoolCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
        this.options = pool.options;
      }
    };
    var ConnectionPoolClosedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var ConnectionCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionReadyEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionClosedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection, reason) {
        super(pool);
        this.connectionId = connection.id;
        this.reason = reason || "unknown";
      }
    };
    var ConnectionCheckOutStartedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var ConnectionCheckOutFailedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, reason) {
        super(pool);
        this.reason = reason;
      }
    };
    var ConnectionCheckedOutEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionCheckedInEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionPoolClearedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var CMAP_EVENT_NAMES = [
      "connectionPoolCreated",
      "connectionPoolClosed",
      "connectionCreated",
      "connectionReady",
      "connectionClosed",
      "connectionCheckOutStarted",
      "connectionCheckOutFailed",
      "connectionCheckedOut",
      "connectionCheckedIn",
      "connectionPoolCleared"
    ];
    module2.exports = {
      CMAP_EVENT_NAMES,
      ConnectionPoolCreatedEvent,
      ConnectionPoolClosedEvent,
      ConnectionCreatedEvent,
      ConnectionReadyEvent,
      ConnectionClosedEvent,
      ConnectionCheckOutStartedEvent,
      ConnectionCheckOutFailedEvent,
      ConnectionCheckedOutEvent,
      ConnectionCheckedInEvent,
      ConnectionPoolClearedEvent
    };
  }
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS({
  "node_modules/mongodb/lib/cmap/connection_pool.js"(exports2, module2) {
    "use strict";
    var Denque = require_denque();
    var EventEmitter = require("events").EventEmitter;
    var Logger = require_logger();
    var makeCounter = require_utils4().makeCounter;
    var MongoError = require_error().MongoError;
    var Connection = require_connection2().Connection;
    var eachAsync = require_utils2().eachAsync;
    var connect = require_connect();
    var relayEvents = require_utils2().relayEvents;
    var errors = require_errors();
    var PoolClosedError = errors.PoolClosedError;
    var WaitQueueTimeoutError = errors.WaitQueueTimeoutError;
    var events = require_events2();
    var ConnectionPoolCreatedEvent = events.ConnectionPoolCreatedEvent;
    var ConnectionPoolClosedEvent = events.ConnectionPoolClosedEvent;
    var ConnectionCreatedEvent = events.ConnectionCreatedEvent;
    var ConnectionReadyEvent = events.ConnectionReadyEvent;
    var ConnectionClosedEvent = events.ConnectionClosedEvent;
    var ConnectionCheckOutStartedEvent = events.ConnectionCheckOutStartedEvent;
    var ConnectionCheckOutFailedEvent = events.ConnectionCheckOutFailedEvent;
    var ConnectionCheckedOutEvent = events.ConnectionCheckedOutEvent;
    var ConnectionCheckedInEvent = events.ConnectionCheckedInEvent;
    var ConnectionPoolClearedEvent = events.ConnectionPoolClearedEvent;
    var kLogger = Symbol("logger");
    var kConnections = Symbol("connections");
    var kPermits = Symbol("permits");
    var kMinPoolSizeTimer = Symbol("minPoolSizeTimer");
    var kGeneration = Symbol("generation");
    var kConnectionCounter = Symbol("connectionCounter");
    var kCancellationToken = Symbol("cancellationToken");
    var kWaitQueue = Symbol("waitQueue");
    var kCancelled = Symbol("cancelled");
    var VALID_POOL_OPTIONS = new Set([
      "ssl",
      "bson",
      "connectionType",
      "monitorCommands",
      "socketTimeout",
      "credentials",
      "compression",
      "host",
      "port",
      "localAddress",
      "localPort",
      "family",
      "hints",
      "lookup",
      "path",
      "ca",
      "cert",
      "sigalgs",
      "ciphers",
      "clientCertEngine",
      "crl",
      "dhparam",
      "ecdhCurve",
      "honorCipherOrder",
      "key",
      "privateKeyEngine",
      "privateKeyIdentifier",
      "maxVersion",
      "minVersion",
      "passphrase",
      "pfx",
      "secureOptions",
      "secureProtocol",
      "sessionIdContext",
      "allowHalfOpen",
      "rejectUnauthorized",
      "pskCallback",
      "ALPNProtocols",
      "servername",
      "checkServerIdentity",
      "session",
      "minDHSize",
      "secureContext",
      "maxPoolSize",
      "minPoolSize",
      "maxIdleTimeMS",
      "waitQueueTimeoutMS"
    ]);
    function resolveOptions(options2, defaults3) {
      const newOptions = Array.from(VALID_POOL_OPTIONS).reduce((obj, key) => {
        if (Object.prototype.hasOwnProperty.call(options2, key)) {
          obj[key] = options2[key];
        }
        return obj;
      }, {});
      return Object.freeze(Object.assign({}, defaults3, newOptions));
    }
    var ConnectionPool = class extends EventEmitter {
      constructor(options2) {
        super();
        options2 = options2 || {};
        this.closed = false;
        this.options = resolveOptions(options2, {
          connectionType: Connection,
          maxPoolSize: typeof options2.maxPoolSize === "number" ? options2.maxPoolSize : 100,
          minPoolSize: typeof options2.minPoolSize === "number" ? options2.minPoolSize : 0,
          maxIdleTimeMS: typeof options2.maxIdleTimeMS === "number" ? options2.maxIdleTimeMS : 0,
          waitQueueTimeoutMS: typeof options2.waitQueueTimeoutMS === "number" ? options2.waitQueueTimeoutMS : 0,
          autoEncrypter: options2.autoEncrypter,
          metadata: options2.metadata
        });
        if (options2.minSize > options2.maxSize) {
          throw new TypeError("Connection pool minimum size must not be greater than maxiumum pool size");
        }
        this[kLogger] = Logger("ConnectionPool", options2);
        this[kConnections] = new Denque();
        this[kPermits] = this.options.maxPoolSize;
        this[kMinPoolSizeTimer] = void 0;
        this[kGeneration] = 0;
        this[kConnectionCounter] = makeCounter(1);
        this[kCancellationToken] = new EventEmitter();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kWaitQueue] = new Denque();
        process.nextTick(() => {
          this.emit("connectionPoolCreated", new ConnectionPoolCreatedEvent(this));
          ensureMinPoolSize(this);
        });
      }
      get address() {
        return `${this.options.host}:${this.options.port}`;
      }
      get generation() {
        return this[kGeneration];
      }
      get totalConnectionCount() {
        return this[kConnections].length + (this.options.maxPoolSize - this[kPermits]);
      }
      get availableConnectionCount() {
        return this[kConnections].length;
      }
      get waitQueueSize() {
        return this[kWaitQueue].length;
      }
      checkOut(callback) {
        this.emit("connectionCheckOutStarted", new ConnectionCheckOutStartedEvent(this));
        if (this.closed) {
          this.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(this, "poolClosed"));
          callback(new PoolClosedError(this));
          return;
        }
        const waitQueueMember = {callback};
        const pool = this;
        const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;
        if (waitQueueTimeoutMS) {
          waitQueueMember.timer = setTimeout(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, "timeout"));
            waitQueueMember.callback(new WaitQueueTimeoutError(pool));
          }, waitQueueTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        process.nextTick(() => processWaitQueue(this));
      }
      checkIn(connection) {
        const poolClosed = this.closed;
        const stale = connectionIsStale(this, connection);
        const willDestroy = !!(poolClosed || stale || connection.closed);
        if (!willDestroy) {
          connection.markAvailable();
          this[kConnections].push(connection);
        }
        this.emit("connectionCheckedIn", new ConnectionCheckedInEvent(this, connection));
        if (willDestroy) {
          const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
          destroyConnection(this, connection, reason);
        }
        process.nextTick(() => processWaitQueue(this));
      }
      clear() {
        this[kGeneration] += 1;
        this.emit("connectionPoolCleared", new ConnectionPoolClearedEvent(this));
      }
      close(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
        }
        options2 = Object.assign({force: false}, options2);
        if (this.closed) {
          return callback();
        }
        this[kCancellationToken].emit("cancel");
        while (this.waitQueueSize) {
          const waitQueueMember = this[kWaitQueue].pop();
          clearTimeout(waitQueueMember.timer);
          if (!waitQueueMember[kCancelled]) {
            waitQueueMember.callback(new MongoError("connection pool closed"));
          }
        }
        if (this[kMinPoolSizeTimer]) {
          clearTimeout(this[kMinPoolSizeTimer]);
        }
        if (typeof this[kConnectionCounter].return === "function") {
          this[kConnectionCounter].return();
        }
        this.closed = true;
        eachAsync(this[kConnections].toArray(), (conn, cb) => {
          this.emit("connectionClosed", new ConnectionClosedEvent(this, conn, "poolClosed"));
          conn.destroy(options2, cb);
        }, (err) => {
          this[kConnections].clear();
          this.emit("connectionPoolClosed", new ConnectionPoolClosedEvent(this));
          callback(err);
        });
      }
      withConnection(fn, callback) {
        this.checkOut((err, conn) => {
          fn(err, conn, (fnErr, result) => {
            if (typeof callback === "function") {
              if (fnErr) {
                callback(fnErr);
              } else {
                callback(void 0, result);
              }
            }
            if (conn) {
              this.checkIn(conn);
            }
          });
        });
      }
    };
    function ensureMinPoolSize(pool) {
      if (pool.closed || pool.options.minPoolSize === 0) {
        return;
      }
      const minPoolSize = pool.options.minPoolSize;
      for (let i = pool.totalConnectionCount; i < minPoolSize; ++i) {
        createConnection(pool);
      }
      pool[kMinPoolSizeTimer] = setTimeout(() => ensureMinPoolSize(pool), 10);
    }
    function connectionIsStale(pool, connection) {
      return connection.generation !== pool[kGeneration];
    }
    function connectionIsIdle(pool, connection) {
      return !!(pool.options.maxIdleTimeMS && connection.idleTime > pool.options.maxIdleTimeMS);
    }
    function createConnection(pool, callback) {
      const connectOptions = Object.assign({
        id: pool[kConnectionCounter].next().value,
        generation: pool[kGeneration]
      }, pool.options);
      pool[kPermits]--;
      connect(connectOptions, pool[kCancellationToken], (err, connection) => {
        if (err) {
          pool[kPermits]++;
          pool[kLogger].debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        if (pool.closed) {
          connection.destroy({force: true});
          return;
        }
        relayEvents(connection, pool, [
          "commandStarted",
          "commandFailed",
          "commandSucceeded",
          "clusterTimeReceived"
        ]);
        pool.emit("connectionCreated", new ConnectionCreatedEvent(pool, connection));
        connection.markAvailable();
        pool.emit("connectionReady", new ConnectionReadyEvent(pool, connection));
        if (typeof callback === "function") {
          callback(void 0, connection);
          return;
        }
        pool[kConnections].push(connection);
        process.nextTick(() => processWaitQueue(pool));
      });
    }
    function destroyConnection(pool, connection, reason) {
      pool.emit("connectionClosed", new ConnectionClosedEvent(pool, connection, reason));
      pool[kPermits]++;
      process.nextTick(() => connection.destroy());
    }
    function processWaitQueue(pool) {
      if (pool.closed) {
        return;
      }
      while (pool.waitQueueSize) {
        const waitQueueMember = pool[kWaitQueue].peekFront();
        if (waitQueueMember[kCancelled]) {
          pool[kWaitQueue].shift();
          continue;
        }
        if (!pool.availableConnectionCount) {
          break;
        }
        const connection = pool[kConnections].shift();
        const isStale = connectionIsStale(pool, connection);
        const isIdle = connectionIsIdle(pool, connection);
        if (!isStale && !isIdle && !connection.closed) {
          pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
          clearTimeout(waitQueueMember.timer);
          pool[kWaitQueue].shift();
          waitQueueMember.callback(void 0, connection);
          return;
        }
        const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
        destroyConnection(pool, connection, reason);
      }
      const maxPoolSize = pool.options.maxPoolSize;
      if (pool.waitQueueSize && (maxPoolSize <= 0 || pool.totalConnectionCount < maxPoolSize)) {
        createConnection(pool, (err, connection) => {
          const waitQueueMember = pool[kWaitQueue].shift();
          if (waitQueueMember == null || waitQueueMember[kCancelled]) {
            if (err == null) {
              pool[kConnections].push(connection);
            }
            return;
          }
          if (err) {
            pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, err));
          } else {
            pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
          }
          clearTimeout(waitQueueMember.timer);
          waitQueueMember.callback(err, connection);
        });
        return;
      }
    }
    module2.exports = {
      ConnectionPool
    };
  }
});

// node_modules/mongodb/lib/core/sdam/monitor.js
var require_monitor = __commonJS({
  "node_modules/mongodb/lib/core/sdam/monitor.js"(exports2, module2) {
    "use strict";
    var ServerType = require_common().ServerType;
    var EventEmitter = require("events");
    var connect = require_connect();
    var Connection = require_connection2().Connection;
    var common = require_common();
    var makeStateMachine = require_utils2().makeStateMachine;
    var MongoNetworkError = require_error().MongoNetworkError;
    var BSON2 = require_utils3().retrieveBSON();
    var makeInterruptableAsyncInterval = require_utils4().makeInterruptableAsyncInterval;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var now = require_utils4().now;
    var sdamEvents = require_events();
    var ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;
    var ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;
    var ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;
    var kServer = Symbol("server");
    var kMonitorId = Symbol("monitorId");
    var kConnection = Symbol("connection");
    var kCancellationToken = Symbol("cancellationToken");
    var kRTTPinger = Symbol("rttPinger");
    var kRoundTripTime = Symbol("roundTripTime");
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_IDLE = "idle";
    var STATE_MONITORING = "monitoring";
    var stateTransition = makeStateMachine({
      [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],
      [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],
      [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],
      [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]
    });
    var INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);
    function isInCloseState(monitor) {
      return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;
    }
    var Monitor = class extends EventEmitter {
      constructor(server, options2) {
        super(options2);
        this[kServer] = server;
        this[kConnection] = void 0;
        this[kCancellationToken] = new EventEmitter();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kMonitorId] = null;
        this.s = {
          state: STATE_CLOSED
        };
        this.address = server.description.address;
        this.options = Object.freeze({
          connectTimeoutMS: typeof options2.connectionTimeout === "number" ? options2.connectionTimeout : typeof options2.connectTimeoutMS === "number" ? options2.connectTimeoutMS : 1e4,
          heartbeatFrequencyMS: typeof options2.heartbeatFrequencyMS === "number" ? options2.heartbeatFrequencyMS : 1e4,
          minHeartbeatFrequencyMS: typeof options2.minHeartbeatFrequencyMS === "number" ? options2.minHeartbeatFrequencyMS : 500
        });
        const connectOptions = Object.assign({
          id: "<monitor>",
          host: server.description.host,
          port: server.description.port,
          bson: server.s.bson,
          connectionType: Connection
        }, server.s.options, this.options, {
          raw: false,
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: true
        });
        delete connectOptions.credentials;
        delete connectOptions.autoEncrypter;
        this.connectOptions = Object.freeze(connectOptions);
      }
      connect() {
        if (this.s.state !== STATE_CLOSED) {
          return;
        }
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
          interval: heartbeatFrequencyMS,
          minInterval: minHeartbeatFrequencyMS,
          immediate: true
        });
      }
      requestCheck() {
        if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
          return;
        }
        this[kMonitorId].wake();
      }
      reset() {
        const topologyVersion = this[kServer].description.topologyVersion;
        if (isInCloseState(this) || topologyVersion == null) {
          return;
        }
        stateTransition(this, STATE_CLOSING);
        resetMonitorState(this);
        stateTransition(this, STATE_IDLE);
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
          interval: heartbeatFrequencyMS,
          minInterval: minHeartbeatFrequencyMS
        });
      }
      close() {
        if (isInCloseState(this)) {
          return;
        }
        stateTransition(this, STATE_CLOSING);
        resetMonitorState(this);
        this.emit("close");
        stateTransition(this, STATE_CLOSED);
      }
    };
    function resetMonitorState(monitor) {
      if (monitor[kMonitorId]) {
        monitor[kMonitorId].stop();
        monitor[kMonitorId] = null;
      }
      if (monitor[kRTTPinger]) {
        monitor[kRTTPinger].close();
        monitor[kRTTPinger] = void 0;
      }
      monitor[kCancellationToken].emit("cancel");
      if (monitor[kMonitorId]) {
        clearTimeout(monitor[kMonitorId]);
        monitor[kMonitorId] = void 0;
      }
      if (monitor[kConnection]) {
        monitor[kConnection].destroy({force: true});
      }
    }
    function checkServer(monitor, callback) {
      let start = now();
      monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
      function failureHandler(err) {
        if (monitor[kConnection]) {
          monitor[kConnection].destroy({force: true});
          monitor[kConnection] = void 0;
        }
        monitor.emit("serverHeartbeatFailed", new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));
        monitor.emit("resetServer", err);
        monitor.emit("resetConnectionPool");
        callback(err);
      }
      if (monitor[kConnection] != null && !monitor[kConnection].closed) {
        const connectTimeoutMS = monitor.options.connectTimeoutMS;
        const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
        const topologyVersion = monitor[kServer].description.topologyVersion;
        const isAwaitable = topologyVersion != null;
        const cmd2 = {ismaster: true};
        const options2 = {socketTimeout: connectTimeoutMS};
        if (isAwaitable) {
          cmd2.maxAwaitTimeMS = maxAwaitTimeMS;
          cmd2.topologyVersion = makeTopologyVersion(topologyVersion);
          if (connectTimeoutMS) {
            options2.socketTimeout = connectTimeoutMS + maxAwaitTimeMS;
          }
          options2.exhaustAllowed = true;
          if (monitor[kRTTPinger] == null) {
            monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);
          }
        }
        monitor[kConnection].command("admin.$cmd", cmd2, options2, (err, result) => {
          if (err) {
            failureHandler(err);
            return;
          }
          const isMaster = result.result;
          const rttPinger = monitor[kRTTPinger];
          const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);
          monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address));
          if (isAwaitable && isMaster.topologyVersion) {
            monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
            start = now();
          } else {
            if (monitor[kRTTPinger]) {
              monitor[kRTTPinger].close();
              monitor[kRTTPinger] = void 0;
            }
            callback(void 0, isMaster);
          }
        });
        return;
      }
      connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {
        if (conn && isInCloseState(monitor)) {
          conn.destroy({force: true});
          return;
        }
        if (err) {
          monitor[kConnection] = void 0;
          if (!(err instanceof MongoNetworkError)) {
            monitor.emit("resetConnectionPool");
          }
          failureHandler(err);
          return;
        }
        monitor[kConnection] = conn;
        monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), conn.ismaster, monitor.address));
        callback(void 0, conn.ismaster);
      });
    }
    function monitorServer(monitor) {
      return (callback) => {
        stateTransition(monitor, STATE_MONITORING);
        function done() {
          if (!isInCloseState(monitor)) {
            stateTransition(monitor, STATE_IDLE);
          }
          callback();
        }
        process.nextTick(() => monitor.emit("monitoring", monitor[kServer]));
        checkServer(monitor, (err, isMaster) => {
          if (err) {
            if (monitor[kServer].description.type === ServerType.Unknown) {
              monitor.emit("resetServer", err);
              return done();
            }
          }
          if (isMaster && isMaster.topologyVersion) {
            setTimeout(() => {
              if (!isInCloseState(monitor)) {
                monitor[kMonitorId].wake();
              }
            });
          }
          done();
        });
      };
    }
    function makeTopologyVersion(tv) {
      return {
        processId: tv.processId,
        counter: BSON2.Long.fromNumber(tv.counter)
      };
    }
    var RTTPinger = class {
      constructor(cancellationToken, options2) {
        this[kConnection] = null;
        this[kCancellationToken] = cancellationToken;
        this[kRoundTripTime] = 0;
        this.closed = false;
        const heartbeatFrequencyMS = options2.heartbeatFrequencyMS;
        this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options2), heartbeatFrequencyMS);
      }
      get roundTripTime() {
        return this[kRoundTripTime];
      }
      close() {
        this.closed = true;
        clearTimeout(this[kMonitorId]);
        this[kMonitorId] = void 0;
        if (this[kConnection]) {
          this[kConnection].destroy({force: true});
        }
      }
    };
    function measureRoundTripTime(rttPinger, options2) {
      const start = now();
      const cancellationToken = rttPinger[kCancellationToken];
      const heartbeatFrequencyMS = options2.heartbeatFrequencyMS;
      if (rttPinger.closed) {
        return;
      }
      function measureAndReschedule(conn) {
        if (rttPinger.closed) {
          conn.destroy({force: true});
          return;
        }
        if (rttPinger[kConnection] == null) {
          rttPinger[kConnection] = conn;
        }
        rttPinger[kRoundTripTime] = calculateDurationInMs(start);
        rttPinger[kMonitorId] = setTimeout(() => measureRoundTripTime(rttPinger, options2), heartbeatFrequencyMS);
      }
      if (rttPinger[kConnection] == null) {
        connect(options2, cancellationToken, (err, conn) => {
          if (err) {
            rttPinger[kConnection] = void 0;
            rttPinger[kRoundTripTime] = 0;
            return;
          }
          measureAndReschedule(conn);
        });
        return;
      }
      rttPinger[kConnection].command("admin.$cmd", {ismaster: 1}, (err) => {
        if (err) {
          rttPinger[kConnection] = void 0;
          rttPinger[kRoundTripTime] = 0;
          return;
        }
        measureAndReschedule();
      });
    }
    module2.exports = {
      Monitor
    };
  }
});

// node_modules/mongodb/lib/core/sdam/server.js
var require_server2 = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var ConnectionPool = require_connection_pool().ConnectionPool;
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var MongoError = require_error().MongoError;
    var relayEvents = require_utils2().relayEvents;
    var BSON2 = require_utils3().retrieveBSON();
    var Logger = require_logger();
    var ServerDescription = require_server_description().ServerDescription;
    var compareTopologyVersion = require_server_description().compareTopologyVersion;
    var ReadPreference = require_read_preference();
    var Monitor = require_monitor().Monitor;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var collationNotSupported = require_utils2().collationNotSupported;
    var debugOptions = require_utils3().debugOptions;
    var isSDAMUnrecoverableError = require_error().isSDAMUnrecoverableError;
    var isRetryableWriteError = require_error().isRetryableWriteError;
    var isNodeShuttingDownError = require_error().isNodeShuttingDownError;
    var isNetworkErrorBeforeHandshake = require_error().isNetworkErrorBeforeHandshake;
    var maxWireVersion = require_utils2().maxWireVersion;
    var makeStateMachine = require_utils2().makeStateMachine;
    var common = require_common();
    var ServerType = common.ServerType;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var DEBUG_FIELDS = [
      "reconnect",
      "reconnectTries",
      "reconnectInterval",
      "emitError",
      "cursorFactory",
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "checkServerIdentity",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "key",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "servername"
    ];
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CONNECTING = common.STATE_CONNECTING;
    var STATE_CONNECTED = common.STATE_CONNECTED;
    var stateTransition = makeStateMachine({
      [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
      [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
      [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
      [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
    });
    var kMonitor = Symbol("monitor");
    var Server = class extends EventEmitter {
      constructor(description, options2, topology) {
        super();
        this.s = {
          description,
          options: options2,
          logger: Logger("Server", options2),
          bson: options2.bson || new BSON2([
            BSON2.Binary,
            BSON2.Code,
            BSON2.DBRef,
            BSON2.Decimal128,
            BSON2.Double,
            BSON2.Int32,
            BSON2.Long,
            BSON2.Map,
            BSON2.MaxKey,
            BSON2.MinKey,
            BSON2.ObjectId,
            BSON2.BSONRegExp,
            BSON2.Symbol,
            BSON2.Timestamp
          ]),
          state: STATE_CLOSED,
          credentials: options2.credentials,
          topology
        };
        const poolOptions = Object.assign({host: this.description.host, port: this.description.port, bson: this.s.bson}, options2);
        this.s.pool = new ConnectionPool(poolOptions);
        relayEvents(this.s.pool, this, ["commandStarted", "commandSucceeded", "commandFailed"].concat(CMAP_EVENT_NAMES));
        this.s.pool.on("clusterTimeReceived", (clusterTime) => {
          this.clusterTime = clusterTime;
        });
        this[kMonitor] = new Monitor(this, this.s.options);
        relayEvents(this[kMonitor], this, [
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "monitoring"
        ]);
        this[kMonitor].on("resetConnectionPool", () => {
          this.s.pool.clear();
        });
        this[kMonitor].on("resetServer", (error3) => markServerUnknown(this, error3));
        this[kMonitor].on("serverHeartbeatSucceeded", (event) => {
          this.emit("descriptionReceived", new ServerDescription(this.description.address, event.reply, {
            roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)
          }));
          if (this.s.state === STATE_CONNECTING) {
            stateTransition(this, STATE_CONNECTED);
            this.emit("connect", this);
          }
        });
      }
      get description() {
        return this.s.description;
      }
      get name() {
        return this.s.description.address;
      }
      get autoEncrypter() {
        if (this.s.options && this.s.options.autoEncrypter) {
          return this.s.options.autoEncrypter;
        }
        return null;
      }
      connect() {
        if (this.s.state !== STATE_CLOSED) {
          return;
        }
        stateTransition(this, STATE_CONNECTING);
        this[kMonitor].connect();
      }
      destroy(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = Object.assign({}, {force: false}, options2);
        if (this.s.state === STATE_CLOSED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CLOSING);
        this[kMonitor].close();
        this.s.pool.close(options2, (err) => {
          stateTransition(this, STATE_CLOSED);
          this.emit("closed");
          if (typeof callback === "function") {
            callback(err);
          }
        });
      }
      requestCheck() {
        this[kMonitor].requestCheck();
      }
      command(ns, cmd2, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2, options2 = {}, options2 = options2 || {};
        }
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        const error3 = basicReadValidations(this, options2);
        if (error3) {
          return callback(error3);
        }
        options2 = Object.assign({}, options2, {wireProtocolCommand: false});
        if (this.s.logger.isDebug()) {
          this.s.logger.debug(`executing command [${JSON.stringify({
            ns,
            cmd: cmd2,
            options: debugOptions(DEBUG_FIELDS, options2)
          })}] against ${this.name}`);
        }
        if (collationNotSupported(this, cmd2)) {
          callback(new MongoError(`server ${this.name} does not support collation`));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.command(ns, cmd2, options2, makeOperationHandler(this, conn, cmd2, options2, cb));
        }, callback);
      }
      query(ns, cmd2, cursorState, options2, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.query(ns, cmd2, cursorState, options2, makeOperationHandler(this, conn, cmd2, options2, cb));
        }, callback);
      }
      getMore(ns, cursorState, batchSize, options2, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.getMore(ns, cursorState, batchSize, options2, makeOperationHandler(this, conn, null, options2, cb));
        }, callback);
      }
      killCursors(ns, cursorState, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          if (typeof callback === "function") {
            callback(new MongoError("server is closed"));
          }
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.killCursors(ns, cursorState, makeOperationHandler(this, conn, null, void 0, cb));
        }, callback);
      }
      insert(ns, ops, options2, callback) {
        executeWriteOperation({server: this, op: "insert", ns, ops}, options2, callback);
      }
      update(ns, ops, options2, callback) {
        executeWriteOperation({server: this, op: "update", ns, ops}, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        executeWriteOperation({server: this, op: "remove", ns, ops}, options2, callback);
      }
    };
    Object.defineProperty(Server.prototype, "clusterTime", {
      get: function() {
        return this.s.topology.clusterTime;
      },
      set: function(clusterTime) {
        this.s.topology.clusterTime = clusterTime;
      }
    });
    function supportsRetryableWrites(server) {
      return server.description.maxWireVersion >= 6 && server.description.logicalSessionTimeoutMinutes && server.description.type !== ServerType.Standalone;
    }
    function calculateRoundTripTime(oldRtt, duration) {
      if (oldRtt === -1) {
        return duration;
      }
      const alpha = 0.2;
      return alpha * duration + (1 - alpha) * oldRtt;
    }
    function basicReadValidations(server, options2) {
      if (options2.readPreference && !(options2.readPreference instanceof ReadPreference)) {
        return new MongoError("readPreference must be an instance of ReadPreference");
      }
    }
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const server = args.server;
      const op = args.op;
      const ns = args.ns;
      const ops = Array.isArray(args.ops) ? args.ops : [args.ops];
      if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {
        callback(new MongoError("server is closed"));
        return;
      }
      if (collationNotSupported(server, options2)) {
        callback(new MongoError(`server ${server.name} does not support collation`));
        return;
      }
      const unacknowledgedWrite = options2.writeConcern && options2.writeConcern.w === 0;
      if (unacknowledgedWrite || maxWireVersion(server) < 5) {
        if ((op === "update" || op === "remove") && ops.find((o) => o.hint)) {
          callback(new MongoError(`servers < 3.4 do not support hint on ${op}`));
          return;
        }
      }
      server.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(server, err);
          return cb(err);
        }
        conn[op](ns, ops, options2, makeOperationHandler(server, conn, ops, options2, cb));
      }, callback);
    }
    function markServerUnknown(server, error3) {
      if (error3 instanceof MongoNetworkError && !(error3 instanceof MongoNetworkTimeoutError)) {
        server[kMonitor].reset();
      }
      server.emit("descriptionReceived", new ServerDescription(server.description.address, null, {
        error: error3,
        topologyVersion: error3 && error3.topologyVersion ? error3.topologyVersion : server.description.topologyVersion
      }));
    }
    function connectionIsStale(pool, connection) {
      return connection.generation !== pool.generation;
    }
    function shouldHandleStateChangeError(server, err) {
      const etv = err.topologyVersion;
      const stv = server.description.topologyVersion;
      return compareTopologyVersion(stv, etv) < 0;
    }
    function inActiveTransaction(session, cmd2) {
      return session && session.inTransaction() && !isTransactionCommand(cmd2);
    }
    function makeOperationHandler(server, connection, cmd2, options2, callback) {
      const session = options2 && options2.session;
      return function handleOperationResult(err, result) {
        if (err && !connectionIsStale(server.s.pool, connection)) {
          if (err instanceof MongoNetworkError) {
            if (session && !session.hasEnded) {
              session.serverSession.isDirty = true;
            }
            if (supportsRetryableWrites(server) && !inActiveTransaction(session, cmd2)) {
              err.addErrorLabel("RetryableWriteError");
            }
            if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {
              markServerUnknown(server, err);
              server.s.pool.clear();
            }
          } else {
            if (maxWireVersion(server) < 9 && isRetryableWriteError(err) && !inActiveTransaction(session, cmd2)) {
              err.addErrorLabel("RetryableWriteError");
            }
            if (isSDAMUnrecoverableError(err)) {
              if (shouldHandleStateChangeError(server, err)) {
                if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {
                  server.s.pool.clear();
                }
                markServerUnknown(server, err);
                process.nextTick(() => server.requestCheck());
              }
            }
          }
        }
        callback(err, result);
      };
    }
    module2.exports = {
      Server
    };
  }
});

// node_modules/mongodb/lib/core/sdam/srv_polling.js
var require_srv_polling = __commonJS({
  "node_modules/mongodb/lib/core/sdam/srv_polling.js"(exports2, module2) {
    "use strict";
    var Logger = require_logger();
    var EventEmitter = require("events").EventEmitter;
    var dns = require("dns");
    function matchesParentDomain(srvAddress, parentDomain) {
      const regex = /^.*?\./;
      const srv = `.${srvAddress.replace(regex, "")}`;
      const parent = `.${parentDomain.replace(regex, "")}`;
      return srv.endsWith(parent);
    }
    var SrvPollingEvent = class {
      constructor(srvRecords) {
        this.srvRecords = srvRecords;
      }
      addresses() {
        return new Set(this.srvRecords.map((record) => `${record.name}:${record.port}`));
      }
    };
    var SrvPoller = class extends EventEmitter {
      constructor(options2) {
        super();
        if (!options2 || !options2.srvHost) {
          throw new TypeError("options for SrvPoller must exist and include srvHost");
        }
        this.srvHost = options2.srvHost;
        this.rescanSrvIntervalMS = 6e4;
        this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS || 1e4;
        this.logger = Logger("srvPoller", options2);
        this.haMode = false;
        this.generation = 0;
        this._timeout = null;
      }
      get srvAddress() {
        return `_mongodb._tcp.${this.srvHost}`;
      }
      get intervalMS() {
        return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
      }
      start() {
        if (!this._timeout) {
          this.schedule();
        }
      }
      stop() {
        if (this._timeout) {
          clearTimeout(this._timeout);
          this.generation += 1;
          this._timeout = null;
        }
      }
      schedule() {
        clearTimeout(this._timeout);
        this._timeout = setTimeout(() => this._poll(), this.intervalMS);
      }
      success(srvRecords) {
        this.haMode = false;
        this.schedule();
        this.emit("srvRecordDiscovery", new SrvPollingEvent(srvRecords));
      }
      failure(message, obj) {
        this.logger.warn(message, obj);
        this.haMode = true;
        this.schedule();
      }
      parentDomainMismatch(srvRecord) {
        this.logger.warn(`parent domain mismatch on SRV record (${srvRecord.name}:${srvRecord.port})`, srvRecord);
      }
      _poll() {
        const generation = this.generation;
        dns.resolveSrv(this.srvAddress, (err, srvRecords) => {
          if (generation !== this.generation) {
            return;
          }
          if (err) {
            this.failure("DNS error", err);
            return;
          }
          const finalAddresses = [];
          srvRecords.forEach((record) => {
            if (matchesParentDomain(record.name, this.srvHost)) {
              finalAddresses.push(record);
            } else {
              this.parentDomainMismatch(record);
            }
          });
          if (!finalAddresses.length) {
            this.failure("No valid addresses found at host");
            return;
          }
          this.success(finalAddresses);
        });
      }
    };
    module2.exports.SrvPollingEvent = SrvPollingEvent;
    module2.exports.SrvPoller = SrvPoller;
  }
});

// node_modules/mongodb/lib/core/sdam/server_selection.js
var require_server_selection = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server_selection.js"(exports2, module2) {
    "use strict";
    var ServerType = require_common().ServerType;
    var TopologyType = require_common().TopologyType;
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var IDLE_WRITE_PERIOD = 1e4;
    var SMALLEST_MAX_STALENESS_SECONDS = 90;
    function writableServerSelector() {
      return function(topologyDescription, servers) {
        return latencyWindowReducer(topologyDescription, servers.filter((s2) => s2.isWritable));
      };
    }
    function maxStalenessReducer(readPreference, topologyDescription, servers) {
      if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
        return servers;
      }
      const maxStaleness = readPreference.maxStalenessSeconds;
      const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1e3;
      if (maxStaleness < maxStalenessVariance) {
        throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);
      }
      if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
        throw new MongoError(`maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
      }
      if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {
        const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
        return servers.reduce((result, server) => {
          const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          if (staleness <= readPreference.maxStalenessSeconds)
            result.push(server);
          return result;
        }, []);
      }
      if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {
        if (servers.length === 0) {
          return servers;
        }
        const sMax = servers.reduce((max, s2) => s2.lastWriteDate > max.lastWriteDate ? s2 : max);
        return servers.reduce((result, server) => {
          const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          if (staleness <= readPreference.maxStalenessSeconds)
            result.push(server);
          return result;
        }, []);
      }
      return servers;
    }
    function tagSetMatch(tagSet, serverTags) {
      const keys = Object.keys(tagSet);
      const serverTagKeys = Object.keys(serverTags);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
          return false;
        }
      }
      return true;
    }
    function tagSetReducer(readPreference, servers) {
      if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
        return servers;
      }
      for (let i = 0; i < readPreference.tags.length; ++i) {
        const tagSet = readPreference.tags[i];
        const serversMatchingTagset = servers.reduce((matched, server) => {
          if (tagSetMatch(tagSet, server.tags))
            matched.push(server);
          return matched;
        }, []);
        if (serversMatchingTagset.length) {
          return serversMatchingTagset;
        }
      }
      return [];
    }
    function latencyWindowReducer(topologyDescription, servers) {
      const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);
      const high = low + topologyDescription.localThresholdMS;
      return servers.reduce((result, server) => {
        if (server.roundTripTime <= high && server.roundTripTime >= low)
          result.push(server);
        return result;
      }, []);
    }
    function primaryFilter(server) {
      return server.type === ServerType.RSPrimary;
    }
    function secondaryFilter(server) {
      return server.type === ServerType.RSSecondary;
    }
    function nearestFilter(server) {
      return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;
    }
    function knownFilter(server) {
      return server.type !== ServerType.Unknown;
    }
    function readPreferenceServerSelector(readPreference) {
      if (!readPreference.isValid()) {
        throw new TypeError("Invalid read preference specified");
      }
      return function(topologyDescription, servers) {
        const commonWireVersion = topologyDescription.commonWireVersion;
        if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
          throw new MongoError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
        }
        if (topologyDescription.type === TopologyType.Unknown) {
          return [];
        }
        if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {
          return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
        }
        const mode = readPreference.mode;
        if (mode === ReadPreference.PRIMARY) {
          return servers.filter(primaryFilter);
        }
        if (mode === ReadPreference.PRIMARY_PREFERRED) {
          const result = servers.filter(primaryFilter);
          if (result.length) {
            return result;
          }
        }
        const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
        const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));
        if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
          return servers.filter(primaryFilter);
        }
        return selectedServers;
      };
    }
    module2.exports = {
      writableServerSelector,
      readPreferenceServerSelector
    };
  }
});

// node_modules/mongodb/lib/core/sdam/topology.js
var require_topology = __commonJS({
  "node_modules/mongodb/lib/core/sdam/topology.js"(exports2, module2) {
    "use strict";
    var Denque = require_denque();
    var EventEmitter = require("events");
    var ServerDescription = require_server_description().ServerDescription;
    var ServerType = require_common().ServerType;
    var TopologyDescription = require_topology_description().TopologyDescription;
    var TopologyType = require_common().TopologyType;
    var events = require_events();
    var Server = require_server2().Server;
    var relayEvents = require_utils2().relayEvents;
    var ReadPreference = require_read_preference();
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var CoreCursor = require_cursor().CoreCursor;
    var deprecate = require("util").deprecate;
    var BSON2 = require_utils3().retrieveBSON();
    var createCompressionInfo = require_shared2().createCompressionInfo;
    var ClientSession = require_sessions().ClientSession;
    var MongoError = require_error().MongoError;
    var MongoServerSelectionError = require_error().MongoServerSelectionError;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var SrvPoller = require_srv_polling().SrvPoller;
    var getMMAPError = require_shared2().getMMAPError;
    var makeStateMachine = require_utils2().makeStateMachine;
    var eachAsync = require_utils2().eachAsync;
    var emitDeprecationWarning = require_utils4().emitDeprecationWarning;
    var ServerSessionPool = require_sessions().ServerSessionPool;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var compareTopologyVersion = require_server_description().compareTopologyVersion;
    var emitWarning = require_utils4().emitWarning;
    var common = require_common();
    var drainTimerQueue = common.drainTimerQueue;
    var clearAndRemoveTimerFrom = common.clearAndRemoveTimerFrom;
    var serverSelection = require_server_selection();
    var readPreferenceServerSelector = serverSelection.readPreferenceServerSelector;
    var writableServerSelector = serverSelection.writableServerSelector;
    var globalTopologyCounter = 0;
    var SERVER_RELAY_EVENTS = [
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      "monitoring"
    ].concat(CMAP_EVENT_NAMES);
    var LOCAL_SERVER_EVENTS = ["connect", "descriptionReceived", "close", "ended"];
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CONNECTING = common.STATE_CONNECTING;
    var STATE_CONNECTED = common.STATE_CONNECTED;
    var stateTransition = makeStateMachine({
      [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
      [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
      [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
      [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
    });
    var DEPRECATED_OPTIONS = new Set([
      "autoReconnect",
      "reconnectTries",
      "reconnectInterval",
      "bufferMaxEntries"
    ]);
    var kCancelled = Symbol("cancelled");
    var kWaitQueue = Symbol("waitQueue");
    var Topology = class extends EventEmitter {
      constructor(seedlist, options2) {
        super();
        if (typeof options2 === "undefined" && typeof seedlist !== "string") {
          options2 = seedlist;
          seedlist = [];
          if (options2.host) {
            seedlist.push({host: options2.host, port: options2.port});
          }
        }
        seedlist = seedlist || [];
        if (typeof seedlist === "string") {
          seedlist = parseStringSeedlist(seedlist);
        }
        options2 = Object.assign({}, common.TOPOLOGY_DEFAULTS, options2);
        options2 = Object.freeze(Object.assign(options2, {
          metadata: makeClientMetadata(options2),
          compression: {compressors: createCompressionInfo(options2)}
        }));
        DEPRECATED_OPTIONS.forEach((optionName) => {
          if (options2[optionName]) {
            emitDeprecationWarning(`The option \`${optionName}\` is incompatible with the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
          }
        });
        const topologyType = topologyTypeFromSeedlist(seedlist, options2);
        const topologyId = globalTopologyCounter++;
        const serverDescriptions = seedlist.reduce((result, seed) => {
          if (seed.domain_socket)
            seed.host = seed.domain_socket;
          const address = seed.port ? `${seed.host}:${seed.port}` : `${seed.host}:27017`;
          result.set(address, new ServerDescription(address));
          return result;
        }, new Map());
        this[kWaitQueue] = new Denque();
        this.s = {
          id: topologyId,
          options: options2,
          seedlist,
          state: STATE_CLOSED,
          description: new TopologyDescription(topologyType, serverDescriptions, options2.replicaSet, null, null, null, options2),
          serverSelectionTimeoutMS: options2.serverSelectionTimeoutMS,
          heartbeatFrequencyMS: options2.heartbeatFrequencyMS,
          minHeartbeatFrequencyMS: options2.minHeartbeatFrequencyMS,
          Cursor: options2.cursorFactory || CoreCursor,
          bson: options2.bson || new BSON2([
            BSON2.Binary,
            BSON2.Code,
            BSON2.DBRef,
            BSON2.Decimal128,
            BSON2.Double,
            BSON2.Int32,
            BSON2.Long,
            BSON2.Map,
            BSON2.MaxKey,
            BSON2.MinKey,
            BSON2.ObjectId,
            BSON2.BSONRegExp,
            BSON2.Symbol,
            BSON2.Timestamp
          ]),
          servers: new Map(),
          sessionPool: new ServerSessionPool(this),
          sessions: new Set(),
          promiseLibrary: options2.promiseLibrary || Promise,
          credentials: options2.credentials,
          clusterTime: null,
          connectionTimers: new Set()
        };
        if (options2.srvHost) {
          this.s.srvPoller = options2.srvPoller || new SrvPoller({
            heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
            srvHost: options2.srvHost,
            logger: options2.logger,
            loggerLevel: options2.loggerLevel
          });
          this.s.detectTopologyDescriptionChange = (ev) => {
            const previousType = ev.previousDescription.type;
            const newType = ev.newDescription.type;
            if (previousType !== TopologyType.Sharded && newType === TopologyType.Sharded) {
              this.s.handleSrvPolling = srvPollingHandler(this);
              this.s.srvPoller.on("srvRecordDiscovery", this.s.handleSrvPolling);
              this.s.srvPoller.start();
            }
          };
          this.on("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
        }
        this.setMaxListeners(Infinity);
      }
      get description() {
        return this.s.description;
      }
      get parserType() {
        return BSON2.native ? "c++" : "js";
      }
      connect(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = options2 || {};
        if (this.s.state === STATE_CONNECTED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CONNECTING);
        this.emit("topologyOpening", new events.TopologyOpeningEvent(this.s.id));
        this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, new TopologyDescription(TopologyType.Unknown), this.s.description));
        connectServers(this, Array.from(this.s.description.servers.values()));
        ReadPreference.translate(options2);
        const readPreference = options2.readPreference || ReadPreference.primary;
        const connectHandler = (err) => {
          if (err) {
            this.close();
            if (typeof callback === "function") {
              callback(err);
            } else {
              this.emit("error", err);
            }
            return;
          }
          stateTransition(this, STATE_CONNECTED);
          this.emit("open", err, this);
          this.emit("connect", this);
          if (typeof callback === "function")
            callback(err, this);
        };
        if (this.s.credentials) {
          this.command("admin.$cmd", {ping: 1}, {readPreference}, connectHandler);
          return;
        }
        this.selectServer(readPreferenceServerSelector(readPreference), options2, connectHandler);
      }
      close(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        if (typeof options2 === "boolean") {
          options2 = {force: options2};
        }
        options2 = options2 || {};
        if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CLOSING);
        drainWaitQueue(this[kWaitQueue], new MongoError("Topology closed"));
        drainTimerQueue(this.s.connectionTimers);
        if (this.s.srvPoller) {
          this.s.srvPoller.stop();
          if (this.s.handleSrvPolling) {
            this.s.srvPoller.removeListener("srvRecordDiscovery", this.s.handleSrvPolling);
            delete this.s.handleSrvPolling;
          }
        }
        if (this.s.detectTopologyDescriptionChange) {
          this.removeListener("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
          delete this.s.detectTopologyDescriptionChange;
        }
        this.s.sessions.forEach((session) => session.endSession());
        this.s.sessionPool.endAllPooledSessions(() => {
          eachAsync(Array.from(this.s.servers.values()), (server, cb) => destroyServer(server, this, options2, cb), (err) => {
            this.s.servers.clear();
            this.emit("topologyClosed", new events.TopologyClosedEvent(this.s.id));
            stateTransition(this, STATE_CLOSED);
            if (typeof callback === "function") {
              callback(err);
            }
          });
        });
      }
      selectServer(selector, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          if (typeof selector !== "function") {
            options2 = selector;
            let readPreference;
            if (selector instanceof ReadPreference) {
              readPreference = selector;
            } else if (typeof selector === "string") {
              readPreference = new ReadPreference(selector);
            } else {
              ReadPreference.translate(options2);
              readPreference = options2.readPreference || ReadPreference.primary;
            }
            selector = readPreferenceServerSelector(readPreference);
          } else {
            options2 = {};
          }
        }
        options2 = Object.assign({}, {serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS}, options2);
        const isSharded = this.description.type === TopologyType.Sharded;
        const session = options2.session;
        const transaction = session && session.transaction;
        if (isSharded && transaction && transaction.server) {
          callback(void 0, transaction.server);
          return;
        }
        let serverSelector = selector;
        if (typeof selector === "object") {
          const readPreference = selector.readPreference ? selector.readPreference : ReadPreference.primary;
          serverSelector = readPreferenceServerSelector(readPreference);
        }
        const waitQueueMember = {
          serverSelector,
          transaction,
          callback
        };
        const serverSelectionTimeoutMS = options2.serverSelectionTimeoutMS;
        if (serverSelectionTimeoutMS) {
          waitQueueMember.timer = setTimeout(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            const timeoutError = new MongoServerSelectionError(`Server selection timed out after ${serverSelectionTimeoutMS} ms`, this.description);
            waitQueueMember.callback(timeoutError);
          }, serverSelectionTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        processWaitQueue(this);
      }
      shouldCheckForSessionSupport() {
        if (this.description.type === TopologyType.Single) {
          return !this.description.hasKnownServers;
        }
        return !this.description.hasDataBearingServers;
      }
      hasSessionSupport() {
        return this.description.logicalSessionTimeoutMinutes != null;
      }
      startSession(options2, clientOptions) {
        const session = new ClientSession(this, this.s.sessionPool, options2, clientOptions);
        session.once("ended", () => {
          this.s.sessions.delete(session);
        });
        this.s.sessions.add(session);
        return session;
      }
      endSessions(sessions, callback) {
        if (!Array.isArray(sessions)) {
          sessions = [sessions];
        }
        this.command("admin.$cmd", {endSessions: sessions}, {readPreference: ReadPreference.primaryPreferred, noResponse: true}, () => {
          if (typeof callback === "function")
            callback();
        });
      }
      serverUpdateHandler(serverDescription) {
        if (!this.s.description.hasServer(serverDescription.address)) {
          return;
        }
        if (isStaleServerDescription(this.s.description, serverDescription)) {
          return;
        }
        const previousTopologyDescription = this.s.description;
        const previousServerDescription = this.s.description.servers.get(serverDescription.address);
        const clusterTime = serverDescription.$clusterTime;
        if (clusterTime) {
          resolveClusterTime(this, clusterTime);
        }
        const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
        this.s.description = this.s.description.update(serverDescription);
        if (this.s.description.compatibilityError) {
          this.emit("error", new MongoError(this.s.description.compatibilityError));
          return;
        }
        if (!equalDescriptions) {
          this.emit("serverDescriptionChanged", new events.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, this.s.description.servers.get(serverDescription.address)));
        }
        updateServers(this, serverDescription);
        if (this[kWaitQueue].length > 0) {
          processWaitQueue(this);
        }
        if (!equalDescriptions) {
          this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
        }
      }
      auth(credentials, callback) {
        if (typeof credentials === "function")
          callback = credentials, credentials = null;
        if (typeof callback === "function")
          callback(null, true);
      }
      logout(callback) {
        if (typeof callback === "function")
          callback(null, true);
      }
      insert(ns, ops, options2, callback) {
        executeWriteOperation({topology: this, op: "insert", ns, ops}, options2, callback);
      }
      update(ns, ops, options2, callback) {
        executeWriteOperation({topology: this, op: "update", ns, ops}, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        executeWriteOperation({topology: this, op: "remove", ns, ops}, options2, callback);
      }
      command(ns, cmd2, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2, options2 = {}, options2 = options2 || {};
        }
        ReadPreference.translate(options2);
        const readPreference = options2.readPreference || ReadPreference.primary;
        this.selectServer(readPreferenceServerSelector(readPreference), options2, (err, server) => {
          if (err) {
            callback(err);
            return;
          }
          const willRetryWrite = !options2.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(this) && !options2.session.inTransaction() && isWriteCommand(cmd2);
          const cb = (err2, result) => {
            if (!err2)
              return callback(null, result);
            if (!shouldRetryOperation(err2)) {
              return callback(err2);
            }
            if (willRetryWrite) {
              const newOptions = Object.assign({}, options2, {retrying: true});
              return this.command(ns, cmd2, newOptions, callback);
            }
            return callback(err2);
          };
          if (willRetryWrite) {
            options2.session.incrementTransactionNumber();
            options2.willRetryWrite = willRetryWrite;
          }
          server.command(ns, cmd2, options2, cb);
        });
      }
      cursor(ns, cmd2, options2) {
        options2 = options2 || {};
        const topology = options2.topology || this;
        const CursorClass = options2.cursorFactory || this.s.Cursor;
        ReadPreference.translate(options2);
        return new CursorClass(topology, ns, cmd2, options2);
      }
      get clientMetadata() {
        return this.s.options.metadata;
      }
      isConnected() {
        return this.s.state === STATE_CONNECTED;
      }
      isDestroyed() {
        return this.s.state === STATE_CLOSED;
      }
      unref() {
        emitWarning("not implemented: `unref`");
      }
      lastIsMaster() {
        const serverDescriptions = Array.from(this.description.servers.values());
        if (serverDescriptions.length === 0)
          return {};
        const sd = serverDescriptions.filter((sd2) => sd2.type !== ServerType.Unknown)[0];
        const result = sd || {maxWireVersion: this.description.commonWireVersion};
        return result;
      }
      get logicalSessionTimeoutMinutes() {
        return this.description.logicalSessionTimeoutMinutes;
      }
      get bson() {
        return this.s.bson;
      }
    };
    Object.defineProperty(Topology.prototype, "clusterTime", {
      enumerable: true,
      get: function() {
        return this.s.clusterTime;
      },
      set: function(clusterTime) {
        this.s.clusterTime = clusterTime;
      }
    });
    Topology.prototype.destroy = deprecate(Topology.prototype.close, "destroy() is deprecated, please use close() instead");
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command2) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command2[op]);
    }
    function isStaleServerDescription(topologyDescription, incomingServerDescription) {
      const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
      const currentTopologyVersion = currentServerDescription.topologyVersion;
      return compareTopologyVersion(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
    }
    function destroyServer(server, topology, options2, callback) {
      options2 = options2 || {};
      LOCAL_SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
      server.destroy(options2, () => {
        topology.emit("serverClosed", new events.ServerClosedEvent(topology.s.id, server.description.address));
        SERVER_RELAY_EVENTS.forEach((event) => server.removeAllListeners(event));
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    function parseStringSeedlist(seedlist) {
      return seedlist.split(",").map((seed) => ({
        host: seed.split(":")[0],
        port: seed.split(":")[1] || 27017
      }));
    }
    function topologyTypeFromSeedlist(seedlist, options2) {
      if (options2.directConnection) {
        return TopologyType.Single;
      }
      const replicaSet = options2.replicaSet || options2.setName || options2.rs_name;
      if (replicaSet == null) {
        return TopologyType.Unknown;
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    function randomSelection(array) {
      return array[Math.floor(Math.random() * array.length)];
    }
    function createAndConnectServer(topology, serverDescription, connectDelay) {
      topology.emit("serverOpening", new events.ServerOpeningEvent(topology.s.id, serverDescription.address));
      const server = new Server(serverDescription, topology.s.options, topology);
      relayEvents(server, topology, SERVER_RELAY_EVENTS);
      server.on("descriptionReceived", topology.serverUpdateHandler.bind(topology));
      if (connectDelay) {
        const connectTimer = setTimeout(() => {
          clearAndRemoveTimerFrom(connectTimer, topology.s.connectionTimers);
          server.connect();
        }, connectDelay);
        topology.s.connectionTimers.add(connectTimer);
        return server;
      }
      server.connect();
      return server;
    }
    function connectServers(topology, serverDescriptions) {
      topology.s.servers = serverDescriptions.reduce((servers, serverDescription) => {
        const server = createAndConnectServer(topology, serverDescription);
        servers.set(serverDescription.address, server);
        return servers;
      }, new Map());
    }
    function updateServers(topology, incomingServerDescription) {
      if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
        const server = topology.s.servers.get(incomingServerDescription.address);
        server.s.description = incomingServerDescription;
      }
      for (const serverDescription of topology.description.servers.values()) {
        if (!topology.s.servers.has(serverDescription.address)) {
          const server = createAndConnectServer(topology, serverDescription);
          topology.s.servers.set(serverDescription.address, server);
        }
      }
      for (const entry of topology.s.servers) {
        const serverAddress = entry[0];
        if (topology.description.hasServer(serverAddress)) {
          continue;
        }
        const server = topology.s.servers.get(serverAddress);
        topology.s.servers.delete(serverAddress);
        destroyServer(server, topology);
      }
    }
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const topology = args.topology;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      const willRetryWrite = !args.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(topology) && !options2.session.inTransaction() && options2.explain === void 0;
      topology.selectServer(writableServerSelector(), options2, (err, server) => {
        if (err) {
          callback(err, null);
          return;
        }
        const handler = (err2, result) => {
          if (!err2)
            return callback(null, result);
          if (!shouldRetryOperation(err2)) {
            err2 = getMMAPError(err2);
            return callback(err2);
          }
          if (willRetryWrite) {
            const newArgs = Object.assign({}, args, {retrying: true});
            return executeWriteOperation(newArgs, options2, callback);
          }
          return callback(err2);
        };
        if (callback.operationId) {
          handler.operationId = callback.operationId;
        }
        if (willRetryWrite) {
          options2.session.incrementTransactionNumber();
          options2.willRetryWrite = willRetryWrite;
        }
        server[op](ns, ops, options2, handler);
      });
    }
    function shouldRetryOperation(err) {
      return err instanceof MongoError && err.hasErrorLabel("RetryableWriteError");
    }
    function srvPollingHandler(topology) {
      return function handleSrvPolling(ev) {
        const previousTopologyDescription = topology.s.description;
        topology.s.description = topology.s.description.updateFromSrvPollingEvent(ev);
        if (topology.s.description === previousTopologyDescription) {
          return;
        }
        updateServers(topology);
        topology.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(topology.s.id, previousTopologyDescription, topology.s.description));
      };
    }
    function drainWaitQueue(queue, err) {
      while (queue.length) {
        const waitQueueMember = queue.shift();
        clearTimeout(waitQueueMember.timer);
        if (!waitQueueMember[kCancelled]) {
          waitQueueMember.callback(err);
        }
      }
    }
    function processWaitQueue(topology) {
      if (topology.s.state === STATE_CLOSED) {
        drainWaitQueue(topology[kWaitQueue], new MongoError("Topology is closed, please connect"));
        return;
      }
      const serverDescriptions = Array.from(topology.description.servers.values());
      const membersToProcess = topology[kWaitQueue].length;
      for (let i = 0; i < membersToProcess && topology[kWaitQueue].length; ++i) {
        const waitQueueMember = topology[kWaitQueue].shift();
        if (waitQueueMember[kCancelled]) {
          continue;
        }
        let selectedDescriptions;
        try {
          const serverSelector = waitQueueMember.serverSelector;
          selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;
        } catch (e) {
          clearTimeout(waitQueueMember.timer);
          waitQueueMember.callback(e);
          continue;
        }
        if (selectedDescriptions.length === 0) {
          topology[kWaitQueue].push(waitQueueMember);
          continue;
        }
        const selectedServerDescription = randomSelection(selectedDescriptions);
        const selectedServer = topology.s.servers.get(selectedServerDescription.address);
        const transaction = waitQueueMember.transaction;
        const isSharded = topology.description.type === TopologyType.Sharded;
        if (isSharded && transaction && transaction.isActive) {
          transaction.pinServer(selectedServer);
        }
        clearTimeout(waitQueueMember.timer);
        waitQueueMember.callback(void 0, selectedServer);
      }
      if (topology[kWaitQueue].length > 0) {
        topology.s.servers.forEach((server) => process.nextTick(() => server.requestCheck()));
      }
    }
    module2.exports = {
      Topology
    };
  }
});

// node_modules/mongodb/lib/core/uri_parser.js
var require_uri_parser = __commonJS({
  "node_modules/mongodb/lib/core/uri_parser.js"(exports2, module2) {
    "use strict";
    var URL2 = require("url");
    var qs = require("querystring");
    var dns = require("dns");
    var MongoParseError = require_error().MongoParseError;
    var ReadPreference = require_read_preference();
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var HOSTS_RX = /(mongodb(?:\+srv|)):\/\/(?: (?:[^:]*) (?: : ([^@]*) )? @ )?([^/?]*)(?:\/|)(.*)/;
    var FILE_PATH_OPTIONS = new Set(["sslCA", "sslCert", "sslKey", "tlsCAFile", "tlsCertificateKeyFile"].map((key) => key.toLowerCase()));
    function matchesParentDomain(srvAddress, parentDomain) {
      const regex = /^.*?\./;
      const srv = `.${srvAddress.replace(regex, "")}`;
      const parent = `.${parentDomain.replace(regex, "")}`;
      return srv.endsWith(parent);
    }
    function parseSrvConnectionString(uri, options2, callback) {
      const result = URL2.parse(uri, true);
      if (options2.directConnection || options2.directconnection) {
        return callback(new MongoParseError("directConnection not supported with SRV URI"));
      }
      if (result.hostname.split(".").length < 3) {
        return callback(new MongoParseError("URI does not have hostname, domain name and tld"));
      }
      result.domainLength = result.hostname.split(".").length;
      if (result.pathname && result.pathname.match(",")) {
        return callback(new MongoParseError("Invalid URI, cannot contain multiple hostnames"));
      }
      if (result.port) {
        return callback(new MongoParseError(`Ports not accepted with '${PROTOCOL_MONGODB_SRV}' URIs`));
      }
      const lookupAddress = result.host;
      dns.resolveSrv(`_mongodb._tcp.${lookupAddress}`, (err, addresses) => {
        if (err)
          return callback(err);
        if (addresses.length === 0) {
          return callback(new MongoParseError("No addresses found at host"));
        }
        for (let i = 0; i < addresses.length; i++) {
          if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
            return callback(new MongoParseError("Server record does not share hostname with parent URI"));
          }
        }
        result.protocol = "mongodb";
        result.host = addresses.map((address) => `${address.name}:${address.port}`).join(",");
        if (!("ssl" in options2) && (!result.search || !("ssl" in result.query) || result.query.ssl === null)) {
          result.query.ssl = true;
        }
        dns.resolveTxt(lookupAddress, (err2, record) => {
          if (err2) {
            if (err2.code !== "ENODATA" && err2.code !== "ENOTFOUND") {
              return callback(err2);
            }
            record = null;
          }
          if (record) {
            if (record.length > 1) {
              return callback(new MongoParseError("Multiple text records not allowed"));
            }
            record = qs.parse(record[0].join(""));
            if (Object.keys(record).some((key) => key !== "authSource" && key !== "replicaSet")) {
              return callback(new MongoParseError("Text record must only set `authSource` or `replicaSet`"));
            }
            result.query = Object.assign({}, record, result.query);
          }
          result.search = qs.stringify(result.query);
          const finalString = URL2.format(result);
          parseConnectionString(finalString, options2, (err3, ret) => {
            if (err3) {
              callback(err3);
              return;
            }
            callback(null, Object.assign({}, ret, {srvHost: lookupAddress}));
          });
        });
      });
    }
    function parseQueryStringItemValue(key, value) {
      if (Array.isArray(value)) {
        value = value.filter((v, idx) => value.indexOf(v) === idx);
        if (value.length === 1)
          value = value[0];
      } else if (value.indexOf(":") > 0) {
        value = value.split(",").reduce((result, pair2) => {
          const parts = pair2.split(":");
          result[parts[0]] = parseQueryStringItemValue(key, parts[1]);
          return result;
        }, {});
      } else if (value.indexOf(",") > 0) {
        value = value.split(",").map((v) => {
          return parseQueryStringItemValue(key, v);
        });
      } else if (value.toLowerCase() === "true" || value.toLowerCase() === "false") {
        value = value.toLowerCase() === "true";
      } else if (!Number.isNaN(value) && !STRING_OPTIONS.has(key)) {
        const numericValue = parseFloat(value);
        if (!Number.isNaN(numericValue)) {
          value = parseFloat(value);
        }
      }
      return value;
    }
    var BOOLEAN_OPTIONS = new Set([
      "slaveok",
      "slave_ok",
      "sslvalidate",
      "fsync",
      "safe",
      "retrywrites",
      "j"
    ]);
    var STRING_OPTIONS = new Set(["authsource", "replicaset"]);
    var AUTH_MECHANISMS = new Set([
      "GSSAPI",
      "MONGODB-AWS",
      "MONGODB-X509",
      "MONGODB-CR",
      "DEFAULT",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256",
      "PLAIN"
    ]);
    var CASE_TRANSLATION = {
      replicaset: "replicaSet",
      connecttimeoutms: "connectTimeoutMS",
      sockettimeoutms: "socketTimeoutMS",
      maxpoolsize: "maxPoolSize",
      minpoolsize: "minPoolSize",
      maxidletimems: "maxIdleTimeMS",
      waitqueuemultiple: "waitQueueMultiple",
      waitqueuetimeoutms: "waitQueueTimeoutMS",
      wtimeoutms: "wtimeoutMS",
      readconcern: "readConcern",
      readconcernlevel: "readConcernLevel",
      readpreference: "readPreference",
      maxstalenessseconds: "maxStalenessSeconds",
      readpreferencetags: "readPreferenceTags",
      authsource: "authSource",
      authmechanism: "authMechanism",
      authmechanismproperties: "authMechanismProperties",
      gssapiservicename: "gssapiServiceName",
      localthresholdms: "localThresholdMS",
      serverselectiontimeoutms: "serverSelectionTimeoutMS",
      serverselectiontryonce: "serverSelectionTryOnce",
      heartbeatfrequencyms: "heartbeatFrequencyMS",
      retrywrites: "retryWrites",
      uuidrepresentation: "uuidRepresentation",
      zlibcompressionlevel: "zlibCompressionLevel",
      tlsallowinvalidcertificates: "tlsAllowInvalidCertificates",
      tlsallowinvalidhostnames: "tlsAllowInvalidHostnames",
      tlsinsecure: "tlsInsecure",
      tlscafile: "tlsCAFile",
      tlscertificatekeyfile: "tlsCertificateKeyFile",
      tlscertificatekeyfilepassword: "tlsCertificateKeyFilePassword",
      wtimeout: "wTimeoutMS",
      j: "journal",
      directconnection: "directConnection"
    };
    function applyConnectionStringOption(obj, key, value, options2) {
      if (key === "journal") {
        key = "j";
      } else if (key === "wtimeoutms") {
        key = "wtimeout";
      }
      if (BOOLEAN_OPTIONS.has(key)) {
        value = value === "true" || value === true;
      } else if (key === "appname") {
        value = decodeURIComponent(value);
      } else if (key === "readconcernlevel") {
        obj["readConcernLevel"] = value;
        key = "readconcern";
        value = {level: value};
      }
      if (key === "compressors") {
        value = Array.isArray(value) ? value : [value];
        if (!value.every((c) => c === "snappy" || c === "zlib")) {
          throw new MongoParseError("Value for `compressors` must be at least one of: `snappy`, `zlib`");
        }
      }
      if (key === "authmechanism" && !AUTH_MECHANISMS.has(value)) {
        throw new MongoParseError(`Value for authMechanism must be one of: ${Array.from(AUTH_MECHANISMS).join(", ")}, found: ${value}`);
      }
      if (key === "readpreference" && !ReadPreference.isValid(value)) {
        throw new MongoParseError("Value for `readPreference` must be one of: `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred`, `nearest`");
      }
      if (key === "zlibcompressionlevel" && (value < -1 || value > 9)) {
        throw new MongoParseError("zlibCompressionLevel must be an integer between -1 and 9");
      }
      if (key === "compressors" || key === "zlibcompressionlevel") {
        obj.compression = obj.compression || {};
        obj = obj.compression;
      }
      if (key === "authmechanismproperties") {
        if (typeof value.SERVICE_NAME === "string")
          obj.gssapiServiceName = value.SERVICE_NAME;
        if (typeof value.SERVICE_REALM === "string")
          obj.gssapiServiceRealm = value.SERVICE_REALM;
        if (typeof value.CANONICALIZE_HOST_NAME !== "undefined") {
          obj.gssapiCanonicalizeHostName = value.CANONICALIZE_HOST_NAME;
        }
      }
      if (key === "readpreferencetags") {
        value = Array.isArray(value) ? splitArrayOfMultipleReadPreferenceTags(value) : [value];
      }
      if (options2.caseTranslate && CASE_TRANSLATION[key]) {
        obj[CASE_TRANSLATION[key]] = value;
        return;
      }
      obj[key] = value;
    }
    var USERNAME_REQUIRED_MECHANISMS = new Set([
      "GSSAPI",
      "MONGODB-CR",
      "PLAIN",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256"
    ]);
    function splitArrayOfMultipleReadPreferenceTags(value) {
      const parsedTags = [];
      for (let i = 0; i < value.length; i++) {
        parsedTags[i] = {};
        value[i].split(",").forEach((individualTag) => {
          const splitTag = individualTag.split(":");
          parsedTags[i][splitTag[0]] = splitTag[1];
        });
      }
      return parsedTags;
    }
    function applyAuthExpectations(parsed) {
      if (parsed.options == null) {
        return;
      }
      const options2 = parsed.options;
      const authSource = options2.authsource || options2.authSource;
      if (authSource != null) {
        parsed.auth = Object.assign({}, parsed.auth, {db: authSource});
      }
      const authMechanism = options2.authmechanism || options2.authMechanism;
      if (authMechanism != null) {
        if (USERNAME_REQUIRED_MECHANISMS.has(authMechanism) && (!parsed.auth || parsed.auth.username == null)) {
          throw new MongoParseError(`Username required for mechanism \`${authMechanism}\``);
        }
        if (authMechanism === "GSSAPI") {
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
        }
        if (authMechanism === "MONGODB-AWS") {
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
        }
        if (authMechanism === "MONGODB-X509") {
          if (parsed.auth && parsed.auth.password != null) {
            throw new MongoParseError(`Password not allowed for mechanism \`${authMechanism}\``);
          }
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
        }
        if (authMechanism === "PLAIN") {
          if (parsed.auth && parsed.auth.db == null) {
            parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
          }
        }
      }
      if (parsed.auth && parsed.auth.db == null) {
        parsed.auth = Object.assign({}, parsed.auth, {db: "admin"});
      }
      return parsed;
    }
    function parseQueryString(query, options2) {
      const result = {};
      let parsedQueryString = qs.parse(query);
      checkTLSOptions(parsedQueryString);
      for (const key in parsedQueryString) {
        const value = parsedQueryString[key];
        if (value === "" || value == null) {
          throw new MongoParseError("Incomplete key value pair for option");
        }
        const normalizedKey = key.toLowerCase();
        const parsedValue = FILE_PATH_OPTIONS.has(normalizedKey) ? value : parseQueryStringItemValue(normalizedKey, value);
        applyConnectionStringOption(result, normalizedKey, parsedValue, options2);
      }
      if (result.wtimeout && result.wtimeoutms) {
        delete result.wtimeout;
        emitWarningOnce("Unsupported option `wtimeout` specified");
      }
      return Object.keys(result).length ? result : null;
    }
    function translateTLSOptions(queryString) {
      if (queryString.tls) {
        queryString.ssl = queryString.tls;
      }
      if (queryString.tlsInsecure) {
        queryString.checkServerIdentity = false;
        queryString.sslValidate = false;
      } else {
        Object.assign(queryString, {
          checkServerIdentity: queryString.tlsAllowInvalidHostnames ? false : true,
          sslValidate: queryString.tlsAllowInvalidCertificates ? false : true
        });
      }
      if (queryString.tlsCAFile) {
        queryString.ssl = true;
        queryString.sslCA = queryString.tlsCAFile;
      }
      if (queryString.tlsCertificateKeyFile) {
        queryString.ssl = true;
        if (queryString.tlsCertificateFile) {
          queryString.sslCert = queryString.tlsCertificateFile;
          queryString.sslKey = queryString.tlsCertificateKeyFile;
        } else {
          queryString.sslKey = queryString.tlsCertificateKeyFile;
          queryString.sslCert = queryString.tlsCertificateKeyFile;
        }
      }
      if (queryString.tlsCertificateKeyFilePassword) {
        queryString.ssl = true;
        queryString.sslPass = queryString.tlsCertificateKeyFilePassword;
      }
      return queryString;
    }
    function checkTLSOptions(queryString) {
      const queryStringKeys = Object.keys(queryString);
      if (queryStringKeys.indexOf("tlsInsecure") !== -1 && (queryStringKeys.indexOf("tlsAllowInvalidCertificates") !== -1 || queryStringKeys.indexOf("tlsAllowInvalidHostnames") !== -1)) {
        throw new MongoParseError("The `tlsInsecure` option cannot be used with `tlsAllowInvalidCertificates` or `tlsAllowInvalidHostnames`.");
      }
      const tlsValue = assertTlsOptionsAreEqual("tls", queryString, queryStringKeys);
      const sslValue = assertTlsOptionsAreEqual("ssl", queryString, queryStringKeys);
      if (tlsValue != null && sslValue != null) {
        if (tlsValue !== sslValue) {
          throw new MongoParseError("All values of `tls` and `ssl` must be the same.");
        }
      }
    }
    function assertTlsOptionsAreEqual(optionName, queryString, queryStringKeys) {
      const queryStringHasTLSOption = queryStringKeys.indexOf(optionName) !== -1;
      let optionValue;
      if (Array.isArray(queryString[optionName])) {
        optionValue = queryString[optionName][0];
      } else {
        optionValue = queryString[optionName];
      }
      if (queryStringHasTLSOption) {
        if (Array.isArray(queryString[optionName])) {
          const firstValue = queryString[optionName][0];
          queryString[optionName].forEach((tlsValue) => {
            if (tlsValue !== firstValue) {
              throw new MongoParseError(`All values of ${optionName} must be the same.`);
            }
          });
        }
      }
      return optionValue;
    }
    var PROTOCOL_MONGODB = "mongodb";
    var PROTOCOL_MONGODB_SRV = "mongodb+srv";
    var SUPPORTED_PROTOCOLS = [PROTOCOL_MONGODB, PROTOCOL_MONGODB_SRV];
    function parseConnectionString(uri, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, {caseTranslate: true}, options2);
      try {
        URL2.parse(uri);
      } catch (e) {
        return callback(new MongoParseError("URI malformed, cannot be parsed"));
      }
      const cap = uri.match(HOSTS_RX);
      if (!cap) {
        return callback(new MongoParseError("Invalid connection string"));
      }
      const protocol = cap[1];
      if (SUPPORTED_PROTOCOLS.indexOf(protocol) === -1) {
        return callback(new MongoParseError("Invalid protocol provided"));
      }
      const dbAndQuery = cap[4].split("?");
      const db = dbAndQuery.length > 0 ? dbAndQuery[0] : null;
      const query = dbAndQuery.length > 1 ? dbAndQuery[1] : null;
      let parsedOptions;
      try {
        parsedOptions = parseQueryString(query, options2);
      } catch (parseError) {
        return callback(parseError);
      }
      parsedOptions = Object.assign({}, parsedOptions, options2);
      if (protocol === PROTOCOL_MONGODB_SRV) {
        return parseSrvConnectionString(uri, parsedOptions, callback);
      }
      const auth = {username: null, password: null, db: db && db !== "" ? qs.unescape(db) : null};
      if (parsedOptions.auth) {
        if (parsedOptions.auth.username)
          auth.username = parsedOptions.auth.username;
        if (parsedOptions.auth.user)
          auth.username = parsedOptions.auth.user;
        if (parsedOptions.auth.password)
          auth.password = parsedOptions.auth.password;
      } else {
        if (parsedOptions.username)
          auth.username = parsedOptions.username;
        if (parsedOptions.user)
          auth.username = parsedOptions.user;
        if (parsedOptions.password)
          auth.password = parsedOptions.password;
      }
      if (cap[4].split("?")[0].indexOf("@") !== -1) {
        return callback(new MongoParseError("Unescaped slash in userinfo section"));
      }
      const authorityParts = cap[3].split("@");
      if (authorityParts.length > 2) {
        return callback(new MongoParseError("Unescaped at-sign in authority section"));
      }
      if (authorityParts[0] == null || authorityParts[0] === "") {
        return callback(new MongoParseError("No username provided in authority section"));
      }
      if (authorityParts.length > 1) {
        const authParts = authorityParts.shift().split(":");
        if (authParts.length > 2) {
          return callback(new MongoParseError("Unescaped colon in authority section"));
        }
        if (authParts[0] === "") {
          return callback(new MongoParseError("Invalid empty username provided"));
        }
        if (!auth.username)
          auth.username = qs.unescape(authParts[0]);
        if (!auth.password)
          auth.password = authParts[1] ? qs.unescape(authParts[1]) : null;
      }
      let hostParsingError = null;
      const hosts = authorityParts.shift().split(",").map((host) => {
        let parsedHost = URL2.parse(`mongodb://${host}`);
        if (parsedHost.path === "/:") {
          hostParsingError = new MongoParseError("Double colon in host identifier");
          return null;
        }
        if (host.match(/\.sock/)) {
          parsedHost.hostname = qs.unescape(host);
          parsedHost.port = null;
        }
        if (Number.isNaN(parsedHost.port)) {
          hostParsingError = new MongoParseError("Invalid port (non-numeric string)");
          return;
        }
        const result2 = {
          host: parsedHost.hostname,
          port: parsedHost.port ? parseInt(parsedHost.port) : 27017
        };
        if (result2.port === 0) {
          hostParsingError = new MongoParseError("Invalid port (zero) with hostname");
          return;
        }
        if (result2.port > 65535) {
          hostParsingError = new MongoParseError("Invalid port (larger than 65535) with hostname");
          return;
        }
        if (result2.port < 0) {
          hostParsingError = new MongoParseError("Invalid port (negative number)");
          return;
        }
        return result2;
      }).filter((host) => !!host);
      if (hostParsingError) {
        return callback(hostParsingError);
      }
      if (hosts.length === 0 || hosts[0].host === "" || hosts[0].host === null) {
        return callback(new MongoParseError("No hostname or hostnames provided in connection string"));
      }
      const directConnection = !!parsedOptions.directConnection;
      if (directConnection && hosts.length !== 1) {
        return callback(new MongoParseError("directConnection option requires exactly one host"));
      }
      if (parsedOptions.directConnection == null && hosts.length === 1 && parsedOptions.replicaSet == null) {
        parsedOptions.directConnection = true;
      }
      const result = {
        hosts,
        auth: auth.db || auth.username ? auth : null,
        options: Object.keys(parsedOptions).length ? parsedOptions : null
      };
      if (result.auth && result.auth.db) {
        result.defaultDatabase = result.auth.db;
      } else {
        result.defaultDatabase = "test";
      }
      result.options = translateTLSOptions(result.options);
      try {
        applyAuthExpectations(result);
      } catch (authError) {
        return callback(authError);
      }
      callback(null, result);
    }
    module2.exports = parseConnectionString;
  }
});

// node_modules/mongodb/lib/core/index.js
var require_core = __commonJS({
  "node_modules/mongodb/lib/core/index.js"(exports2, module2) {
    "use strict";
    var BSON2 = require_bson2();
    var require_optional = require_optional_require()(require);
    var EJSON = require_utils2().retrieveEJSON();
    try {
      const BSONNative = require_optional("bson-ext");
      if (BSONNative) {
        BSON2 = BSONNative;
      }
    } catch (err) {
    }
    module2.exports = {
      MongoError: require_error().MongoError,
      MongoNetworkError: require_error().MongoNetworkError,
      MongoParseError: require_error().MongoParseError,
      MongoTimeoutError: require_error().MongoTimeoutError,
      MongoServerSelectionError: require_error().MongoServerSelectionError,
      MongoWriteConcernError: require_error().MongoWriteConcernError,
      Connection: require_connection(),
      Server: require_server(),
      ReplSet: require_replset(),
      Mongos: require_mongos(),
      Logger: require_logger(),
      Cursor: require_cursor().CoreCursor,
      ReadPreference: require_read_preference(),
      Sessions: require_sessions(),
      BSON: BSON2,
      EJSON,
      Topology: require_topology().Topology,
      Query: require_commands().Query,
      MongoCredentials: require_mongo_credentials().MongoCredentials,
      defaultAuthProviders: require_defaultAuthProviders().defaultAuthProviders,
      MongoCR: require_mongocr(),
      X509: require_x509(),
      Plain: require_plain(),
      GSSAPI: require_gssapi(),
      ScramSHA1: require_scram().ScramSHA1,
      ScramSHA256: require_scram().ScramSHA256,
      parseConnectionString: require_uri_parser()
    };
  }
});

// node_modules/mongodb/lib/apm.js
var require_apm2 = __commonJS({
  "node_modules/mongodb/lib/apm.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var Instrumentation = class extends EventEmitter {
      constructor() {
        super();
      }
      instrument(MongoClient2, callback) {
        this.$MongoClient = MongoClient2;
        const $prototypeConnect = this.$prototypeConnect = MongoClient2.prototype.connect;
        const instrumentation = this;
        MongoClient2.prototype.connect = function(callback2) {
          this.s.options.monitorCommands = true;
          this.on("commandStarted", (event) => instrumentation.emit("started", event));
          this.on("commandSucceeded", (event) => instrumentation.emit("succeeded", event));
          this.on("commandFailed", (event) => instrumentation.emit("failed", event));
          return $prototypeConnect.call(this, callback2);
        };
        if (typeof callback === "function")
          callback(null, this);
      }
      uninstrument() {
        this.$MongoClient.prototype.connect = this.$prototypeConnect;
      }
    };
    module2.exports = Instrumentation;
  }
});

// node_modules/mongodb/lib/error.js
var require_error2 = __commonJS({
  "node_modules/mongodb/lib/error.js"(exports2, module2) {
    "use strict";
    var MongoNetworkError = require_core().MongoNetworkError;
    var GET_MORE_RESUMABLE_CODES = new Set([
      6,
      7,
      89,
      91,
      189,
      262,
      9001,
      10107,
      11600,
      11602,
      13435,
      13436,
      63,
      150,
      13388,
      234,
      133,
      43
    ]);
    function isResumableError(error3, wireVersion) {
      if (error3 instanceof MongoNetworkError) {
        return true;
      }
      if (wireVersion >= 9) {
        if (error3.code === 43) {
          return true;
        }
        return error3.hasErrorLabel("ResumableChangeStreamError");
      }
      return GET_MORE_RESUMABLE_CODES.has(error3.code);
    }
    module2.exports = {GET_MORE_RESUMABLE_CODES, isResumableError};
  }
});

// node_modules/mongodb/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/mongodb/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      SYSTEM_NAMESPACE_COLLECTION: "system.namespaces",
      SYSTEM_INDEX_COLLECTION: "system.indexes",
      SYSTEM_PROFILE_COLLECTION: "system.profile",
      SYSTEM_USER_COLLECTION: "system.users",
      SYSTEM_COMMAND_COLLECTION: "$cmd",
      SYSTEM_JS_COLLECTION: "system.js"
    };
  }
});

// node_modules/mongodb/lib/operations/db_ops.js
var require_db_ops = __commonJS({
  "node_modules/mongodb/lib/operations/db_ops.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var debugOptions = require_utils4().debugOptions;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var parseIndexOptions = require_utils4().parseIndexOptions;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var CONSTANTS = require_constants2();
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var debugFields = [
      "authSource",
      "w",
      "wtimeout",
      "j",
      "native_parser",
      "forceServerObjectId",
      "serializeFunctions",
      "raw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bufferMaxEntries",
      "numberOfRetries",
      "retryMiliSeconds",
      "readPreference",
      "pkFactory",
      "parentDb",
      "promiseLibrary",
      "noListener"
    ];
    function createIndex(db, name2, fieldOrSpec, options2, callback) {
      let finalOptions = Object.assign({}, {readPreference: ReadPreference.PRIMARY}, options2);
      finalOptions = applyWriteConcern(finalOptions, {db}, options2);
      if (finalOptions.writeConcern && typeof callback !== "function") {
        throw MongoError.create({
          message: "Cannot use a writeConcern without a provided callback",
          driver: true
        });
      }
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      createIndexUsingCreateIndexes(db, name2, fieldOrSpec, finalOptions, (err, result) => {
        if (err == null)
          return handleCallback(callback, err, result);
        if (err.code === 67 || err.code === 11e3 || err.code === 85 || err.code === 86 || err.code === 11600 || err.code === 197) {
          return handleCallback(callback, err, result);
        }
        const doc2 = createCreateIndexCommand(db, name2, fieldOrSpec, options2);
        finalOptions.checkKeys = false;
        db.s.topology.insert(db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION), doc2, finalOptions, (err2, result2) => {
          if (callback == null)
            return;
          if (err2)
            return handleCallback(callback, err2);
          if (result2 == null)
            return handleCallback(callback, null, null);
          if (result2.result.writeErrors)
            return handleCallback(callback, MongoError.create(result2.result.writeErrors[0]), null);
          handleCallback(callback, null, doc2.name);
        });
      });
    }
    function createListener(db, e, object) {
      function listener(err) {
        if (object.listeners(e).length > 0) {
          object.emit(e, err, db);
          for (let i = 0; i < db.s.children.length; i++) {
            db.s.children[i].emit(e, err, db.s.children[i]);
          }
        }
      }
      return listener;
    }
    function ensureIndex(db, name2, fieldOrSpec, options2, callback) {
      const finalOptions = applyWriteConcern({}, {db}, options2);
      const selector = createCreateIndexCommand(db, name2, fieldOrSpec, options2);
      const index_name = selector.name;
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      finalOptions.readPreference = ReadPreference.PRIMARY;
      indexInformation(db, name2, finalOptions, (err, indexInformation2) => {
        if (err != null && err.code !== 26)
          return handleCallback(callback, err, null);
        if (indexInformation2 == null || !indexInformation2[index_name]) {
          createIndex(db, name2, fieldOrSpec, options2, callback);
        } else {
          if (typeof callback === "function")
            return handleCallback(callback, null, index_name);
        }
      });
    }
    function evaluate(db, code, parameters, options2, callback) {
      let finalCode = code;
      let finalParameters = [];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      if (!(finalCode && finalCode._bsontype === "Code"))
        finalCode = new Code2(finalCode);
      if (parameters != null && !Array.isArray(parameters) && typeof parameters !== "function") {
        finalParameters = [parameters];
      } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== "function") {
        finalParameters = parameters;
      }
      let cmd2 = {$eval: finalCode, args: finalParameters};
      if (options2["nolock"]) {
        cmd2["nolock"] = options2["nolock"];
      }
      options2.readPreference = new ReadPreference(ReadPreference.PRIMARY);
      executeCommand(db, cmd2, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result && result.ok === 1)
          return handleCallback(callback, null, result.retval);
        if (result)
          return handleCallback(callback, MongoError.create({message: `eval failed: ${result.errmsg}`, driver: true}), null);
        handleCallback(callback, err, result);
      });
    }
    function executeCommand(db, command2, options2, callback) {
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      const dbName = options2.dbName || options2.authdb || db.databaseName;
      options2.readPreference = ReadPreference.resolve(db, options2);
      if (db.s.logger.isDebug())
        db.s.logger.debug(`executing command ${JSON.stringify(command2)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options2))}]`);
      db.s.topology.command(db.s.namespace.withCollection("$cmd"), command2, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err);
        if (options2.full)
          return handleCallback(callback, null, result);
        handleCallback(callback, null, result.result);
      });
    }
    function executeDbAdminCommand(db, command2, options2, callback) {
      const namespace = new MongoDBNamespace("admin", "$cmd");
      db.s.topology.command(namespace, command2, options2, (err, result) => {
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, result.result);
      });
    }
    function indexInformation(db, name2, options2, callback) {
      const full = options2["full"] == null ? false : options2["full"];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      function processResults(indexes) {
        let info = {};
        for (let i = 0; i < indexes.length; i++) {
          const index2 = indexes[i];
          info[index2.name] = [];
          for (let name3 in index2.key) {
            info[index2.name].push([name3, index2.key[name3]]);
          }
        }
        return info;
      }
      db.collection(name2).listIndexes(options2).toArray((err, indexes) => {
        if (err)
          return callback(toError(err));
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, []);
        if (full)
          return handleCallback(callback, null, indexes);
        handleCallback(callback, null, processResults(indexes));
      });
    }
    function profilingInfo(db, options2, callback) {
      try {
        db.collection("system.profile").find({}, options2).toArray(callback);
      } catch (err) {
        return callback(err, null);
      }
    }
    function validateDatabaseName(databaseName) {
      if (typeof databaseName !== "string")
        throw MongoError.create({message: "database name must be a string", driver: true});
      if (databaseName.length === 0)
        throw MongoError.create({message: "database name cannot be the empty string", driver: true});
      if (databaseName === "$external")
        return;
      const invalidChars = [" ", ".", "$", "/", "\\"];
      for (let i = 0; i < invalidChars.length; i++) {
        if (databaseName.indexOf(invalidChars[i]) !== -1)
          throw MongoError.create({
            message: "database names cannot contain the character '" + invalidChars[i] + "'",
            driver: true
          });
      }
    }
    function createCreateIndexCommand(db, name2, fieldOrSpec, options2) {
      const indexParameters = parseIndexOptions(fieldOrSpec);
      const fieldHash = indexParameters.fieldHash;
      const indexName = typeof options2.name === "string" ? options2.name : indexParameters.name;
      const selector = {
        ns: db.s.namespace.withCollection(name2).toString(),
        key: fieldHash,
        name: indexName
      };
      const finalUnique = options2 == null || typeof options2 === "object" ? false : options2;
      options2 = options2 == null || typeof options2 === "boolean" ? {} : options2;
      const keysToOmit = Object.keys(selector);
      for (let optionName in options2) {
        if (keysToOmit.indexOf(optionName) === -1) {
          selector[optionName] = options2[optionName];
        }
      }
      if (selector["unique"] == null)
        selector["unique"] = finalUnique;
      const removeKeys = ["w", "wtimeout", "j", "fsync", "readPreference", "session"];
      for (let i = 0; i < removeKeys.length; i++) {
        delete selector[removeKeys[i]];
      }
      return selector;
    }
    function createIndexUsingCreateIndexes(db, name2, fieldOrSpec, options2, callback) {
      const indexParameters = parseIndexOptions(fieldOrSpec);
      const indexName = typeof options2.name === "string" ? options2.name : indexParameters.name;
      const indexes = [{name: indexName, key: indexParameters.fieldHash}];
      const keysToOmit = Object.keys(indexes[0]).concat([
        "writeConcern",
        "w",
        "wtimeout",
        "j",
        "fsync",
        "readPreference",
        "session"
      ]);
      for (let optionName in options2) {
        if (keysToOmit.indexOf(optionName) === -1) {
          indexes[0][optionName] = options2[optionName];
        }
      }
      const capabilities = db.s.topology.capabilities();
      if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {
        const error3 = new MongoError("server/primary/mongos does not support collation");
        error3.code = 67;
        return callback(error3);
      }
      const cmd2 = applyWriteConcern({createIndexes: name2, indexes}, {db}, options2);
      options2.readPreference = ReadPreference.PRIMARY;
      executeCommand(db, cmd2, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result.ok === 0)
          return handleCallback(callback, toError(result), null);
        handleCallback(callback, null, indexName);
      });
    }
    module2.exports = {
      createListener,
      createIndex,
      ensureIndex,
      evaluate,
      executeCommand,
      executeDbAdminCommand,
      indexInformation,
      profilingInfo,
      validateDatabaseName
    };
  }
});

// node_modules/mongodb/lib/operations/common_functions.js
var require_common_functions = __commonJS({
  "node_modules/mongodb/lib/operations/common_functions.js"(exports2, module2) {
    "use strict";
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var CursorState = require_cursor().CursorState;
    var maxWireVersion = require_utils2().maxWireVersion;
    function buildCountCommand(collectionOrCursor, query, options2) {
      const skip = options2.skip;
      const limit = options2.limit;
      let hint = options2.hint;
      const maxTimeMS = options2.maxTimeMS;
      query = query || {};
      const cmd2 = {
        count: options2.collectionName,
        query
      };
      if (collectionOrCursor.s.numberOfRetries) {
        if (collectionOrCursor.options.hint) {
          hint = collectionOrCursor.options.hint;
        } else if (collectionOrCursor.cmd.hint) {
          hint = collectionOrCursor.cmd.hint;
        }
        decorateWithCollation(cmd2, collectionOrCursor, collectionOrCursor.cmd);
      } else {
        decorateWithCollation(cmd2, collectionOrCursor, options2);
      }
      if (typeof skip === "number")
        cmd2.skip = skip;
      if (typeof limit === "number")
        cmd2.limit = limit;
      if (typeof maxTimeMS === "number")
        cmd2.maxTimeMS = maxTimeMS;
      if (hint)
        cmd2.hint = hint;
      decorateWithReadConcern(cmd2, collectionOrCursor);
      return cmd2;
    }
    function findAndModify(coll, query, sort, doc2, options2, callback) {
      const queryObject = {
        findAndModify: coll.collectionName,
        query
      };
      sort = formattedOrderClause(sort);
      if (sort) {
        queryObject.sort = sort;
      }
      queryObject.new = options2.new ? true : false;
      queryObject.remove = options2.remove ? true : false;
      queryObject.upsert = options2.upsert ? true : false;
      const projection = options2.projection || options2.fields;
      if (projection) {
        queryObject.fields = projection;
      }
      if (options2.arrayFilters) {
        queryObject.arrayFilters = options2.arrayFilters;
        delete options2.arrayFilters;
      }
      if (doc2 && !options2.remove) {
        queryObject.update = doc2;
      }
      if (options2.maxTimeMS)
        queryObject.maxTimeMS = options2.maxTimeMS;
      options2.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
      options2.checkKeys = false;
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options2);
      if (finalOptions.writeConcern) {
        queryObject.writeConcern = finalOptions.writeConcern;
      }
      if (finalOptions.bypassDocumentValidation === true) {
        queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
      }
      finalOptions.readPreference = ReadPreference.primary;
      try {
        decorateWithCollation(queryObject, coll, finalOptions);
      } catch (err) {
        return callback(err, null);
      }
      executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        return handleCallback(callback, null, result);
      });
    }
    function indexInformation(db, name2, options2, callback) {
      const full = options2["full"] == null ? false : options2["full"];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      function processResults(indexes) {
        let info = {};
        for (let i = 0; i < indexes.length; i++) {
          const index2 = indexes[i];
          info[index2.name] = [];
          for (let name3 in index2.key) {
            info[index2.name].push([name3, index2.key[name3]]);
          }
        }
        return info;
      }
      db.collection(name2).listIndexes(options2).toArray((err, indexes) => {
        if (err)
          return callback(toError(err));
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, []);
        if (full)
          return handleCallback(callback, null, indexes);
        handleCallback(callback, null, processResults(indexes));
      });
    }
    function prepareDocs(coll, docs, options2) {
      const forceServerObjectId = typeof options2.forceServerObjectId === "boolean" ? options2.forceServerObjectId : coll.s.db.options.forceServerObjectId;
      if (forceServerObjectId === true) {
        return docs;
      }
      return docs.map((doc2) => {
        if (forceServerObjectId !== true && doc2._id == null) {
          doc2._id = coll.s.pkFactory.createPk();
        }
        return doc2;
      });
    }
    function nextObject(cursor, callback) {
      if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
        return handleCallback(callback, MongoError.create({message: "Cursor is closed", driver: true}));
      }
      if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {
        try {
          cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
        } catch (err) {
          return handleCallback(callback, err);
        }
      }
      cursor._next((err, doc2) => {
        cursor.s.state = CursorState.OPEN;
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, doc2);
      });
    }
    function insertDocuments(coll, docs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      docs = Array.isArray(docs) ? docs : [docs];
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options2);
      if (finalOptions.keepGoing === true)
        finalOptions.ordered = false;
      finalOptions.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
      docs = prepareDocs(coll, docs, options2);
      coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors)
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        result.ops = docs;
        handleCallback(callback, null, result);
      });
    }
    function removeDocuments(coll, selector, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {};
      } else if (typeof selector === "function") {
        callback = selector;
        options2 = {};
        selector = {};
      }
      options2 = options2 || {};
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options2);
      if (selector == null)
        selector = {};
      const op = {q: selector, limit: 0};
      if (options2.single) {
        op.limit = 1;
      } else if (finalOptions.retryWrites) {
        finalOptions.retryWrites = false;
      }
      if (options2.hint) {
        op.hint = options2.hint;
      }
      try {
        decorateWithCollation(finalOptions, coll, options2);
      } catch (err) {
        return callback(err, null);
      }
      if (options2.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
        return callback ? callback(new MongoError(`server does not support explain on remove`)) : void 0;
      }
      coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors) {
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        }
        handleCallback(callback, null, result);
      });
    }
    function updateDocuments(coll, selector, document2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = null;
      if (options2 == null)
        options2 = {};
      if (!(typeof callback === "function"))
        callback = null;
      if (selector == null || typeof selector !== "object")
        return callback(toError("selector must be a valid JavaScript object"));
      if (document2 == null || typeof document2 !== "object")
        return callback(toError("document must be a valid JavaScript object"));
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options2);
      finalOptions.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
      const op = {q: selector, u: document2};
      op.upsert = options2.upsert !== void 0 ? !!options2.upsert : false;
      op.multi = options2.multi !== void 0 ? !!options2.multi : false;
      if (options2.hint) {
        op.hint = options2.hint;
      }
      if (finalOptions.arrayFilters) {
        op.arrayFilters = finalOptions.arrayFilters;
        delete finalOptions.arrayFilters;
      }
      if (finalOptions.retryWrites && op.multi) {
        finalOptions.retryWrites = false;
      }
      try {
        decorateWithCollation(finalOptions, coll, options2);
      } catch (err) {
        return callback(err, null);
      }
      if (options2.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
        return callback ? callback(new MongoError(`server does not support explain on update`)) : void 0;
      }
      coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors)
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        handleCallback(callback, null, result);
      });
    }
    module2.exports = {
      buildCountCommand,
      findAndModify,
      indexInformation,
      nextObject,
      prepareDocs,
      insertDocuments,
      removeDocuments,
      updateDocuments
    };
  }
});

// node_modules/mongodb/lib/operations/collection_ops.js
var require_collection_ops = __commonJS({
  "node_modules/mongodb/lib/operations/collection_ops.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var createIndexDb = require_db_ops().createIndex;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var ensureIndexDb = require_db_ops().ensureIndex;
    var evaluate = require_db_ops().evaluate;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils4().handleCallback;
    var indexInformationDb = require_db_ops().indexInformation;
    var Long2 = require_core().BSON.Long;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var insertDocuments = require_common_functions().insertDocuments;
    var updateDocuments = require_common_functions().updateDocuments;
    var groupFunction = 'function () {\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) {\nvar obj = c.next();\nvar key = {};\n\nfor (var i = 0, len = keys.length; i < len; ++i) {\nvar k = keys[i];\nkey[k] = obj[k];\n}\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) {\nvar newObj = Object.extend({}, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n}\n\nreduce_function(obj, aggObj);\n}\n\nreturn { "result": map.values() };\n}';
    function createIndex(coll, fieldOrSpec, options2, callback) {
      createIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options2, callback);
    }
    function createIndexes(coll, indexSpecs, options2, callback) {
      const capabilities = coll.s.topology.capabilities();
      for (let i = 0; i < indexSpecs.length; i++) {
        if (indexSpecs[i].name == null) {
          const keys = [];
          if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {
            return callback(new MongoError("server/primary/mongos does not support collation"));
          }
          for (let name2 in indexSpecs[i].key) {
            keys.push(`${name2}_${indexSpecs[i].key[name2]}`);
          }
          indexSpecs[i].name = keys.join("_");
        }
      }
      options2 = Object.assign({}, options2, {readPreference: ReadPreference.PRIMARY});
      executeCommand(coll.s.db, {
        createIndexes: coll.collectionName,
        indexes: indexSpecs
      }, options2, callback);
    }
    function ensureIndex(coll, fieldOrSpec, options2, callback) {
      ensureIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options2, callback);
    }
    function group(coll, keys, condition, initial, reduce, finalize, command2, options2, callback) {
      if (command2) {
        const reduceFunction = reduce && reduce._bsontype === "Code" ? reduce : new Code2(reduce);
        const selector = {
          group: {
            ns: coll.collectionName,
            $reduce: reduceFunction,
            cond: condition,
            initial,
            out: "inline"
          }
        };
        if (finalize != null)
          selector.group["finalize"] = finalize;
        if (typeof keys === "function" || keys && keys._bsontype === "Code") {
          selector.group.$keyf = keys && keys._bsontype === "Code" ? keys : new Code2(keys);
        } else {
          const hash2 = {};
          keys.forEach((key) => {
            hash2[key] = 1;
          });
          selector.group.key = hash2;
        }
        options2 = Object.assign({}, options2);
        options2.readPreference = ReadPreference.resolve(coll, options2);
        decorateWithReadConcern(selector, coll, options2);
        try {
          decorateWithCollation(selector, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        executeCommand(coll.s.db, selector, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, result.retval);
        });
      } else {
        const scope = reduce != null && reduce._bsontype === "Code" ? reduce.scope : {};
        scope.ns = coll.collectionName;
        scope.keys = keys;
        scope.condition = condition;
        scope.initial = initial;
        const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ";");
        evaluate(coll.s.db, new Code2(groupfn, scope), null, options2, (err, results) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, results.result || results);
        });
      }
    }
    function indexes(coll, options2, callback) {
      options2 = Object.assign({}, {full: true}, options2);
      indexInformationDb(coll.s.db, coll.collectionName, options2, callback);
    }
    function indexExists(coll, indexes2, options2, callback) {
      indexInformation(coll, options2, (err, indexInformation2) => {
        if (err != null)
          return handleCallback(callback, err, null);
        if (!Array.isArray(indexes2))
          return handleCallback(callback, null, indexInformation2[indexes2] != null);
        for (let i = 0; i < indexes2.length; i++) {
          if (indexInformation2[indexes2[i]] == null) {
            return handleCallback(callback, null, false);
          }
        }
        return handleCallback(callback, null, true);
      });
    }
    function indexInformation(coll, options2, callback) {
      indexInformationDb(coll.s.db, coll.collectionName, options2, callback);
    }
    function parallelCollectionScan(coll, options2, callback) {
      const commandObject = {
        parallelCollectionScan: coll.collectionName,
        numCursors: options2.numCursors
      };
      decorateWithReadConcern(commandObject, coll, options2);
      const raw = options2.raw;
      delete options2["raw"];
      executeCommand(coll.s.db, commandObject, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, new Error("no result returned for parallelCollectionScan"), null);
        options2 = Object.assign({explicitlyIgnoreSession: true}, options2);
        const cursors = [];
        if (raw)
          options2.raw = raw;
        for (let i = 0; i < result.cursors.length; i++) {
          const rawId = result.cursors[i].cursor.id;
          const cursorId = typeof rawId === "number" ? Long2.fromNumber(rawId) : rawId;
          cursors.push(coll.s.topology.cursor(coll.namespace, cursorId, options2));
        }
        handleCallback(callback, null, cursors);
      });
    }
    function save(coll, doc2, options2, callback) {
      const finalOptions = applyWriteConcern(Object.assign({}, options2), {db: coll.s.db, collection: coll}, options2);
      if (doc2._id != null) {
        finalOptions.upsert = true;
        return updateDocuments(coll, {_id: doc2._id}, doc2, finalOptions, callback);
      }
      insertDocuments(coll, [doc2], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (doc2 == null)
          return handleCallback(callback, null, null);
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, null, result);
      });
    }
    module2.exports = {
      createIndex,
      createIndexes,
      ensureIndex,
      group,
      indexes,
      indexExists,
      indexInformation,
      parallelCollectionScan,
      save
    };
  }
});

// node_modules/mongodb/lib/operations/cursor_ops.js
var require_cursor_ops = __commonJS({
  "node_modules/mongodb/lib/operations/cursor_ops.js"(exports2, module2) {
    "use strict";
    var buildCountCommand = require_collection_ops().buildCountCommand;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var push = Array.prototype.push;
    var CursorState = require_cursor().CursorState;
    function count(cursor, applySkipLimit, opts, callback) {
      if (applySkipLimit) {
        if (typeof cursor.cursorSkip() === "number")
          opts.skip = cursor.cursorSkip();
        if (typeof cursor.cursorLimit() === "number")
          opts.limit = cursor.cursorLimit();
      }
      if (opts.readPreference) {
        cursor.setReadPreference(opts.readPreference);
      }
      if (typeof opts.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
        opts.maxTimeMS = cursor.cmd.maxTimeMS;
      }
      let options2 = {};
      options2.skip = opts.skip;
      options2.limit = opts.limit;
      options2.hint = opts.hint;
      options2.maxTimeMS = opts.maxTimeMS;
      options2.collectionName = cursor.namespace.collection;
      let command2;
      try {
        command2 = buildCountCommand(cursor, cursor.cmd.query, options2);
      } catch (err) {
        return callback(err);
      }
      cursor.server = cursor.topology.s.coreTopology;
      cursor.topology.command(cursor.namespace.withCollection("$cmd"), command2, cursor.options, (err, result) => {
        callback(err, result ? result.result.n : null);
      });
    }
    function each2(cursor, callback) {
      if (!callback)
        throw MongoError.create({message: "callback is mandatory", driver: true});
      if (cursor.isNotified())
        return;
      if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {
        return handleCallback(callback, MongoError.create({message: "Cursor is closed", driver: true}));
      }
      if (cursor.s.state === CursorState.INIT) {
        cursor.s.state = CursorState.OPEN;
      }
      let fn = null;
      if (cursor.bufferedCount() > 0) {
        while (fn = loop(cursor, callback))
          fn(cursor, callback);
        each2(cursor, callback);
      } else {
        cursor.next((err, item) => {
          if (err)
            return handleCallback(callback, err);
          if (item == null) {
            return cursor.close({skipKillCursors: true}, () => handleCallback(callback, null, null));
          }
          if (handleCallback(callback, null, item) === false)
            return;
          each2(cursor, callback);
        });
      }
    }
    function loop(cursor, callback) {
      if (cursor.bufferedCount() === 0)
        return;
      cursor._next(callback);
      return loop;
    }
    function toArray(cursor, callback) {
      const items = [];
      cursor.rewind();
      cursor.s.state = CursorState.INIT;
      const fetchDocs = () => {
        cursor._next((err, doc2) => {
          if (err) {
            return handleCallback(callback, err);
          }
          if (doc2 == null) {
            return cursor.close({skipKillCursors: true}, () => handleCallback(callback, null, items));
          }
          items.push(doc2);
          if (cursor.bufferedCount() > 0) {
            let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
            if (cursor.s.transforms && typeof cursor.s.transforms.doc === "function") {
              docs = docs.map(cursor.s.transforms.doc);
            }
            push.apply(items, docs);
          }
          fetchDocs();
        });
      };
      fetchDocs();
    }
    module2.exports = {count, each: each2, toArray};
  }
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS({
  "node_modules/mongodb/lib/operations/count.js"(exports2, module2) {
    "use strict";
    var buildCountCommand = require_common_functions().buildCountCommand;
    var OperationBase = require_operation().OperationBase;
    var CountOperation = class extends OperationBase {
      constructor(cursor, applySkipLimit, options2) {
        super(options2);
        this.cursor = cursor;
        this.applySkipLimit = applySkipLimit;
      }
      execute(callback) {
        const cursor = this.cursor;
        const applySkipLimit = this.applySkipLimit;
        const options2 = this.options;
        if (applySkipLimit) {
          if (typeof cursor.cursorSkip() === "number")
            options2.skip = cursor.cursorSkip();
          if (typeof cursor.cursorLimit() === "number")
            options2.limit = cursor.cursorLimit();
        }
        if (options2.readPreference) {
          cursor.setReadPreference(options2.readPreference);
        }
        if (typeof options2.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
          options2.maxTimeMS = cursor.cmd.maxTimeMS;
        }
        let finalOptions = {};
        finalOptions.skip = options2.skip;
        finalOptions.limit = options2.limit;
        finalOptions.hint = options2.hint;
        finalOptions.maxTimeMS = options2.maxTimeMS;
        finalOptions.collectionName = cursor.namespace.collection;
        let command2;
        try {
          command2 = buildCountCommand(cursor, cursor.cmd.query, finalOptions);
        } catch (err) {
          return callback(err);
        }
        cursor.server = cursor.topology.s.coreTopology;
        cursor.topology.command(cursor.namespace.withCollection("$cmd"), command2, cursor.options, (err, result) => {
          callback(err, result ? result.result.n : null);
        });
      }
    };
    module2.exports = CountOperation;
  }
});

// node_modules/mongodb/lib/cursor.js
var require_cursor2 = __commonJS({
  "node_modules/mongodb/lib/cursor.js"(exports2, module2) {
    "use strict";
    var Transform = require("stream").Transform;
    var PassThrough2 = require("stream").PassThrough;
    var deprecate = require("util").deprecate;
    var handleCallback = require_utils4().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var CoreCursor = require_cursor().CoreCursor;
    var CursorState = require_cursor().CursorState;
    var Map2 = require_core().BSON.Map;
    var maybePromise = require_utils4().maybePromise;
    var executeOperation = require_execute_operation();
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var Explain = require_explain().Explain;
    var Aspect = require_operation().Aspect;
    var each2 = require_cursor_ops().each;
    var CountOperation = require_count();
    var flags = ["tailable", "oplogReplay", "noCursorTimeout", "awaitData", "exhaust", "partial"];
    var fields = ["numberOfRetries", "tailableRetryInterval"];
    var Cursor = class extends CoreCursor {
      constructor(topology, ns, cmd2, options2) {
        super(topology, ns, cmd2, options2);
        if (this.operation) {
          options2 = this.operation.options;
        }
        const numberOfRetries = options2.numberOfRetries || 5;
        const tailableRetryInterval = options2.tailableRetryInterval || 500;
        const currentNumberOfRetries = numberOfRetries;
        const promiseLibrary = options2.promiseLibrary || Promise;
        this.s = {
          numberOfRetries,
          tailableRetryInterval,
          currentNumberOfRetries,
          state: CursorState.INIT,
          promiseLibrary,
          explicitlyIgnoreSession: !!options2.explicitlyIgnoreSession
        };
        if (!options2.explicitlyIgnoreSession && options2.session) {
          this.cursorState.session = options2.session;
        }
        if (this.options.noCursorTimeout === true) {
          this.addCursorFlag("noCursorTimeout", true);
        }
        let batchSize = 1e3;
        if (this.cmd.cursor && this.cmd.cursor.batchSize) {
          batchSize = this.cmd.cursor.batchSize;
        } else if (options2.cursor && options2.cursor.batchSize) {
          batchSize = options2.cursor.batchSize;
        } else if (typeof options2.batchSize === "number") {
          batchSize = options2.batchSize;
        }
        this.setCursorBatchSize(batchSize);
      }
      get readPreference() {
        if (this.operation) {
          return this.operation.readPreference;
        }
        return this.options.readPreference;
      }
      get sortValue() {
        return this.cmd.sort;
      }
      _initializeCursor(callback) {
        if (this.operation && this.operation.session != null) {
          this.cursorState.session = this.operation.session;
        } else {
          if (!this.s.explicitlyIgnoreSession && !this.cursorState.session && this.topology.hasSessionSupport()) {
            this.cursorState.session = this.topology.startSession({owner: this});
            if (this.operation) {
              this.operation.session = this.cursorState.session;
            }
          }
        }
        super._initializeCursor(callback);
      }
      hasNext(callback) {
        if (this.s.state === CursorState.CLOSED || this.isDead && this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          if (cursor.isNotified()) {
            return cb(null, false);
          }
          cursor._next((err, doc2) => {
            if (err)
              return cb(err);
            if (doc2 == null || cursor.s.state === Cursor.CLOSED || cursor.isDead()) {
              return cb(null, false);
            }
            cursor.s.state = CursorState.OPEN;
            cursor.cursorState.cursorIndex--;
            if (cursor.cursorState.limit > 0) {
              cursor.cursorState.currentLimit--;
            }
            cb(null, true);
          });
        });
      }
      next(callback) {
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
            cb(MongoError.create({message: "Cursor is closed", driver: true}));
            return;
          }
          if (cursor.s.state === CursorState.INIT && cursor.cmd.sort) {
            try {
              cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
            } catch (err) {
              return cb(err);
            }
          }
          cursor._next((err, doc2) => {
            if (err)
              return cb(err);
            cursor.s.state = CursorState.OPEN;
            cb(null, doc2);
          });
        });
      }
      filter(filter) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.query = filter;
        return this;
      }
      maxScan(maxScan) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.maxScan = maxScan;
        return this;
      }
      hint(hint) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.hint = hint;
        return this;
      }
      min(min) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.min = min;
        return this;
      }
      max(max) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.max = max;
        return this;
      }
      returnKey(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.returnKey = value;
        return this;
      }
      showRecordId(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.showDiskLoc = value;
        return this;
      }
      snapshot(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.snapshot = value;
        return this;
      }
      setCursorOption(field, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (fields.indexOf(field) === -1) {
          throw MongoError.create({
            message: `option ${field} is not a supported option ${fields}`,
            driver: true
          });
        }
        this.s[field] = value;
        if (field === "numberOfRetries")
          this.s.currentNumberOfRetries = value;
        return this;
      }
      addCursorFlag(flag, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (flags.indexOf(flag) === -1) {
          throw MongoError.create({
            message: `flag ${flag} is not a supported flag ${flags}`,
            driver: true
          });
        }
        if (typeof value !== "boolean") {
          throw MongoError.create({message: `flag ${flag} must be a boolean value`, driver: true});
        }
        this.cmd[flag] = value;
        return this;
      }
      addQueryModifier(name2, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (name2[0] !== "$") {
          throw MongoError.create({message: `${name2} is not a valid query modifier`, driver: true});
        }
        const field = name2.substr(1);
        this.cmd[field] = value;
        if (field === "orderby")
          this.cmd.sort = this.cmd[field];
        return this;
      }
      comment(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.comment = value;
        return this;
      }
      maxAwaitTimeMS(value) {
        if (typeof value !== "number") {
          throw MongoError.create({message: "maxAwaitTimeMS must be a number", driver: true});
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.maxAwaitTimeMS = value;
        return this;
      }
      maxTimeMS(value) {
        if (typeof value !== "number") {
          throw MongoError.create({message: "maxTimeMS must be a number", driver: true});
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.maxTimeMS = value;
        return this;
      }
      project(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.fields = value;
        return this;
      }
      sort(keyOrList, direction) {
        if (this.options.tailable) {
          throw MongoError.create({message: "Tailable cursor doesn't support sorting", driver: true});
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        let order = keyOrList;
        if (Array.isArray(order) && Array.isArray(order[0])) {
          order = new Map2(order.map((x) => {
            const value = [x[0], null];
            if (x[1] === "asc") {
              value[1] = 1;
            } else if (x[1] === "desc") {
              value[1] = -1;
            } else if (x[1] === 1 || x[1] === -1 || x[1].$meta) {
              value[1] = x[1];
            } else {
              throw new MongoError("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
            }
            return value;
          }));
        }
        if (direction != null) {
          order = [[keyOrList, direction]];
        }
        this.cmd.sort = order;
        return this;
      }
      batchSize(value) {
        if (this.options.tailable) {
          throw MongoError.create({
            message: "Tailable cursor doesn't support batchSize",
            driver: true
          });
        }
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (typeof value !== "number") {
          throw MongoError.create({message: "batchSize requires an integer", driver: true});
        }
        this.cmd.batchSize = value;
        this.setCursorBatchSize(value);
        return this;
      }
      collation(value) {
        this.cmd.collation = value;
        return this;
      }
      limit(value) {
        if (this.options.tailable) {
          throw MongoError.create({message: "Tailable cursor doesn't support limit", driver: true});
        }
        if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (typeof value !== "number") {
          throw MongoError.create({message: "limit requires an integer", driver: true});
        }
        this.cmd.limit = value;
        this.setCursorLimit(value);
        return this;
      }
      skip(value) {
        if (this.options.tailable) {
          throw MongoError.create({message: "Tailable cursor doesn't support skip", driver: true});
        }
        if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (typeof value !== "number") {
          throw MongoError.create({message: "skip requires an integer", driver: true});
        }
        this.cmd.skip = value;
        this.setCursorSkip(value);
        return this;
      }
      each(callback) {
        this.rewind();
        this.s.state = CursorState.INIT;
        each2(this, callback);
      }
      forEach(iterator, callback) {
        this.rewind();
        this.s.state = CursorState.INIT;
        if (typeof callback === "function") {
          each2(this, (err, doc2) => {
            if (err) {
              callback(err);
              return false;
            }
            if (doc2 != null) {
              iterator(doc2);
              return true;
            }
            if (doc2 == null && callback) {
              const internalCallback = callback;
              callback = null;
              internalCallback(null);
              return false;
            }
          });
        } else {
          return new this.s.promiseLibrary((fulfill, reject) => {
            each2(this, (err, doc2) => {
              if (err) {
                reject(err);
                return false;
              } else if (doc2 == null) {
                fulfill(null);
                return false;
              } else {
                iterator(doc2);
                return true;
              }
            });
          });
        }
      }
      setReadPreference(readPreference) {
        if (this.s.state !== CursorState.INIT) {
          throw MongoError.create({
            message: "cannot change cursor readPreference after cursor has been accessed",
            driver: true
          });
        }
        if (readPreference instanceof ReadPreference) {
          this.options.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.options.readPreference = new ReadPreference(readPreference);
        } else {
          throw new TypeError("Invalid read preference: " + readPreference);
        }
        return this;
      }
      toArray(callback) {
        if (this.options.tailable) {
          throw MongoError.create({
            message: "Tailable cursor cannot be converted to array",
            driver: true
          });
        }
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          const items = [];
          cursor.rewind();
          cursor.s.state = CursorState.INIT;
          const fetchDocs = () => {
            cursor._next((err, doc2) => {
              if (err) {
                return handleCallback(cb, err);
              }
              if (doc2 == null) {
                return cursor.close({skipKillCursors: true}, () => handleCallback(cb, null, items));
              }
              items.push(doc2);
              if (cursor.bufferedCount() > 0) {
                let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
                Array.prototype.push.apply(items, docs);
              }
              fetchDocs();
            });
          };
          fetchDocs();
        });
      }
      count(applySkipLimit, opts, callback) {
        if (this.cmd.query == null)
          throw MongoError.create({
            message: "count can only be used with find command",
            driver: true
          });
        if (typeof opts === "function")
          callback = opts, opts = {};
        opts = opts || {};
        if (typeof applySkipLimit === "function") {
          callback = applySkipLimit;
          applySkipLimit = true;
        }
        if (this.cursorState.session) {
          opts = Object.assign({}, opts, {session: this.cursorState.session});
        }
        const countOperation = new CountOperation(this, applySkipLimit, opts);
        return executeOperation(this.topology, countOperation, callback);
      }
      close(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = Object.assign({}, {skipKillCursors: false}, options2);
        return maybePromise(this, callback, (cb) => {
          this.s.state = CursorState.CLOSED;
          if (!options2.skipKillCursors) {
            this.kill();
          }
          this._endSession(() => {
            this.emit("close");
            cb(null, this);
          });
        });
      }
      map(transform) {
        if (this.cursorState.transforms && this.cursorState.transforms.doc) {
          const oldTransform = this.cursorState.transforms.doc;
          this.cursorState.transforms.doc = (doc2) => {
            return transform(oldTransform(doc2));
          };
        } else {
          this.cursorState.transforms = {doc: transform};
        }
        return this;
      }
      isClosed() {
        return this.isDead();
      }
      destroy(err) {
        if (err)
          this.emit("error", err);
        this.pause();
        this.close();
      }
      stream(options2) {
        this.cursorState.streamOptions = options2 || {};
        return this;
      }
      transformStream(options2) {
        const streamOptions = options2 || {};
        if (typeof streamOptions.transform === "function") {
          const stream = new Transform({
            objectMode: true,
            transform: function(chunk, encoding, callback) {
              this.push(streamOptions.transform(chunk));
              callback();
            }
          });
          return this.pipe(stream);
        }
        return this.pipe(new PassThrough2({objectMode: true}));
      }
      explain(verbosity, callback) {
        if (typeof verbosity === "function")
          callback = verbosity, verbosity = true;
        if (verbosity === void 0)
          verbosity = true;
        if (!this.operation || !this.operation.hasAspect(Aspect.EXPLAINABLE)) {
          throw new MongoError("This command cannot be explained");
        }
        this.operation.explain = new Explain(verbosity);
        return maybePromise(this, callback, (cb) => {
          CoreCursor.prototype._next.apply(this, [cb]);
        });
      }
      getLogger() {
        return this.logger;
      }
    };
    Cursor.prototype.maxTimeMs = Cursor.prototype.maxTimeMS;
    deprecate(Cursor.prototype.each, "Cursor.each is deprecated. Use Cursor.forEach instead.");
    deprecate(Cursor.prototype.maxScan, "Cursor.maxScan is deprecated, and will be removed in a later version");
    deprecate(Cursor.prototype.snapshot, "Cursor Snapshot is deprecated, and will be removed in a later version");
    module2.exports = Cursor;
  }
});

// node_modules/mongodb/lib/operations/command_v2.js
var require_command_v2 = __commonJS({
  "node_modules/mongodb/lib/operations/command_v2.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_core().ReadPreference;
    var ReadConcern = require_read_concern();
    var WriteConcern = require_write_concern();
    var maxWireVersion = require_utils2().maxWireVersion;
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var commandSupportsReadConcern = require_sessions().commandSupportsReadConcern;
    var MongoError = require_error().MongoError;
    var SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;
    var CommandOperationV2 = class extends OperationBase {
      constructor(parent, options2, operationOptions) {
        super(options2);
        this.ns = parent.s.namespace.withCollection("$cmd");
        const propertyProvider = this.hasAspect(Aspect.NO_INHERIT_OPTIONS) ? void 0 : parent;
        this.readPreference = this.hasAspect(Aspect.WRITE_OPERATION) ? ReadPreference.primary : ReadPreference.resolve(propertyProvider, this.options);
        this.readConcern = resolveReadConcern(propertyProvider, this.options);
        this.writeConcern = resolveWriteConcern(propertyProvider, this.options);
        if (operationOptions && typeof operationOptions.fullResponse === "boolean") {
          this.fullResponse = true;
        }
        this.options.readPreference = this.readPreference;
        if (parent.s.logger) {
          this.logger = parent.s.logger;
        } else if (parent.s.db && parent.s.db.logger) {
          this.logger = parent.s.db.logger;
        }
      }
      executeCommand(server, cmd2, callback) {
        this.server = server;
        const options2 = this.options;
        const serverWireVersion = maxWireVersion(server);
        const inTransaction = this.session && this.session.inTransaction();
        if (this.readConcern && commandSupportsReadConcern(cmd2) && !inTransaction) {
          Object.assign(cmd2, {readConcern: this.readConcern});
        }
        if (options2.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
          callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
          return;
        }
        if (serverWireVersion >= SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
          if (this.writeConcern && this.hasAspect(Aspect.WRITE_OPERATION)) {
            Object.assign(cmd2, {writeConcern: this.writeConcern});
          }
          if (options2.collation && typeof options2.collation === "object") {
            Object.assign(cmd2, {collation: options2.collation});
          }
        }
        if (typeof options2.maxTimeMS === "number") {
          cmd2.maxTimeMS = options2.maxTimeMS;
        }
        if (typeof options2.comment === "string") {
          cmd2.comment = options2.comment;
        }
        if (this.hasAspect(Aspect.EXPLAINABLE) && this.explain) {
          if (serverWireVersion < 6 && cmd2.aggregate) {
            cmd2.explain = true;
          } else {
            cmd2 = decorateWithExplain(cmd2, this.explain);
          }
        }
        if (this.logger && this.logger.isDebug()) {
          this.logger.debug(`executing command ${JSON.stringify(cmd2)} against ${this.ns}`);
        }
        server.command(this.ns.toString(), cmd2, this.options, (err, result) => {
          if (err) {
            callback(err, null);
            return;
          }
          if (this.fullResponse) {
            callback(null, result);
            return;
          }
          callback(null, result.result);
        });
      }
    };
    function resolveWriteConcern(parent, options2) {
      return WriteConcern.fromOptions(options2) || parent && parent.writeConcern;
    }
    function resolveReadConcern(parent, options2) {
      return ReadConcern.fromOptions(options2) || parent && parent.readConcern;
    }
    module2.exports = CommandOperationV2;
  }
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS({
  "node_modules/mongodb/lib/operations/aggregate.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var MongoError = require_core().MongoError;
    var maxWireVersion = require_utils2().maxWireVersion;
    var ReadPreference = require_core().ReadPreference;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DB_AGGREGATE_COLLECTION = 1;
    var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
    var AggregateOperation = class extends CommandOperationV2 {
      constructor(parent, pipeline2, options2) {
        super(parent, options2, {fullResponse: true});
        this.target = parent.s.namespace && parent.s.namespace.collection ? parent.s.namespace.collection : DB_AGGREGATE_COLLECTION;
        this.pipeline = pipeline2;
        this.hasWriteStage = false;
        if (typeof options2.out === "string") {
          this.pipeline = this.pipeline.concat({$out: options2.out});
          this.hasWriteStage = true;
        } else if (pipeline2.length > 0) {
          const finalStage = pipeline2[pipeline2.length - 1];
          if (finalStage.$out || finalStage.$merge) {
            this.hasWriteStage = true;
          }
        }
        if (this.hasWriteStage) {
          this.readPreference = ReadPreference.primary;
        }
        if (this.explain && this.writeConcern) {
          throw new MongoError('"explain" cannot be used on an aggregate call with writeConcern');
        }
        if (options2.cursor != null && typeof options2.cursor !== "object") {
          throw new MongoError("cursor options must be an object");
        }
      }
      get canRetryRead() {
        return !this.hasWriteStage;
      }
      addToPipeline(stage) {
        this.pipeline.push(stage);
      }
      execute(server, callback) {
        const options2 = this.options;
        const serverWireVersion = maxWireVersion(server);
        const command2 = {aggregate: this.target, pipeline: this.pipeline};
        if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
          this.readConcern = null;
        }
        if (serverWireVersion >= 5) {
          if (this.hasWriteStage && this.writeConcern) {
            Object.assign(command2, {writeConcern: this.writeConcern});
          }
        }
        if (options2.bypassDocumentValidation === true) {
          command2.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        if (typeof options2.allowDiskUse === "boolean") {
          command2.allowDiskUse = options2.allowDiskUse;
        }
        if (options2.hint) {
          command2.hint = options2.hint;
        }
        if (this.explain) {
          options2.full = false;
        }
        command2.cursor = options2.cursor || {};
        if (options2.batchSize && !this.hasWriteStage) {
          command2.cursor.batchSize = options2.batchSize;
        }
        super.executeCommand(server, command2, callback);
      }
    };
    defineAspects(AggregateOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = AggregateOperation;
  }
});

// node_modules/mongodb/lib/bulk/common.js
var require_common2 = __commonJS({
  "node_modules/mongodb/lib/bulk/common.js"(exports2, module2) {
    "use strict";
    var Long2 = require_core().BSON.Long;
    var MongoError = require_core().MongoError;
    var ObjectID2 = require_core().BSON.ObjectID;
    var BSON2 = require_core().BSON;
    var MongoWriteConcernError = require_core().MongoWriteConcernError;
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var toError = require_utils4().toError;
    var handleCallback = require_utils4().handleCallback;
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var isPromiseLike = require_utils4().isPromiseLike;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var maxWireVersion = require_utils2().maxWireVersion;
    var WRITE_CONCERN_ERROR = 64;
    var INSERT = 1;
    var UPDATE = 2;
    var REMOVE = 3;
    var bson = new BSON2([
      BSON2.Binary,
      BSON2.Code,
      BSON2.DBRef,
      BSON2.Decimal128,
      BSON2.Double,
      BSON2.Int32,
      BSON2.Long,
      BSON2.Map,
      BSON2.MaxKey,
      BSON2.MinKey,
      BSON2.ObjectId,
      BSON2.BSONRegExp,
      BSON2.Symbol,
      BSON2.Timestamp
    ]);
    var Batch = class {
      constructor(batchType, originalZeroIndex) {
        this.originalZeroIndex = originalZeroIndex;
        this.currentIndex = 0;
        this.originalIndexes = [];
        this.batchType = batchType;
        this.operations = [];
        this.size = 0;
        this.sizeBytes = 0;
      }
    };
    var BulkWriteResult = class {
      constructor(bulkResult) {
        this.result = bulkResult;
      }
      get insertedCount() {
        return typeof this.result.nInserted !== "number" ? 0 : this.result.nInserted;
      }
      get matchedCount() {
        return typeof this.result.nMatched !== "number" ? 0 : this.result.nMatched;
      }
      get modifiedCount() {
        return typeof this.result.nModified !== "number" ? 0 : this.result.nModified;
      }
      get deletedCount() {
        return typeof this.result.nRemoved !== "number" ? 0 : this.result.nRemoved;
      }
      get upsertedCount() {
        return !this.result.upserted ? 0 : this.result.upserted.length;
      }
      get upsertedIds() {
        const upserted = {};
        for (const doc2 of !this.result.upserted ? [] : this.result.upserted) {
          upserted[doc2.index] = doc2._id;
        }
        return upserted;
      }
      get insertedIds() {
        const inserted = {};
        for (const doc2 of !this.result.insertedIds ? [] : this.result.insertedIds) {
          inserted[doc2.index] = doc2._id;
        }
        return inserted;
      }
      get ok() {
        return this.result.ok;
      }
      get nInserted() {
        return this.result.nInserted;
      }
      get nUpserted() {
        return this.result.nUpserted;
      }
      get nMatched() {
        return this.result.nMatched;
      }
      get nModified() {
        return this.result.nModified;
      }
      get nRemoved() {
        return this.result.nRemoved;
      }
      getInsertedIds() {
        return this.result.insertedIds;
      }
      getUpsertedIds() {
        return this.result.upserted;
      }
      getUpsertedIdAt(index2) {
        return this.result.upserted[index2];
      }
      getRawResponse() {
        return this.result;
      }
      hasWriteErrors() {
        return this.result.writeErrors.length > 0;
      }
      getWriteErrorCount() {
        return this.result.writeErrors.length;
      }
      getWriteErrorAt(index2) {
        if (index2 < this.result.writeErrors.length) {
          return this.result.writeErrors[index2];
        }
        return null;
      }
      getWriteErrors() {
        return this.result.writeErrors;
      }
      getLastOp() {
        return this.result.lastOp;
      }
      getWriteConcernError() {
        if (this.result.writeConcernErrors.length === 0) {
          return null;
        } else if (this.result.writeConcernErrors.length === 1) {
          return this.result.writeConcernErrors[0];
        } else {
          let errmsg = "";
          for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
            const err = this.result.writeConcernErrors[i];
            errmsg = errmsg + err.errmsg;
            if (i === 0)
              errmsg = errmsg + " and ";
          }
          return new WriteConcernError({errmsg, code: WRITE_CONCERN_ERROR});
        }
      }
      toJSON() {
        return this.result;
      }
      toString() {
        return `BulkWriteResult(${this.toJSON(this.result)})`;
      }
      isOk() {
        return this.result.ok === 1;
      }
    };
    var WriteConcernError = class {
      constructor(err) {
        this.err = err;
      }
      get code() {
        return this.err.code;
      }
      get errmsg() {
        return this.err.errmsg;
      }
      toJSON() {
        return {code: this.err.code, errmsg: this.err.errmsg};
      }
      toString() {
        return `WriteConcernError(${this.err.errmsg})`;
      }
    };
    var WriteError = class {
      constructor(err) {
        this.err = err;
      }
      get code() {
        return this.err.code;
      }
      get index() {
        return this.err.index;
      }
      get errmsg() {
        return this.err.errmsg;
      }
      getOperation() {
        return this.err.op;
      }
      toJSON() {
        return {code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op};
      }
      toString() {
        return `WriteError(${JSON.stringify(this.toJSON())})`;
      }
    };
    function mergeBatchResults(batch, bulkResult, err, result) {
      if (err) {
        result = err;
      } else if (result && result.result) {
        result = result.result;
      } else if (result == null) {
        return;
      }
      if (result.ok === 0 && bulkResult.ok === 1) {
        bulkResult.ok = 0;
        const writeError = {
          index: 0,
          code: result.code || 0,
          errmsg: result.message,
          op: batch.operations[0]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
        return;
      } else if (result.ok === 0 && bulkResult.ok === 0) {
        return;
      }
      if (result.opTime || result.lastOp) {
        const opTime = result.lastOp || result.opTime;
        let lastOpTS = null;
        let lastOpT = null;
        if (opTime && opTime._bsontype === "Timestamp") {
          if (bulkResult.lastOp == null) {
            bulkResult.lastOp = opTime;
          } else if (opTime.greaterThan(bulkResult.lastOp)) {
            bulkResult.lastOp = opTime;
          }
        } else {
          if (bulkResult.lastOp) {
            lastOpTS = typeof bulkResult.lastOp.ts === "number" ? Long2.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;
            lastOpT = typeof bulkResult.lastOp.t === "number" ? Long2.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;
          }
          const opTimeTS = typeof opTime.ts === "number" ? Long2.fromNumber(opTime.ts) : opTime.ts;
          const opTimeT = typeof opTime.t === "number" ? Long2.fromNumber(opTime.t) : opTime.t;
          if (bulkResult.lastOp == null) {
            bulkResult.lastOp = opTime;
          } else if (opTimeTS.greaterThan(lastOpTS)) {
            bulkResult.lastOp = opTime;
          } else if (opTimeTS.equals(lastOpTS)) {
            if (opTimeT.greaterThan(lastOpT)) {
              bulkResult.lastOp = opTime;
            }
          }
        }
      }
      if (batch.batchType === INSERT && result.n) {
        bulkResult.nInserted = bulkResult.nInserted + result.n;
      }
      if (batch.batchType === REMOVE && result.n) {
        bulkResult.nRemoved = bulkResult.nRemoved + result.n;
      }
      let nUpserted = 0;
      if (Array.isArray(result.upserted)) {
        nUpserted = result.upserted.length;
        for (let i = 0; i < result.upserted.length; i++) {
          bulkResult.upserted.push({
            index: result.upserted[i].index + batch.originalZeroIndex,
            _id: result.upserted[i]._id
          });
        }
      } else if (result.upserted) {
        nUpserted = 1;
        bulkResult.upserted.push({
          index: batch.originalZeroIndex,
          _id: result.upserted
        });
      }
      if (batch.batchType === UPDATE && result.n) {
        const nModified = result.nModified;
        bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
        bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
        if (typeof nModified === "number") {
          bulkResult.nModified = bulkResult.nModified + nModified;
        } else {
          bulkResult.nModified = null;
        }
      }
      if (Array.isArray(result.writeErrors)) {
        for (let i = 0; i < result.writeErrors.length; i++) {
          const writeError = {
            index: batch.originalIndexes[result.writeErrors[i].index],
            code: result.writeErrors[i].code,
            errmsg: result.writeErrors[i].errmsg,
            op: batch.operations[result.writeErrors[i].index]
          };
          bulkResult.writeErrors.push(new WriteError(writeError));
        }
      }
      if (result.writeConcernError) {
        bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
      }
    }
    function executeCommands(bulkOperation, options2, callback) {
      if (bulkOperation.s.batches.length === 0) {
        return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));
      }
      const batch = bulkOperation.s.batches.shift();
      function resultHandler(err, result) {
        if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {
          return handleCallback(callback, err);
        }
        if (err)
          err.ok = 0;
        if (err instanceof MongoWriteConcernError) {
          return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);
        }
        const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
        const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
        if (mergeResult != null) {
          return handleCallback(callback, null, writeResult);
        }
        if (bulkOperation.handleWriteError(callback, writeResult))
          return;
        executeCommands(bulkOperation, options2, callback);
      }
      bulkOperation.finalOptionsHandler({options: options2, batch, resultHandler}, callback);
    }
    function handleMongoWriteConcernError(batch, bulkResult, err, callback) {
      mergeBatchResults(batch, bulkResult, null, err.result);
      const wrappedWriteConcernError = new WriteConcernError({
        errmsg: err.result.writeConcernError.errmsg,
        code: err.result.writeConcernError.result
      });
      return handleCallback(callback, new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)), null);
    }
    var BulkWriteError = class extends MongoError {
      constructor(error3, result) {
        const message = error3.err || error3.errmsg || error3.errMessage || error3;
        super(message);
        Object.assign(this, error3);
        this.name = "BulkWriteError";
        this.result = result;
      }
      get insertedCount() {
        return this.result.insertedCount;
      }
      get matchedCount() {
        return this.result.matchedCount;
      }
      get modifiedCount() {
        return this.result.modifiedCount;
      }
      get deletedCount() {
        return this.result.deletedCount;
      }
      get upsertedCount() {
        return this.result.upsertedCount;
      }
      get insertedIds() {
        return this.result.insertedIds;
      }
      get upsertedIds() {
        return this.result.upsertedIds;
      }
    };
    var FindOperators = class {
      constructor(bulkOperation) {
        this.s = bulkOperation.s;
      }
      update(updateDocument) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: updateDocument,
          multi: true,
          upsert
        };
        if (updateDocument.hint) {
          document2.hint = updateDocument.hint;
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      updateOne(updateDocument) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: updateDocument,
          multi: false,
          upsert
        };
        if (updateDocument.hint) {
          document2.hint = updateDocument.hint;
        }
        if (!hasAtomicOperators(updateDocument)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      replaceOne(replacement) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: replacement,
          multi: false,
          upsert
        };
        if (replacement.hint) {
          document2.hint = replacement.hint;
        }
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not use atomic operators");
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      upsert() {
        this.s.currentOp.upsert = true;
        return this;
      }
      deleteOne() {
        const document2 = {
          q: this.s.currentOp.selector,
          limit: 1
        };
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, REMOVE, document2);
      }
      delete() {
        const document2 = {
          q: this.s.currentOp.selector,
          limit: 0
        };
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, REMOVE, document2);
      }
      removeOne() {
        emitWarningOnce("bulk operation `removeOne` has been deprecated, please use `deleteOne`");
        return this.deleteOne();
      }
      remove() {
        emitWarningOnce("bulk operation `remove` has been deprecated, please use `delete`");
        return this.delete();
      }
    };
    var BulkOperationBase = class {
      constructor(topology, collection, options2, isOrdered) {
        this.isOrdered = isOrdered;
        options2 = options2 == null ? {} : options2;
        const namespace = collection.s.namespace;
        const executed = false;
        const currentOp = null;
        const bson2 = topology.bson;
        const isMaster = topology.lastIsMaster();
        const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
        const maxBsonObjectSize = isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;
        const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
        const maxWriteBatchSize = isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1e3;
        const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
        let finalOptions = Object.assign({}, options2);
        finalOptions = applyRetryableWrites(finalOptions, collection.s.db);
        finalOptions = applyWriteConcern(finalOptions, {collection}, options2);
        const writeConcern = finalOptions.writeConcern;
        const promiseLibrary = options2.promiseLibrary || Promise;
        const bulkResult = {
          ok: 1,
          writeErrors: [],
          writeConcernErrors: [],
          insertedIds: [],
          nInserted: 0,
          nUpserted: 0,
          nMatched: 0,
          nModified: 0,
          nRemoved: 0,
          upserted: []
        };
        this.s = {
          bulkResult,
          currentBatch: null,
          currentIndex: 0,
          currentBatchSize: 0,
          currentBatchSizeBytes: 0,
          currentInsertBatch: null,
          currentUpdateBatch: null,
          currentRemoveBatch: null,
          batches: [],
          writeConcern,
          maxBsonObjectSize,
          maxBatchSizeBytes,
          maxWriteBatchSize,
          maxKeySize,
          namespace,
          bson: bson2,
          topology,
          options: finalOptions,
          currentOp,
          executed,
          collection,
          promiseLibrary,
          err: null,
          checkKeys: typeof options2.checkKeys === "boolean" ? options2.checkKeys : true
        };
        if (options2.bypassDocumentValidation === true) {
          this.s.bypassDocumentValidation = true;
        }
      }
      insert(document2) {
        if (this.s.collection.s.db.options.forceServerObjectId !== true && document2._id == null)
          document2._id = new ObjectID2();
        return this.s.options.addToOperationsList(this, INSERT, document2);
      }
      find(selector) {
        if (!selector) {
          throw toError("Bulk find operation must specify a selector");
        }
        this.s.currentOp = {
          selector
        };
        return new FindOperators(this);
      }
      raw(op) {
        const key = Object.keys(op)[0];
        const forceServerObjectId = typeof this.s.options.forceServerObjectId === "boolean" ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
        if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {
          op[key].multi = op.updateOne || op.replaceOne ? false : true;
          return this.s.options.addToOperationsList(this, UPDATE, op[key]);
        }
        if (op.updateOne || op.updateMany || op.replaceOne) {
          if (op.replaceOne && hasAtomicOperators(op[key].replacement)) {
            throw new TypeError("Replacement document must not use atomic operators");
          } else if ((op.updateOne || op.updateMany) && !hasAtomicOperators(op[key].update)) {
            throw new TypeError("Update document requires atomic operators");
          }
          const multi = op.updateOne || op.replaceOne ? false : true;
          const operation = {
            q: op[key].filter,
            u: op[key].update || op[key].replacement,
            multi
          };
          if (op[key].hint) {
            operation.hint = op[key].hint;
          }
          if (this.isOrdered) {
            operation.upsert = op[key].upsert ? true : false;
            if (op.collation)
              operation.collation = op.collation;
          } else {
            if (op[key].upsert)
              operation.upsert = true;
          }
          if (op[key].arrayFilters) {
            if (maxWireVersion(this.s.topology) < 6) {
              throw new TypeError("arrayFilters are only supported on MongoDB 3.6+");
            }
            operation.arrayFilters = op[key].arrayFilters;
          }
          return this.s.options.addToOperationsList(this, UPDATE, operation);
        }
        if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {
          op[key].limit = op.removeOne ? 1 : 0;
          return this.s.options.addToOperationsList(this, REMOVE, op[key]);
        }
        if (op.deleteOne || op.deleteMany) {
          const limit = op.deleteOne ? 1 : 0;
          const operation = {q: op[key].filter, limit};
          if (op[key].hint) {
            operation.hint = op[key].hint;
          }
          if (this.isOrdered) {
            if (op.collation)
              operation.collation = op.collation;
          }
          return this.s.options.addToOperationsList(this, REMOVE, operation);
        }
        if (op.insertOne && op.insertOne.document == null) {
          if (forceServerObjectId !== true && op.insertOne._id == null)
            op.insertOne._id = new ObjectID2();
          return this.s.options.addToOperationsList(this, INSERT, op.insertOne);
        } else if (op.insertOne && op.insertOne.document) {
          if (forceServerObjectId !== true && op.insertOne.document._id == null)
            op.insertOne.document._id = new ObjectID2();
          return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);
        }
        if (op.insertMany) {
          emitWarningOnce("bulk operation `insertMany` has been deprecated; use multiple `insertOne` ops instead");
          for (let i = 0; i < op.insertMany.length; i++) {
            if (forceServerObjectId !== true && op.insertMany[i]._id == null)
              op.insertMany[i]._id = new ObjectID2();
            this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);
          }
          return;
        }
        throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
      }
      _handleEarlyError(err, callback) {
        if (typeof callback === "function") {
          callback(err, null);
          return;
        }
        return this.s.promiseLibrary.reject(err);
      }
      bulkExecute(_writeConcern, options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = options2 || {};
        if (typeof _writeConcern === "function") {
          callback = _writeConcern;
        } else if (_writeConcern && typeof _writeConcern === "object") {
          this.s.writeConcern = _writeConcern;
        }
        if (this.s.executed) {
          const executedError = toError("batch cannot be re-executed");
          return this._handleEarlyError(executedError, callback);
        }
        if (this.isOrdered) {
          if (this.s.currentBatch)
            this.s.batches.push(this.s.currentBatch);
        } else {
          if (this.s.currentInsertBatch)
            this.s.batches.push(this.s.currentInsertBatch);
          if (this.s.currentUpdateBatch)
            this.s.batches.push(this.s.currentUpdateBatch);
          if (this.s.currentRemoveBatch)
            this.s.batches.push(this.s.currentRemoveBatch);
        }
        if (this.s.batches.length === 0) {
          const emptyBatchError = toError("Invalid Operation, no operations specified");
          return this._handleEarlyError(emptyBatchError, callback);
        }
        return {options: options2, callback};
      }
      execute(_writeConcern, options2, callback) {
        const ret = this.bulkExecute(_writeConcern, options2, callback);
        if (!ret || isPromiseLike(ret)) {
          return ret;
        }
        options2 = ret.options;
        callback = ret.callback;
        return executeLegacyOperation(this.s.topology, executeCommands, [this, options2, callback]);
      }
      finalOptionsHandler(config2, callback) {
        const finalOptions = Object.assign({ordered: this.isOrdered}, config2.options);
        if (this.s.writeConcern != null) {
          finalOptions.writeConcern = this.s.writeConcern;
        }
        if (finalOptions.bypassDocumentValidation !== true) {
          delete finalOptions.bypassDocumentValidation;
        }
        if (this.operationId) {
          config2.resultHandler.operationId = this.operationId;
        }
        if (this.s.options.serializeFunctions) {
          finalOptions.serializeFunctions = true;
        }
        if (this.s.options.ignoreUndefined) {
          finalOptions.ignoreUndefined = true;
        }
        if (this.s.bypassDocumentValidation === true) {
          finalOptions.bypassDocumentValidation = true;
        }
        if (this.s.checkKeys === false) {
          finalOptions.checkKeys = false;
        }
        if (finalOptions.retryWrites) {
          if (config2.batch.batchType === UPDATE) {
            finalOptions.retryWrites = finalOptions.retryWrites && !config2.batch.operations.some((op) => op.multi);
          }
          if (config2.batch.batchType === REMOVE) {
            finalOptions.retryWrites = finalOptions.retryWrites && !config2.batch.operations.some((op) => op.limit === 0);
          }
        }
        try {
          if (config2.batch.batchType === INSERT) {
            this.s.topology.insert(this.s.namespace, config2.batch.operations, finalOptions, config2.resultHandler);
          } else if (config2.batch.batchType === UPDATE) {
            this.s.topology.update(this.s.namespace, config2.batch.operations, finalOptions, config2.resultHandler);
          } else if (config2.batch.batchType === REMOVE) {
            this.s.topology.remove(this.s.namespace, config2.batch.operations, finalOptions, config2.resultHandler);
          }
        } catch (err) {
          err.ok = 0;
          handleCallback(callback, null, mergeBatchResults(config2.batch, this.s.bulkResult, err, null));
        }
      }
      handleWriteError(callback, writeResult) {
        if (this.s.bulkResult.writeErrors.length > 0) {
          const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
          handleCallback(callback, new BulkWriteError(toError({
            message: msg,
            code: this.s.bulkResult.writeErrors[0].code,
            writeErrors: this.s.bulkResult.writeErrors
          }), writeResult), null);
          return true;
        }
        if (writeResult.getWriteConcernError()) {
          handleCallback(callback, new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult), null);
          return true;
        }
      }
    };
    Object.defineProperty(BulkOperationBase.prototype, "length", {
      enumerable: true,
      get: function() {
        return this.s.currentIndex;
      }
    });
    module2.exports = {
      Batch,
      BulkOperationBase,
      bson,
      INSERT,
      UPDATE,
      REMOVE,
      BulkWriteError
    };
  }
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS({
  "node_modules/mongodb/lib/bulk/unordered.js"(exports2, module2) {
    "use strict";
    var common = require_common2();
    var BulkOperationBase = common.BulkOperationBase;
    var Batch = common.Batch;
    var bson = common.bson;
    var utils2 = require_utils4();
    var toError = utils2.toError;
    function addToOperationsList(bulkOperation, docType, document2) {
      const bsonSize = bson.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
        throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
      bulkOperation.s.currentBatch = null;
      if (docType === common.INSERT) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;
      } else if (docType === common.UPDATE) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;
      } else if (docType === common.REMOVE) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;
      }
      const maxKeySize = bulkOperation.s.maxKeySize;
      if (bulkOperation.s.currentBatch == null)
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      if (bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatch.size > 0 && bulkOperation.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
        bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      }
      if (Array.isArray(document2)) {
        throw toError("operation passed in cannot be an Array");
      }
      bulkOperation.s.currentBatch.operations.push(document2);
      bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
      bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;
      if (docType === common.INSERT) {
        bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;
        bulkOperation.s.bulkResult.insertedIds.push({
          index: bulkOperation.s.bulkResult.insertedIds.length,
          _id: document2._id
        });
      } else if (docType === common.UPDATE) {
        bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;
      } else if (docType === common.REMOVE) {
        bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;
      }
      bulkOperation.s.currentBatch.size += 1;
      bulkOperation.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
      return bulkOperation;
    }
    var UnorderedBulkOperation = class extends BulkOperationBase {
      constructor(topology, collection, options2) {
        options2 = options2 || {};
        options2 = Object.assign(options2, {addToOperationsList});
        super(topology, collection, options2, false);
      }
      handleWriteError(callback, writeResult) {
        if (this.s.batches.length) {
          return false;
        }
        return super.handleWriteError(callback, writeResult);
      }
    };
    function initializeUnorderedBulkOp(topology, collection, options2) {
      return new UnorderedBulkOperation(topology, collection, options2);
    }
    initializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;
    module2.exports = initializeUnorderedBulkOp;
    module2.exports.Bulk = UnorderedBulkOperation;
  }
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS({
  "node_modules/mongodb/lib/bulk/ordered.js"(exports2, module2) {
    "use strict";
    var common = require_common2();
    var BulkOperationBase = common.BulkOperationBase;
    var Batch = common.Batch;
    var bson = common.bson;
    var utils2 = require_utils4();
    var toError = utils2.toError;
    function addToOperationsList(bulkOperation, docType, document2) {
      const bsonSize = bson.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
        throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
      if (bulkOperation.s.currentBatch == null)
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      const maxKeySize = bulkOperation.s.maxKeySize;
      if (bulkOperation.s.currentBatchSize + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatchSize > 0 && bulkOperation.s.currentBatchSizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
        bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
        bulkOperation.s.currentBatchSize = 0;
        bulkOperation.s.currentBatchSizeBytes = 0;
      }
      if (docType === common.INSERT) {
        bulkOperation.s.bulkResult.insertedIds.push({
          index: bulkOperation.s.currentIndex,
          _id: document2._id
        });
      }
      if (Array.isArray(document2)) {
        throw toError("operation passed in cannot be an Array");
      }
      bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
      bulkOperation.s.currentBatch.operations.push(document2);
      bulkOperation.s.currentBatchSize += 1;
      bulkOperation.s.currentBatchSizeBytes += maxKeySize + bsonSize;
      bulkOperation.s.currentIndex += 1;
      return bulkOperation;
    }
    var OrderedBulkOperation = class extends BulkOperationBase {
      constructor(topology, collection, options2) {
        options2 = options2 || {};
        options2 = Object.assign(options2, {addToOperationsList});
        super(topology, collection, options2, true);
      }
    };
    function initializeOrderedBulkOp(topology, collection, options2) {
      return new OrderedBulkOperation(topology, collection, options2);
    }
    initializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;
    module2.exports = initializeOrderedBulkOp;
    module2.exports.Bulk = OrderedBulkOperation;
  }
});

// node_modules/mongodb/lib/aggregation_cursor.js
var require_aggregation_cursor = __commonJS({
  "node_modules/mongodb/lib/aggregation_cursor.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var CursorState = require_cursor().CursorState;
    var AggregationCursor = class extends Cursor {
      constructor(topology, operation, options2) {
        super(topology, operation, options2);
      }
      batchSize(value) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (typeof value !== "number") {
          throw MongoError.create({message: "batchSize requires an integer", driver: true});
        }
        this.operation.options.batchSize = value;
        this.setCursorBatchSize(value);
        return this;
      }
      geoNear(document2) {
        this.operation.addToPipeline({$geoNear: document2});
        return this;
      }
      group(document2) {
        this.operation.addToPipeline({$group: document2});
        return this;
      }
      limit(value) {
        this.operation.addToPipeline({$limit: value});
        return this;
      }
      match(document2) {
        this.operation.addToPipeline({$match: document2});
        return this;
      }
      maxTimeMS(value) {
        this.operation.options.maxTimeMS = value;
        return this;
      }
      out(destination) {
        this.operation.addToPipeline({$out: destination});
        return this;
      }
      project(document2) {
        this.operation.addToPipeline({$project: document2});
        return this;
      }
      lookup(document2) {
        this.operation.addToPipeline({$lookup: document2});
        return this;
      }
      redact(document2) {
        this.operation.addToPipeline({$redact: document2});
        return this;
      }
      skip(value) {
        this.operation.addToPipeline({$skip: value});
        return this;
      }
      sort(document2) {
        this.operation.addToPipeline({$sort: document2});
        return this;
      }
      unwind(field) {
        this.operation.addToPipeline({$unwind: field});
        return this;
      }
      getLogger() {
        return this.logger;
      }
    };
    AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;
    module2.exports = AggregationCursor;
  }
});

// node_modules/mongodb/lib/command_cursor.js
var require_command_cursor = __commonJS({
  "node_modules/mongodb/lib/command_cursor.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var CursorState = require_cursor().CursorState;
    var CommandCursor = class extends Cursor {
      constructor(topology, ns, cmd2, options2) {
        super(topology, ns, cmd2, options2);
      }
      setReadPreference(readPreference) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (this.s.state !== CursorState.INIT) {
          throw MongoError.create({
            message: "cannot change cursor readPreference after cursor has been accessed",
            driver: true
          });
        }
        if (readPreference instanceof ReadPreference) {
          this.options.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.options.readPreference = new ReadPreference(readPreference);
        } else {
          throw new TypeError("Invalid read preference: " + readPreference);
        }
        return this;
      }
      batchSize(value) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (typeof value !== "number") {
          throw MongoError.create({message: "batchSize requires an integer", driver: true});
        }
        if (this.cmd.cursor) {
          this.cmd.cursor.batchSize = value;
        }
        this.setCursorBatchSize(value);
        return this;
      }
      maxTimeMS(value) {
        if (this.topology.lastIsMaster().minWireVersion > 2) {
          this.cmd.maxTimeMS = value;
        }
        return this;
      }
      getLogger() {
        return this.logger;
      }
    };
    CommandCursor.prototype.get = CommandCursor.prototype.toArray;
    module2.exports = CommandCursor;
  }
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS({
  "node_modules/mongodb/lib/operations/bulk_write.js"(exports2, module2) {
    "use strict";
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var MongoError = require_core().MongoError;
    var OperationBase = require_operation().OperationBase;
    var BulkWriteOperation = class extends OperationBase {
      constructor(collection, operations, options2) {
        super(options2);
        this.collection = collection;
        this.operations = operations;
      }
      execute(callback) {
        const coll = this.collection;
        const operations = this.operations;
        let options2 = this.options;
        if (coll.s.options.ignoreUndefined) {
          options2 = Object.assign({}, options2);
          options2.ignoreUndefined = coll.s.options.ignoreUndefined;
        }
        const bulk = options2.ordered === true || options2.ordered == null ? coll.initializeOrderedBulkOp(options2) : coll.initializeUnorderedBulkOp(options2);
        let collation = false;
        try {
          for (let i = 0; i < operations.length; i++) {
            const key = Object.keys(operations[i])[0];
            if (operations[i][key].collation) {
              collation = true;
            }
            bulk.raw(operations[i]);
          }
        } catch (err) {
          return callback(err, null);
        }
        let finalOptions = Object.assign({}, options2);
        finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
        finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options2);
        const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
        const capabilities = coll.s.topology.capabilities();
        if (collation && capabilities && !capabilities.commandsTakeCollation) {
          return callback(new MongoError("server/primary/mongos does not support collation"));
        }
        bulk.execute(writeCon, finalOptions, (err, r) => {
          if (!r && err) {
            return callback(err, null);
          }
          r.n = r.insertedCount;
          const inserted = r.getInsertedIds();
          for (let i = 0; i < inserted.length; i++) {
            r.insertedIds[inserted[i].index] = inserted[i]._id;
          }
          const upserted = r.getUpsertedIds();
          for (let i = 0; i < upserted.length; i++) {
            r.upsertedIds[upserted[i].index] = upserted[i]._id;
          }
          callback(null, r);
        });
      }
    };
    module2.exports = BulkWriteOperation;
  }
});

// node_modules/mongodb/lib/operations/count_documents.js
var require_count_documents = __commonJS({
  "node_modules/mongodb/lib/operations/count_documents.js"(exports2, module2) {
    "use strict";
    var AggregateOperation = require_aggregate();
    var CountDocumentsOperation = class extends AggregateOperation {
      constructor(collection, query, options2) {
        const pipeline2 = [{$match: query}];
        if (typeof options2.skip === "number") {
          pipeline2.push({$skip: options2.skip});
        }
        if (typeof options2.limit === "number") {
          pipeline2.push({$limit: options2.limit});
        }
        pipeline2.push({$group: {_id: 1, n: {$sum: 1}}});
        super(collection, pipeline2, options2);
      }
      execute(server, callback) {
        super.execute(server, (err, result) => {
          if (err) {
            callback(err, null);
            return;
          }
          const response = result.result;
          if (response.cursor == null || response.cursor.firstBatch == null) {
            callback(null, 0);
            return;
          }
          const docs = response.cursor.firstBatch;
          callback(null, docs.length ? docs[0].n : 0);
        });
      }
    };
    module2.exports = CountDocumentsOperation;
  }
});

// node_modules/mongodb/lib/operations/create_indexes.js
var require_create_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/create_indexes.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var MongoError = require_core().MongoError;
    var parseIndexOptions = require_utils4().parseIndexOptions;
    var maxWireVersion = require_utils2().maxWireVersion;
    var VALID_INDEX_OPTIONS = new Set([
      "background",
      "unique",
      "name",
      "partialFilterExpression",
      "sparse",
      "expireAfterSeconds",
      "storageEngine",
      "collation",
      "weights",
      "default_language",
      "language_override",
      "textIndexVersion",
      "2dsphereIndexVersion",
      "bits",
      "min",
      "max",
      "bucketSize",
      "wildcardProjection"
    ]);
    var CreateIndexesOperation = class extends CommandOperationV2 {
      constructor(parent, collection, indexes, options2) {
        super(parent, options2);
        this.collection = collection;
        if (!Array.isArray(indexes) || Array.isArray(indexes[0])) {
          this.onlyReturnNameOfCreatedIndex = true;
          const indexParameters = parseIndexOptions(indexes);
          const name2 = typeof options2.name === "string" ? options2.name : indexParameters.name;
          const indexSpec = {name: name2, key: indexParameters.fieldHash};
          for (let optionName in options2) {
            if (VALID_INDEX_OPTIONS.has(optionName)) {
              indexSpec[optionName] = options2[optionName];
            }
          }
          this.indexes = [indexSpec];
          return;
        }
        this.indexes = indexes;
      }
      execute(server, callback) {
        const options2 = this.options;
        const indexes = this.indexes;
        const serverWireVersion = maxWireVersion(server);
        for (let i = 0; i < indexes.length; i++) {
          if (indexes[i].collation && serverWireVersion < 5) {
            callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
            return;
          }
          if (indexes[i].name == null) {
            const keys = [];
            for (let name2 in indexes[i].key) {
              keys.push(`${name2}_${indexes[i].key[name2]}`);
            }
            indexes[i].name = keys.join("_");
          }
        }
        const cmd2 = {createIndexes: this.collection, indexes};
        if (options2.commitQuorum != null) {
          if (serverWireVersion < 9) {
            callback(new MongoError("`commitQuorum` option for `createIndexes` not supported on servers < 4.4"));
            return;
          }
          cmd2.commitQuorum = options2.commitQuorum;
        }
        this.options.collation = void 0;
        super.executeCommand(server, cmd2, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, this.onlyReturnNameOfCreatedIndex ? indexes[0].name : result);
        });
      }
    };
    defineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION, Aspect.EXECUTE_WITH_SELECTION]);
    module2.exports = CreateIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/delete_many.js
var require_delete_many = __commonJS({
  "node_modules/mongodb/lib/operations/delete_many.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var removeDocuments = require_common_functions().removeDocuments;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DeleteManyOperation = class extends OperationBase {
      constructor(collection, filter, options2) {
        super(options2);
        this.collection = collection;
        this.filter = filter;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const options2 = this.options;
        options2.single = false;
        removeDocuments(coll, filter, options2, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, {result: {ok: 1}});
          if (this.explain)
            return callback(void 0, r.result);
          r.deletedCount = r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(DeleteManyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = DeleteManyOperation;
  }
});

// node_modules/mongodb/lib/operations/delete_one.js
var require_delete_one = __commonJS({
  "node_modules/mongodb/lib/operations/delete_one.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var removeDocuments = require_common_functions().removeDocuments;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DeleteOneOperation = class extends OperationBase {
      constructor(collection, filter, options2) {
        super(options2);
        this.collection = collection;
        this.filter = filter;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const options2 = this.options;
        options2.single = true;
        removeDocuments(coll, filter, options2, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, {result: {ok: 1}});
          if (this.explain)
            return callback(void 0, r.result);
          r.deletedCount = r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(DeleteOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = DeleteOneOperation;
  }
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS({
  "node_modules/mongodb/lib/operations/distinct.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var DistinctOperation = class extends CommandOperationV2 {
      constructor(collection, key, query, options2) {
        super(collection, options2);
        this.collection = collection;
        this.key = key;
        this.query = query;
      }
      execute(server, callback) {
        const coll = this.collection;
        const key = this.key;
        const query = this.query;
        const options2 = this.options;
        const cmd2 = {
          distinct: coll.collectionName,
          key,
          query
        };
        if (typeof options2.maxTimeMS === "number") {
          cmd2.maxTimeMS = options2.maxTimeMS;
        }
        decorateWithReadConcern(cmd2, coll, options2);
        try {
          decorateWithCollation(cmd2, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        if (this.explain && maxWireVersion(server) < 4) {
          callback(new MongoError(`server does not support explain on distinct`));
          return;
        }
        super.executeCommand(server, cmd2, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, this.options.full || this.explain ? result : result.values);
        });
      }
    };
    defineAspects(DistinctOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = DistinctOperation;
  }
});

// node_modules/mongodb/lib/operations/command.js
var require_command2 = __commonJS({
  "node_modules/mongodb/lib/operations/command.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var debugOptions = require_utils4().debugOptions;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var debugFields = [
      "authSource",
      "w",
      "wtimeout",
      "j",
      "native_parser",
      "forceServerObjectId",
      "serializeFunctions",
      "raw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bufferMaxEntries",
      "numberOfRetries",
      "retryMiliSeconds",
      "readPreference",
      "pkFactory",
      "parentDb",
      "promiseLibrary",
      "noListener"
    ];
    var CommandOperation = class extends OperationBase {
      constructor(db, options2, collection, command2) {
        super(options2);
        if (!this.hasAspect(Aspect.WRITE_OPERATION)) {
          if (collection != null) {
            this.options.readPreference = ReadPreference.resolve(collection, options2);
          } else {
            this.options.readPreference = ReadPreference.resolve(db, options2);
          }
        } else {
          if (collection != null) {
            applyWriteConcern(this.options, {db, coll: collection}, this.options);
          } else {
            applyWriteConcern(this.options, {db}, this.options);
          }
          this.options.readPreference = ReadPreference.primary;
        }
        this.db = db;
        if (command2 != null) {
          this.command = command2;
        }
        if (collection != null) {
          this.collection = collection;
        }
      }
      _buildCommand() {
        if (this.command != null) {
          return this.command;
        }
      }
      execute(callback) {
        const db = this.db;
        const options2 = Object.assign({}, this.options);
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        let command2;
        try {
          command2 = this._buildCommand();
        } catch (e) {
          return callback(e);
        }
        const dbName = options2.dbName || options2.authdb || db.databaseName;
        if (this.hasAspect(Aspect.WRITE_OPERATION)) {
          if (options2.writeConcern && (!options2.session || !options2.session.inTransaction())) {
            command2.writeConcern = options2.writeConcern;
          }
        }
        if (db.s.logger.isDebug()) {
          db.s.logger.debug(`executing command ${JSON.stringify(command2)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options2))}]`);
        }
        const namespace = this.namespace != null ? this.namespace : new MongoDBNamespace(dbName, "$cmd");
        db.s.topology.command(namespace, command2, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (options2.full)
            return handleCallback(callback, null, result);
          handleCallback(callback, null, result.result);
        });
      }
    };
    module2.exports = CommandOperation;
  }
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS({
  "node_modules/mongodb/lib/operations/drop.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var handleCallback = require_utils4().handleCallback;
    var DropOperation = class extends CommandOperation {
      constructor(db, options2) {
        const finalOptions = Object.assign({}, options2, db.s.options);
        if (options2.session) {
          finalOptions.session = options2.session;
        }
        super(db, finalOptions);
      }
      execute(callback) {
        super.execute((err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (result.ok)
            return handleCallback(callback, null, true);
          handleCallback(callback, null, false);
        });
      }
    };
    defineAspects(DropOperation, Aspect.WRITE_OPERATION);
    var DropCollectionOperation = class extends DropOperation {
      constructor(db, name2, options2) {
        super(db, options2);
        this.name = name2;
        this.namespace = `${db.namespace}.${name2}`;
      }
      _buildCommand() {
        return {drop: this.name};
      }
    };
    var DropDatabaseOperation = class extends DropOperation {
      _buildCommand() {
        return {dropDatabase: 1};
      }
    };
    module2.exports = {
      DropOperation,
      DropCollectionOperation,
      DropDatabaseOperation
    };
  }
});

// node_modules/mongodb/lib/operations/drop_index.js
var require_drop_index = __commonJS({
  "node_modules/mongodb/lib/operations/drop_index.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperation = require_command2();
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var handleCallback = require_utils4().handleCallback;
    var DropIndexOperation = class extends CommandOperation {
      constructor(collection, indexName, options2) {
        super(collection.s.db, options2, collection);
        this.collection = collection;
        this.indexName = indexName;
      }
      _buildCommand() {
        const collection = this.collection;
        const indexName = this.indexName;
        const options2 = this.options;
        let cmd2 = {dropIndexes: collection.collectionName, index: indexName};
        cmd2 = applyWriteConcern(cmd2, {db: collection.s.db, collection}, options2);
        return cmd2;
      }
      execute(callback) {
        super.execute((err, result) => {
          if (typeof callback !== "function")
            return;
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, result);
        });
      }
    };
    defineAspects(DropIndexOperation, Aspect.WRITE_OPERATION);
    module2.exports = DropIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/drop_indexes.js
var require_drop_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/drop_indexes.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DropIndexOperation = require_drop_index();
    var handleCallback = require_utils4().handleCallback;
    var DropIndexesOperation = class extends DropIndexOperation {
      constructor(collection, options2) {
        super(collection, "*", options2);
      }
      execute(callback) {
        super.execute((err) => {
          if (err)
            return handleCallback(callback, err, false);
          handleCallback(callback, null, true);
        });
      }
    };
    defineAspects(DropIndexesOperation, Aspect.WRITE_OPERATION);
    module2.exports = DropIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS({
  "node_modules/mongodb/lib/operations/estimated_document_count.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var EstimatedDocumentCountOperation = class extends CommandOperationV2 {
      constructor(collection, query, options2) {
        if (typeof options2 === "undefined") {
          options2 = query;
          query = void 0;
        }
        super(collection, options2);
        this.collectionName = collection.s.namespace.collection;
        if (query) {
          this.query = query;
        }
      }
      execute(server, callback) {
        const options2 = this.options;
        const cmd2 = {count: this.collectionName};
        if (this.query) {
          cmd2.query = this.query;
        }
        if (typeof options2.skip === "number") {
          cmd2.skip = options2.skip;
        }
        if (typeof options2.limit === "number") {
          cmd2.limit = options2.limit;
        }
        if (options2.hint) {
          cmd2.hint = options2.hint;
        }
        super.executeCommand(server, cmd2, (err, response) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, response.n);
        });
      }
    };
    defineAspects(EstimatedDocumentCountOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = EstimatedDocumentCountOperation;
  }
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS({
  "node_modules/mongodb/lib/operations/find.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var ReadPreference = require_core().ReadPreference;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error().MongoError;
    var FindOperation = class extends OperationBase {
      constructor(collection, ns, command2, options2) {
        super(options2);
        this.ns = ns;
        this.cmd = command2;
        this.readPreference = ReadPreference.resolve(collection, this.options);
      }
      execute(server, callback) {
        this.server = server;
        this.readPreference = ReadPreference.resolve(this, this.options);
        if (typeof this.cmd.allowDiskUse !== "undefined" && maxWireVersion(server) < 4) {
          callback(new MongoError("The `allowDiskUse` option is not supported on MongoDB < 3.2"));
          return;
        }
        if (this.explain) {
          this.options.explain = this.explain.verbosity;
        }
        const cursorState = this.cursorState || {};
        server.query(this.ns.toString(), this.cmd, cursorState, this.options, callback);
      }
    };
    defineAspects(FindOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = FindOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one.js
var require_find_one = __commonJS({
  "node_modules/mongodb/lib/operations/find_one.js"(exports2, module2) {
    "use strict";
    var handleCallback = require_utils4().handleCallback;
    var OperationBase = require_operation().OperationBase;
    var toError = require_utils4().toError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var FindOneOperation = class extends OperationBase {
      constructor(collection, query, options2) {
        super(options2);
        this.collection = collection;
        this.query = query;
      }
      execute(callback) {
        const coll = this.collection;
        const query = this.query;
        const options2 = this.options;
        try {
          const cursor = coll.find(query, options2).limit(-1).batchSize(1);
          cursor.next((err, item) => {
            if (err != null)
              return handleCallback(callback, toError(err), null);
            handleCallback(callback, null, item);
          });
        } catch (e) {
          callback(e);
        }
      }
    };
    defineAspects(FindOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = FindOneOperation;
  }
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS({
  "node_modules/mongodb/lib/operations/find_and_modify.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var executeCommand = require_db_ops().executeCommand;
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var handleCallback = require_utils4().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var FindAndModifyOperation = class extends OperationBase {
      constructor(collection, query, sort, doc2, options2) {
        super(options2);
        this.collection = collection;
        this.query = query;
        this.sort = sort;
        this.doc = doc2;
      }
      execute(callback) {
        const coll = this.collection;
        const query = this.query;
        const sort = formattedOrderClause(this.sort);
        const doc2 = this.doc;
        let options2 = this.options;
        let queryObject = {
          findAndModify: coll.collectionName,
          query
        };
        if (sort) {
          queryObject.sort = sort;
        }
        queryObject.new = options2.new ? true : false;
        queryObject.remove = options2.remove ? true : false;
        queryObject.upsert = options2.upsert ? true : false;
        const projection = options2.projection || options2.fields;
        if (projection) {
          queryObject.fields = projection;
        }
        if (options2.arrayFilters) {
          queryObject.arrayFilters = options2.arrayFilters;
        }
        if (doc2 && !options2.remove) {
          queryObject.update = doc2;
        }
        if (options2.maxTimeMS)
          queryObject.maxTimeMS = options2.maxTimeMS;
        options2.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
        options2.checkKeys = false;
        options2 = applyRetryableWrites(options2, coll.s.db);
        options2 = applyWriteConcern(options2, {db: coll.s.db, collection: coll}, options2);
        if (options2.writeConcern) {
          queryObject.writeConcern = options2.writeConcern;
        }
        if (options2.bypassDocumentValidation === true) {
          queryObject.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        options2.readPreference = ReadPreference.primary;
        try {
          decorateWithCollation(queryObject, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        if (options2.hint) {
          const unacknowledgedWrite = options2.writeConcern && options2.writeConcern.w === 0;
          if (unacknowledgedWrite || maxWireVersion(coll.s.topology) < 8) {
            callback(new MongoError("The current topology does not support a hint on findAndModify commands"));
            return;
          }
          queryObject.hint = options2.hint;
        }
        if (this.explain) {
          if (maxWireVersion(coll.s.topology) < 4) {
            callback(new MongoError(`server does not support explain on findAndModify`));
            return;
          }
          queryObject = decorateWithExplain(queryObject, this.explain);
        }
        executeCommand(coll.s.db, queryObject, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          return handleCallback(callback, null, result);
        });
      }
    };
    defineAspects(FindAndModifyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = FindAndModifyOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_delete.js
var require_find_one_and_delete = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_delete.js"(exports2, module2) {
    "use strict";
    var FindAndModifyOperation = require_find_and_modify();
    var FindOneAndDeleteOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, options2) {
        const finalOptions = Object.assign({}, options2);
        finalOptions.fields = options2.projection;
        finalOptions.remove = true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        super(collection, filter, finalOptions.sort, null, finalOptions);
      }
    };
    module2.exports = FindOneAndDeleteOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_replace.js
var require_find_one_and_replace = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_replace.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var FindAndModifyOperation = require_find_and_modify();
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var FindOneAndReplaceOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, replacement, options2) {
        if ("returnDocument" in options2 && "returnOriginal" in options2) {
          throw new MongoError("findOneAndReplace option returnOriginal is deprecated in favor of returnDocument and cannot be combined");
        }
        const finalOptions = Object.assign({}, options2);
        finalOptions.fields = options2.projection;
        finalOptions.update = true;
        finalOptions.new = options2.returnDocument === "after" || options2.returnOriginal === false;
        finalOptions.upsert = options2.upsert === true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        if (replacement == null || typeof replacement !== "object") {
          throw new TypeError("Replacement parameter must be an object");
        }
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not contain atomic operators");
        }
        super(collection, filter, finalOptions.sort, replacement, finalOptions);
      }
    };
    module2.exports = FindOneAndReplaceOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_update.js
var require_find_one_and_update = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_update.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var FindAndModifyOperation = require_find_and_modify();
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var FindOneAndUpdateOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, update, options2) {
        if ("returnDocument" in options2 && "returnOriginal" in options2) {
          throw new MongoError("findOneAndUpdate option returnOriginal is deprecated in favor of returnDocument and cannot be combined");
        }
        const finalOptions = Object.assign({}, options2);
        finalOptions.fields = options2.projection;
        finalOptions.update = true;
        finalOptions.new = options2.returnDocument === "after" || options2.returnOriginal === false;
        finalOptions.upsert = options2.upsert === true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        if (update == null || typeof update !== "object") {
          throw new TypeError("Update parameter must be an object");
        }
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        super(collection, filter, finalOptions.sort, update, finalOptions);
      }
    };
    module2.exports = FindOneAndUpdateOperation;
  }
});

// node_modules/mongodb/lib/operations/geo_haystack_search.js
var require_geo_haystack_search = __commonJS({
  "node_modules/mongodb/lib/operations/geo_haystack_search.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var OperationBase = require_operation().OperationBase;
    var decorateCommand = require_utils4().decorateCommand;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils4().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var GeoHaystackSearchOperation = class extends OperationBase {
      constructor(collection, x, y, options2) {
        super(options2);
        this.collection = collection;
        this.x = x;
        this.y = y;
      }
      execute(callback) {
        const coll = this.collection;
        const x = this.x;
        const y = this.y;
        let options2 = this.options;
        let commandObject = {
          geoSearch: coll.collectionName,
          near: [x, y]
        };
        commandObject = decorateCommand(commandObject, options2, ["readPreference", "session"]);
        options2 = Object.assign({}, options2);
        options2.readPreference = ReadPreference.resolve(coll, options2);
        decorateWithReadConcern(commandObject, coll, options2);
        executeCommand(coll.s.db, commandObject, options2, (err, res) => {
          if (err)
            return handleCallback(callback, err);
          if (res.err || res.errmsg)
            handleCallback(callback, toError(res));
          handleCallback(callback, null, res);
        });
      }
    };
    defineAspects(GeoHaystackSearchOperation, Aspect.READ_OPERATION);
    module2.exports = GeoHaystackSearchOperation;
  }
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/indexes.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var indexInformation = require_common_functions().indexInformation;
    var IndexesOperation = class extends OperationBase {
      constructor(collection, options2) {
        super(options2);
        this.collection = collection;
      }
      execute(callback) {
        const coll = this.collection;
        let options2 = this.options;
        options2 = Object.assign({}, {full: true}, options2);
        indexInformation(coll.s.db, coll.collectionName, options2, callback);
      }
    };
    module2.exports = IndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/index_exists.js
var require_index_exists = __commonJS({
  "node_modules/mongodb/lib/operations/index_exists.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var indexInformationDb = require_db_ops().indexInformation;
    var IndexExistsOperation = class extends OperationBase {
      constructor(collection, indexes, options2) {
        super(options2);
        this.collection = collection;
        this.indexes = indexes;
      }
      execute(callback) {
        const coll = this.collection;
        const indexes = this.indexes;
        const options2 = this.options;
        indexInformationDb(coll.s.db, coll.collectionName, options2, (err, indexInformation) => {
          if (err != null)
            return handleCallback(callback, err, null);
          if (!Array.isArray(indexes))
            return handleCallback(callback, null, indexInformation[indexes] != null);
          for (let i = 0; i < indexes.length; i++) {
            if (indexInformation[indexes[i]] == null) {
              return handleCallback(callback, null, false);
            }
          }
          return handleCallback(callback, null, true);
        });
      }
    };
    module2.exports = IndexExistsOperation;
  }
});

// node_modules/mongodb/lib/operations/index_information.js
var require_index_information = __commonJS({
  "node_modules/mongodb/lib/operations/index_information.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var indexInformation = require_common_functions().indexInformation;
    var IndexInformationOperation = class extends OperationBase {
      constructor(db, name2, options2) {
        super(options2);
        this.db = db;
        this.name = name2;
      }
      execute(callback) {
        const db = this.db;
        const name2 = this.name;
        const options2 = this.options;
        indexInformation(db, name2, options2, callback);
      }
    };
    module2.exports = IndexInformationOperation;
  }
});

// node_modules/mongodb/lib/operations/insert_many.js
var require_insert_many = __commonJS({
  "node_modules/mongodb/lib/operations/insert_many.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var BulkWriteOperation = require_bulk_write();
    var MongoError = require_core().MongoError;
    var prepareDocs = require_common_functions().prepareDocs;
    var InsertManyOperation = class extends OperationBase {
      constructor(collection, docs, options2) {
        super(options2);
        this.collection = collection;
        this.docs = docs;
      }
      execute(callback) {
        const coll = this.collection;
        let docs = this.docs;
        const options2 = this.options;
        if (!Array.isArray(docs)) {
          return callback(MongoError.create({message: "docs parameter must be an array of documents", driver: true}));
        }
        options2["serializeFunctions"] = options2["serializeFunctions"] || coll.s.serializeFunctions;
        docs = prepareDocs(coll, docs, options2);
        const operations = docs.map((document2) => ({insertOne: {document: document2}}));
        const bulkWriteOperation = new BulkWriteOperation(coll, operations, options2);
        bulkWriteOperation.execute((err, result) => {
          if (err)
            return callback(err, null);
          callback(null, mapInsertManyResults(docs, result));
        });
      }
    };
    function mapInsertManyResults(docs, r) {
      const finalResult = {
        result: {ok: 1, n: r.insertedCount},
        ops: docs,
        insertedCount: r.insertedCount,
        insertedIds: r.insertedIds
      };
      if (r.getLastOp()) {
        finalResult.result.opTime = r.getLastOp();
      }
      return finalResult;
    }
    module2.exports = InsertManyOperation;
  }
});

// node_modules/mongodb/lib/operations/insert_one.js
var require_insert_one = __commonJS({
  "node_modules/mongodb/lib/operations/insert_one.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var OperationBase = require_operation().OperationBase;
    var insertDocuments = require_common_functions().insertDocuments;
    var InsertOneOperation = class extends OperationBase {
      constructor(collection, doc2, options2) {
        super(options2);
        this.collection = collection;
        this.doc = doc2;
      }
      execute(callback) {
        const coll = this.collection;
        const doc2 = this.doc;
        const options2 = this.options;
        if (Array.isArray(doc2)) {
          return callback(MongoError.create({message: "doc parameter must be an object", driver: true}));
        }
        insertDocuments(coll, [doc2], options2, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, {result: {ok: 1}});
          r.insertedCount = r.result.n;
          r.insertedId = doc2._id;
          if (callback)
            callback(null, r);
        });
      }
    };
    module2.exports = InsertOneOperation;
  }
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS({
  "node_modules/mongodb/lib/operations/options_operation.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var OptionsOperation = class extends OperationBase {
      constructor(collection, options2) {
        super(options2);
        this.collection = collection;
      }
      execute(callback) {
        const coll = this.collection;
        const opts = this.options;
        coll.s.db.listCollections({name: coll.collectionName}, opts).toArray((err, collections) => {
          if (err)
            return handleCallback(callback, err);
          if (collections.length === 0) {
            return handleCallback(callback, MongoError.create({message: `collection ${coll.namespace} not found`, driver: true}));
          }
          handleCallback(callback, err, collections[0].options || null);
        });
      }
    };
    module2.exports = OptionsOperation;
  }
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS({
  "node_modules/mongodb/lib/operations/is_capped.js"(exports2, module2) {
    "use strict";
    var OptionsOperation = require_options_operation();
    var handleCallback = require_utils4().handleCallback;
    var IsCappedOperation = class extends OptionsOperation {
      constructor(collection, options2) {
        super(collection, options2);
      }
      execute(callback) {
        super.execute((err, document2) => {
          if (err)
            return handleCallback(callback, err);
          handleCallback(callback, null, !!(document2 && document2.capped));
        });
      }
    };
    module2.exports = IsCappedOperation;
  }
});

// node_modules/mongodb/lib/operations/list_indexes.js
var require_list_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/list_indexes.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var maxWireVersion = require_utils2().maxWireVersion;
    var LIST_INDEXES_WIRE_VERSION = 3;
    var ListIndexesOperation = class extends CommandOperationV2 {
      constructor(collection, options2) {
        super(collection, options2, {fullResponse: true});
        this.collectionNamespace = collection.s.namespace;
      }
      execute(server, callback) {
        const serverWireVersion = maxWireVersion(server);
        if (serverWireVersion < LIST_INDEXES_WIRE_VERSION) {
          const systemIndexesNS = this.collectionNamespace.withCollection("system.indexes").toString();
          const collectionNS = this.collectionNamespace.toString();
          server.query(systemIndexesNS, {query: {ns: collectionNS}}, {}, this.options, callback);
          return;
        }
        const cursor = this.options.batchSize ? {batchSize: this.options.batchSize} : {};
        super.executeCommand(server, {listIndexes: this.collectionNamespace.collection, cursor}, callback);
      }
    };
    defineAspects(ListIndexesOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/add_user.js
var require_add_user = __commonJS({
  "node_modules/mongodb/lib/operations/add_user.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var crypto = require("crypto");
    var handleCallback = require_utils4().handleCallback;
    var toError = require_utils4().toError;
    var emitWarning = require_utils4().emitWarning;
    var AddUserOperation = class extends CommandOperation {
      constructor(db, username, password, options2) {
        super(db, options2);
        this.username = username;
        this.password = password;
      }
      _buildCommand() {
        const db = this.db;
        const username = this.username;
        const password = this.password;
        const options2 = this.options;
        let roles = [];
        if (Array.isArray(options2.roles))
          roles = options2.roles;
        if (typeof options2.roles === "string")
          roles = [options2.roles];
        if (roles.length === 0) {
          emitWarning("Creating a user without roles is deprecated in MongoDB >= 2.6");
        }
        if ((db.databaseName.toLowerCase() === "admin" || options2.dbName === "admin") && !Array.isArray(options2.roles)) {
          roles = ["root"];
        } else if (!Array.isArray(options2.roles)) {
          roles = ["dbOwner"];
        }
        const digestPassword = db.s.topology.lastIsMaster().maxWireVersion >= 7;
        let userPassword = password;
        if (!digestPassword) {
          const md5 = crypto.createHash("md5");
          md5.update(username + ":mongo:" + password);
          userPassword = md5.digest("hex");
        }
        const command2 = {
          createUser: username,
          customData: options2.customData || {},
          roles,
          digestPassword
        };
        if (typeof password === "string") {
          command2.pwd = userPassword;
        }
        return command2;
      }
      execute(callback) {
        const options2 = this.options;
        if (options2.digestPassword != null) {
          return callback(toError("The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option."));
        }
        super.execute((err, r) => {
          if (!err) {
            return handleCallback(callback, err, r);
          }
          return handleCallback(callback, err, null);
        });
      }
    };
    defineAspects(AddUserOperation, Aspect.WRITE_OPERATION);
    module2.exports = AddUserOperation;
  }
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS({
  "node_modules/mongodb/lib/operations/collections.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var collection;
    function loadCollection() {
      if (!collection) {
        collection = require_collection();
      }
      return collection;
    }
    var CollectionsOperation = class extends OperationBase {
      constructor(db, options2) {
        super(options2);
        this.db = db;
      }
      execute(callback) {
        const db = this.db;
        let options2 = this.options;
        let Collection = loadCollection();
        options2 = Object.assign({}, options2, {nameOnly: true});
        db.listCollections({}, options2).toArray((err, documents) => {
          if (err != null)
            return handleCallback(callback, err, null);
          documents = documents.filter((doc2) => {
            return doc2.name.indexOf("$") === -1;
          });
          handleCallback(callback, null, documents.map((d) => {
            return new Collection(db, db.s.topology, db.databaseName, d.name, db.s.pkFactory, db.s.options);
          }));
        });
      }
    };
    module2.exports = CollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS({
  "node_modules/mongodb/lib/operations/run_command.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var defineAspects = require_operation().defineAspects;
    var Aspect = require_operation().Aspect;
    var RunCommandOperation = class extends CommandOperationV2 {
      constructor(parent, command2, options2) {
        super(parent, options2);
        this.command = command2;
      }
      execute(server, callback) {
        const command2 = this.command;
        this.executeCommand(server, command2, callback);
      }
    };
    defineAspects(RunCommandOperation, [Aspect.EXECUTE_WITH_SELECTION, Aspect.NO_INHERIT_OPTIONS]);
    module2.exports = RunCommandOperation;
  }
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS({
  "node_modules/mongodb/lib/operations/create_collection.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperation = require_command2();
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var loadCollection = require_dynamic_loaders().loadCollection;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var ILLEGAL_COMMAND_FIELDS = new Set([
      "w",
      "wtimeout",
      "j",
      "fsync",
      "autoIndexId",
      "strict",
      "serializeFunctions",
      "pkFactory",
      "raw",
      "readPreference",
      "session",
      "readConcern",
      "writeConcern"
    ]);
    var CreateCollectionOperation = class extends CommandOperation {
      constructor(db, name2, options2) {
        super(db, options2);
        this.name = name2;
      }
      _buildCommand() {
        const name2 = this.name;
        const options2 = this.options;
        const cmd2 = {create: name2};
        for (let n in options2) {
          if (options2[n] != null && typeof options2[n] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n)) {
            cmd2[n] = options2[n];
          }
        }
        return cmd2;
      }
      execute(callback) {
        const db = this.db;
        const name2 = this.name;
        const options2 = this.options;
        const Collection = loadCollection();
        let listCollectionOptions = Object.assign({nameOnly: true, strict: false}, options2);
        listCollectionOptions = applyWriteConcern(listCollectionOptions, {db}, listCollectionOptions);
        function done(err) {
          if (err) {
            return callback(err);
          }
          try {
            callback(null, new Collection(db, db.s.topology, db.databaseName, name2, db.s.pkFactory, options2));
          } catch (err2) {
            callback(err2);
          }
        }
        const strictMode = listCollectionOptions.strict;
        if (strictMode) {
          db.listCollections({name: name2}, listCollectionOptions).setReadPreference(ReadPreference.PRIMARY).toArray((err, collections) => {
            if (err) {
              return callback(err);
            }
            if (collections.length > 0) {
              return callback(new MongoError(`Collection ${name2} already exists. Currently in strict mode.`));
            }
            super.execute(done);
          });
          return;
        }
        super.execute(done);
      }
    };
    defineAspects(CreateCollectionOperation, Aspect.WRITE_OPERATION);
    module2.exports = CreateCollectionOperation;
  }
});

// node_modules/mongodb/lib/operations/execute_db_admin_command.js
var require_execute_db_admin_command = __commonJS({
  "node_modules/mongodb/lib/operations/execute_db_admin_command.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var ExecuteDbAdminCommandOperation = class extends OperationBase {
      constructor(db, selector, options2) {
        super(options2);
        this.db = db;
        this.selector = selector;
      }
      execute(callback) {
        const db = this.db;
        const selector = this.selector;
        const options2 = this.options;
        const namespace = new MongoDBNamespace("admin", "$cmd");
        db.s.topology.command(namespace, selector, options2, (err, result) => {
          if (db.serverConfig && db.serverConfig.isDestroyed()) {
            return callback(new MongoError("topology was destroyed"));
          }
          if (err)
            return handleCallback(callback, err);
          handleCallback(callback, null, result.result);
        });
      }
    };
    module2.exports = ExecuteDbAdminCommandOperation;
  }
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS({
  "node_modules/mongodb/lib/operations/list_collections.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var maxWireVersion = require_utils2().maxWireVersion;
    var CONSTANTS = require_constants2();
    var LIST_COLLECTIONS_WIRE_VERSION = 3;
    function listCollectionsTransforms(databaseName) {
      const matching = `${databaseName}.`;
      return {
        doc: (doc2) => {
          const index2 = doc2.name.indexOf(matching);
          if (doc2.name && index2 === 0) {
            doc2.name = doc2.name.substr(index2 + matching.length);
          }
          return doc2;
        }
      };
    }
    var ListCollectionsOperation = class extends CommandOperationV2 {
      constructor(db, filter, options2) {
        super(db, options2, {fullResponse: true});
        this.db = db;
        this.filter = filter;
        this.nameOnly = !!this.options.nameOnly;
        if (typeof this.options.batchSize === "number") {
          this.batchSize = this.options.batchSize;
        }
      }
      execute(server, callback) {
        if (maxWireVersion(server) < LIST_COLLECTIONS_WIRE_VERSION) {
          let filter = this.filter;
          const databaseName = this.db.s.namespace.db;
          if (typeof filter.name === "string" && !new RegExp("^" + databaseName + "\\.").test(filter.name)) {
            filter = Object.assign({}, filter);
            filter.name = this.db.s.namespace.withCollection(filter.name).toString();
          }
          if (filter == null) {
            filter.name = `/${databaseName}/`;
          }
          if (filter.name) {
            filter = {$and: [{name: filter.name}, {name: /^((?!\$).)*$/}]};
          } else {
            filter = {name: /^((?!\$).)*$/};
          }
          const transforms = listCollectionsTransforms(databaseName);
          server.query(`${databaseName}.${CONSTANTS.SYSTEM_NAMESPACE_COLLECTION}`, {query: filter}, {batchSize: this.batchSize || 1e3}, {}, (err, result) => {
            if (result && result.message && result.message.documents && Array.isArray(result.message.documents)) {
              result.message.documents = result.message.documents.map(transforms.doc);
            }
            callback(err, result);
          });
          return;
        }
        const command2 = {
          listCollections: 1,
          filter: this.filter,
          cursor: this.batchSize ? {batchSize: this.batchSize} : {},
          nameOnly: this.nameOnly
        };
        return super.executeCommand(server, command2, callback);
      }
    };
    defineAspects(ListCollectionsOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListCollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/profiling_level.js"(exports2, module2) {
    "use strict";
    var CommandOperation = require_command2();
    var ProfilingLevelOperation = class extends CommandOperation {
      constructor(db, command2, options2) {
        super(db, options2);
      }
      _buildCommand() {
        const command2 = {profile: -1};
        return command2;
      }
      execute(callback) {
        super.execute((err, doc2) => {
          if (err == null && doc2.ok === 1) {
            const was = doc2.was;
            if (was === 0)
              return callback(null, "off");
            if (was === 1)
              return callback(null, "slow_only");
            if (was === 2)
              return callback(null, "all");
            return callback(new Error("Error: illegal profiling level value " + was), null);
          } else {
            err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
          }
        });
      }
    };
    module2.exports = ProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS({
  "node_modules/mongodb/lib/operations/remove_user.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var handleCallback = require_utils4().handleCallback;
    var WriteConcern = require_write_concern();
    var RemoveUserOperation = class extends CommandOperation {
      constructor(db, username, options2) {
        const commandOptions = {};
        const writeConcern = WriteConcern.fromOptions(options2);
        if (writeConcern != null) {
          commandOptions.writeConcern = writeConcern;
        }
        if (options2.dbName) {
          commandOptions.dbName = options2.dbName;
        }
        if (typeof options2.maxTimeMS === "number") {
          commandOptions.maxTimeMS = options2.maxTimeMS;
        }
        super(db, commandOptions);
        this.username = username;
      }
      _buildCommand() {
        const username = this.username;
        const command2 = {dropUser: username};
        return command2;
      }
      execute(callback) {
        super.execute((err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, err, result.ok ? true : false);
        });
      }
    };
    defineAspects(RemoveUserOperation, Aspect.WRITE_OPERATION);
    module2.exports = RemoveUserOperation;
  }
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS({
  "node_modules/mongodb/lib/operations/rename.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var checkCollectionName = require_utils4().checkCollectionName;
    var executeDbAdminCommand = require_db_ops().executeDbAdminCommand;
    var handleCallback = require_utils4().handleCallback;
    var loadCollection = require_dynamic_loaders().loadCollection;
    var toError = require_utils4().toError;
    var RenameOperation = class extends OperationBase {
      constructor(collection, newName, options2) {
        super(options2);
        this.collection = collection;
        this.newName = newName;
      }
      execute(callback) {
        const coll = this.collection;
        const newName = this.newName;
        const options2 = this.options;
        let Collection = loadCollection();
        checkCollectionName(newName);
        const renameCollection = coll.namespace;
        const toCollection = coll.s.namespace.withCollection(newName).toString();
        const dropTarget = typeof options2.dropTarget === "boolean" ? options2.dropTarget : false;
        const cmd2 = {renameCollection, to: toCollection, dropTarget};
        applyWriteConcern(cmd2, {db: coll.s.db, collection: coll}, options2);
        executeDbAdminCommand(coll.s.db.admin().s.db, cmd2, options2, (err, doc2) => {
          if (err)
            return handleCallback(callback, err, null);
          if (doc2.errmsg)
            return handleCallback(callback, toError(doc2), null);
          try {
            return handleCallback(callback, null, new Collection(coll.s.db, coll.s.topology, coll.s.namespace.db, newName, coll.s.pkFactory, coll.s.options));
          } catch (err2) {
            return handleCallback(callback, toError(err2), null);
          }
        });
      }
    };
    module2.exports = RenameOperation;
  }
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/set_profiling_level.js"(exports2, module2) {
    "use strict";
    var CommandOperation = require_command2();
    var levelValues = new Set(["off", "slow_only", "all"]);
    var SetProfilingLevelOperation = class extends CommandOperation {
      constructor(db, level, options2) {
        let profile = 0;
        if (level === "off") {
          profile = 0;
        } else if (level === "slow_only") {
          profile = 1;
        } else if (level === "all") {
          profile = 2;
        }
        super(db, options2);
        this.level = level;
        this.profile = profile;
      }
      _buildCommand() {
        const profile = this.profile;
        const command2 = {profile};
        return command2;
      }
      execute(callback) {
        const level = this.level;
        if (!levelValues.has(level)) {
          return callback(new Error("Error: illegal profiling level value " + level));
        }
        super.execute((err, doc2) => {
          if (err == null && doc2.ok === 1)
            return callback(null, level);
          return err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
        });
      }
    };
    module2.exports = SetProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS({
  "node_modules/mongodb/lib/operations/validate_collection.js"(exports2, module2) {
    "use strict";
    var CommandOperation = require_command2();
    var ValidateCollectionOperation = class extends CommandOperation {
      constructor(admin, collectionName, options2) {
        let command2 = {validate: collectionName};
        const keys = Object.keys(options2);
        for (let i = 0; i < keys.length; i++) {
          if (Object.prototype.hasOwnProperty.call(options2, keys[i]) && keys[i] !== "session") {
            command2[keys[i]] = options2[keys[i]];
          }
        }
        super(admin.s.db, options2, null, command2);
        this.collectionName = collectionName;
      }
      execute(callback) {
        const collectionName = this.collectionName;
        super.execute((err, doc2) => {
          if (err != null)
            return callback(err, null);
          if (doc2.ok === 0)
            return callback(new Error("Error with validate command"), null);
          if (doc2.result != null && doc2.result.constructor !== String)
            return callback(new Error("Error with validation data"), null);
          if (doc2.result != null && doc2.result.match(/exception|corrupt/) != null)
            return callback(new Error("Error: invalid collection " + collectionName), null);
          if (doc2.valid != null && !doc2.valid)
            return callback(new Error("Error: invalid collection " + collectionName), null);
          return callback(null, doc2);
        });
      }
    };
    module2.exports = ValidateCollectionOperation;
  }
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS({
  "node_modules/mongodb/lib/operations/list_databases.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var ListDatabasesOperation = class extends CommandOperationV2 {
      constructor(db, options2) {
        super(db, options2);
        this.ns = new MongoDBNamespace("admin", "$cmd");
      }
      execute(server, callback) {
        const cmd2 = {listDatabases: 1};
        if (this.options.nameOnly) {
          cmd2.nameOnly = Number(cmd2.nameOnly);
        }
        if (this.options.filter) {
          cmd2.filter = this.options.filter;
        }
        if (typeof this.options.authorizedDatabases === "boolean") {
          cmd2.authorizedDatabases = this.options.authorizedDatabases;
        }
        super.executeCommand(server, cmd2, callback);
      }
    };
    defineAspects(ListDatabasesOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListDatabasesOperation;
  }
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS({
  "node_modules/mongodb/lib/admin.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var AddUserOperation = require_add_user();
    var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
    var RemoveUserOperation = require_remove_user();
    var ValidateCollectionOperation = require_validate_collection();
    var ListDatabasesOperation = require_list_databases();
    var executeOperation = require_execute_operation();
    function Admin(db, topology, promiseLibrary) {
      if (!(this instanceof Admin))
        return new Admin(db, topology);
      this.s = {
        db,
        topology,
        promiseLibrary
      };
    }
    Admin.prototype.command = function(command2, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : {};
      const commandOperation = new ExecuteDbAdminCommandOperation(this.s.db, command2, options2);
      return executeOperation(this.s.db.s.topology, commandOperation, callback);
    };
    Admin.prototype.buildInfo = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const cmd2 = {buildinfo: 1};
      const buildInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd2, options2);
      return executeOperation(this.s.db.s.topology, buildInfoOperation, callback);
    };
    Admin.prototype.serverInfo = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const cmd2 = {buildinfo: 1};
      const serverInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd2, options2);
      return executeOperation(this.s.db.s.topology, serverInfoOperation, callback);
    };
    Admin.prototype.serverStatus = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const serverStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, {serverStatus: 1}, options2);
      return executeOperation(this.s.db.s.topology, serverStatusOperation, callback);
    };
    Admin.prototype.ping = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const cmd2 = {ping: 1};
      const pingOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd2, options2);
      return executeOperation(this.s.db.s.topology, pingOperation, callback);
    };
    Admin.prototype.addUser = function(username, password, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      if (typeof username === "string" && password != null && typeof password === "object") {
        options2 = password;
        password = null;
      }
      options2 = args.length ? args.shift() : {};
      options2 = Object.assign({}, options2);
      options2 = applyWriteConcern(options2, {db: this.s.db});
      options2.dbName = "admin";
      const addUserOperation = new AddUserOperation(this.s.db, username, password, options2);
      return executeOperation(this.s.db.s.topology, addUserOperation, callback);
    };
    Admin.prototype.removeUser = function(username, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : {};
      options2 = Object.assign({}, options2);
      options2 = applyWriteConcern(options2, {db: this.s.db});
      options2.dbName = "admin";
      const removeUserOperation = new RemoveUserOperation(this.s.db, username, options2);
      return executeOperation(this.s.db.s.topology, removeUserOperation, callback);
    };
    Admin.prototype.validateCollection = function(collectionName, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const validateCollectionOperation = new ValidateCollectionOperation(this, collectionName, options2);
      return executeOperation(this.s.db.s.topology, validateCollectionOperation, callback);
    };
    Admin.prototype.listDatabases = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeOperation(this.s.db.s.topology, new ListDatabasesOperation(this.s.db, options2), callback);
    };
    Admin.prototype.replSetGetStatus = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const replSetGetStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, {replSetGetStatus: 1}, options2);
      return executeOperation(this.s.db.s.topology, replSetGetStatusOperation, callback);
    };
    module2.exports = Admin;
  }
});

// node_modules/mongodb/lib/db.js
var require_db = __commonJS({
  "node_modules/mongodb/lib/db.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var inherits = require("util").inherits;
    var getSingleProperty = require_utils4().getSingleProperty;
    var CommandCursor = require_command_cursor();
    var handleCallback = require_utils4().handleCallback;
    var filterOptions = require_utils4().filterOptions;
    var toError = require_utils4().toError;
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var ObjectID2 = require_core().ObjectID;
    var Logger = require_core().Logger;
    var Collection = require_collection();
    var conditionallyMergeWriteConcern = require_utils4().conditionallyMergeWriteConcern;
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var ChangeStream = require_change_stream();
    var deprecate = require("util").deprecate;
    var deprecateOptions = require_utils4().deprecateOptions;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var CONSTANTS = require_constants2();
    var WriteConcern = require_write_concern();
    var ReadConcern = require_read_concern();
    var AggregationCursor = require_aggregation_cursor();
    var createListener = require_db_ops().createListener;
    var ensureIndex = require_db_ops().ensureIndex;
    var evaluate = require_db_ops().evaluate;
    var profilingInfo = require_db_ops().profilingInfo;
    var validateDatabaseName = require_db_ops().validateDatabaseName;
    var AggregateOperation = require_aggregate();
    var AddUserOperation = require_add_user();
    var CollectionsOperation = require_collections();
    var CommandOperation = require_command2();
    var RunCommandOperation = require_run_command();
    var CreateCollectionOperation = require_create_collection();
    var CreateIndexesOperation = require_create_indexes();
    var DropCollectionOperation = require_drop().DropCollectionOperation;
    var DropDatabaseOperation = require_drop().DropDatabaseOperation;
    var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
    var IndexInformationOperation = require_index_information();
    var ListCollectionsOperation = require_list_collections();
    var ProfilingLevelOperation = require_profiling_level();
    var RemoveUserOperation = require_remove_user();
    var RenameOperation = require_rename();
    var SetProfilingLevelOperation = require_set_profiling_level();
    var executeOperation = require_execute_operation();
    var legalOptionNames = [
      "w",
      "wtimeout",
      "fsync",
      "j",
      "writeConcern",
      "readPreference",
      "readPreferenceTags",
      "native_parser",
      "forceServerObjectId",
      "pkFactory",
      "serializeFunctions",
      "raw",
      "bufferMaxEntries",
      "authSource",
      "ignoreUndefined",
      "promoteLongs",
      "promiseLibrary",
      "readConcern",
      "retryMiliSeconds",
      "numberOfRetries",
      "parentDb",
      "noListener",
      "loggerLevel",
      "logger",
      "promoteBuffers",
      "promoteLongs",
      "promoteValues",
      "compression",
      "retryWrites"
    ];
    function Db(databaseName, topology, options2) {
      options2 = options2 || {};
      if (!(this instanceof Db))
        return new Db(databaseName, topology, options2);
      EventEmitter.call(this);
      const promiseLibrary = options2.promiseLibrary || Promise;
      options2 = filterOptions(options2, legalOptionNames);
      options2.promiseLibrary = promiseLibrary;
      this.s = {
        dbCache: {},
        children: [],
        topology,
        options: options2,
        logger: Logger("Db", options2),
        bson: topology ? topology.bson : null,
        readPreference: ReadPreference.fromOptions(options2),
        bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : -1,
        parentDb: options2.parentDb || null,
        pkFactory: options2.pkFactory || ObjectID2,
        nativeParser: options2.nativeParser || options2.native_parser,
        promiseLibrary,
        noListener: typeof options2.noListener === "boolean" ? options2.noListener : false,
        readConcern: ReadConcern.fromOptions(options2),
        writeConcern: WriteConcern.fromOptions(options2),
        namespace: new MongoDBNamespace(databaseName)
      };
      validateDatabaseName(databaseName);
      getSingleProperty(this, "serverConfig", this.s.topology);
      getSingleProperty(this, "bufferMaxEntries", this.s.bufferMaxEntries);
      getSingleProperty(this, "databaseName", this.s.namespace.db);
      if (options2.parentDb)
        return;
      if (this.s.noListener)
        return;
      topology.on("error", createListener(this, "error", this));
      topology.on("timeout", createListener(this, "timeout", this));
      topology.on("close", createListener(this, "close", this));
      topology.on("parseError", createListener(this, "parseError", this));
      topology.once("open", createListener(this, "open", this));
      topology.once("fullsetup", createListener(this, "fullsetup", this));
      topology.once("all", createListener(this, "all", this));
      topology.on("reconnect", createListener(this, "reconnect", this));
    }
    inherits(Db, EventEmitter);
    Db.prototype.on = deprecate(function() {
      return Db.super_.prototype.on.apply(this, arguments);
    }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
    Db.prototype.once = deprecate(function() {
      return Db.super_.prototype.once.apply(this, arguments);
    }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
    Object.defineProperty(Db.prototype, "topology", {
      enumerable: true,
      get: function() {
        return this.s.topology;
      }
    });
    Object.defineProperty(Db.prototype, "options", {
      enumerable: true,
      get: function() {
        return this.s.options;
      }
    });
    Object.defineProperty(Db.prototype, "slaveOk", {
      enumerable: true,
      get: function() {
        if (this.s.options.readPreference != null && (this.s.options.readPreference !== "primary" || this.s.options.readPreference.mode !== "primary")) {
          return true;
        }
        return false;
      }
    });
    Object.defineProperty(Db.prototype, "readConcern", {
      enumerable: true,
      get: function() {
        return this.s.readConcern;
      }
    });
    Object.defineProperty(Db.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        if (this.s.readPreference == null) {
          return ReadPreference.primary;
        }
        return this.s.readPreference;
      }
    });
    Object.defineProperty(Db.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(Db.prototype, "namespace", {
      enumerable: true,
      get: function() {
        return this.s.namespace.toString();
      }
    });
    Db.prototype.command = function(command2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      const commandOperation = new RunCommandOperation(this, command2, options2);
      return executeOperation(this.s.topology, commandOperation, callback);
    };
    Db.prototype.aggregate = function(pipeline2, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      if (options2 == null && callback == null) {
        options2 = {};
      }
      const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline2, options2), options2);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    };
    Db.prototype.admin = function() {
      const Admin = require_admin();
      return new Admin(this, this.s.topology, this.s.promiseLibrary);
    };
    var COLLECTION_OPTION_KEYS = [
      "pkFactory",
      "readPreference",
      "serializeFunctions",
      "strict",
      "readConcern",
      "ignoreUndefined",
      "promoteValues",
      "promoteBuffers",
      "promoteLongs"
    ];
    Db.prototype.collection = function(name2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      options2 = Object.assign({}, options2);
      options2.promiseLibrary = this.s.promiseLibrary;
      options2.readConcern = options2.readConcern ? new ReadConcern(options2.readConcern.level) : this.readConcern;
      if (this.s.options.ignoreUndefined) {
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      for (const collectionOptionKey of COLLECTION_OPTION_KEYS) {
        if (!(collectionOptionKey in options2) && this.s.options[collectionOptionKey] !== void 0) {
          options2[collectionOptionKey] = this.s.options[collectionOptionKey];
        }
      }
      options2 = conditionallyMergeWriteConcern(options2, this.s.options);
      if (options2 == null || !options2.strict) {
        try {
          const collection = new Collection(this, this.s.topology, this.databaseName, name2, this.s.pkFactory, options2);
          if (callback)
            callback(null, collection);
          return collection;
        } catch (err) {
          if (err instanceof MongoError && callback)
            return callback(err);
          throw err;
        }
      }
      if (typeof callback !== "function") {
        throw toError(`A callback is required in strict mode. While getting collection ${name2}`);
      }
      if (this.serverConfig && this.serverConfig.isDestroyed()) {
        return callback(new MongoError("topology was destroyed"));
      }
      const listCollectionOptions = Object.assign({}, options2, {nameOnly: true});
      this.listCollections({name: name2}, listCollectionOptions).toArray((err, collections) => {
        if (err != null)
          return handleCallback(callback, err, null);
        if (collections.length === 0)
          return handleCallback(callback, toError(`Collection ${name2} does not exist. Currently in strict mode.`), null);
        try {
          return handleCallback(callback, null, new Collection(this, this.s.topology, this.databaseName, name2, this.s.pkFactory, options2));
        } catch (err2) {
          return handleCallback(callback, err2, null);
        }
      });
    };
    Db.prototype.createCollection = deprecateOptions({
      name: "Db.createCollection",
      deprecatedOptions: ["autoIndexId", "strict", "w", "wtimeout", "j"],
      optionsIndex: 1
    }, function(name2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      options2.promiseLibrary = options2.promiseLibrary || this.s.promiseLibrary;
      options2.readConcern = options2.readConcern ? new ReadConcern(options2.readConcern.level) : this.readConcern;
      const createCollectionOperation = new CreateCollectionOperation(this, name2, options2);
      return executeOperation(this.s.topology, createCollectionOperation, callback);
    });
    Db.prototype.stats = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const commandObject = {dbStats: true};
      if (options2["scale"] != null)
        commandObject["scale"] = options2["scale"];
      if (options2.readPreference == null && this.s.readPreference) {
        options2.readPreference = this.s.readPreference;
      }
      const statsOperation = new CommandOperation(this, options2, null, commandObject);
      return executeOperation(this.s.topology, statsOperation, callback);
    };
    Db.prototype.listCollections = function(filter, options2) {
      filter = filter || {};
      options2 = options2 || {};
      return new CommandCursor(this.s.topology, new ListCollectionsOperation(this, filter, options2), options2);
    };
    Db.prototype.eval = deprecate(function(code, parameters, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      parameters = args.length ? args.shift() : parameters;
      options2 = args.length ? args.shift() || {} : {};
      return executeLegacyOperation(this.s.topology, evaluate, [
        this,
        code,
        parameters,
        options2,
        callback
      ]);
    }, "Db.eval is deprecated as of MongoDB version 3.2");
    Db.prototype.renameCollection = function(fromCollection, toCollection, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2, {readPreference: ReadPreference.PRIMARY});
      options2.new_collection = true;
      const renameOperation = new RenameOperation(this.collection(fromCollection), toCollection, options2);
      return executeOperation(this.s.topology, renameOperation, callback);
    };
    Db.prototype.dropCollection = function(name2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const dropCollectionOperation = new DropCollectionOperation(this, name2, options2);
      return executeOperation(this.s.topology, dropCollectionOperation, callback);
    };
    Db.prototype.dropDatabase = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const dropDatabaseOperation = new DropDatabaseOperation(this, options2);
      return executeOperation(this.s.topology, dropDatabaseOperation, callback);
    };
    Db.prototype.collections = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const collectionsOperation = new CollectionsOperation(this, options2);
      return executeOperation(this.s.topology, collectionsOperation, callback);
    };
    Db.prototype.executeDbAdminCommand = function(selector, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      options2.readPreference = ReadPreference.resolve(this, options2);
      const executeDbAdminCommandOperation = new ExecuteDbAdminCommandOperation(this, selector, options2);
      return executeOperation(this.s.topology, executeDbAdminCommandOperation, callback);
    };
    Db.prototype.createIndex = function(name2, fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {};
      const createIndexesOperation = new CreateIndexesOperation(this, name2, fieldOrSpec, options2);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Db.prototype.ensureIndex = deprecate(function(name2, fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.s.topology, ensureIndex, [
        this,
        name2,
        fieldOrSpec,
        options2,
        callback
      ]);
    }, "Db.ensureIndex is deprecated as of MongoDB version 3.0 / driver version 2.0");
    Db.prototype.addChild = function(db) {
      if (this.s.parentDb)
        return this.s.parentDb.addChild(db);
      this.s.children.push(db);
    };
    Db.prototype.addUser = function(username, password, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (typeof username === "string" && password != null && typeof password === "object") {
        options2 = password;
        password = null;
      }
      const addUserOperation = new AddUserOperation(this, username, password, options2);
      return executeOperation(this.s.topology, addUserOperation, callback);
    };
    Db.prototype.removeUser = function(username, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const removeUserOperation = new RemoveUserOperation(this, username, options2);
      return executeOperation(this.s.topology, removeUserOperation, callback);
    };
    Db.prototype.setProfilingLevel = function(level, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const setProfilingLevelOperation = new SetProfilingLevelOperation(this, level, options2);
      return executeOperation(this.s.topology, setProfilingLevelOperation, callback);
    };
    Db.prototype.profilingInfo = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.s.topology, profilingInfo, [this, options2, callback]);
    }, "Db.profilingInfo is deprecated. Query the system.profile collection directly.");
    Db.prototype.profilingLevel = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const profilingLevelOperation = new ProfilingLevelOperation(this, options2);
      return executeOperation(this.s.topology, profilingLevelOperation, callback);
    };
    Db.prototype.indexInformation = function(name2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const indexInformationOperation = new IndexInformationOperation(this, name2, options2);
      return executeOperation(this.s.topology, indexInformationOperation, callback);
    };
    Db.prototype.unref = function() {
      this.s.topology.unref();
    };
    Db.prototype.watch = function(pipeline2, options2) {
      pipeline2 = pipeline2 || [];
      options2 = options2 || {};
      if (!Array.isArray(pipeline2)) {
        options2 = pipeline2;
        pipeline2 = [];
      }
      return new ChangeStream(this, pipeline2, options2);
    };
    Db.prototype.getLogger = function() {
      return this.s.logger;
    };
    Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
    Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
    Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
    Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
    Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
    Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
    module2.exports = Db;
  }
});

// node_modules/mongodb/lib/dynamic_loaders.js
var require_dynamic_loaders = __commonJS({
  "node_modules/mongodb/lib/dynamic_loaders.js"(exports2, module2) {
    "use strict";
    var collection;
    var cursor;
    var db;
    function loadCollection() {
      if (!collection) {
        collection = require_collection();
      }
      return collection;
    }
    function loadCursor() {
      if (!cursor) {
        cursor = require_cursor2();
      }
      return cursor;
    }
    function loadDb() {
      if (!db) {
        db = require_db();
      }
      return db;
    }
    module2.exports = {
      loadCollection,
      loadCursor,
      loadDb
    };
  }
});

// node_modules/mongodb/lib/operations/map_reduce.js
var require_map_reduce = __commonJS({
  "node_modules/mongodb/lib/operations/map_reduce.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils4().handleCallback;
    var isObject = require_utils4().isObject;
    var loadDb = require_dynamic_loaders().loadDb;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var exclusionList = [
      "explain",
      "readPreference",
      "session",
      "bypassDocumentValidation",
      "w",
      "wtimeout",
      "j",
      "writeConcern"
    ];
    var MapReduceOperation = class extends OperationBase {
      constructor(collection, map, reduce, options2) {
        super(options2);
        this.collection = collection;
        this.map = map;
        this.reduce = reduce;
      }
      execute(callback) {
        const coll = this.collection;
        const map = this.map;
        const reduce = this.reduce;
        let options2 = this.options;
        let mapCommandHash = {
          mapReduce: coll.collectionName,
          map,
          reduce
        };
        for (let n in options2) {
          if (n === "scope") {
            mapCommandHash[n] = processScope(options2[n]);
          } else {
            if (exclusionList.indexOf(n) === -1) {
              mapCommandHash[n] = options2[n];
            }
          }
        }
        options2 = Object.assign({}, options2);
        options2.readPreference = ReadPreference.resolve(coll, options2);
        if (options2.readPreference !== false && options2.readPreference !== "primary" && options2["out"] && options2["out"].inline !== 1 && options2["out"] !== "inline") {
          options2.readPreference = "primary";
          applyWriteConcern(mapCommandHash, {db: coll.s.db, collection: coll}, options2);
        } else {
          decorateWithReadConcern(mapCommandHash, coll, options2);
        }
        if (options2.bypassDocumentValidation === true) {
          mapCommandHash.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        try {
          decorateWithCollation(mapCommandHash, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        if (this.explain) {
          if (maxWireVersion(coll.s.topology) < 9) {
            callback(new MongoError(`server does not support explain on mapReduce`));
            return;
          }
          mapCommandHash = decorateWithExplain(mapCommandHash, this.explain);
        }
        executeCommand(coll.s.db, mapCommandHash, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (result.ok !== 1 || result.err || result.errmsg) {
            return handleCallback(callback, toError(result));
          }
          if (this.explain)
            return callback(void 0, result);
          const stats = {};
          if (result.timeMillis)
            stats["processtime"] = result.timeMillis;
          if (result.counts)
            stats["counts"] = result.counts;
          if (result.timing)
            stats["timing"] = result.timing;
          if (result.results) {
            if (options2["verbose"] == null || !options2["verbose"]) {
              return handleCallback(callback, null, result.results);
            }
            return handleCallback(callback, null, {results: result.results, stats});
          }
          let collection = null;
          if (result.result != null && typeof result.result === "object") {
            const doc2 = result.result;
            let Db = loadDb();
            collection = new Db(doc2.db, coll.s.db.s.topology, coll.s.db.s.options).collection(doc2.collection);
          } else {
            collection = coll.s.db.collection(result.result);
          }
          if (options2["verbose"] == null || !options2["verbose"]) {
            return handleCallback(callback, err, collection);
          }
          handleCallback(callback, err, {collection, stats});
        });
      }
    };
    function processScope(scope) {
      if (!isObject(scope) || scope._bsontype === "ObjectID") {
        return scope;
      }
      const keys = Object.keys(scope);
      let key;
      const new_scope = {};
      for (let i = keys.length - 1; i >= 0; i--) {
        key = keys[i];
        if (typeof scope[key] === "function") {
          new_scope[key] = new Code2(String(scope[key]));
        } else {
          new_scope[key] = processScope(scope[key]);
        }
      }
      return new_scope;
    }
    defineAspects(MapReduceOperation, [Aspect.EXPLAINABLE]);
    module2.exports = MapReduceOperation;
  }
});

// node_modules/mongodb/lib/operations/re_index.js
var require_re_index = __commonJS({
  "node_modules/mongodb/lib/operations/re_index.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var serverType = require_common().serverType;
    var ServerType = require_common().ServerType;
    var MongoError = require_core().MongoError;
    var ReIndexOperation = class extends CommandOperationV2 {
      constructor(collection, options2) {
        super(collection, options2);
        this.collectionName = collection.collectionName;
      }
      execute(server, callback) {
        if (serverType(server) !== ServerType.Standalone) {
          callback(new MongoError(`reIndex can only be executed on standalone servers.`));
          return;
        }
        super.executeCommand(server, {reIndex: this.collectionName}, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, !!result.ok);
        });
      }
    };
    defineAspects(ReIndexOperation, [Aspect.EXECUTE_WITH_SELECTION]);
    module2.exports = ReIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/replace_one.js
var require_replace_one = __commonJS({
  "node_modules/mongodb/lib/operations/replace_one.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var ReplaceOneOperation = class extends OperationBase {
      constructor(collection, filter, replacement, options2) {
        super(options2);
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not contain atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.replacement = replacement;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const replacement = this.replacement;
        const options2 = this.options;
        options2.multi = false;
        updateDocuments(coll, filter, replacement, options2, (err, r) => replaceCallback(err, r, replacement, callback));
      }
    };
    function replaceCallback(err, r, doc2, callback) {
      if (callback == null)
        return;
      if (err && callback)
        return callback(err);
      if (r == null)
        return callback(null, {result: {ok: 1}});
      r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
      r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
      r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
      r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
      r.ops = [doc2];
      if (callback)
        callback(null, r);
    }
    module2.exports = ReplaceOneOperation;
  }
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS({
  "node_modules/mongodb/lib/operations/stats.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var StatsOperation = class extends CommandOperation {
      constructor(collection, options2) {
        super(collection.s.db, options2, collection);
      }
      _buildCommand() {
        const collection = this.collection;
        const options2 = this.options;
        const command2 = {
          collStats: collection.collectionName
        };
        if (options2["scale"] != null) {
          command2["scale"] = options2["scale"];
        }
        return command2;
      }
    };
    defineAspects(StatsOperation, Aspect.READ_OPERATION);
    module2.exports = StatsOperation;
  }
});

// node_modules/mongodb/lib/operations/update_many.js
var require_update_many = __commonJS({
  "node_modules/mongodb/lib/operations/update_many.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var UpdateManyOperation = class extends OperationBase {
      constructor(collection, filter, update, options2) {
        super(options2);
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.update = update;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const update = this.update;
        const options2 = this.options;
        options2.multi = true;
        updateDocuments(coll, filter, update, options2, (err, r) => {
          if (callback == null)
            return;
          if (err)
            return callback(err);
          if (r == null)
            return callback(null, {result: {ok: 1}});
          if (this.explain)
            return callback(void 0, r.result);
          r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
          r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
          r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
          r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(UpdateManyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = UpdateManyOperation;
  }
});

// node_modules/mongodb/lib/operations/update_one.js
var require_update_one = __commonJS({
  "node_modules/mongodb/lib/operations/update_one.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var UpdateOneOperation = class extends OperationBase {
      constructor(collection, filter, update, options2) {
        super(options2);
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.update = update;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const update = this.update;
        const options2 = this.options;
        options2.multi = false;
        updateDocuments(coll, filter, update, options2, (err, r) => {
          if (callback == null)
            return;
          if (err)
            return callback(err);
          if (r == null)
            return callback(null, {result: {ok: 1}});
          if (this.explain)
            return callback(void 0, r.result);
          r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
          r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
          r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
          r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(UpdateOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = UpdateOneOperation;
  }
});

// node_modules/mongodb/lib/collection.js
var require_collection = __commonJS({
  "node_modules/mongodb/lib/collection.js"(exports2, module2) {
    "use strict";
    var deprecate = require("util").deprecate;
    var deprecateOptions = require_utils4().deprecateOptions;
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var checkCollectionName = require_utils4().checkCollectionName;
    var ObjectID2 = require_core().BSON.ObjectID;
    var MongoError = require_core().MongoError;
    var normalizeHintField = require_utils4().normalizeHintField;
    var decorateCommand = require_utils4().decorateCommand;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var ReadPreference = require_core().ReadPreference;
    var unordered = require_unordered();
    var ordered = require_ordered();
    var ChangeStream = require_change_stream();
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var WriteConcern = require_write_concern();
    var ReadConcern = require_read_concern();
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var AggregationCursor = require_aggregation_cursor();
    var CommandCursor = require_command_cursor();
    var ensureIndex = require_collection_ops().ensureIndex;
    var group = require_collection_ops().group;
    var parallelCollectionScan = require_collection_ops().parallelCollectionScan;
    var removeDocuments = require_common_functions().removeDocuments;
    var save = require_collection_ops().save;
    var updateDocuments = require_common_functions().updateDocuments;
    var AggregateOperation = require_aggregate();
    var BulkWriteOperation = require_bulk_write();
    var CountDocumentsOperation = require_count_documents();
    var CreateIndexesOperation = require_create_indexes();
    var DeleteManyOperation = require_delete_many();
    var DeleteOneOperation = require_delete_one();
    var DistinctOperation = require_distinct();
    var DropCollectionOperation = require_drop().DropCollectionOperation;
    var DropIndexOperation = require_drop_index();
    var DropIndexesOperation = require_drop_indexes();
    var EstimatedDocumentCountOperation = require_estimated_document_count();
    var FindOperation = require_find();
    var FindOneOperation = require_find_one();
    var FindAndModifyOperation = require_find_and_modify();
    var FindOneAndDeleteOperation = require_find_one_and_delete();
    var FindOneAndReplaceOperation = require_find_one_and_replace();
    var FindOneAndUpdateOperation = require_find_one_and_update();
    var GeoHaystackSearchOperation = require_geo_haystack_search();
    var IndexesOperation = require_indexes();
    var IndexExistsOperation = require_index_exists();
    var IndexInformationOperation = require_index_information();
    var InsertManyOperation = require_insert_many();
    var InsertOneOperation = require_insert_one();
    var IsCappedOperation = require_is_capped();
    var ListIndexesOperation = require_list_indexes();
    var MapReduceOperation = require_map_reduce();
    var OptionsOperation = require_options_operation();
    var RenameOperation = require_rename();
    var ReIndexOperation = require_re_index();
    var ReplaceOneOperation = require_replace_one();
    var StatsOperation = require_stats();
    var UpdateManyOperation = require_update_many();
    var UpdateOneOperation = require_update_one();
    var executeOperation = require_execute_operation();
    var mergeKeys = ["ignoreUndefined"];
    function Collection(db, topology, dbName, name2, pkFactory, options2) {
      checkCollectionName(name2);
      const internalHint = null;
      const slaveOk = options2 == null || options2.slaveOk == null ? db.slaveOk : options2.slaveOk;
      const serializeFunctions = options2 == null || options2.serializeFunctions == null ? db.s.options.serializeFunctions : options2.serializeFunctions;
      const raw = options2 == null || options2.raw == null ? db.s.options.raw : options2.raw;
      const promoteLongs = options2 == null || options2.promoteLongs == null ? db.s.options.promoteLongs : options2.promoteLongs;
      const promoteValues = options2 == null || options2.promoteValues == null ? db.s.options.promoteValues : options2.promoteValues;
      const promoteBuffers = options2 == null || options2.promoteBuffers == null ? db.s.options.promoteBuffers : options2.promoteBuffers;
      const collectionHint = null;
      const namespace = new MongoDBNamespace(dbName, name2);
      const promiseLibrary = options2.promiseLibrary || Promise;
      pkFactory = pkFactory == null ? ObjectID2 : pkFactory;
      this.s = {
        pkFactory,
        db,
        topology,
        options: options2,
        namespace,
        readPreference: ReadPreference.fromOptions(options2),
        slaveOk,
        serializeFunctions,
        raw,
        promoteLongs,
        promoteValues,
        promoteBuffers,
        internalHint,
        collectionHint,
        promiseLibrary,
        readConcern: ReadConcern.fromOptions(options2),
        writeConcern: WriteConcern.fromOptions(options2)
      };
    }
    Object.defineProperty(Collection.prototype, "dbName", {
      enumerable: true,
      get: function() {
        return this.s.namespace.db;
      }
    });
    Object.defineProperty(Collection.prototype, "collectionName", {
      enumerable: true,
      get: function() {
        return this.s.namespace.collection;
      }
    });
    Object.defineProperty(Collection.prototype, "namespace", {
      enumerable: true,
      get: function() {
        return this.s.namespace.toString();
      }
    });
    Object.defineProperty(Collection.prototype, "readConcern", {
      enumerable: true,
      get: function() {
        if (this.s.readConcern == null) {
          return this.s.db.readConcern;
        }
        return this.s.readConcern;
      }
    });
    Object.defineProperty(Collection.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        if (this.s.readPreference == null) {
          return this.s.db.readPreference;
        }
        return this.s.readPreference;
      }
    });
    Object.defineProperty(Collection.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        if (this.s.writeConcern == null) {
          return this.s.db.writeConcern;
        }
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(Collection.prototype, "hint", {
      enumerable: true,
      get: function() {
        return this.s.collectionHint;
      },
      set: function(v) {
        this.s.collectionHint = normalizeHintField(v);
      }
    });
    var DEPRECATED_FIND_OPTIONS = ["maxScan", "fields", "snapshot", "oplogReplay"];
    Collection.prototype.find = deprecateOptions({
      name: "collection.find",
      deprecatedOptions: DEPRECATED_FIND_OPTIONS,
      optionsIndex: 1
    }, function(query, options2, callback) {
      if (typeof callback === "object") {
        emitWarningOnce("Third parameter to `find()` must be a callback or undefined");
      }
      let selector = query;
      if (typeof callback !== "function") {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = void 0;
        } else if (options2 == null) {
          callback = typeof selector === "function" ? selector : void 0;
          selector = typeof selector === "object" ? selector : void 0;
        }
      }
      selector = selector == null ? {} : selector;
      const object = selector;
      if (Buffer.isBuffer(object)) {
        const object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
        if (object_size !== object.length) {
          const error3 = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
          error3.name = "MongoError";
          throw error3;
        }
      }
      if (selector != null && selector._bsontype === "ObjectID") {
        selector = {_id: selector};
      }
      if (!options2)
        options2 = {};
      let projection = options2.projection || options2.fields;
      if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) {
        projection = projection.length ? projection.reduce((result, field) => {
          result[field] = 1;
          return result;
        }, {}) : {_id: 1};
      }
      let newOptions = Object.assign({}, options2);
      for (let key in this.s.options) {
        if (mergeKeys.indexOf(key) !== -1) {
          newOptions[key] = this.s.options[key];
        }
      }
      newOptions.skip = options2.skip ? options2.skip : 0;
      newOptions.limit = options2.limit ? options2.limit : 0;
      newOptions.raw = typeof options2.raw === "boolean" ? options2.raw : this.s.raw;
      newOptions.hint = options2.hint != null ? normalizeHintField(options2.hint) : this.s.collectionHint;
      newOptions.timeout = typeof options2.timeout === "undefined" ? void 0 : options2.timeout;
      newOptions.slaveOk = options2.slaveOk != null ? options2.slaveOk : this.s.db.slaveOk;
      newOptions.readPreference = ReadPreference.resolve(this, newOptions);
      if (newOptions.readPreference != null && (newOptions.readPreference !== "primary" || newOptions.readPreference.mode !== "primary")) {
        newOptions.slaveOk = true;
      }
      if (selector != null && typeof selector !== "object") {
        throw MongoError.create({message: "query selector must be an object", driver: true});
      }
      const findCommand = {
        find: this.s.namespace.toString(),
        limit: newOptions.limit,
        skip: newOptions.skip,
        query: selector
      };
      if (typeof options2.allowDiskUse === "boolean") {
        findCommand.allowDiskUse = options2.allowDiskUse;
      }
      if (typeof newOptions.awaitdata === "boolean") {
        newOptions.awaitData = newOptions.awaitdata;
      }
      if (typeof newOptions.timeout === "boolean")
        newOptions.noCursorTimeout = !newOptions.timeout;
      decorateCommand(findCommand, newOptions, ["session", "collation"]);
      if (projection)
        findCommand.fields = projection;
      newOptions.db = this.s.db;
      newOptions.promiseLibrary = this.s.promiseLibrary;
      if (newOptions.raw == null && typeof this.s.raw === "boolean")
        newOptions.raw = this.s.raw;
      if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === "boolean")
        newOptions.promoteLongs = this.s.promoteLongs;
      if (newOptions.promoteValues == null && typeof this.s.promoteValues === "boolean")
        newOptions.promoteValues = this.s.promoteValues;
      if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === "boolean")
        newOptions.promoteBuffers = this.s.promoteBuffers;
      if (findCommand.sort) {
        findCommand.sort = formattedOrderClause(findCommand.sort);
      }
      decorateWithReadConcern(findCommand, this, options2);
      try {
        decorateWithCollation(findCommand, this, options2);
      } catch (err) {
        if (typeof callback === "function")
          return callback(err, null);
        throw err;
      }
      const cursor = this.s.topology.cursor(new FindOperation(this, this.s.namespace, findCommand, newOptions), newOptions);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    });
    Collection.prototype.insertOne = function(doc2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const insertOneOperation = new InsertOneOperation(this, doc2, options2);
      return executeOperation(this.s.topology, insertOneOperation, callback);
    };
    Collection.prototype.insertMany = function(docs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {ordered: true};
      const insertManyOperation = new InsertManyOperation(this, docs, options2);
      return executeOperation(this.s.topology, insertManyOperation, callback);
    };
    Collection.prototype.bulkWrite = function(operations, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {ordered: true};
      if (!Array.isArray(operations)) {
        throw MongoError.create({message: "operations must be an array of documents", driver: true});
      }
      const bulkWriteOperation = new BulkWriteOperation(this, operations, options2);
      return executeOperation(this.s.topology, bulkWriteOperation, callback);
    };
    Collection.prototype.insert = deprecate(function(docs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {ordered: false};
      docs = !Array.isArray(docs) ? [docs] : docs;
      if (options2.keepGoing === true) {
        options2.ordered = false;
      }
      return this.insertMany(docs, options2, callback);
    }, "collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.");
    Collection.prototype.updateOne = function(filter, update, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new UpdateOneOperation(this, filter, update, options2), callback);
    };
    Collection.prototype.replaceOne = function(filter, doc2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new ReplaceOneOperation(this, filter, doc2, options2), callback);
    };
    Collection.prototype.updateMany = function(filter, update, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new UpdateManyOperation(this, filter, update, options2), callback);
    };
    Collection.prototype.update = deprecate(function(selector, update, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, updateDocuments, [
        this,
        selector,
        update,
        options2,
        callback
      ]);
    }, "collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.");
    Collection.prototype.deleteOne = function(filter, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const deleteOneOperation = new DeleteOneOperation(this, filter, options2);
      return executeOperation(this.s.topology, deleteOneOperation, callback);
    };
    Collection.prototype.removeOne = Collection.prototype.deleteOne;
    Collection.prototype.deleteMany = function(filter, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const deleteManyOperation = new DeleteManyOperation(this, filter, options2);
      return executeOperation(this.s.topology, deleteManyOperation, callback);
    };
    Collection.prototype.removeMany = Collection.prototype.deleteMany;
    Collection.prototype.remove = deprecate(function(selector, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, removeDocuments, [
        this,
        selector,
        options2,
        callback
      ]);
    }, "collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.");
    Collection.prototype.save = deprecate(function(doc2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, save, [this, doc2, options2, callback]);
    }, "collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead.");
    Collection.prototype.findOne = deprecateOptions({
      name: "collection.find",
      deprecatedOptions: DEPRECATED_FIND_OPTIONS,
      optionsIndex: 1
    }, function(query, options2, callback) {
      if (typeof callback === "object") {
        emitWarningOnce("Third parameter to `findOne()` must be a callback or undefined");
      }
      if (typeof query === "function")
        callback = query, query = {}, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      query = query || {};
      options2 = options2 || {};
      const findOneOperation = new FindOneOperation(this, query, options2);
      return executeOperation(this.s.topology, findOneOperation, callback);
    });
    Collection.prototype.rename = function(newName, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2, {readPreference: ReadPreference.PRIMARY});
      const renameOperation = new RenameOperation(this, newName, options2);
      return executeOperation(this.s.topology, renameOperation, callback);
    };
    Collection.prototype.drop = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const dropCollectionOperation = new DropCollectionOperation(this.s.db, this.collectionName, options2);
      return executeOperation(this.s.topology, dropCollectionOperation, callback);
    };
    Collection.prototype.options = function(opts, callback) {
      if (typeof opts === "function")
        callback = opts, opts = {};
      opts = opts || {};
      const optionsOperation = new OptionsOperation(this, opts);
      return executeOperation(this.s.topology, optionsOperation, callback);
    };
    Collection.prototype.isCapped = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const isCappedOperation = new IsCappedOperation(this, options2);
      return executeOperation(this.s.topology, isCappedOperation, callback);
    };
    Collection.prototype.createIndex = function(fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, fieldOrSpec, options2);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Collection.prototype.createIndexes = function(indexSpecs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {};
      if (typeof options2.maxTimeMS !== "number")
        delete options2.maxTimeMS;
      const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, indexSpecs, options2);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Collection.prototype.dropIndex = function(indexName, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      options2.readPreference = ReadPreference.PRIMARY;
      const dropIndexOperation = new DropIndexOperation(this, indexName, options2);
      return executeOperation(this.s.topology, dropIndexOperation, callback);
    };
    Collection.prototype.dropIndexes = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {};
      if (typeof options2.maxTimeMS !== "number")
        delete options2.maxTimeMS;
      const dropIndexesOperation = new DropIndexesOperation(this, options2);
      return executeOperation(this.s.topology, dropIndexesOperation, callback);
    };
    Collection.prototype.dropAllIndexes = deprecate(Collection.prototype.dropIndexes, "collection.dropAllIndexes is deprecated. Use dropIndexes instead.");
    Collection.prototype.reIndex = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const reIndexOperation = new ReIndexOperation(this, options2);
      return executeOperation(this.s.topology, reIndexOperation, callback);
    }, "collection.reIndex is deprecated. Use db.command instead.");
    Collection.prototype.listIndexes = function(options2) {
      const cursor = new CommandCursor(this.s.topology, new ListIndexesOperation(this, options2), options2);
      return cursor;
    };
    Collection.prototype.ensureIndex = deprecate(function(fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.s.topology, ensureIndex, [
        this,
        fieldOrSpec,
        options2,
        callback
      ]);
    }, "collection.ensureIndex is deprecated. Use createIndexes instead.");
    Collection.prototype.indexExists = function(indexes, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const indexExistsOperation = new IndexExistsOperation(this, indexes, options2);
      return executeOperation(this.s.topology, indexExistsOperation, callback);
    };
    Collection.prototype.indexInformation = function(options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      const indexInformationOperation = new IndexInformationOperation(this.s.db, this.collectionName, options2);
      return executeOperation(this.s.topology, indexInformationOperation, callback);
    };
    Collection.prototype.count = deprecate(function(query, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      query = args.length ? args.shift() || {} : {};
      options2 = args.length ? args.shift() || {} : {};
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeOperation(this.s.topology, new EstimatedDocumentCountOperation(this, query, options2), callback);
    }, "collection.count is deprecated, and will be removed in a future version. Use Collection.countDocuments or Collection.estimatedDocumentCount instead");
    Collection.prototype.estimatedDocumentCount = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const estimatedDocumentCountOperation = new EstimatedDocumentCountOperation(this, options2);
      return executeOperation(this.s.topology, estimatedDocumentCountOperation, callback);
    };
    Collection.prototype.countDocuments = function(query, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      query = args.length ? args.shift() || {} : {};
      options2 = args.length ? args.shift() || {} : {};
      const countDocumentsOperation = new CountDocumentsOperation(this, query, options2);
      return executeOperation(this.s.topology, countDocumentsOperation, callback);
    };
    Collection.prototype.distinct = function(key, query, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      const queryOption = args.length ? args.shift() || {} : {};
      const optionsOption = args.length ? args.shift() || {} : {};
      const distinctOperation = new DistinctOperation(this, key, queryOption, optionsOption);
      return executeOperation(this.s.topology, distinctOperation, callback);
    };
    Collection.prototype.indexes = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const indexesOperation = new IndexesOperation(this, options2);
      return executeOperation(this.s.topology, indexesOperation, callback);
    };
    Collection.prototype.stats = function(options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      const statsOperation = new StatsOperation(this, options2);
      return executeOperation(this.s.topology, statsOperation, callback);
    };
    Collection.prototype.findOneAndDelete = function(filter, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndDeleteOperation(this, filter, options2), callback);
    };
    Collection.prototype.findOneAndReplace = deprecateOptions({
      name: "collection.findOneAndReplace",
      deprecatedOptions: ["returnOriginal"],
      optionsIndex: 2
    }, function(filter, replacement, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndReplaceOperation(this, filter, replacement, options2), callback);
    });
    Collection.prototype.findOneAndUpdate = deprecateOptions({
      name: "collection.findOneAndUpdate",
      deprecatedOptions: ["returnOriginal"],
      optionsIndex: 2
    }, function(filter, update, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndUpdateOperation(this, filter, update, options2), callback);
    });
    Collection.prototype.findAndModify = deprecate(_findAndModify, "collection.findAndModify is deprecated. Use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead.");
    Collection.prototype._findAndModify = _findAndModify;
    function _findAndModify(query, sort, doc2, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      sort = args.length ? args.shift() || [] : [];
      doc2 = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() || {} : {};
      options2 = Object.assign({}, options2);
      options2.readPreference = ReadPreference.PRIMARY;
      return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, doc2, options2), callback);
    }
    Collection.prototype.findAndRemove = deprecate(function(query, sort, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      sort = args.length ? args.shift() || [] : [];
      options2 = args.length ? args.shift() || {} : {};
      options2.remove = true;
      return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, null, options2), callback);
    }, "collection.findAndRemove is deprecated. Use findOneAndDelete instead.");
    Collection.prototype.aggregate = function(pipeline2, options2, callback) {
      if (Array.isArray(pipeline2)) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        if (options2 == null && callback == null) {
          options2 = {};
        }
      } else {
        const args = Array.prototype.slice.call(arguments, 0);
        callback = args.pop();
        const opts = args[args.length - 1];
        options2 = opts && (opts.readPreference || opts.explain || opts.cursor || opts.out || opts.maxTimeMS || opts.hint || opts.allowDiskUse) ? args.pop() : {};
        pipeline2 = args;
      }
      const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline2, options2), options2);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    };
    Collection.prototype.watch = function(pipeline2, options2) {
      pipeline2 = pipeline2 || [];
      options2 = options2 || {};
      if (!Array.isArray(pipeline2)) {
        options2 = pipeline2;
        pipeline2 = [];
      }
      return new ChangeStream(this, pipeline2, options2);
    };
    Collection.prototype.parallelCollectionScan = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {numCursors: 1};
      options2.numCursors = options2.numCursors || 1;
      options2.batchSize = options2.batchSize || 1e3;
      options2 = Object.assign({}, options2);
      options2.readPreference = ReadPreference.resolve(this, options2);
      options2.promiseLibrary = this.s.promiseLibrary;
      if (options2.session) {
        options2.session = void 0;
      }
      return executeLegacyOperation(this.s.topology, parallelCollectionScan, [this, options2, callback], {skipSessions: true});
    }, "parallelCollectionScan is deprecated in MongoDB v4.1");
    Collection.prototype.geoHaystackSearch = deprecate(function(x, y, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      const geoHaystackSearchOperation = new GeoHaystackSearchOperation(this, x, y, options2);
      return executeOperation(this.s.topology, geoHaystackSearchOperation, callback);
    }, "geoHaystackSearch is deprecated, and will be removed in a future version.");
    Collection.prototype.group = deprecate(function(keys, condition, initial, reduce, finalize, command2, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 3);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      reduce = args.length ? args.shift() : null;
      finalize = args.length ? args.shift() : null;
      command2 = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() || {} : {};
      if (!(typeof finalize === "function")) {
        command2 = finalize;
        finalize = null;
      }
      if (!Array.isArray(keys) && keys instanceof Object && typeof keys !== "function" && !(keys._bsontype === "Code")) {
        keys = Object.keys(keys);
      }
      if (typeof reduce === "function") {
        reduce = reduce.toString();
      }
      if (typeof finalize === "function") {
        finalize = finalize.toString();
      }
      command2 = command2 == null ? true : command2;
      return executeLegacyOperation(this.s.topology, group, [
        this,
        keys,
        condition,
        initial,
        reduce,
        finalize,
        command2,
        options2,
        callback
      ]);
    }, "MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.");
    Collection.prototype.mapReduce = function(map, reduce, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      if (options2.out == null) {
        throw new Error("the out option parameter must be defined, see mongodb docs for possible values");
      }
      if (typeof map === "function") {
        map = map.toString();
      }
      if (typeof reduce === "function") {
        reduce = reduce.toString();
      }
      if (typeof options2.finalize === "function") {
        options2.finalize = options2.finalize.toString();
      }
      const mapReduceOperation = new MapReduceOperation(this, map, reduce, options2);
      return executeOperation(this.s.topology, mapReduceOperation, callback);
    };
    Collection.prototype.initializeUnorderedBulkOp = function(options2) {
      options2 = options2 || {};
      if (options2.ignoreUndefined == null) {
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      options2.promiseLibrary = this.s.promiseLibrary;
      return unordered(this.s.topology, this, options2);
    };
    Collection.prototype.initializeOrderedBulkOp = function(options2) {
      options2 = options2 || {};
      if (options2.ignoreUndefined == null) {
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      options2.promiseLibrary = this.s.promiseLibrary;
      return ordered(this.s.topology, this, options2);
    };
    Collection.prototype.getLogger = function() {
      return this.s.db.s.logger;
    };
    module2.exports = Collection;
  }
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS({
  "node_modules/mongodb/lib/change_stream.js"(exports2, module2) {
    "use strict";
    var Denque = require_denque();
    var EventEmitter = require("events");
    var isResumableError = require_error2().isResumableError;
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var relayEvents = require_utils2().relayEvents;
    var maxWireVersion = require_utils2().maxWireVersion;
    var maybePromise = require_utils4().maybePromise;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var AggregateOperation = require_aggregate();
    var kResumeQueue = Symbol("resumeQueue");
    var CHANGE_STREAM_OPTIONS = ["resumeAfter", "startAfter", "startAtOperationTime", "fullDocument"];
    var CURSOR_OPTIONS = ["batchSize", "maxAwaitTimeMS", "collation", "readPreference"].concat(CHANGE_STREAM_OPTIONS);
    var CHANGE_DOMAIN_TYPES = {
      COLLECTION: Symbol("Collection"),
      DATABASE: Symbol("Database"),
      CLUSTER: Symbol("Cluster")
    };
    var ChangeStream = class extends EventEmitter {
      constructor(parent, pipeline2, options2) {
        super();
        const Collection = require_collection();
        const Db = require_db();
        const MongoClient2 = require_mongo_client();
        this.pipeline = pipeline2 || [];
        this.options = options2 || {};
        this.parent = parent;
        this.namespace = parent.s.namespace;
        if (parent instanceof Collection) {
          this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
          this.topology = parent.s.db.serverConfig;
        } else if (parent instanceof Db) {
          this.type = CHANGE_DOMAIN_TYPES.DATABASE;
          this.topology = parent.serverConfig;
        } else if (parent instanceof MongoClient2) {
          this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
          this.topology = parent.topology;
        } else {
          throw new TypeError("parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient");
        }
        this.promiseLibrary = parent.s.promiseLibrary;
        if (!this.options.readPreference && parent.s.readPreference) {
          this.options.readPreference = parent.s.readPreference;
        }
        this[kResumeQueue] = new Denque();
        this.cursor = createChangeStreamCursor(this, options2);
        this.closed = false;
        this.on("newListener", (eventName) => {
          if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
            this.cursor.on("data", (change) => processNewChange(this, change));
          }
        });
        this.on("removeListener", (eventName) => {
          if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
            this.cursor.removeAllListeners("data");
          }
        });
      }
      get resumeToken() {
        return this.cursor.resumeToken;
      }
      hasNext(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          getCursor(this, (err, cursor) => {
            if (err)
              return cb(err);
            cursor.hasNext(cb);
          });
        });
      }
      next(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          getCursor(this, (err, cursor) => {
            if (err)
              return cb(err);
            cursor.next((error3, change) => {
              if (error3) {
                this[kResumeQueue].push(() => this.next(cb));
                processError(this, error3, cb);
                return;
              }
              processNewChange(this, change, cb);
            });
          });
        });
      }
      isClosed() {
        return this.closed || this.cursor && this.cursor.isClosed();
      }
      close(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          if (this.closed)
            return cb();
          this.closed = true;
          if (!this.cursor)
            return cb();
          const cursor = this.cursor;
          return cursor.close((err) => {
            ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
            this.cursor = void 0;
            return cb(err);
          });
        });
      }
      pipe(destination, options2) {
        if (!this.pipeDestinations) {
          this.pipeDestinations = [];
        }
        this.pipeDestinations.push(destination);
        return this.cursor.pipe(destination, options2);
      }
      unpipe(destination) {
        if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {
          this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);
        }
        return this.cursor.unpipe(destination);
      }
      stream(options2) {
        this.streamOptions = options2;
        return this.cursor.stream(options2);
      }
      pause() {
        return this.cursor.pause();
      }
      resume() {
        return this.cursor.resume();
      }
    };
    var ChangeStreamCursor = class extends Cursor {
      constructor(topology, operation, options2) {
        super(topology, operation, options2);
        options2 = options2 || {};
        this._resumeToken = null;
        this.startAtOperationTime = options2.startAtOperationTime;
        if (options2.startAfter) {
          this.resumeToken = options2.startAfter;
        } else if (options2.resumeAfter) {
          this.resumeToken = options2.resumeAfter;
        }
      }
      set resumeToken(token) {
        this._resumeToken = token;
        this.emit("resumeTokenChanged", token);
      }
      get resumeToken() {
        return this._resumeToken;
      }
      get resumeOptions() {
        const result = {};
        for (const optionName of CURSOR_OPTIONS) {
          if (this.options[optionName])
            result[optionName] = this.options[optionName];
        }
        if (this.resumeToken || this.startAtOperationTime) {
          ["resumeAfter", "startAfter", "startAtOperationTime"].forEach((key) => delete result[key]);
          if (this.resumeToken) {
            const resumeKey = this.options.startAfter && !this.hasReceived ? "startAfter" : "resumeAfter";
            result[resumeKey] = this.resumeToken;
          } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {
            result.startAtOperationTime = this.startAtOperationTime;
          }
        }
        return result;
      }
      cacheResumeToken(resumeToken) {
        if (this.bufferedCount() === 0 && this.cursorState.postBatchResumeToken) {
          this.resumeToken = this.cursorState.postBatchResumeToken;
        } else {
          this.resumeToken = resumeToken;
        }
        this.hasReceived = true;
      }
      _processBatch(batchName, response) {
        const cursor = response.cursor;
        if (cursor.postBatchResumeToken) {
          this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;
          if (cursor[batchName].length === 0) {
            this.resumeToken = cursor.postBatchResumeToken;
          }
        }
      }
      _initializeCursor(callback) {
        super._initializeCursor((err, result) => {
          if (err || result == null) {
            callback(err, result);
            return;
          }
          const response = result.documents[0];
          if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && maxWireVersion(this.server) >= 7) {
            this.startAtOperationTime = response.operationTime;
          }
          this._processBatch("firstBatch", response);
          this.emit("init", result);
          this.emit("response");
          callback(err, result);
        });
      }
      _getMore(callback) {
        super._getMore((err, response) => {
          if (err) {
            callback(err);
            return;
          }
          this._processBatch("nextBatch", response);
          this.emit("more", response);
          this.emit("response");
          callback(err, response);
        });
      }
    };
    function createChangeStreamCursor(self2, options2) {
      const changeStreamStageOptions = {fullDocument: options2.fullDocument || "default"};
      applyKnownOptions(changeStreamStageOptions, options2, CHANGE_STREAM_OPTIONS);
      if (self2.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
        changeStreamStageOptions.allChangesForCluster = true;
      }
      const pipeline2 = [{$changeStream: changeStreamStageOptions}].concat(self2.pipeline);
      const cursorOptions = applyKnownOptions({}, options2, CURSOR_OPTIONS);
      const changeStreamCursor = new ChangeStreamCursor(self2.topology, new AggregateOperation(self2.parent, pipeline2, options2), cursorOptions);
      relayEvents(changeStreamCursor, self2, ["resumeTokenChanged", "end", "close"]);
      if (self2.listenerCount("change") > 0) {
        changeStreamCursor.on("data", function(change) {
          processNewChange(self2, change);
        });
      }
      changeStreamCursor.on("error", function(error3) {
        processError(self2, error3);
      });
      if (self2.pipeDestinations) {
        const cursorStream = changeStreamCursor.stream(self2.streamOptions);
        for (let pipeDestination of self2.pipeDestinations) {
          cursorStream.pipe(pipeDestination);
        }
      }
      return changeStreamCursor;
    }
    function applyKnownOptions(target, source, optionNames) {
      optionNames.forEach((name2) => {
        if (source[name2]) {
          target[name2] = source[name2];
        }
      });
      return target;
    }
    var SELECTION_TIMEOUT = 3e4;
    function waitForTopologyConnected(topology, options2, callback) {
      setTimeout(() => {
        if (options2 && options2.start == null) {
          options2.start = now();
        }
        const start = options2.start || now();
        const timeout = options2.timeout || SELECTION_TIMEOUT;
        const readPreference = options2.readPreference;
        if (topology.isConnected({readPreference})) {
          return callback();
        }
        if (calculateDurationInMs(start) > timeout) {
          return callback(new MongoError("Timed out waiting for connection"));
        }
        waitForTopologyConnected(topology, options2, callback);
      }, 500);
    }
    function processNewChange(changeStream, change, callback) {
      const cursor = changeStream.cursor;
      if (change == null) {
        changeStream.closed = true;
      }
      if (changeStream.closed) {
        if (callback)
          callback(new MongoError("ChangeStream is closed"));
        return;
      }
      if (change && !change._id) {
        const noResumeTokenError = new Error("A change stream document has been received that lacks a resume token (_id).");
        if (!callback)
          return changeStream.emit("error", noResumeTokenError);
        return callback(noResumeTokenError);
      }
      cursor.cacheResumeToken(change._id);
      changeStream.options.startAtOperationTime = void 0;
      if (!callback)
        return changeStream.emit("change", change);
      return callback(void 0, change);
    }
    function processError(changeStream, error3, callback) {
      const topology = changeStream.topology;
      const cursor = changeStream.cursor;
      if (changeStream.closed) {
        if (callback)
          callback(new MongoError("ChangeStream is closed"));
        return;
      }
      function resumeWithCursor(newCursor) {
        changeStream.cursor = newCursor;
        processResumeQueue(changeStream);
      }
      function unresumableError(err) {
        if (!callback) {
          changeStream.emit("error", err);
          changeStream.emit("close");
        }
        processResumeQueue(changeStream, err);
        changeStream.closed = true;
      }
      if (cursor && isResumableError(error3, maxWireVersion(cursor.server))) {
        changeStream.cursor = void 0;
        ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
        cursor.close();
        waitForTopologyConnected(topology, {readPreference: cursor.options.readPreference}, (err) => {
          if (err)
            return unresumableError(err);
          const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);
          if (!callback)
            return resumeWithCursor(newCursor);
          newCursor.hasNext((err2) => {
            if (err2)
              return unresumableError(err2);
            resumeWithCursor(newCursor);
          });
        });
        return;
      }
      if (!callback)
        return changeStream.emit("error", error3);
      return callback(error3);
    }
    function getCursor(changeStream, callback) {
      if (changeStream.isClosed()) {
        callback(new MongoError("ChangeStream is closed."));
        return;
      }
      if (changeStream.cursor) {
        callback(void 0, changeStream.cursor);
        return;
      }
      changeStream[kResumeQueue].push(callback);
    }
    function processResumeQueue(changeStream, err) {
      while (changeStream[kResumeQueue].length) {
        const request = changeStream[kResumeQueue].pop();
        if (changeStream.isClosed() && !err) {
          request(new MongoError("Change Stream is not open."));
          return;
        }
        request(err, changeStream.cursor);
      }
    }
    module2.exports = ChangeStream;
  }
});

// node_modules/mongodb/lib/topologies/topology_base.js
var require_topology_base = __commonJS({
  "node_modules/mongodb/lib/topologies/topology_base.js"(exports2) {
    "use strict";
    var EventEmitter = require("events");
    var MongoError = require_core().MongoError;
    var f = require("util").format;
    var ReadPreference = require_core().ReadPreference;
    var ClientSession = require_core().Sessions.ClientSession;
    var Store = function(topology, storeOptions) {
      var self2 = this;
      var storedOps = [];
      storeOptions = storeOptions || {force: false, bufferMaxEntries: -1};
      this.s = {
        storedOps,
        storeOptions,
        topology
      };
      Object.defineProperty(this, "length", {
        enumerable: true,
        get: function() {
          return self2.s.storedOps.length;
        }
      });
    };
    Store.prototype.add = function(opType, ns, ops, options2, callback) {
      if (this.s.storeOptions.force) {
        return callback(MongoError.create({message: "db closed by application", driver: true}));
      }
      if (this.s.storeOptions.bufferMaxEntries === 0) {
        return callback(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
        while (this.s.storedOps.length > 0) {
          var op = this.s.storedOps.shift();
          op.c(MongoError.create({
            message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
            driver: true
          }));
        }
        return;
      }
      this.s.storedOps.push({t: opType, n: ns, o: ops, op: options2, c: callback});
    };
    Store.prototype.addObjectAndMethod = function(opType, object, method, params, callback) {
      if (this.s.storeOptions.force) {
        return callback(MongoError.create({message: "db closed by application", driver: true}));
      }
      if (this.s.storeOptions.bufferMaxEntries === 0) {
        return callback(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
        while (this.s.storedOps.length > 0) {
          var op = this.s.storedOps.shift();
          op.c(MongoError.create({
            message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
            driver: true
          }));
        }
        return;
      }
      this.s.storedOps.push({t: opType, m: method, o: object, p: params, c: callback});
    };
    Store.prototype.flush = function(err) {
      while (this.s.storedOps.length > 0) {
        this.s.storedOps.shift().c(err || MongoError.create({message: f("no connection available for operation"), driver: true}));
      }
    };
    var primaryOptions = ["primary", "primaryPreferred", "nearest", "secondaryPreferred"];
    var secondaryOptions = ["secondary", "secondaryPreferred"];
    Store.prototype.execute = function(options2) {
      options2 = options2 || {};
      var ops = this.s.storedOps;
      this.s.storedOps = [];
      var executePrimary = typeof options2.executePrimary === "boolean" ? options2.executePrimary : true;
      var executeSecondary = typeof options2.executeSecondary === "boolean" ? options2.executeSecondary : true;
      while (ops.length > 0) {
        var op = ops.shift();
        if (op.t === "cursor") {
          if (executePrimary && executeSecondary) {
            op.o[op.m].apply(op.o, op.p);
          } else if (executePrimary && op.o.options && op.o.options.readPreference && primaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
            op.o[op.m].apply(op.o, op.p);
          } else if (!executePrimary && executeSecondary && op.o.options && op.o.options.readPreference && secondaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
            op.o[op.m].apply(op.o, op.p);
          }
        } else if (op.t === "auth") {
          this.s.topology[op.t].apply(this.s.topology, op.o);
        } else {
          if (executePrimary && executeSecondary) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          } else if (executePrimary && op.op && op.op.readPreference && primaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          } else if (!executePrimary && executeSecondary && op.op && op.op.readPreference && secondaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          }
        }
      }
    };
    Store.prototype.all = function() {
      return this.s.storedOps;
    };
    var ServerCapabilities = function(ismaster) {
      var setup_get_property = function(object, name2, value) {
        Object.defineProperty(object, name2, {
          enumerable: true,
          get: function() {
            return value;
          }
        });
      };
      var aggregationCursor = false;
      var writeCommands = false;
      var textSearch = false;
      var authCommands = false;
      var listCollections = false;
      var listIndexes = false;
      var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1e3;
      var commandsTakeWriteConcern = false;
      var commandsTakeCollation = false;
      if (ismaster.minWireVersion >= 0) {
        textSearch = true;
      }
      if (ismaster.maxWireVersion >= 1) {
        aggregationCursor = true;
        authCommands = true;
      }
      if (ismaster.maxWireVersion >= 2) {
        writeCommands = true;
      }
      if (ismaster.maxWireVersion >= 3) {
        listCollections = true;
        listIndexes = true;
      }
      if (ismaster.maxWireVersion >= 5) {
        commandsTakeWriteConcern = true;
        commandsTakeCollation = true;
      }
      if (ismaster.minWireVersion == null) {
        ismaster.minWireVersion = 0;
      }
      if (ismaster.maxWireVersion == null) {
        ismaster.maxWireVersion = 0;
      }
      setup_get_property(this, "hasAggregationCursor", aggregationCursor);
      setup_get_property(this, "hasWriteCommands", writeCommands);
      setup_get_property(this, "hasTextSearch", textSearch);
      setup_get_property(this, "hasAuthCommands", authCommands);
      setup_get_property(this, "hasListCollectionsCommand", listCollections);
      setup_get_property(this, "hasListIndexesCommand", listIndexes);
      setup_get_property(this, "minWireVersion", ismaster.minWireVersion);
      setup_get_property(this, "maxWireVersion", ismaster.maxWireVersion);
      setup_get_property(this, "maxNumberOfDocsInBatch", maxNumberOfDocsInBatch);
      setup_get_property(this, "commandsTakeWriteConcern", commandsTakeWriteConcern);
      setup_get_property(this, "commandsTakeCollation", commandsTakeCollation);
    };
    var TopologyBase = class extends EventEmitter {
      constructor() {
        super();
        this.setMaxListeners(Infinity);
      }
      hasSessionSupport() {
        return this.logicalSessionTimeoutMinutes != null;
      }
      startSession(options2, clientOptions) {
        const session = new ClientSession(this, this.s.sessionPool, options2, clientOptions);
        session.once("ended", () => {
          this.s.sessions.delete(session);
        });
        this.s.sessions.add(session);
        return session;
      }
      endSessions(sessions, callback) {
        return this.s.coreTopology.endSessions(sessions, callback);
      }
      get clientMetadata() {
        return this.s.coreTopology.s.options.metadata;
      }
      capabilities() {
        if (this.s.sCapabilities)
          return this.s.sCapabilities;
        if (this.s.coreTopology.lastIsMaster() == null)
          return null;
        this.s.sCapabilities = new ServerCapabilities(this.s.coreTopology.lastIsMaster());
        return this.s.sCapabilities;
      }
      command(ns, cmd2, options2, callback) {
        this.s.coreTopology.command(ns.toString(), cmd2, ReadPreference.translate(options2), callback);
      }
      insert(ns, ops, options2, callback) {
        this.s.coreTopology.insert(ns.toString(), ops, options2, callback);
      }
      update(ns, ops, options2, callback) {
        this.s.coreTopology.update(ns.toString(), ops, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        this.s.coreTopology.remove(ns.toString(), ops, options2, callback);
      }
      isConnected(options2) {
        options2 = options2 || {};
        options2 = ReadPreference.translate(options2);
        return this.s.coreTopology.isConnected(options2);
      }
      isDestroyed() {
        return this.s.coreTopology.isDestroyed();
      }
      cursor(ns, cmd2, options2) {
        options2 = options2 || {};
        options2 = ReadPreference.translate(options2);
        options2.disconnectHandler = this.s.store;
        options2.topology = this;
        return this.s.coreTopology.cursor(ns, cmd2, options2);
      }
      lastIsMaster() {
        return this.s.coreTopology.lastIsMaster();
      }
      selectServer(selector, options2, callback) {
        return this.s.coreTopology.selectServer(selector, options2, callback);
      }
      unref() {
        return this.s.coreTopology.unref();
      }
      connections() {
        return this.s.coreTopology.connections();
      }
      close(forceClosed, callback) {
        this.s.sessions.forEach((session) => session.endSession());
        if (this.s.sessionPool) {
          this.s.sessionPool.endAllPooledSessions();
        }
        if (forceClosed === true) {
          this.s.storeOptions.force = forceClosed;
          this.s.store.flush();
        }
        this.s.coreTopology.destroy({
          force: typeof forceClosed === "boolean" ? forceClosed : false
        }, callback);
      }
    };
    Object.defineProperty(TopologyBase.prototype, "bson", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.bson;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.parserType;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.logicalSessionTimeoutMinutes;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "type", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.type;
      }
    });
    exports2.Store = Store;
    exports2.ServerCapabilities = ServerCapabilities;
    exports2.TopologyBase = TopologyBase;
  }
});

// node_modules/mongodb/lib/topologies/native_topology.js
var require_native_topology = __commonJS({
  "node_modules/mongodb/lib/topologies/native_topology.js"(exports2, module2) {
    "use strict";
    var Topology = require_core().Topology;
    var ServerCapabilities = require_topology_base().ServerCapabilities;
    var Cursor = require_cursor2();
    var translateOptions = require_utils4().translateOptions;
    var NativeTopology = class extends Topology {
      constructor(servers, options2) {
        options2 = options2 || {};
        let clonedOptions = Object.assign({}, {
          cursorFactory: Cursor,
          reconnect: false,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          maxPoolSize: typeof options2.maxPoolSize === "number" ? options2.maxPoolSize : typeof options2.poolSize === "number" ? options2.poolSize : 10,
          minPoolSize: typeof options2.minPoolSize === "number" ? options2.minPoolSize : typeof options2.minSize === "number" ? options2.minSize : 0,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        super(servers, clonedOptions);
      }
      capabilities() {
        if (this.s.sCapabilities)
          return this.s.sCapabilities;
        if (this.lastIsMaster() == null)
          return null;
        this.s.sCapabilities = new ServerCapabilities(this.lastIsMaster());
        return this.s.sCapabilities;
      }
      command(ns, cmd2, options2, callback) {
        super.command(ns.toString(), cmd2, options2, callback);
      }
      insert(ns, ops, options2, callback) {
        super.insert(ns.toString(), ops, options2, callback);
      }
      update(ns, ops, options2, callback) {
        super.update(ns.toString(), ops, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        super.remove(ns.toString(), ops, options2, callback);
      }
    };
    module2.exports = NativeTopology;
  }
});

// node_modules/mongodb/lib/topologies/server.js
var require_server3 = __commonJS({
  "node_modules/mongodb/lib/topologies/server.js"(exports2, module2) {
    "use strict";
    var CServer = require_core().Server;
    var Cursor = require_cursor2();
    var TopologyBase = require_topology_base().TopologyBase;
    var Store = require_topology_base().Store;
    var MongoError = require_core().MongoError;
    var MAX_JS_INT = require_utils4().MAX_JS_INT;
    var translateOptions = require_utils4().translateOptions;
    var filterOptions = require_utils4().filterOptions;
    var mergeOptions = require_utils4().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "acceptableLatencyMS",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCRL",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "family",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "reconnectInterval",
      "monitoring",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "compression",
      "promiseLibrary",
      "monitorCommands"
    ];
    var Server = class extends TopologyBase {
      constructor(host, port, options2) {
        super();
        var self2 = this;
        options2 = filterOptions(options2, legalOptionNames);
        const promiseLibrary = options2.promiseLibrary;
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : MAX_JS_INT
        };
        var store = options2.store || new Store(self2, storeOptions);
        if (host.indexOf("/") !== -1) {
          if (port != null && typeof port === "object") {
            options2 = port;
            port = null;
          }
        } else if (port == null) {
          throw MongoError.create({message: "port must be specified", driver: true});
        }
        var reconnect = typeof options2.auto_reconnect === "boolean" ? options2.auto_reconnect : true;
        reconnect = typeof options2.autoReconnect === "boolean" ? options2.autoReconnect : reconnect;
        var clonedOptions = mergeOptions({}, {
          host,
          port,
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          size: typeof options2.poolSize === "number" ? options2.poolSize : 5,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        this.s = {
          coreTopology: new CServer(clonedOptions),
          sCapabilities: null,
          clonedOptions,
          reconnect: clonedOptions.reconnect,
          emitError: clonedOptions.emitError,
          poolSize: clonedOptions.size,
          storeOptions,
          store,
          host,
          port,
          options: options2,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: promiseLibrary || Promise
        };
      }
      connect(_options, callback) {
        var self2 = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = this.s.clonedOptions;
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var connectErrorHandler = function() {
          return function(err) {
            var events = ["timeout", "error", "close"];
            events.forEach(function(e) {
              self2.s.coreTopology.removeListener(e, connectHandlers[e]);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            try {
              callback(err);
            } catch (err2) {
              process.nextTick(function() {
                throw err2;
              });
            }
          };
        };
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var reconnectHandler = function() {
          self2.emit("reconnect", self2);
          self2.s.store.execute();
        };
        var reconnectFailedHandler = function(err) {
          self2.emit("reconnectFailed", err);
          self2.s.store.flush(err);
        };
        var destroyHandler = function() {
          self2.s.store.flush();
        };
        var relay = function(event) {
          return function(t2, server) {
            self2.emit(event, t2, server);
          };
        };
        var connectHandler = function() {
          ["timeout", "error", "close", "destroy"].forEach(function(e) {
            self2.s.coreTopology.removeAllListeners(e);
          });
          self2.s.coreTopology.on("timeout", errorHandler("timeout"));
          self2.s.coreTopology.once("error", errorHandler("error"));
          self2.s.coreTopology.on("close", errorHandler("close"));
          self2.s.coreTopology.on("destroy", destroyHandler);
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var connectHandlers = {
          timeout: connectErrorHandler("timeout"),
          error: connectErrorHandler("error"),
          close: connectErrorHandler("close")
        };
        [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed"
        ].forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.once("timeout", connectHandlers.timeout);
        self2.s.coreTopology.once("error", connectHandlers.error);
        self2.s.coreTopology.once("close", connectHandlers.close);
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.on("reconnect", reconnectHandler);
        self2.s.coreTopology.on("reconnectFailed", reconnectFailedHandler);
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.on("attemptReconnect", relay("attemptReconnect"));
        self2.s.coreTopology.on("monitoring", relay("monitoring"));
        self2.s.coreTopology.connect(_options);
      }
    };
    Object.defineProperty(Server.prototype, "poolSize", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.connections().length;
      }
    });
    Object.defineProperty(Server.prototype, "autoReconnect", {
      enumerable: true,
      get: function() {
        return this.s.reconnect;
      }
    });
    Object.defineProperty(Server.prototype, "host", {
      enumerable: true,
      get: function() {
        return this.s.host;
      }
    });
    Object.defineProperty(Server.prototype, "port", {
      enumerable: true,
      get: function() {
        return this.s.port;
      }
    });
    module2.exports = Server;
  }
});

// node_modules/mongodb/lib/topologies/mongos.js
var require_mongos2 = __commonJS({
  "node_modules/mongodb/lib/topologies/mongos.js"(exports2, module2) {
    "use strict";
    var TopologyBase = require_topology_base().TopologyBase;
    var MongoError = require_core().MongoError;
    var CMongos = require_core().Mongos;
    var Cursor = require_cursor2();
    var Server = require_server3();
    var Store = require_topology_base().Store;
    var MAX_JS_INT = require_utils4().MAX_JS_INT;
    var translateOptions = require_utils4().translateOptions;
    var filterOptions = require_utils4().filterOptions;
    var mergeOptions = require_utils4().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "acceptableLatencyMS",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCRL",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "promiseLibrary",
      "monitorCommands"
    ];
    var Mongos = class extends TopologyBase {
      constructor(servers, options2) {
        super();
        options2 = options2 || {};
        var self2 = this;
        options2 = filterOptions(options2, legalOptionNames);
        for (var i = 0; i < servers.length; i++) {
          if (!(servers[i] instanceof Server)) {
            throw MongoError.create({
              message: "all seed list instances must be of the Server type",
              driver: true
            });
          }
        }
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : MAX_JS_INT
        };
        var store = options2.store || new Store(self2, storeOptions);
        var seedlist = servers.map(function(x) {
          return {host: x.host, port: x.port};
        });
        var reconnect = typeof options2.auto_reconnect === "boolean" ? options2.auto_reconnect : true;
        reconnect = typeof options2.autoReconnect === "boolean" ? options2.autoReconnect : reconnect;
        var clonedOptions = mergeOptions({}, {
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          size: typeof options2.poolSize === "number" ? options2.poolSize : 5,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        this.s = {
          coreTopology: new CMongos(seedlist, clonedOptions),
          sCapabilities: null,
          debug: clonedOptions.debug,
          storeOptions,
          clonedOptions,
          store,
          options: options2,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: options2.promiseLibrary || Promise
        };
      }
      connect(_options, callback) {
        var self2 = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = {};
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var connectErrorHandler = function() {
          return function(err) {
            var events2 = ["timeout", "error", "close"];
            events2.forEach(function(e) {
              self2.removeListener(e, connectErrorHandler);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            self2.close(true);
            try {
              callback(err);
            } catch (err2) {
              process.nextTick(function() {
                throw err2;
              });
            }
          };
        };
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var reconnectHandler = function() {
          self2.emit("reconnect");
          self2.s.store.execute();
        };
        var relay = function(event) {
          return function(t2, server) {
            self2.emit(event, t2, server);
          };
        };
        var connectHandler = function() {
          var events2 = ["timeout", "error", "close", "fullsetup"];
          events2.forEach(function(e) {
            self2.s.coreTopology.removeAllListeners(e);
          });
          self2.s.coreTopology.on("timeout", errorHandler("timeout"));
          self2.s.coreTopology.on("error", errorHandler("error"));
          self2.s.coreTopology.on("close", errorHandler("close"));
          self2.s.coreTopology.on("fullsetup", function() {
            self2.emit("fullsetup", self2);
          });
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var events = [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed"
        ];
        events.forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
        self2.s.coreTopology.once("error", connectErrorHandler("error"));
        self2.s.coreTopology.once("close", connectErrorHandler("close"));
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.on("joined", relay("joined"));
        self2.s.coreTopology.on("left", relay("left"));
        self2.s.coreTopology.on("reconnect", reconnectHandler);
        self2.s.coreTopology.connect(_options);
      }
    };
    Object.defineProperty(Mongos.prototype, "haInterval", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.haInterval;
      }
    });
    module2.exports = Mongos;
  }
});

// node_modules/mongodb/lib/topologies/replset.js
var require_replset2 = __commonJS({
  "node_modules/mongodb/lib/topologies/replset.js"(exports2, module2) {
    "use strict";
    var Server = require_server3();
    var Cursor = require_cursor2();
    var MongoError = require_core().MongoError;
    var TopologyBase = require_topology_base().TopologyBase;
    var Store = require_topology_base().Store;
    var CReplSet = require_core().ReplSet;
    var MAX_JS_INT = require_utils4().MAX_JS_INT;
    var translateOptions = require_utils4().translateOptions;
    var filterOptions = require_utils4().filterOptions;
    var mergeOptions = require_utils4().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "replicaSet",
      "rs_name",
      "secondaryAcceptableLatencyMS",
      "connectWithNoPrimary",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslCRL",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "strategy",
      "debug",
      "family",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "maxStalenessSeconds",
      "promiseLibrary",
      "minSize",
      "monitorCommands"
    ];
    var ReplSet = class extends TopologyBase {
      constructor(servers, options2) {
        super();
        options2 = options2 || {};
        var self2 = this;
        options2 = filterOptions(options2, legalOptionNames);
        for (var i = 0; i < servers.length; i++) {
          if (!(servers[i] instanceof Server)) {
            throw MongoError.create({
              message: "all seed list instances must be of the Server type",
              driver: true
            });
          }
        }
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : MAX_JS_INT
        };
        var store = options2.store || new Store(self2, storeOptions);
        var seedlist = servers.map(function(x) {
          return {host: x.host, port: x.port};
        });
        var clonedOptions = mergeOptions({}, {
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect: false,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          size: typeof options2.poolSize === "number" ? options2.poolSize : 5,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        var coreTopology = new CReplSet(seedlist, clonedOptions);
        coreTopology.on("reconnect", function() {
          self2.emit("reconnect");
          store.execute();
        });
        this.s = {
          coreTopology,
          sCapabilities: null,
          tag: options2.tag,
          storeOptions,
          clonedOptions,
          store,
          options: options2,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: options2.promiseLibrary || Promise
        };
        if (clonedOptions.debug) {
          Object.defineProperty(this, "replset", {
            enumerable: true,
            get: function() {
              return coreTopology;
            }
          });
        }
      }
      connect(_options, callback) {
        var self2 = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = {};
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var events = [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed",
          "joined",
          "left",
          "ping",
          "ha"
        ];
        events.forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        var relay = function(event) {
          return function(t2, server) {
            self2.emit(event, t2, server);
          };
        };
        var replsetRelay = function(event) {
          return function(t2, server) {
            self2.emit(event, t2, server.lastIsMaster(), server);
          };
        };
        var relayHa = function(t2, state) {
          self2.emit("ha", t2, state);
          if (t2 === "start") {
            self2.emit("ha_connect", t2, state);
          } else if (t2 === "end") {
            self2.emit("ha_ismaster", t2, state);
          }
        };
        self2.s.coreTopology.on("joined", replsetRelay("joined"));
        self2.s.coreTopology.on("left", relay("left"));
        self2.s.coreTopology.on("ping", relay("ping"));
        self2.s.coreTopology.on("ha", relayHa);
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.on("fullsetup", function() {
          self2.emit("fullsetup", self2, self2);
        });
        self2.s.coreTopology.on("all", function() {
          self2.emit("all", null, self2);
        });
        var connectHandler = function() {
          self2.s.coreTopology.once("timeout", errorHandler("timeout"));
          self2.s.coreTopology.once("error", errorHandler("error"));
          self2.s.coreTopology.once("close", errorHandler("close"));
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var connectErrorHandler = function() {
          return function(err) {
            ["timeout", "error", "close"].forEach(function(e) {
              self2.s.coreTopology.removeListener(e, connectErrorHandler);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            self2.s.coreTopology.destroy();
            try {
              callback(err);
            } catch (err2) {
              if (!self2.s.coreTopology.isConnected())
                process.nextTick(function() {
                  throw err2;
                });
            }
          };
        };
        self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
        self2.s.coreTopology.once("error", connectErrorHandler("error"));
        self2.s.coreTopology.once("close", connectErrorHandler("close"));
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.connect(_options);
      }
      close(forceClosed, callback) {
        ["timeout", "error", "close", "joined", "left"].forEach((e) => this.removeAllListeners(e));
        super.close(forceClosed, callback);
      }
    };
    Object.defineProperty(ReplSet.prototype, "haInterval", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.haInterval;
      }
    });
    module2.exports = ReplSet;
  }
});

// node_modules/mongodb/lib/url_parser.js
var require_url_parser = __commonJS({
  "node_modules/mongodb/lib/url_parser.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_core().ReadPreference;
    var parser2 = require("url");
    var f = require("util").format;
    var Logger = require_core().Logger;
    var dns = require("dns");
    var ReadConcern = require_read_concern();
    var qs = require("querystring");
    var MongoParseError = require_error().MongoParseError;
    module2.exports = function(url, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      let result;
      try {
        result = parser2.parse(url, true);
      } catch (e) {
        return callback(new Error("URL malformed, cannot be parsed"));
      }
      if (result.protocol !== "mongodb:" && result.protocol !== "mongodb+srv:") {
        return callback(new Error("Invalid schema, expected `mongodb` or `mongodb+srv`"));
      }
      if (result.protocol === "mongodb:") {
        return parseHandler(url, options2, callback);
      }
      if (result.hostname.split(".").length < 3) {
        return callback(new Error("URI does not have hostname, domain name and tld"));
      }
      result.domainLength = result.hostname.split(".").length;
      if (result.pathname && result.pathname.match(",")) {
        return callback(new Error("Invalid URI, cannot contain multiple hostnames"));
      }
      if (result.port) {
        return callback(new Error("Ports not accepted with `mongodb+srv` URIs"));
      }
      let srvAddress = `_mongodb._tcp.${result.host}`;
      dns.resolveSrv(srvAddress, function(err, addresses) {
        if (err)
          return callback(err);
        if (addresses.length === 0) {
          return callback(new Error("No addresses found at host"));
        }
        for (let i = 0; i < addresses.length; i++) {
          if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
            return callback(new Error("Server record does not share hostname with parent URI"));
          }
        }
        let base2 = result.auth ? `mongodb://${result.auth}@` : `mongodb://`;
        let connectionStrings = addresses.map(function(address, i) {
          if (i === 0)
            return `${base2}${address.name}:${address.port}`;
          else
            return `${address.name}:${address.port}`;
        });
        let connectionString = connectionStrings.join(",") + "/";
        let connectionStringOptions = [];
        if (result.path) {
          let defaultDb = result.path.slice(1);
          if (defaultDb.indexOf("?") !== -1) {
            defaultDb = defaultDb.slice(0, defaultDb.indexOf("?"));
          }
          connectionString += defaultDb;
        }
        if (!options2.ssl && !result.search) {
          connectionStringOptions.push("ssl=true");
        } else if (!options2.ssl && result.search && !result.search.match("ssl")) {
          connectionStringOptions.push("ssl=true");
        }
        if (result.search) {
          connectionStringOptions.push(result.search.replace("?", ""));
        }
        dns.resolveTxt(result.host, function(err2, record) {
          if (err2 && err2.code !== "ENODATA" && err2.code !== "ENOTFOUND")
            return callback(err2);
          if (err2 && err2.code === "ENODATA")
            record = null;
          if (record) {
            if (record.length > 1) {
              return callback(new MongoParseError("Multiple text records not allowed"));
            }
            record = record[0].join("");
            const parsedRecord = qs.parse(record);
            const items = Object.keys(parsedRecord);
            if (items.some((item) => item !== "authSource" && item !== "replicaSet")) {
              return callback(new MongoParseError("Text record must only set `authSource` or `replicaSet`"));
            }
            if (items.length > 0) {
              connectionStringOptions.push(record);
            }
          }
          if (connectionStringOptions.length) {
            connectionString += `?${connectionStringOptions.join("&")}`;
          }
          parseHandler(connectionString, options2, callback);
        });
      });
    };
    function matchesParentDomain(srvAddress, parentDomain) {
      let regex = /^.*?\./;
      let srv = `.${srvAddress.replace(regex, "")}`;
      let parent = `.${parentDomain.replace(regex, "")}`;
      if (srv.endsWith(parent))
        return true;
      else
        return false;
    }
    function parseHandler(address, options2, callback) {
      let result, err;
      try {
        result = parseConnectionString(address, options2);
      } catch (e) {
        err = e;
      }
      return err ? callback(err, null) : callback(null, result);
    }
    function parseConnectionString(url, options2) {
      let connection_part = "";
      let auth_part = "";
      let query_string_part = "";
      let dbName = "admin";
      let result = parser2.parse(url, true);
      if ((result.hostname == null || result.hostname === "") && url.indexOf(".sock") === -1) {
        throw new Error("No hostname or hostnames provided in connection string");
      }
      if (result.port === "0") {
        throw new Error("Invalid port (zero) with hostname");
      }
      if (!isNaN(parseInt(result.port, 10)) && parseInt(result.port, 10) > 65535) {
        throw new Error("Invalid port (larger than 65535) with hostname");
      }
      if (result.path && result.path.length > 0 && result.path[0] !== "/" && url.indexOf(".sock") === -1) {
        throw new Error("Missing delimiting slash between hosts and options");
      }
      if (result.query) {
        for (let name2 in result.query) {
          if (name2.indexOf("::") !== -1) {
            throw new Error("Double colon in host identifier");
          }
          if (result.query[name2] === "") {
            throw new Error("Query parameter " + name2 + " is an incomplete value pair");
          }
        }
      }
      if (result.auth) {
        let parts = result.auth.split(":");
        if (url.indexOf(result.auth) !== -1 && parts.length > 2) {
          throw new Error("Username with password containing an unescaped colon");
        }
        if (url.indexOf(result.auth) !== -1 && result.auth.indexOf("@") !== -1) {
          throw new Error("Username containing an unescaped at-sign");
        }
      }
      let clean = url.split("?").shift();
      let strings = clean.split(",");
      let hosts = [];
      for (let i = 0; i < strings.length; i++) {
        let hostString = strings[i];
        if (hostString.indexOf("mongodb") !== -1) {
          if (hostString.indexOf("@") !== -1) {
            hosts.push(hostString.split("@").pop());
          } else {
            hosts.push(hostString.substr("mongodb://".length));
          }
        } else if (hostString.indexOf("/") !== -1) {
          hosts.push(hostString.split("/").shift());
        } else if (hostString.indexOf("/") === -1) {
          hosts.push(hostString.trim());
        }
      }
      for (let i = 0; i < hosts.length; i++) {
        let r = parser2.parse(f("mongodb://%s", hosts[i].trim()));
        if (r.path && r.path.indexOf(".sock") !== -1)
          continue;
        if (r.path && r.path.indexOf(":") !== -1) {
          if (r.path.split("/").length > 1 && r.path.indexOf("::") === -1) {
            throw new Error("Slash in host identifier");
          } else {
            throw new Error("Double colon in host identifier");
          }
        }
      }
      if (url.indexOf("?") !== -1) {
        query_string_part = url.substr(url.indexOf("?") + 1);
        connection_part = url.substring("mongodb://".length, url.indexOf("?"));
      } else {
        connection_part = url.substring("mongodb://".length);
      }
      if (connection_part.indexOf("@") !== -1) {
        auth_part = connection_part.split("@")[0];
        connection_part = connection_part.split("@")[1];
      }
      if (connection_part.split("/").length > 2) {
        throw new Error("Unsupported host '" + connection_part.split("?")[0] + "', hosts must be URL encoded and contain at most one unencoded slash");
      }
      if (connection_part.indexOf(".sock") !== -1) {
        if (connection_part.indexOf(".sock/") !== -1) {
          dbName = connection_part.split(".sock/")[1];
          if (dbName.indexOf("/") !== -1) {
            if (dbName.split("/").length === 2 && dbName.split("/")[1].length === 0) {
              throw new Error("Illegal trailing backslash after database name");
            }
            throw new Error("More than 1 database name in URL");
          }
          connection_part = connection_part.split("/", connection_part.indexOf(".sock") + ".sock".length);
        }
      } else if (connection_part.indexOf("/") !== -1) {
        if (connection_part.split("/").length > 2) {
          if (connection_part.split("/")[2].length === 0) {
            throw new Error("Illegal trailing backslash after database name");
          }
          throw new Error("More than 1 database name in URL");
        }
        dbName = connection_part.split("/")[1];
        connection_part = connection_part.split("/")[0];
      }
      connection_part = decodeURIComponent(connection_part);
      let object = {};
      let authPart = auth_part || "";
      let auth = authPart.split(":", 2);
      let user = decodeURIComponent(auth[0]);
      if (auth[0] !== encodeURIComponent(user)) {
        throw new Error("Username contains an illegal unescaped character");
      }
      auth[0] = user;
      if (auth[1]) {
        let pass = decodeURIComponent(auth[1]);
        if (auth[1] !== encodeURIComponent(pass)) {
          throw new Error("Password contains an illegal unescaped character");
        }
        auth[1] = pass;
      }
      if (auth.length === 2)
        object.auth = {user: auth[0], password: auth[1]};
      if (options2 && options2.auth != null)
        object.auth = options2.auth;
      let hostPart;
      let urlOptions;
      let servers;
      let compression;
      let serverOptions = {socketOptions: {}};
      let dbOptions = {read_preference_tags: []};
      let replSetServersOptions = {socketOptions: {}};
      let mongosOptions = {socketOptions: {}};
      object.server_options = serverOptions;
      object.db_options = dbOptions;
      object.rs_options = replSetServersOptions;
      object.mongos_options = mongosOptions;
      if (url.match(/\.sock/)) {
        let domainSocket = url.substring(url.indexOf("mongodb://") + "mongodb://".length, url.lastIndexOf(".sock") + ".sock".length);
        if (domainSocket.indexOf("@") !== -1)
          domainSocket = domainSocket.split("@")[1];
        domainSocket = decodeURIComponent(domainSocket);
        servers = [{domain_socket: domainSocket}];
      } else {
        hostPart = connection_part;
        let deduplicatedServers = {};
        servers = hostPart.split(",").map(function(h) {
          let _host, _port, ipv6match;
          if (ipv6match = /\[([^\]]+)\](?::(.+))?/.exec(h)) {
            _host = ipv6match[1];
            _port = parseInt(ipv6match[2], 10) || 27017;
          } else {
            let hostPort = h.split(":", 2);
            _host = hostPort[0] || "localhost";
            _port = hostPort[1] != null ? parseInt(hostPort[1], 10) : 27017;
            if (_host.indexOf("?") !== -1)
              _host = _host.split(/\?/)[0];
          }
          if (deduplicatedServers[_host + "_" + _port])
            return null;
          deduplicatedServers[_host + "_" + _port] = 1;
          return {host: _host, port: _port};
        }).filter(function(x) {
          return x != null;
        });
      }
      object.dbName = dbName || "admin";
      urlOptions = (query_string_part || "").split(/[&;]/);
      urlOptions.forEach(function(opt) {
        if (!opt)
          return;
        var splitOpt = opt.split("="), name2 = splitOpt[0], value = splitOpt[1];
        switch (name2) {
          case "slaveOk":
          case "slave_ok":
            serverOptions.slave_ok = value === "true";
            dbOptions.slaveOk = value === "true";
            break;
          case "maxPoolSize":
          case "poolSize":
            serverOptions.poolSize = parseInt(value, 10);
            replSetServersOptions.poolSize = parseInt(value, 10);
            break;
          case "appname":
            object.appname = decodeURIComponent(value);
            break;
          case "autoReconnect":
          case "auto_reconnect":
            serverOptions.auto_reconnect = value === "true";
            break;
          case "ssl":
            if (value === "prefer") {
              serverOptions.ssl = value;
              replSetServersOptions.ssl = value;
              mongosOptions.ssl = value;
              break;
            }
            serverOptions.ssl = value === "true";
            replSetServersOptions.ssl = value === "true";
            mongosOptions.ssl = value === "true";
            break;
          case "sslValidate":
            serverOptions.sslValidate = value === "true";
            replSetServersOptions.sslValidate = value === "true";
            mongosOptions.sslValidate = value === "true";
            break;
          case "replicaSet":
          case "rs_name":
            replSetServersOptions.rs_name = value;
            break;
          case "reconnectWait":
            replSetServersOptions.reconnectWait = parseInt(value, 10);
            break;
          case "retries":
            replSetServersOptions.retries = parseInt(value, 10);
            break;
          case "readSecondary":
          case "read_secondary":
            replSetServersOptions.read_secondary = value === "true";
            break;
          case "fsync":
            dbOptions.fsync = value === "true";
            break;
          case "journal":
            dbOptions.j = value === "true";
            break;
          case "safe":
            dbOptions.safe = value === "true";
            break;
          case "nativeParser":
          case "native_parser":
            dbOptions.native_parser = value === "true";
            break;
          case "readConcernLevel":
            dbOptions.readConcern = new ReadConcern(value);
            break;
          case "connectTimeoutMS":
            serverOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            replSetServersOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            mongosOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            break;
          case "socketTimeoutMS":
            serverOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            replSetServersOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            mongosOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            break;
          case "w":
            dbOptions.w = parseInt(value, 10);
            if (isNaN(dbOptions.w))
              dbOptions.w = value;
            break;
          case "authSource":
            dbOptions.authSource = value;
            break;
          case "gssapiServiceName":
            dbOptions.gssapiServiceName = value;
            break;
          case "authMechanism":
            if (value === "GSSAPI") {
              if (object.auth == null) {
                let urlDecodeAuthPart = decodeURIComponent(authPart);
                if (urlDecodeAuthPart.indexOf("@") === -1)
                  throw new Error("GSSAPI requires a provided principal");
                object.auth = {user: urlDecodeAuthPart, password: null};
              } else {
                object.auth.user = decodeURIComponent(object.auth.user);
              }
            } else if (value === "MONGODB-X509") {
              object.auth = {user: decodeURIComponent(authPart)};
            }
            if (value !== "GSSAPI" && value !== "MONGODB-X509" && value !== "MONGODB-CR" && value !== "DEFAULT" && value !== "SCRAM-SHA-1" && value !== "SCRAM-SHA-256" && value !== "PLAIN")
              throw new Error("Only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, or SCRAM-SHA-1 is supported by authMechanism");
            dbOptions.authMechanism = value;
            break;
          case "authMechanismProperties":
            {
              let values = value.split(",");
              let o = {};
              values.forEach(function(x) {
                let v = x.split(":");
                o[v[0]] = v[1];
              });
              dbOptions.authMechanismProperties = o;
              if (typeof o.SERVICE_NAME === "string")
                dbOptions.gssapiServiceName = o.SERVICE_NAME;
              if (typeof o.SERVICE_REALM === "string")
                dbOptions.gssapiServiceRealm = o.SERVICE_REALM;
              if (typeof o.CANONICALIZE_HOST_NAME === "string")
                dbOptions.gssapiCanonicalizeHostName = o.CANONICALIZE_HOST_NAME === "true" ? true : false;
            }
            break;
          case "wtimeoutMS":
            dbOptions.wtimeout = parseInt(value, 10);
            break;
          case "readPreference":
            if (!ReadPreference.isValid(value))
              throw new Error("readPreference must be either primary/primaryPreferred/secondary/secondaryPreferred/nearest");
            dbOptions.readPreference = value;
            break;
          case "maxStalenessSeconds":
            dbOptions.maxStalenessSeconds = parseInt(value, 10);
            break;
          case "readPreferenceTags":
            {
              value = decodeURIComponent(value);
              let tagObject = {};
              if (value == null || value === "") {
                dbOptions.read_preference_tags.push(tagObject);
                break;
              }
              let tags2 = value.split(/,/);
              for (let i = 0; i < tags2.length; i++) {
                let parts = tags2[i].trim().split(/:/);
                tagObject[parts[0]] = parts[1];
              }
              dbOptions.read_preference_tags.push(tagObject);
            }
            break;
          case "compressors":
            {
              compression = serverOptions.compression || {};
              let compressors = value.split(",");
              if (!compressors.every(function(compressor) {
                return compressor === "snappy" || compressor === "zlib";
              })) {
                throw new Error("Compressors must be at least one of snappy or zlib");
              }
              compression.compressors = compressors;
              serverOptions.compression = compression;
            }
            break;
          case "zlibCompressionLevel":
            {
              compression = serverOptions.compression || {};
              let zlibCompressionLevel = parseInt(value, 10);
              if (zlibCompressionLevel < -1 || zlibCompressionLevel > 9) {
                throw new Error("zlibCompressionLevel must be an integer between -1 and 9");
              }
              compression.zlibCompressionLevel = zlibCompressionLevel;
              serverOptions.compression = compression;
            }
            break;
          case "retryWrites":
            dbOptions.retryWrites = value === "true";
            break;
          case "minSize":
            dbOptions.minSize = parseInt(value, 10);
            break;
          default:
            {
              let logger = Logger("URL Parser");
              logger.warn(`${name2} is not supported as a connection string option`);
            }
            break;
        }
      });
      if (dbOptions.read_preference_tags.length === 0) {
        dbOptions.read_preference_tags = null;
      }
      if ((dbOptions.w === -1 || dbOptions.w === 0) && (dbOptions.journal === true || dbOptions.fsync === true || dbOptions.safe === true))
        throw new Error("w set to -1 or 0 cannot be combined with safe/w/journal/fsync");
      if (!dbOptions.readPreference) {
        dbOptions.readPreference = "primary";
      }
      dbOptions = Object.assign(dbOptions, options2);
      object.servers = servers;
      return object;
    }
  }
});

// node_modules/mongodb-client-encryption/lib/common.js
var require_common3 = __commonJS({
  "node_modules/mongodb-client-encryption/lib/common.js"(exports2, module2) {
    "use strict";
    function debug(msg) {
      if (process.env.MONGODB_CRYPT_DEBUG) {
        console.log(msg);
      }
    }
    function databaseNamespace(ns) {
      return ns.split(".")[0];
    }
    function collectionNamespace(ns) {
      return ns.split(".").slice(1).join(".");
    }
    var MongoCryptError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "MongoCryptError";
        Error.captureStackTrace(this, this.constructor);
      }
    };
    function promiseOrCallback(callback, fn) {
      if (typeof callback === "function") {
        fn(function(err) {
          if (err != null) {
            try {
              callback(err);
            } catch (error3) {
              return process.nextTick(() => {
                throw error3;
              });
            }
            return;
          }
          callback.apply(this, arguments);
        });
        return;
      }
      return new Promise((resolve2, reject) => {
        fn(function(err, res) {
          if (err != null) {
            return reject(err);
          }
          if (arguments.length > 2) {
            return resolve2(Array.prototype.slice.call(arguments, 1));
          }
          resolve2(res);
        });
      });
    }
    module2.exports = {
      debug,
      databaseNamespace,
      collectionNamespace,
      MongoCryptError,
      promiseOrCallback
    };
  }
});

// node_modules/mongodb-client-encryption/lib/stateMachine.js
var require_stateMachine = __commonJS({
  "node_modules/mongodb-client-encryption/lib/stateMachine.js"(exports2, module2) {
    "use strict";
    module2.exports = function(modules) {
      const tls = require("tls");
      const MongoTimeoutError = modules.mongodb.MongoTimeoutError;
      const common = require_common3();
      const debug = common.debug;
      const databaseNamespace = common.databaseNamespace;
      const collectionNamespace = common.collectionNamespace;
      const MongoCryptError = common.MongoCryptError;
      const BufferList = require_bl();
      const MONGOCRYPT_CTX_ERROR = 0;
      const MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;
      const MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;
      const MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;
      const MONGOCRYPT_CTX_NEED_KMS = 4;
      const MONGOCRYPT_CTX_READY = 5;
      const MONGOCRYPT_CTX_DONE = 6;
      const HTTPS_PORT = 443;
      const stateToString = new Map([
        [MONGOCRYPT_CTX_ERROR, "MONGOCRYPT_CTX_ERROR"],
        [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, "MONGOCRYPT_CTX_NEED_MONGO_COLLINFO"],
        [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, "MONGOCRYPT_CTX_NEED_MONGO_MARKINGS"],
        [MONGOCRYPT_CTX_NEED_MONGO_KEYS, "MONGOCRYPT_CTX_NEED_MONGO_KEYS"],
        [MONGOCRYPT_CTX_NEED_KMS, "MONGOCRYPT_CTX_NEED_KMS"],
        [MONGOCRYPT_CTX_READY, "MONGOCRYPT_CTX_READY"],
        [MONGOCRYPT_CTX_DONE, "MONGOCRYPT_CTX_DONE"]
      ]);
      class StateMachine {
        constructor(options2) {
          this.options = options2 || {};
          this.bson = options2.bson;
        }
        execute(autoEncrypter, context, callback) {
          const bson = this.bson;
          const keyVaultNamespace = autoEncrypter._keyVaultNamespace;
          const keyVaultClient = autoEncrypter._keyVaultClient;
          const metaDataClient = autoEncrypter._metaDataClient;
          const mongocryptdClient = autoEncrypter._mongocryptdClient;
          const mongocryptdManager = autoEncrypter._mongocryptdManager;
          debug(`[context#${context.id}] ${stateToString.get(context.state) || context.state}`);
          switch (context.state) {
            case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {
              const filter = bson.deserialize(context.nextMongoOperation());
              this.fetchCollectionInfo(metaDataClient, context.ns, filter, (err, collInfo) => {
                if (err) {
                  return callback(err, null);
                }
                if (collInfo) {
                  context.addMongoOperationResponse(collInfo);
                }
                context.finishMongoOperation();
                this.execute(autoEncrypter, context, callback);
              });
              return;
            }
            case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {
              const command2 = context.nextMongoOperation();
              this.markCommand(mongocryptdClient, context.ns, command2, (err, markedCommand) => {
                if (err) {
                  if (err instanceof MongoTimeoutError && mongocryptdManager && !mongocryptdManager.bypassSpawn) {
                    mongocryptdManager.spawn(() => {
                      this.markCommand(mongocryptdClient, context.ns, command2, (err2, markedCommand2) => {
                        if (err2)
                          return callback(err2, null);
                        context.addMongoOperationResponse(markedCommand2);
                        context.finishMongoOperation();
                        this.execute(autoEncrypter, context, callback);
                      });
                    });
                    return;
                  }
                  return callback(err, null);
                }
                context.addMongoOperationResponse(markedCommand);
                context.finishMongoOperation();
                this.execute(autoEncrypter, context, callback);
              });
              return;
            }
            case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {
              const filter = context.nextMongoOperation();
              this.fetchKeys(keyVaultClient, keyVaultNamespace, filter, (err, keys) => {
                if (err)
                  return callback(err, null);
                keys.forEach((key) => {
                  context.addMongoOperationResponse(bson.serialize(key));
                });
                context.finishMongoOperation();
                this.execute(autoEncrypter, context, callback);
              });
              return;
            }
            case MONGOCRYPT_CTX_NEED_KMS: {
              const promises = [];
              let request;
              while (request = context.nextKMSRequest()) {
                promises.push(this.kmsRequest(request));
              }
              Promise.all(promises).then(() => {
                context.finishKMSRequests();
                this.execute(autoEncrypter, context, callback);
              }).catch((err) => {
                callback(err, null);
              });
              return;
            }
            case MONGOCRYPT_CTX_READY: {
              const finalizedContext = context.finalize();
              if (context.state === MONGOCRYPT_CTX_ERROR) {
                const message = context.status.message || "Finalization error";
                callback(new MongoCryptError(message));
                return;
              }
              callback(null, bson.deserialize(finalizedContext, this.options));
              return;
            }
            case MONGOCRYPT_CTX_ERROR: {
              const message = context.status.message;
              callback(new MongoCryptError(message));
              return;
            }
            case MONGOCRYPT_CTX_DONE:
              return;
            default:
              callback(new MongoCryptError(`Unknown state: ${context.state}`));
              return;
          }
        }
        kmsRequest(request) {
          const parsedUrl = request.endpoint.split(":");
          const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;
          const options2 = {host: parsedUrl[0], servername: parsedUrl[0], port};
          const message = request.message;
          return new Promise((resolve2, reject) => {
            const buffer = new BufferList();
            const socket = tls.connect(options2, () => {
              socket.write(message);
            });
            socket.once("timeout", () => {
              socket.removeAllListeners();
              socket.destroy();
              reject(new MongoCryptError("KMS request timed out"));
            });
            socket.once("error", (err) => {
              socket.removeAllListeners();
              socket.destroy();
              const mcError = new MongoCryptError("KMS request failed");
              mcError.originalError = err;
              reject(mcError);
            });
            socket.on("data", (data) => {
              buffer.append(data);
              while (request.bytesNeeded > 0 && buffer.length) {
                const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);
                request.addResponse(buffer.slice(0, bytesNeeded));
                buffer.consume(bytesNeeded);
              }
              if (request.bytesNeeded <= 0) {
                socket.end(resolve2);
              }
            });
          });
        }
        fetchCollectionInfo(client, ns, filter, callback) {
          const bson = this.bson;
          const dbName = databaseNamespace(ns);
          client.db(dbName).listCollections(filter).toArray((err, collections) => {
            if (err) {
              callback(err, null);
              return;
            }
            const info = collections.length > 0 ? bson.serialize(collections[0]) : null;
            callback(null, info);
          });
        }
        markCommand(client, ns, command2, callback) {
          const bson = this.bson;
          const dbName = databaseNamespace(ns);
          const rawCommand = bson.deserialize(command2, {promoteLongs: false, promoteValues: false});
          client.db(dbName).command(rawCommand, (err, response) => {
            if (err) {
              callback(err, null);
              return;
            }
            callback(err, bson.serialize(response, this.options));
          });
        }
        fetchKeys(client, keyVaultNamespace, filter, callback) {
          const bson = this.bson;
          const dbName = databaseNamespace(keyVaultNamespace);
          const collectionName = collectionNamespace(keyVaultNamespace);
          filter = bson.deserialize(filter);
          client.db(dbName).collection(collectionName, {readConcern: {level: "majority"}}).find(filter).toArray((err, keys) => {
            if (err) {
              callback(err, null);
              return;
            }
            callback(null, keys);
          });
        }
      }
      return {StateMachine};
    };
  }
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS({
  "node_modules/file-uri-to-path/index.js"(exports2, module2) {
    var sep = require("path").sep || "/";
    module2.exports = fileUriToPath;
    function fileUriToPath(uri) {
      if (typeof uri != "string" || uri.length <= 7 || uri.substring(0, 7) != "file://") {
        throw new TypeError("must pass in a file:// URI to convert to a file path");
      }
      var rest = decodeURI(uri.substring(7));
      var firstSlash = rest.indexOf("/");
      var host = rest.substring(0, firstSlash);
      var path = rest.substring(firstSlash + 1);
      if (host == "localhost")
        host = "";
      if (host) {
        host = sep + sep + host;
      }
      path = path.replace(/^(.+)\|/, "$1:");
      if (sep == "\\") {
        path = path.replace(/\//g, "\\");
      }
      if (/^.+\:/.test(path)) {
      } else {
        path = sep + path;
      }
      return host + path;
    }
  }
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS({
  "node_modules/bindings/bindings.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var fileURLToPath = require_file_uri_to_path();
    var join = path.join;
    var dirname = path.dirname;
    var exists = fs.accessSync && function(path2) {
      try {
        fs.accessSync(path2);
      } catch (e) {
        return false;
      }
      return true;
    } || fs.existsSync || path.existsSync;
    var defaults3 = {
      arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [
        ["module_root", "build", "bindings"],
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        ["module_root", "build", "default", "bindings"],
        ["module_root", "compiled", "version", "platform", "arch", "bindings"],
        ["module_root", "addon-build", "release", "install-root", "bindings"],
        ["module_root", "addon-build", "debug", "install-root", "bindings"],
        ["module_root", "addon-build", "default", "install-root", "bindings"],
        ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
      ]
    };
    function bindings(opts) {
      if (typeof opts == "string") {
        opts = {bindings: opts};
      } else if (!opts) {
        opts = {};
      }
      Object.keys(defaults3).map(function(i2) {
        if (!(i2 in opts))
          opts[i2] = defaults3[i2];
      });
      if (!opts.module_root) {
        opts.module_root = exports2.getRoot(exports2.getFileName());
      }
      if (path.extname(opts.bindings) != ".node") {
        opts.bindings += ".node";
      }
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
      var tries = [], i = 0, l = opts.try.length, n, b, err;
      for (; i < l; i++) {
        n = join.apply(null, opts.try[i].map(function(p) {
          return opts[p] || p;
        }));
        tries.push(n);
        try {
          b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
          if (!opts.path) {
            b.path = n;
          }
          return b;
        } catch (e) {
          if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
            throw e;
          }
        }
      }
      err = new Error("Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
        return opts.arrow + a;
      }).join("\n"));
      err.tries = tries;
      throw err;
    }
    module2.exports = exports2 = bindings;
    exports2.getFileName = function getFileName(calling_file) {
      var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
      Error.stackTraceLimit = 10;
      Error.prepareStackTrace = function(e, st) {
        for (var i = 0, l = st.length; i < l; i++) {
          fileName = st[i].getFileName();
          if (fileName !== __filename) {
            if (calling_file) {
              if (fileName !== calling_file) {
                return;
              }
            } else {
              return;
            }
          }
        }
      };
      Error.captureStackTrace(dummy);
      dummy.stack;
      Error.prepareStackTrace = origPST;
      Error.stackTraceLimit = origSTL;
      var fileSchema = "file://";
      if (fileName.indexOf(fileSchema) === 0) {
        fileName = fileURLToPath(fileName);
      }
      return fileName;
    };
    exports2.getRoot = function getRoot(file) {
      var dir = dirname(file), prev;
      while (true) {
        if (dir === ".") {
          dir = process.cwd();
        }
        if (exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) {
          return dir;
        }
        if (prev === dir) {
          throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
        }
        prev = dir;
        dir = join(dir, "..");
      }
    };
  }
});

// node_modules/mongodb-client-encryption/lib/mongocryptdManager.js
var require_mongocryptdManager = __commonJS({
  "node_modules/mongodb-client-encryption/lib/mongocryptdManager.js"(exports2, module2) {
    "use strict";
    var spawn = require("child_process").spawn;
    var MongocryptdManager = class {
      constructor(extraOptions) {
        extraOptions = extraOptions || {};
        if (extraOptions.mongocryptdURI) {
          this.uri = extraOptions.mongocryptdURI;
        } else {
          this.uri = "mongodb://localhost:27020/?serverSelectionTimeoutMS=1000";
        }
        this.bypassSpawn = !!extraOptions.mongocryptdBypassSpawn;
        this.spawnPath = extraOptions.mongocryptdSpawnPath || "";
        this.spawnArgs = [];
        if (Array.isArray(extraOptions.mongocryptdSpawnArgs)) {
          this.spawnArgs = this.spawnArgs.concat(extraOptions.mongocryptdSpawnArgs);
        }
        if (this.spawnArgs.filter((arg) => typeof arg === "string").every((arg) => arg.indexOf("--idleShutdownTimeoutSecs") < 0)) {
          this.spawnArgs.push("--idleShutdownTimeoutSecs", 60);
        }
      }
      spawn(callback) {
        const cmdName = this.spawnPath || "mongocryptd";
        this._child = spawn(cmdName, this.spawnArgs, {
          stdio: "ignore",
          detached: true
        });
        this._child.on("error", () => {
        });
        this._child.unref();
        process.nextTick(callback);
      }
    };
    module2.exports = {MongocryptdManager};
  }
});

// node_modules/mongodb-client-encryption/lib/cryptoCallbacks.js
var require_cryptoCallbacks = __commonJS({
  "node_modules/mongodb-client-encryption/lib/cryptoCallbacks.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    function aes256CbcEncryptHook(key, iv, input, output) {
      let result;
      try {
        let cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
        cipher.setAutoPadding(false);
        result = cipher.update(input);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function aes256CbcDecryptHook(key, iv, input, output) {
      let result;
      try {
        let cipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
        cipher.setAutoPadding(false);
        result = cipher.update(input);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function randomHook(buffer, count) {
      try {
        crypto.randomFillSync(buffer, 0, count);
      } catch (e) {
        return e;
      }
      return count;
    }
    function randomHookNode4(buffer, count) {
      let result;
      try {
        result = crypto.randomBytes(count);
      } catch (e) {
        return e;
      }
      result.copy(buffer);
      return count;
    }
    function sha256Hook(input, output) {
      let result;
      try {
        result = crypto.createHash("sha256").update(input).digest();
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function makeHmacHook(algorithm) {
      return (key, input, output) => {
        let result;
        try {
          result = crypto.createHmac(algorithm, key).update(input).digest();
        } catch (e) {
          return e;
        }
        result.copy(output);
        return result.length;
      };
    }
    function signRsaSha256Hook(key, input, output) {
      let result;
      try {
        const signer = crypto.createSign("sha256WithRSAEncryption");
        const privateKey = Buffer.from(`-----BEGIN PRIVATE KEY-----
${key.toString("base64")}
-----END PRIVATE KEY-----
`);
        result = signer.update(input).end().sign(privateKey);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    module2.exports = {
      aes256CbcEncryptHook,
      aes256CbcDecryptHook,
      randomHook: typeof crypto.randomFillSync === "function" ? randomHook : randomHookNode4,
      hmacSha512Hook: makeHmacHook("sha512"),
      hmacSha256Hook: makeHmacHook("sha256"),
      sha256Hook,
      signRsaSha256Hook
    };
  }
});

// node_modules/mongodb-client-encryption/lib/autoEncrypter.js
var require_autoEncrypter = __commonJS({
  "node_modules/mongodb-client-encryption/lib/autoEncrypter.js"(exports2, module2) {
    "use strict";
    module2.exports = function(modules) {
      const mc = require_bindings()("mongocrypt");
      const common = require_common3();
      const databaseNamespace = common.databaseNamespace;
      const StateMachine = modules.stateMachine.StateMachine;
      const MongocryptdManager = require_mongocryptdManager().MongocryptdManager;
      const MongoClient2 = modules.mongodb.MongoClient;
      const MongoError = modules.mongodb.MongoError;
      const cryptoCallbacks = require_cryptoCallbacks();
      class AutoEncrypter {
        constructor(client, options2) {
          this._client = client;
          this._bson = options2.bson || client.topology.bson;
          this._mongocryptdManager = new MongocryptdManager(options2.extraOptions);
          this._mongocryptdClient = new MongoClient2(this._mongocryptdManager.uri, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
            serverSelectionTimeoutMS: 1e3
          });
          this._keyVaultNamespace = options2.keyVaultNamespace || "admin.datakeys";
          this._keyVaultClient = options2.keyVaultClient || client;
          this._metaDataClient = options2.metadataClient || client;
          this._bypassEncryption = typeof options2.bypassAutoEncryption === "boolean" ? options2.bypassAutoEncryption : false;
          const mongoCryptOptions = {};
          if (options2.schemaMap) {
            mongoCryptOptions.schemaMap = Buffer.isBuffer(options2.schemaMap) ? options2.schemaMap : this._bson.serialize(options2.schemaMap);
          }
          if (options2.kmsProviders) {
            mongoCryptOptions.kmsProviders = !Buffer.isBuffer(options2.kmsProviders) ? this._bson.serialize(options2.kmsProviders) : options2.kmsProviders;
          }
          if (options2.logger) {
            mongoCryptOptions.logger = options2.logger;
          }
          Object.assign(mongoCryptOptions, {cryptoCallbacks});
          this._mongocrypt = new mc.MongoCrypt(mongoCryptOptions);
          this._contextCounter = 0;
        }
        init(callback) {
          const _callback = (err, res) => {
            if (err && err.message && (err.message.match(/timed out after/) || err.message.match(/ENOTFOUND/))) {
              callback(new MongoError("Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn"));
              return;
            }
            callback(err, res);
          };
          if (this._mongocryptdManager.bypassSpawn) {
            return this._mongocryptdClient.connect(_callback);
          }
          this._mongocryptdManager.spawn(() => this._mongocryptdClient.connect(_callback));
        }
        teardown(force, callback) {
          this._mongocryptdClient.close(force, callback);
        }
        encrypt(ns, cmd2, options2, callback) {
          if (typeof ns !== "string") {
            throw new TypeError("Parameter `ns` must be a string");
          }
          if (typeof cmd2 !== "object") {
            throw new TypeError("Parameter `cmd` must be an object");
          }
          if (typeof options2 === "function" && callback == null) {
            callback = options2;
            options2 = {};
          }
          if (this._bypassEncryption) {
            callback(void 0, cmd2);
            return;
          }
          const bson = this._bson;
          const commandBuffer = Buffer.isBuffer(cmd2) ? cmd2 : bson.serialize(cmd2, options2);
          let context;
          try {
            context = this._mongocrypt.makeEncryptionContext(databaseNamespace(ns), commandBuffer);
          } catch (err) {
            callback(err, null);
            return;
          }
          context.id = this._contextCounter++;
          context.ns = ns;
          context.document = cmd2;
          const stateMachine = new StateMachine(Object.assign({bson}, options2));
          stateMachine.execute(this, context, callback);
        }
        decrypt(response, options2, callback) {
          if (typeof options2 === "function" && callback == null) {
            callback = options2;
            options2 = {};
          }
          const bson = this._bson;
          const buffer = Buffer.isBuffer(response) ? response : bson.serialize(response, options2);
          let context;
          try {
            context = this._mongocrypt.makeDecryptionContext(buffer);
          } catch (err) {
            callback(err, null);
            return;
          }
          context.id = this._contextCounter++;
          const stateMachine = new StateMachine(Object.assign({bson}, options2));
          stateMachine.execute(this, context, callback);
        }
      }
      return {AutoEncrypter};
    };
  }
});

// node_modules/mongodb-client-encryption/lib/clientEncryption.js
var require_clientEncryption = __commonJS({
  "node_modules/mongodb-client-encryption/lib/clientEncryption.js"(exports2, module2) {
    "use strict";
    module2.exports = function(modules) {
      const mc = require_bindings()("mongocrypt");
      const common = require_common3();
      const databaseNamespace = common.databaseNamespace;
      const collectionNamespace = common.collectionNamespace;
      const promiseOrCallback = common.promiseOrCallback;
      const StateMachine = modules.stateMachine.StateMachine;
      const cryptoCallbacks = require_cryptoCallbacks();
      function sanitizeDataKeyOptions(bson, options2) {
        options2 = Object.assign({}, options2);
        if (options2.keyAltNames) {
          if (!Array.isArray(options2.keyAltNames)) {
            throw new TypeError(`Option "keyAltNames" must be an array of string, but was of type ${typeof options2.keyAltNames}.`);
          }
          const serializedKeyAltNames = [];
          for (let i = 0; i < options2.keyAltNames.length; i += 1) {
            const item = options2.keyAltNames[i];
            const itemType = typeof item;
            if (itemType !== "string") {
              throw new TypeError(`Option "keyAltNames" must be an array of string, but item at index ${i} was of type ${itemType} `);
            }
            serializedKeyAltNames.push(bson.serialize({keyAltName: item}));
          }
          options2.keyAltNames = serializedKeyAltNames;
        } else if (options2.keyAltNames == null) {
          delete options2.keyAltNames;
        }
        return options2;
      }
      class ClientEncryption {
        constructor(client, options2) {
          this._client = client;
          this._bson = options2.bson || client.topology.bson;
          if (options2.keyVaultNamespace == null) {
            throw new TypeError("Missing required option `keyVaultNamespace`");
          }
          Object.assign(options2, {cryptoCallbacks});
          if (options2.kmsProviders && !Buffer.isBuffer(options2.kmsProviders)) {
            options2.kmsProviders = this._bson.serialize(options2.kmsProviders);
          }
          this._keyVaultNamespace = options2.keyVaultNamespace;
          this._keyVaultClient = options2.keyVaultClient || client;
          this._mongoCrypt = new mc.MongoCrypt(options2);
        }
        createDataKey(provider, options2, callback) {
          if (typeof options2 === "function")
            callback = options2, options2 = {};
          const bson = this._bson;
          options2 = sanitizeDataKeyOptions(bson, options2);
          const dataKeyBson = bson.serialize(Object.assign({provider}, options2.masterKey));
          const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson);
          const stateMachine = new StateMachine({bson});
          return promiseOrCallback(callback, (cb) => {
            stateMachine.execute(this, context, (err, dataKey) => {
              if (err) {
                cb(err, null);
                return;
              }
              const dbName = databaseNamespace(this._keyVaultNamespace);
              const collectionName = collectionNamespace(this._keyVaultNamespace);
              this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey, {w: "majority"}, (err2, result) => {
                if (err2) {
                  cb(err2, null);
                  return;
                }
                cb(null, result.insertedId);
              });
            });
          });
        }
        encrypt(value, options2, callback) {
          const bson = this._bson;
          const valueBuffer = bson.serialize({v: value});
          const contextOptions = Object.assign({}, options2);
          if (options2.keyId) {
            contextOptions.keyId = options2.keyId.buffer;
          }
          if (options2.keyAltName) {
            const keyAltName = options2.keyAltName;
            if (options2.keyId) {
              throw new TypeError(`"options" cannot contain both "keyId" and "keyAltName"`);
            }
            const keyAltNameType = typeof keyAltName;
            if (keyAltNameType !== "string") {
              throw new TypeError(`"options.keyAltName" must be of type string, but was of type ${keyAltNameType}`);
            }
            contextOptions.keyAltName = bson.serialize({keyAltName});
          }
          const stateMachine = new StateMachine({bson});
          const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);
          return promiseOrCallback(callback, (cb) => {
            stateMachine.execute(this, context, (err, result) => {
              if (err) {
                cb(err, null);
                return;
              }
              cb(null, result.v);
            });
          });
        }
        decrypt(value, callback) {
          const bson = this._bson;
          const valueBuffer = bson.serialize({v: value});
          const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);
          const stateMachine = new StateMachine({bson});
          return promiseOrCallback(callback, (cb) => {
            stateMachine.execute(this, context, (err, result) => {
              if (err) {
                cb(err, null);
                return;
              }
              cb(null, result.v);
            });
          });
        }
      }
      return {ClientEncryption};
    };
  }
});

// node_modules/mongodb-client-encryption/index.js
var require_mongodb_client_encryption = __commonJS({
  "node_modules/mongodb-client-encryption/index.js"(exports2, module2) {
    "use strict";
    var defaultModule;
    function loadDefaultModule() {
      if (!defaultModule) {
        defaultModule = extension(require_mongodb());
      }
      return defaultModule;
    }
    var MongoCryptError = require_common3().MongoCryptError;
    function extension(mongodb) {
      const modules = {mongodb};
      modules.stateMachine = require_stateMachine()(modules);
      modules.autoEncrypter = require_autoEncrypter()(modules);
      modules.clientEncryption = require_clientEncryption()(modules);
      return {
        AutoEncrypter: modules.autoEncrypter.AutoEncrypter,
        ClientEncryption: modules.clientEncryption.ClientEncryption,
        MongoCryptError
      };
    }
    module2.exports = {
      extension,
      MongoCryptError,
      get AutoEncrypter() {
        const m = loadDefaultModule();
        delete module2.exports.AutoEncrypter;
        module2.exports.AutoEncrypter = m.AutoEncrypter;
        return m.AutoEncrypter;
      },
      get ClientEncryption() {
        const m = loadDefaultModule();
        delete module2.exports.ClientEncryption;
        module2.exports.ClientEncryption = m.ClientEncryption;
        return m.ClientEncryption;
      }
    };
  }
});

// node_modules/mongodb/lib/encrypter.js
var require_encrypter = __commonJS({
  "node_modules/mongodb/lib/encrypter.js"(exports2, module2) {
    "use strict";
    var MongoClient2 = require_mongo_client();
    var BSON2 = require_utils3().retrieveBSON();
    var MongoError = require_error().MongoError;
    try {
      require.resolve("mongodb-client-encryption");
    } catch (err) {
      throw new MongoError("Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project");
    }
    var mongodbClientEncryption = require_mongodb_client_encryption();
    if (typeof mongodbClientEncryption.extension !== "function") {
      throw new MongoError("loaded version of `mongodb-client-encryption` does not have property `extension`. Please make sure you are loading the correct version of `mongodb-client-encryption`");
    }
    var AutoEncrypter = mongodbClientEncryption.extension(require_mongodb()).AutoEncrypter;
    var kInternalClient = Symbol("internalClient");
    var Encrypter = class {
      constructor(client, options2) {
        this.bypassAutoEncryption = !!options2.autoEncryption.bypassAutoEncryption;
        this.needsConnecting = false;
        if (options2.maxPoolSize === 0 && options2.autoEncryption.keyVaultClient == null) {
          options2.autoEncryption.keyVaultClient = client;
        } else if (options2.autoEncryption.keyVaultClient == null) {
          options2.autoEncryption.keyVaultClient = this.getInternalClient(client);
        }
        if (this.bypassAutoEncryption) {
          options2.autoEncryption.metadataClient = void 0;
        } else if (options2.maxPoolSize === 0) {
          options2.autoEncryption.metadataClient = client;
        } else {
          options2.autoEncryption.metadataClient = this.getInternalClient(client);
        }
        options2.autoEncryption.bson = Encrypter.makeBSON(options2);
        this.autoEncrypter = new AutoEncrypter(client, options2.autoEncryption);
      }
      getInternalClient(client) {
        if (!this[kInternalClient]) {
          const clonedOptions = {};
          for (const key of Object.keys(client.s.options)) {
            if (["autoEncryption", "minPoolSize", "servers", "caseTranslate", "dbName"].indexOf(key) !== -1)
              continue;
            clonedOptions[key] = client.s.options[key];
          }
          clonedOptions.minPoolSize = 0;
          const allEvents = [
            "commandStarted",
            "commandSucceeded",
            "commandFailed",
            "serverOpening",
            "serverClosed",
            "serverDescriptionChanged",
            "serverHeartbeatStarted",
            "serverHeartbeatSucceeded",
            "serverHeartbeatFailed",
            "topologyOpening",
            "topologyClosed",
            "topologyDescriptionChanged",
            "joined",
            "left",
            "ping",
            "ha",
            "connectionPoolCreated",
            "connectionPoolClosed",
            "connectionCreated",
            "connectionReady",
            "connectionClosed",
            "connectionCheckOutStarted",
            "connectionCheckOutFailed",
            "connectionCheckedOut",
            "connectionCheckedIn",
            "connectionPoolCleared"
          ];
          this[kInternalClient] = new MongoClient2(client.s.url, clonedOptions);
          for (const eventName of allEvents) {
            for (const listener of client.listeners(eventName)) {
              this[kInternalClient].on(eventName, listener);
            }
          }
          client.on("newListener", (eventName, listener) => {
            this[kInternalClient].on(eventName, listener);
          });
          this.needsConnecting = true;
        }
        return this[kInternalClient];
      }
      connectInternalClient(callback) {
        if (this.needsConnecting) {
          this.needsConnecting = false;
          return this[kInternalClient].connect(callback);
        }
        return callback();
      }
      close(client, force, callback) {
        this.autoEncrypter.teardown((e) => {
          if (this[kInternalClient] && client !== this[kInternalClient]) {
            return this[kInternalClient].close(force, callback);
          }
          callback(e);
        });
      }
      static makeBSON(options2) {
        return (options2 || {}).bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]);
      }
    };
    module2.exports = {Encrypter};
  }
});

// node_modules/mongodb/lib/operations/connect.js
var require_connect2 = __commonJS({
  "node_modules/mongodb/lib/operations/connect.js"(exports2, module2) {
    "use strict";
    var deprecate = require("util").deprecate;
    var Logger = require_core().Logger;
    var MongoCredentials = require_core().MongoCredentials;
    var MongoError = require_core().MongoError;
    var Mongos = require_mongos2();
    var NativeTopology = require_native_topology();
    var parse = require_core().parseConnectionString;
    var ReadConcern = require_read_concern();
    var ReadPreference = require_core().ReadPreference;
    var ReplSet = require_replset2();
    var Server = require_server3();
    var ServerSessionPool = require_core().Sessions.ServerSessionPool;
    var emitDeprecationWarning = require_utils4().emitDeprecationWarning;
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var fs = require("fs");
    var WriteConcern = require_write_concern();
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var client;
    function loadClient() {
      if (!client) {
        client = require_mongo_client();
      }
      return client;
    }
    var legacyParse = deprecate(require_url_parser(), "current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.");
    var AUTH_MECHANISM_INTERNAL_MAP = {
      DEFAULT: "default",
      PLAIN: "plain",
      GSSAPI: "gssapi",
      "MONGODB-CR": "mongocr",
      "MONGODB-X509": "x509",
      "MONGODB-AWS": "mongodb-aws",
      "SCRAM-SHA-1": "scram-sha-1",
      "SCRAM-SHA-256": "scram-sha-256"
    };
    var monitoringEvents = [
      "timeout",
      "close",
      "serverOpening",
      "serverDescriptionChanged",
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "serverClosed",
      "topologyOpening",
      "topologyClosed",
      "topologyDescriptionChanged",
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      "joined",
      "left",
      "ping",
      "ha",
      "all",
      "fullsetup",
      "open"
    ];
    var VALID_AUTH_MECHANISMS = new Set([
      "DEFAULT",
      "PLAIN",
      "GSSAPI",
      "MONGODB-CR",
      "MONGODB-X509",
      "MONGODB-AWS",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256"
    ]);
    var validOptionNames = [
      "poolSize",
      "ssl",
      "sslValidate",
      "sslCA",
      "sslCert",
      "sslKey",
      "sslPass",
      "sslCRL",
      "autoReconnect",
      "noDelay",
      "keepAlive",
      "keepAliveInitialDelay",
      "connectTimeoutMS",
      "family",
      "socketTimeoutMS",
      "reconnectTries",
      "reconnectInterval",
      "ha",
      "haInterval",
      "replicaSet",
      "secondaryAcceptableLatencyMS",
      "acceptableLatencyMS",
      "connectWithNoPrimary",
      "authSource",
      "w",
      "wtimeout",
      "j",
      "writeConcern",
      "forceServerObjectId",
      "serializeFunctions",
      "ignoreUndefined",
      "raw",
      "bufferMaxEntries",
      "readPreference",
      "pkFactory",
      "promiseLibrary",
      "readConcern",
      "maxStalenessSeconds",
      "loggerLevel",
      "logger",
      "promoteValues",
      "promoteBuffers",
      "promoteLongs",
      "domainsEnabled",
      "checkServerIdentity",
      "validateOptions",
      "appname",
      "auth",
      "user",
      "password",
      "authMechanism",
      "compression",
      "fsync",
      "readPreferenceTags",
      "numberOfRetries",
      "auto_reconnect",
      "minSize",
      "monitorCommands",
      "retryWrites",
      "retryReads",
      "useNewUrlParser",
      "useUnifiedTopology",
      "serverSelectionTimeoutMS",
      "useRecoveryToken",
      "autoEncryption",
      "driverInfo",
      "tls",
      "tlsInsecure",
      "tlsinsecure",
      "tlsAllowInvalidCertificates",
      "tlsAllowInvalidHostnames",
      "tlsCAFile",
      "tlsCertificateFile",
      "tlsCertificateKeyFile",
      "tlsCertificateKeyFilePassword",
      "minHeartbeatFrequencyMS",
      "heartbeatFrequencyMS",
      "directConnection",
      "appName",
      "maxPoolSize",
      "minPoolSize",
      "maxIdleTimeMS",
      "waitQueueTimeoutMS"
    ];
    var ignoreOptionNames = ["native_parser"];
    var legacyOptionNames = ["server", "replset", "replSet", "mongos", "db"];
    function validOptions(options2) {
      const _validOptions = validOptionNames.concat(legacyOptionNames);
      for (const name2 in options2) {
        if (ignoreOptionNames.indexOf(name2) !== -1) {
          continue;
        }
        if (_validOptions.indexOf(name2) === -1) {
          if (options2.validateOptions) {
            return new MongoError(`option ${name2} is not supported`);
          } else {
            emitWarningOnce(`the options [${name2}] is not supported`);
          }
        }
        if (legacyOptionNames.indexOf(name2) !== -1) {
          emitWarningOnce(`the server/replset/mongos/db options are deprecated, all their options are supported at the top level of the options object [${validOptionNames}]`);
        }
      }
    }
    var LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name2) => {
      obj[name2.toLowerCase()] = name2;
      return obj;
    }, {});
    function addListeners(mongoClient, topology) {
      topology.on("authenticated", createListener(mongoClient, "authenticated"));
      topology.on("error", createListener(mongoClient, "error"));
      topology.on("timeout", createListener(mongoClient, "timeout"));
      topology.on("close", createListener(mongoClient, "close"));
      topology.on("parseError", createListener(mongoClient, "parseError"));
      topology.once("open", createListener(mongoClient, "open"));
      topology.once("fullsetup", createListener(mongoClient, "fullsetup"));
      topology.once("all", createListener(mongoClient, "all"));
      topology.on("reconnect", createListener(mongoClient, "reconnect"));
    }
    function assignTopology(client2, topology) {
      client2.topology = topology;
      if (!(topology instanceof NativeTopology)) {
        topology.s.sessionPool = new ServerSessionPool(topology.s.coreTopology);
      }
    }
    function clearAllEvents(topology) {
      monitoringEvents.forEach((event) => topology.removeAllListeners(event));
    }
    function collectEvents(mongoClient, topology) {
      let MongoClient2 = loadClient();
      const collectedEvents = [];
      if (mongoClient instanceof MongoClient2) {
        monitoringEvents.forEach((event) => {
          topology.on(event, (object1, object2) => {
            if (event === "open") {
              collectedEvents.push({event, object1: mongoClient});
            } else {
              collectedEvents.push({event, object1, object2});
            }
          });
        });
      }
      return collectedEvents;
    }
    function resolveTLSOptions(options2) {
      if (options2.tls == null) {
        return;
      }
      ["sslCA", "sslKey", "sslCert"].forEach((optionName) => {
        if (options2[optionName]) {
          options2[optionName] = fs.readFileSync(options2[optionName]);
        }
      });
    }
    function connect(mongoClient, url, options2, callback) {
      options2 = Object.assign({}, options2);
      if (callback == null) {
        throw new Error("no callback function provided");
      }
      let didRequestAuthentication = false;
      const logger = Logger("MongoClient", options2);
      if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {
        return connectWithUrl(mongoClient, url, options2, connectCallback);
      }
      const useNewUrlParser = options2.useNewUrlParser !== false;
      const parseFn = useNewUrlParser ? parse : legacyParse;
      const transform = useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;
      parseFn(url, options2, (err, _object) => {
        if (err)
          return callback(err);
        const object = transform(_object);
        const _finalOptions = createUnifiedOptions(object, options2);
        if (_finalOptions.socketTimeoutMS == null)
          _finalOptions.socketTimeoutMS = 0;
        if (_finalOptions.connectTimeoutMS == null)
          _finalOptions.connectTimeoutMS = 1e4;
        if (_finalOptions.retryWrites == null)
          _finalOptions.retryWrites = true;
        if (_finalOptions.useRecoveryToken == null)
          _finalOptions.useRecoveryToken = true;
        if (_finalOptions.readPreference == null)
          _finalOptions.readPreference = "primary";
        if (_finalOptions.db_options && _finalOptions.db_options.auth) {
          delete _finalOptions.db_options.auth;
        }
        resolveTLSOptions(_finalOptions);
        mongoClient.s.options = _finalOptions;
        mongoClient.s.readPreference = ReadPreference.fromOptions(_finalOptions);
        mongoClient.s.writeConcern = WriteConcern.fromOptions(_finalOptions);
        if (object.servers.length === 0) {
          return callback(new Error("connection string must contain at least one seed host"));
        }
        if (_finalOptions.auth && !_finalOptions.credentials) {
          try {
            didRequestAuthentication = true;
            _finalOptions.credentials = generateCredentials(mongoClient, _finalOptions.auth.user, _finalOptions.auth.password, _finalOptions);
          } catch (err2) {
            return callback(err2);
          }
        }
        if (_finalOptions.useUnifiedTopology) {
          return createTopology(mongoClient, "unified", _finalOptions, connectCallback);
        }
        emitWarningOnce("Current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.");
        if (_finalOptions.replicaSet || _finalOptions.rs_name) {
          return createTopology(mongoClient, "replicaset", _finalOptions, connectCallback);
        } else if (object.servers.length > 1) {
          return createTopology(mongoClient, "mongos", _finalOptions, connectCallback);
        } else {
          return createServer(mongoClient, _finalOptions, connectCallback);
        }
      });
      function connectCallback(err, topology) {
        const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;
        if (err && err.message === "no mongos proxies found in seed list") {
          if (logger.isWarn()) {
            logger.warn(warningMessage);
          }
          return callback(new MongoError(warningMessage));
        }
        if (didRequestAuthentication) {
          mongoClient.emit("authenticated", null, true);
        }
        callback(err, topology);
      }
    }
    function connectWithUrl(mongoClient, url, options2, connectCallback) {
      assignTopology(mongoClient, url);
      addListeners(mongoClient, url);
      relayEvents(mongoClient, url);
      let finalOptions = Object.assign({}, options2);
      if (typeof options2.readPreference === "string" || typeof options2.read_preference === "string") {
        finalOptions.readPreference = new ReadPreference(options2.readPreference || options2.read_preference);
      }
      const isDoingAuth = finalOptions.user || finalOptions.password || finalOptions.authMechanism;
      if (isDoingAuth && !finalOptions.credentials) {
        try {
          finalOptions.credentials = generateCredentials(mongoClient, finalOptions.user, finalOptions.password, finalOptions);
        } catch (err) {
          return connectCallback(err, url);
        }
      }
      return url.connect(finalOptions, connectCallback);
    }
    function createListener(mongoClient, event) {
      const eventSet = new Set(["all", "fullsetup", "open", "reconnect"]);
      return (v1, v2) => {
        if (eventSet.has(event)) {
          return mongoClient.emit(event, mongoClient);
        }
        mongoClient.emit(event, v1, v2);
      };
    }
    function createServer(mongoClient, options2, callback) {
      options2.promiseLibrary = mongoClient.s.promiseLibrary;
      const servers = translateOptions(options2);
      const server = servers[0];
      const collectedEvents = collectEvents(mongoClient, server);
      server.connect(options2, (err, topology) => {
        if (err) {
          server.close(true);
          return callback(err);
        }
        clearAllEvents(server);
        relayEvents(mongoClient, server);
        addListeners(mongoClient, server);
        const ismaster = topology.lastIsMaster();
        assignTopology(mongoClient, topology);
        if (ismaster && ismaster.msg === "isdbgrid") {
          topology.close();
          return createTopology(mongoClient, "mongos", options2, callback);
        }
        replayEvents(mongoClient, collectedEvents);
        callback(err, topology);
      });
    }
    var DEPRECATED_UNIFIED_EVENTS = new Set([
      "reconnect",
      "reconnectFailed",
      "attemptReconnect",
      "joined",
      "left",
      "ping",
      "ha",
      "all",
      "fullsetup",
      "open"
    ]);
    function registerDeprecatedEventNotifiers(client2) {
      client2.on("newListener", (eventName) => {
        if (DEPRECATED_UNIFIED_EVENTS.has(eventName)) {
          emitDeprecationWarning(`The \`${eventName}\` event is no longer supported by the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
        }
      });
    }
    function createTopology(mongoClient, topologyType, options2, callback) {
      options2.promiseLibrary = mongoClient.s.promiseLibrary;
      const translationOptions = {};
      if (topologyType === "unified")
        translationOptions.createServers = false;
      const servers = translateOptions(options2, translationOptions);
      if (options2.autoEncryption != null) {
        const Encrypter = require_encrypter().Encrypter;
        options2.encrypter = new Encrypter(mongoClient, options2);
        options2.autoEncrypter = options2.encrypter.autoEncrypter;
      }
      let topology;
      if (topologyType === "mongos") {
        topology = new Mongos(servers, options2);
      } else if (topologyType === "replicaset") {
        topology = new ReplSet(servers, options2);
      } else if (topologyType === "unified") {
        topology = new NativeTopology(options2.servers, options2);
        registerDeprecatedEventNotifiers(mongoClient);
      }
      addListeners(mongoClient, topology);
      relayEvents(mongoClient, topology);
      assignTopology(mongoClient, topology);
      if (options2.autoEncrypter) {
        options2.autoEncrypter.init((err) => {
          if (err) {
            callback(err);
            return;
          }
          topology.connect(options2, (err2) => {
            if (err2) {
              topology.close(true);
              callback(err2);
              return;
            }
            options2.encrypter.connectInternalClient((error3) => {
              if (error3)
                return callback(error3);
              callback(void 0, topology);
            });
          });
        });
        return;
      }
      topology.connect(options2, (err) => {
        if (err) {
          topology.close(true);
          return callback(err);
        }
        callback(void 0, topology);
        return;
      });
    }
    function createUnifiedOptions(finalOptions, options2) {
      const childOptions = [
        "mongos",
        "server",
        "db",
        "replset",
        "db_options",
        "server_options",
        "rs_options",
        "mongos_options"
      ];
      const noMerge = ["readconcern", "compression", "autoencryption"];
      const skip = ["w", "wtimeout", "j", "journal", "fsync", "writeconcern"];
      for (const name2 in options2) {
        if (skip.indexOf(name2.toLowerCase()) !== -1) {
          continue;
        } else if (noMerge.indexOf(name2.toLowerCase()) !== -1) {
          finalOptions[name2] = options2[name2];
        } else if (childOptions.indexOf(name2.toLowerCase()) !== -1) {
          finalOptions = mergeOptions(finalOptions, options2[name2], false);
        } else {
          if (options2[name2] && typeof options2[name2] === "object" && !Buffer.isBuffer(options2[name2]) && !Array.isArray(options2[name2])) {
            finalOptions = mergeOptions(finalOptions, options2[name2], true);
          } else {
            finalOptions[name2] = options2[name2];
          }
        }
      }
      const optionsWriteConcern = WriteConcern.fromOptions(options2);
      if (optionsWriteConcern) {
        finalOptions.writeConcern = Object.assign({}, finalOptions.writeConcern, optionsWriteConcern);
      }
      return finalOptions;
    }
    function generateCredentials(client2, username, password, options2) {
      options2 = Object.assign({}, options2);
      const source = options2.authSource || options2.authdb || options2.dbName;
      const authMechanismRaw = options2.authMechanism || "DEFAULT";
      const authMechanism = authMechanismRaw.toUpperCase();
      const mechanismProperties = options2.authMechanismProperties;
      if (!VALID_AUTH_MECHANISMS.has(authMechanism)) {
        throw MongoError.create({
          message: `authentication mechanism ${authMechanismRaw} not supported', options.authMechanism`,
          driver: true
        });
      }
      return new MongoCredentials({
        mechanism: AUTH_MECHANISM_INTERNAL_MAP[authMechanism],
        mechanismProperties,
        source,
        username,
        password
      });
    }
    function legacyTransformUrlOptions(object) {
      return mergeOptions(createUnifiedOptions({}, object), object, false);
    }
    function mergeOptions(target, source, flatten2) {
      for (const name2 in source) {
        if (source[name2] && typeof source[name2] === "object" && flatten2) {
          target = mergeOptions(target, source[name2], flatten2);
        } else {
          target[name2] = source[name2];
        }
      }
      return target;
    }
    function relayEvents(mongoClient, topology) {
      const serverOrCommandEvents = [
        "commandStarted",
        "commandSucceeded",
        "commandFailed",
        "serverOpening",
        "serverClosed",
        "serverDescriptionChanged",
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "topologyOpening",
        "topologyClosed",
        "topologyDescriptionChanged",
        "joined",
        "left",
        "ping",
        "ha"
      ].concat(CMAP_EVENT_NAMES);
      serverOrCommandEvents.forEach((event) => {
        topology.on(event, (object1, object2) => {
          mongoClient.emit(event, object1, object2);
        });
      });
    }
    function replayEvents(mongoClient, events) {
      for (let i = 0; i < events.length; i++) {
        mongoClient.emit(events[i].event, events[i].object1, events[i].object2);
      }
    }
    function transformUrlOptions(_object) {
      let object = Object.assign({servers: _object.hosts}, _object.options);
      for (let name2 in object) {
        const camelCaseName = LEGACY_OPTIONS_MAP[name2];
        if (camelCaseName) {
          object[camelCaseName] = object[name2];
        }
      }
      const hasUsername = _object.auth && _object.auth.username;
      const hasAuthMechanism = _object.options && _object.options.authMechanism;
      if (hasUsername || hasAuthMechanism) {
        object.auth = Object.assign({}, _object.auth);
        if (object.auth.db) {
          object.authSource = object.authSource || object.auth.db;
        }
        if (object.auth.username) {
          object.auth.user = object.auth.username;
        }
      }
      if (_object.defaultDatabase) {
        object.dbName = _object.defaultDatabase;
      }
      if (object.maxPoolSize) {
        object.poolSize = object.maxPoolSize;
      }
      if (object.readConcernLevel) {
        object.readConcern = new ReadConcern(object.readConcernLevel);
      }
      if (object.wTimeoutMS) {
        object.wtimeout = object.wTimeoutMS;
        object.wTimeoutMS = void 0;
      }
      if (_object.srvHost) {
        object.srvHost = _object.srvHost;
      }
      const wcKeys = ["w", "wtimeout", "j", "journal", "fsync"];
      for (const key of wcKeys) {
        if (object[key] !== void 0) {
          if (object.writeConcern === void 0)
            object.writeConcern = {};
          object.writeConcern[key] = object[key];
          object[key] = void 0;
        }
      }
      return object;
    }
    function translateOptions(options2, translationOptions) {
      translationOptions = Object.assign({}, {createServers: true}, translationOptions);
      if (typeof options2.readPreference === "string" || typeof options2.read_preference === "string") {
        options2.readPreference = new ReadPreference(options2.readPreference || options2.read_preference);
      }
      if (options2.readPreference && (options2.readPreferenceTags || options2.read_preference_tags)) {
        options2.readPreference.tags = options2.readPreferenceTags || options2.read_preference_tags;
      }
      if (options2.maxStalenessSeconds) {
        options2.readPreference.maxStalenessSeconds = options2.maxStalenessSeconds;
      }
      if (options2.socketTimeoutMS == null)
        options2.socketTimeoutMS = 0;
      if (options2.connectTimeoutMS == null)
        options2.connectTimeoutMS = 1e4;
      if (!translationOptions.createServers) {
        return;
      }
      return options2.servers.map((serverObj) => {
        return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options2) : new Server(serverObj.host, serverObj.port, options2);
      });
    }
    module2.exports = {validOptions, connect};
  }
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS({
  "node_modules/mongodb/lib/mongo_client.js"(exports2, module2) {
    "use strict";
    var ChangeStream = require_change_stream();
    var Db = require_db();
    var EventEmitter = require("events").EventEmitter;
    var inherits = require("util").inherits;
    var MongoError = require_core().MongoError;
    var deprecate = require("util").deprecate;
    var WriteConcern = require_write_concern();
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var ReadPreference = require_read_preference();
    var maybePromise = require_utils4().maybePromise;
    var NativeTopology = require_native_topology();
    var connect = require_connect2().connect;
    var validOptions = require_connect2().validOptions;
    function MongoClient2(url, options2) {
      if (!(this instanceof MongoClient2))
        return new MongoClient2(url, options2);
      EventEmitter.call(this);
      if (options2 && options2.autoEncryption)
        require_encrypter();
      this.s = {
        url,
        options: options2 || {},
        promiseLibrary: options2 && options2.promiseLibrary || Promise,
        dbCache: new Map(),
        sessions: new Set(),
        writeConcern: WriteConcern.fromOptions(options2),
        readPreference: ReadPreference.fromOptions(options2) || ReadPreference.primary,
        namespace: new MongoDBNamespace("admin")
      };
    }
    inherits(MongoClient2, EventEmitter);
    Object.defineProperty(MongoClient2.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(MongoClient2.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        return this.s.readPreference;
      }
    });
    MongoClient2.prototype.connect = function(callback) {
      if (typeof callback === "string") {
        throw new TypeError("`connect` only accepts a callback");
      }
      const client = this;
      return maybePromise(this, callback, (cb) => {
        const err = validOptions(client.s.options);
        if (err)
          return cb(err);
        connect(client, client.s.url, client.s.options, (err2) => {
          if (err2)
            return cb(err2);
          cb(null, client);
        });
      });
    };
    MongoClient2.prototype.logout = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      if (typeof callback === "function")
        callback(null, true);
    }, "Multiple authentication is prohibited on a connected client, please only authenticate once per MongoClient");
    MongoClient2.prototype.close = function(force, callback) {
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      const client = this;
      return maybePromise(this, callback, (cb) => {
        const completeClose = (err) => {
          client.emit("close", client);
          if (!(client.topology instanceof NativeTopology)) {
            for (const item of client.s.dbCache) {
              item[1].emit("close", client);
            }
          }
          client.removeAllListeners("close");
          cb(err);
        };
        if (client.topology == null) {
          completeClose();
          return;
        }
        client.topology.close(force, (err) => {
          const encrypter = client.topology.s.options.encrypter;
          if (encrypter) {
            return encrypter.close(client, force, (err2) => {
              completeClose(err || err2);
            });
          }
          completeClose(err);
        });
      });
    };
    MongoClient2.prototype.db = function(dbName, options2) {
      options2 = options2 || {};
      if (!dbName) {
        dbName = this.s.options.dbName;
      }
      const finalOptions = Object.assign({}, this.s.options, options2);
      if (this.s.dbCache.has(dbName) && finalOptions.returnNonCachedInstance !== true) {
        return this.s.dbCache.get(dbName);
      }
      finalOptions.promiseLibrary = this.s.promiseLibrary;
      if (!this.topology) {
        throw new MongoError("MongoClient must be connected before calling MongoClient.prototype.db");
      }
      const db = new Db(dbName, this.topology, finalOptions);
      this.s.dbCache.set(dbName, db);
      return db;
    };
    MongoClient2.prototype.isConnected = function(options2) {
      options2 = options2 || {};
      if (!this.topology)
        return false;
      return this.topology.isConnected(options2);
    };
    MongoClient2.connect = function(url, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : null;
      options2 = options2 || {};
      const mongoClient = new MongoClient2(url, options2);
      return mongoClient.connect(callback);
    };
    MongoClient2.prototype.startSession = function(options2) {
      options2 = Object.assign({explicit: true}, options2);
      if (!this.topology) {
        throw new MongoError("Must connect to a server before calling this method");
      }
      return this.topology.startSession(options2, this.s.options);
    };
    MongoClient2.prototype.withSession = function(options2, operation) {
      if (typeof options2 === "function")
        operation = options2, options2 = void 0;
      const session = this.startSession(options2);
      let cleanupHandler = (err, result, opts) => {
        cleanupHandler = () => {
          throw new ReferenceError("cleanupHandler was called too many times");
        };
        opts = Object.assign({throw: true}, opts);
        session.endSession();
        if (err) {
          if (opts.throw)
            throw err;
          return Promise.reject(err);
        }
      };
      try {
        const result = operation(session);
        return Promise.resolve(result).then((result2) => cleanupHandler(null, result2)).catch((err) => cleanupHandler(err, null, {throw: true}));
      } catch (err) {
        return cleanupHandler(err, null, {throw: false});
      }
    };
    MongoClient2.prototype.watch = function(pipeline2, options2) {
      pipeline2 = pipeline2 || [];
      options2 = options2 || {};
      if (!Array.isArray(pipeline2)) {
        options2 = pipeline2;
        pipeline2 = [];
      }
      return new ChangeStream(this, pipeline2, options2);
    };
    MongoClient2.prototype.getLogger = function() {
      return this.s.options.logger;
    };
    module2.exports = MongoClient2;
  }
});

// node_modules/mongodb/lib/gridfs/chunk.js
var require_chunk = __commonJS({
  "node_modules/mongodb/lib/gridfs/chunk.js"(exports2, module2) {
    "use strict";
    var Binary2 = require_core().BSON.Binary;
    var ObjectID2 = require_core().BSON.ObjectID;
    var Buffer2 = require_safe_buffer().Buffer;
    var Chunk2 = function(file, mongoObject, writeConcern) {
      if (!(this instanceof Chunk2))
        return new Chunk2(file, mongoObject);
      this.file = file;
      var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
      this.writeConcern = writeConcern || {w: 1};
      this.objectId = mongoObjectFinal._id == null ? new ObjectID2() : mongoObjectFinal._id;
      this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
      this.data = new Binary2();
      if (typeof mongoObjectFinal.data === "string") {
        var buffer = Buffer2.alloc(mongoObjectFinal.data.length);
        buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, "binary");
        this.data = new Binary2(buffer);
      } else if (Array.isArray(mongoObjectFinal.data)) {
        buffer = Buffer2.alloc(mongoObjectFinal.data.length);
        var data = mongoObjectFinal.data.join("");
        buffer.write(data, 0, data.length, "binary");
        this.data = new Binary2(buffer);
      } else if (mongoObjectFinal.data && mongoObjectFinal.data._bsontype === "Binary") {
        this.data = mongoObjectFinal.data;
      } else if (!Buffer2.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)) {
        throw Error("Illegal chunk format");
      }
      this.internalPosition = 0;
    };
    Chunk2.prototype.write = function(data, callback) {
      this.data.write(data, this.internalPosition, data.length, "binary");
      this.internalPosition = this.data.length();
      if (callback != null)
        return callback(null, this);
      return this;
    };
    Chunk2.prototype.read = function(length) {
      length = length == null || length === 0 ? this.length() : length;
      if (this.length() - this.internalPosition + 1 >= length) {
        var data = this.data.read(this.internalPosition, length);
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return "";
      }
    };
    Chunk2.prototype.readSlice = function(length) {
      if (this.length() - this.internalPosition >= length) {
        var data = null;
        if (this.data.buffer != null) {
          data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
        } else {
          data = Buffer2.alloc(length);
          length = this.data.readInto(data, this.internalPosition);
        }
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return null;
      }
    };
    Chunk2.prototype.eof = function() {
      return this.internalPosition === this.length() ? true : false;
    };
    Chunk2.prototype.getc = function() {
      return this.read(1);
    };
    Chunk2.prototype.rewind = function() {
      this.internalPosition = 0;
      this.data = new Binary2();
    };
    Chunk2.prototype.save = function(options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      self2.file.chunkCollection(function(err, collection) {
        if (err)
          return callback(err);
        var writeOptions = {upsert: true};
        for (var name2 in options2)
          writeOptions[name2] = options2[name2];
        for (name2 in self2.writeConcern)
          writeOptions[name2] = self2.writeConcern[name2];
        if (self2.data.length() > 0) {
          self2.buildMongoObject(function(mongoObject) {
            var options3 = {forceServerObjectId: true};
            for (var name3 in self2.writeConcern) {
              options3[name3] = self2.writeConcern[name3];
            }
            collection.replaceOne({_id: self2.objectId}, mongoObject, writeOptions, function(err2) {
              callback(err2, self2);
            });
          });
        } else {
          callback(null, self2);
        }
      });
    };
    Chunk2.prototype.buildMongoObject = function(callback) {
      var mongoObject = {
        files_id: this.file.fileId,
        n: this.chunkNumber,
        data: this.data
      };
      if (this.objectId != null)
        mongoObject._id = this.objectId;
      callback(mongoObject);
    };
    Chunk2.prototype.length = function() {
      return this.data.length();
    };
    Object.defineProperty(Chunk2.prototype, "position", {
      enumerable: true,
      get: function() {
        return this.internalPosition;
      },
      set: function(value) {
        this.internalPosition = value;
      }
    });
    Chunk2.DEFAULT_CHUNK_SIZE = 1024 * 255;
    module2.exports = Chunk2;
  }
});

// node_modules/mongodb/lib/gridfs/grid_store.js
var require_grid_store = __commonJS({
  "node_modules/mongodb/lib/gridfs/grid_store.js"(exports2, module2) {
    "use strict";
    var Chunk2 = require_chunk();
    var ObjectID2 = require_core().BSON.ObjectID;
    var ReadPreference = require_core().ReadPreference;
    var Buffer2 = require_safe_buffer().Buffer;
    var fs = require("fs");
    var f = require("util").format;
    var util = require("util");
    var MongoError = require_core().MongoError;
    var inherits = util.inherits;
    var Duplex = require("stream").Duplex;
    var shallowClone = require_utils4().shallowClone;
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var deprecate = require("util").deprecate;
    var REFERENCE_BY_FILENAME = 0;
    var REFERENCE_BY_ID = 1;
    var deprecationFn = deprecate(() => {
    }, "GridStore is deprecated, and will be removed in a future version. Please use GridFSBucket instead");
    var GridStore = function GridStore2(db, id, filename, mode, options2) {
      deprecationFn();
      if (!(this instanceof GridStore2))
        return new GridStore2(db, id, filename, mode, options2);
      this.db = db;
      if (typeof options2 === "undefined")
        options2 = {};
      if (typeof mode === "undefined") {
        mode = filename;
        filename = void 0;
      } else if (typeof mode === "object") {
        options2 = mode;
        mode = filename;
        filename = void 0;
      }
      if (id && id._bsontype === "ObjectID") {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      } else if (typeof filename === "undefined") {
        this.referenceBy = REFERENCE_BY_FILENAME;
        this.filename = id;
        if (mode.indexOf("w") != null) {
          this.fileId = new ObjectID2();
        }
      } else {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      }
      this.mode = mode == null ? "r" : mode;
      this.options = options2 || {};
      this.isOpen = false;
      this.root = this.options["root"] == null ? GridStore2.DEFAULT_ROOT_COLLECTION : this.options["root"];
      this.position = 0;
      this.readPreference = this.options.readPreference || db.options.readPreference || ReadPreference.primary;
      this.writeConcern = _getWriteConcern(db, this.options);
      this.internalChunkSize = this.options["chunkSize"] == null ? Chunk2.DEFAULT_CHUNK_SIZE : this.options["chunkSize"];
      var promiseLibrary = this.options.promiseLibrary || Promise;
      this.promiseLibrary = promiseLibrary;
      Object.defineProperty(this, "chunkSize", {
        enumerable: true,
        get: function() {
          return this.internalChunkSize;
        },
        set: function(value) {
          if (!(this.mode[0] === "w" && this.position === 0 && this.uploadDate == null)) {
            this.internalChunkSize = this.internalChunkSize;
          } else {
            this.internalChunkSize = value;
          }
        }
      });
      Object.defineProperty(this, "md5", {
        enumerable: true,
        get: function() {
          return this.internalMd5;
        }
      });
      Object.defineProperty(this, "chunkNumber", {
        enumerable: true,
        get: function() {
          return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
        }
      });
    };
    GridStore.prototype.open = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.mode !== "w" && this.mode !== "w+" && this.mode !== "r") {
        throw MongoError.create({message: "Illegal mode " + this.mode, driver: true});
      }
      return executeLegacyOperation(this.db.s.topology, open, [this, options2, callback], {
        skipSessions: true
      });
    };
    var open = function(self2, options2, callback) {
      var writeConcern = _getWriteConcern(self2.db, self2.options);
      if (self2.mode === "w" || self2.mode === "w+") {
        var collection = self2.collection();
        collection.ensureIndex([["filename", 1]], writeConcern, function() {
          var chunkCollection = self2.chunkCollection();
          var chunkIndexOptions = shallowClone(writeConcern);
          chunkIndexOptions.unique = true;
          chunkCollection.ensureIndex([
            ["files_id", 1],
            ["n", 1]
          ], chunkIndexOptions, function() {
            _open(self2, writeConcern, function(err, r) {
              if (err)
                return callback(err);
              self2.isOpen = true;
              callback(err, r);
            });
          });
        });
      } else {
        _open(self2, writeConcern, function(err, r) {
          if (err)
            return callback(err);
          self2.isOpen = true;
          callback(err, r);
        });
      }
    };
    GridStore.prototype.eof = function() {
      return this.position === this.length ? true : false;
    };
    GridStore.prototype.getc = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, getc, [this, options2, callback], {
        skipSessions: true
      });
    };
    var getc = function(self2, options2, callback) {
      if (self2.eof()) {
        callback(null, null);
      } else if (self2.currentChunk.eof()) {
        nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
          self2.currentChunk = chunk;
          self2.position = self2.position + 1;
          callback(err, self2.currentChunk.getc());
        });
      } else {
        self2.position = self2.position + 1;
        callback(null, self2.currentChunk.getc());
      }
    };
    GridStore.prototype.puts = function(string2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      var finalString = string2.match(/\n$/) == null ? string2 + "\n" : string2;
      return executeLegacyOperation(this.db.s.topology, this.write.bind(this), [finalString, options2, callback], {skipSessions: true});
    };
    GridStore.prototype.stream = function() {
      return new GridStoreStream(this);
    };
    GridStore.prototype.write = function write(data, close2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, _writeNormal, [this, data, close2, options2, callback], {skipSessions: true});
    };
    GridStore.prototype.destroy = function destroy() {
      if (!this.writable)
        return;
      this.readable = false;
      if (this.writable) {
        this.writable = false;
        this._q.length = 0;
        this.emit("close");
      }
    };
    GridStore.prototype.writeFile = function(file, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, writeFile, [this, file, options2, callback], {
        skipSessions: true
      });
    };
    var writeFile = function(self2, file, options2, callback) {
      if (typeof file === "string") {
        fs.open(file, "r", function(err, fd) {
          if (err)
            return callback(err);
          self2.writeFile(fd, callback);
        });
        return;
      }
      self2.open(function(err, self3) {
        if (err)
          return callback(err, self3);
        fs.fstat(file, function(err2, stats) {
          if (err2)
            return callback(err2, self3);
          var offset = 0;
          var index2 = 0;
          var writeChunk = function() {
            var _buffer = Buffer2.alloc(self3.chunkSize);
            fs.read(file, _buffer, 0, _buffer.length, offset, function(err3, bytesRead, data) {
              if (err3)
                return callback(err3, self3);
              offset = offset + bytesRead;
              var chunk = new Chunk2(self3, {n: index2++}, self3.writeConcern);
              chunk.write(data.slice(0, bytesRead), function(err4, chunk2) {
                if (err4)
                  return callback(err4, self3);
                chunk2.save({}, function(err5) {
                  if (err5)
                    return callback(err5, self3);
                  self3.position = self3.position + bytesRead;
                  self3.currentChunk = chunk2;
                  if (offset >= stats.size) {
                    fs.close(file, function(err6) {
                      if (err6)
                        return callback(err6);
                      self3.close(function(err7) {
                        if (err7)
                          return callback(err7, self3);
                        return callback(null, self3);
                      });
                    });
                  } else {
                    return process.nextTick(writeChunk);
                  }
                });
              });
            });
          };
          process.nextTick(writeChunk);
        });
      });
    };
    GridStore.prototype.close = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, close, [this, options2, callback], {
        skipSessions: true
      });
    };
    var close = function(self2, options2, callback) {
      if (self2.mode[0] === "w") {
        options2 = Object.assign({}, self2.writeConcern, options2);
        if (self2.currentChunk != null && self2.currentChunk.position > 0) {
          self2.currentChunk.save({}, function(err) {
            if (err && typeof callback === "function")
              return callback(err);
            self2.collection(function(err2, files) {
              if (err2 && typeof callback === "function")
                return callback(err2);
              if (self2.uploadDate != null) {
                buildMongoObject(self2, function(err3, mongoObject) {
                  if (err3) {
                    if (typeof callback === "function")
                      return callback(err3);
                    else
                      throw err3;
                  }
                  files.save(mongoObject, options2, function(err4) {
                    if (typeof callback === "function")
                      callback(err4, mongoObject);
                  });
                });
              } else {
                self2.uploadDate = new Date();
                buildMongoObject(self2, function(err3, mongoObject) {
                  if (err3) {
                    if (typeof callback === "function")
                      return callback(err3);
                    else
                      throw err3;
                  }
                  files.save(mongoObject, options2, function(err4) {
                    if (typeof callback === "function")
                      callback(err4, mongoObject);
                  });
                });
              }
            });
          });
        } else {
          self2.collection(function(err, files) {
            if (err && typeof callback === "function")
              return callback(err);
            self2.uploadDate = new Date();
            buildMongoObject(self2, function(err2, mongoObject) {
              if (err2) {
                if (typeof callback === "function")
                  return callback(err2);
                else
                  throw err2;
              }
              files.save(mongoObject, options2, function(err3) {
                if (typeof callback === "function")
                  callback(err3, mongoObject);
              });
            });
          });
        }
      } else if (self2.mode[0] === "r") {
        if (typeof callback === "function")
          callback(null, null);
      } else {
        if (typeof callback === "function")
          callback(MongoError.create({message: f("Illegal mode %s", self2.mode), driver: true}));
      }
    };
    GridStore.prototype.chunkCollection = function(callback) {
      if (typeof callback === "function")
        return this.db.collection(this.root + ".chunks", callback);
      return this.db.collection(this.root + ".chunks");
    };
    GridStore.prototype.unlink = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, unlink, [this, options2, callback], {
        skipSessions: true
      });
    };
    var unlink = function(self2, options2, callback) {
      deleteChunks(self2, function(err) {
        if (err !== null) {
          err.message = "at deleteChunks: " + err.message;
          return callback(err);
        }
        self2.collection(function(err2, collection) {
          if (err2 !== null) {
            err2.message = "at collection: " + err2.message;
            return callback(err2);
          }
          collection.remove({_id: self2.fileId}, self2.writeConcern, function(err3) {
            callback(err3, self2);
          });
        });
      });
    };
    GridStore.prototype.collection = function(callback) {
      if (typeof callback === "function")
        this.db.collection(this.root + ".files", callback);
      return this.db.collection(this.root + ".files");
    };
    GridStore.prototype.readlines = function(separator, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      separator = args.length ? args.shift() : "\n";
      separator = separator || "\n";
      options2 = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, readlines, [this, separator, options2, callback], {skipSessions: true});
    };
    var readlines = function(self2, separator, options2, callback) {
      self2.read(function(err, data) {
        if (err)
          return callback(err);
        var items = data.toString().split(separator);
        items = items.length > 0 ? items.splice(0, items.length - 1) : [];
        for (var i = 0; i < items.length; i++) {
          items[i] = items[i] + separator;
        }
        callback(null, items);
      });
    };
    GridStore.prototype.rewind = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, rewind, [this, options2, callback], {
        skipSessions: true
      });
    };
    var rewind = function(self2, options2, callback) {
      if (self2.currentChunk.chunkNumber !== 0) {
        if (self2.mode[0] === "w") {
          deleteChunks(self2, function(err) {
            if (err)
              return callback(err);
            self2.currentChunk = new Chunk2(self2, {n: 0}, self2.writeConcern);
            self2.position = 0;
            callback(null, self2);
          });
        } else {
          self2.currentChunk(0, function(err, chunk) {
            if (err)
              return callback(err);
            self2.currentChunk = chunk;
            self2.currentChunk.rewind();
            self2.position = 0;
            callback(null, self2);
          });
        }
      } else {
        self2.currentChunk.rewind();
        self2.position = 0;
        callback(null, self2);
      }
    };
    GridStore.prototype.read = function(length, buffer, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      length = args.length ? args.shift() : null;
      buffer = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, read2, [this, length, buffer, options2, callback], {skipSessions: true});
    };
    var read2 = function(self2, length, buffer, options2, callback) {
      var finalLength = length == null ? self2.length - self2.position : length;
      var finalBuffer = buffer == null ? Buffer2.alloc(finalLength) : buffer;
      finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;
      if (self2.currentChunk.length() - self2.currentChunk.position + finalBuffer._index >= finalLength) {
        var slice = self2.currentChunk.readSlice(finalLength - finalBuffer._index);
        slice.copy(finalBuffer, finalBuffer._index);
        self2.position = self2.position + finalBuffer.length;
        if (finalLength === 0 && finalBuffer.length === 0)
          return callback(MongoError.create({message: "File does not exist", driver: true}), null);
        return callback(null, finalBuffer);
      }
      slice = self2.currentChunk.readSlice(self2.currentChunk.length() - self2.currentChunk.position);
      slice.copy(finalBuffer, finalBuffer._index);
      finalBuffer._index += slice.length;
      nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
        if (err)
          return callback(err);
        if (chunk.length() > 0) {
          self2.currentChunk = chunk;
          self2.read(length, finalBuffer, callback);
        } else {
          if (finalBuffer._index > 0) {
            callback(null, finalBuffer);
          } else {
            callback(MongoError.create({
              message: "no chunks found for file, possibly corrupt",
              driver: true
            }), null);
          }
        }
      });
    };
    GridStore.prototype.tell = function(callback) {
      var self2 = this;
      if (typeof callback === "function")
        return callback(null, this.position);
      return new self2.promiseLibrary(function(resolve2) {
        resolve2(self2.position);
      });
    };
    GridStore.prototype.seek = function(position, seekLocation, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      seekLocation = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, seek, [this, position, seekLocation, options2, callback], {skipSessions: true});
    };
    var seek = function(self2, position, seekLocation, options2, callback) {
      if (self2.mode !== "r") {
        return callback(MongoError.create({message: "seek is only supported for mode r", driver: true}));
      }
      var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
      var finalPosition = position;
      var targetPosition = 0;
      if (seekLocationFinal === GridStore.IO_SEEK_CUR) {
        targetPosition = self2.position + finalPosition;
      } else if (seekLocationFinal === GridStore.IO_SEEK_END) {
        targetPosition = self2.length + finalPosition;
      } else {
        targetPosition = finalPosition;
      }
      var newChunkNumber = Math.floor(targetPosition / self2.chunkSize);
      var seekChunk = function() {
        nthChunk(self2, newChunkNumber, function(err, chunk) {
          if (err)
            return callback(err, null);
          if (chunk == null)
            return callback(new Error("no chunk found"));
          self2.currentChunk = chunk;
          self2.position = targetPosition;
          self2.currentChunk.position = self2.position % self2.chunkSize;
          callback(err, self2);
        });
      };
      seekChunk();
    };
    var _open = function(self2, options2, callback) {
      var collection = self2.collection();
      var query = self2.referenceBy === REFERENCE_BY_ID ? {_id: self2.fileId} : {filename: self2.filename};
      query = self2.fileId == null && self2.filename == null ? null : query;
      options2.readPreference = self2.readPreference;
      if (query != null) {
        collection.findOne(query, options2, function(err, doc2) {
          if (err) {
            return error3(err);
          }
          if (doc2 != null) {
            self2.fileId = doc2._id;
            self2.filename = self2.mode === "r" || self2.filename === void 0 ? doc2.filename : self2.filename;
            self2.contentType = doc2.contentType;
            self2.internalChunkSize = doc2.chunkSize;
            self2.uploadDate = doc2.uploadDate;
            self2.aliases = doc2.aliases;
            self2.length = doc2.length;
            self2.metadata = doc2.metadata;
            self2.internalMd5 = doc2.md5;
          } else if (self2.mode !== "r") {
            self2.fileId = self2.fileId == null ? new ObjectID2() : self2.fileId;
            self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
            self2.internalChunkSize = self2.internalChunkSize == null ? Chunk2.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
            self2.length = 0;
          } else {
            self2.length = 0;
            var txtId = self2.fileId._bsontype === "ObjectID" ? self2.fileId.toHexString() : self2.fileId;
            return error3(MongoError.create({
              message: f("file with id %s not opened for writing", self2.referenceBy === REFERENCE_BY_ID ? txtId : self2.filename),
              driver: true
            }), self2);
          }
          if (self2.mode === "r") {
            nthChunk(self2, 0, options2, function(err2, chunk) {
              if (err2)
                return error3(err2);
              self2.currentChunk = chunk;
              self2.position = 0;
              callback(null, self2);
            });
          } else if (self2.mode === "w" && doc2) {
            deleteChunks(self2, options2, function(err2) {
              if (err2)
                return error3(err2);
              self2.currentChunk = new Chunk2(self2, {n: 0}, self2.writeConcern);
              self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
              self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
              self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
              self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
              self2.position = 0;
              callback(null, self2);
            });
          } else if (self2.mode === "w") {
            self2.currentChunk = new Chunk2(self2, {n: 0}, self2.writeConcern);
            self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
            self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = 0;
            callback(null, self2);
          } else if (self2.mode === "w+") {
            nthChunk(self2, lastChunkNumber(self2), options2, function(err2, chunk) {
              if (err2)
                return error3(err2);
              self2.currentChunk = chunk == null ? new Chunk2(self2, {n: 0}, self2.writeConcern) : chunk;
              self2.currentChunk.position = self2.currentChunk.data.length();
              self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
              self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
              self2.position = self2.length;
              callback(null, self2);
            });
          }
        });
      } else {
        self2.fileId = self2.fileId == null ? new ObjectID2() : self2.fileId;
        self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
        self2.internalChunkSize = self2.internalChunkSize == null ? Chunk2.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
        self2.length = 0;
        if (self2.mode === "w") {
          deleteChunks(self2, options2, function(err) {
            if (err)
              return error3(err);
            self2.currentChunk = new Chunk2(self2, {n: 0}, self2.writeConcern);
            self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
            self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = 0;
            callback(null, self2);
          });
        } else if (self2.mode === "w+") {
          nthChunk(self2, lastChunkNumber(self2), options2, function(err, chunk) {
            if (err)
              return error3(err);
            self2.currentChunk = chunk == null ? new Chunk2(self2, {n: 0}, self2.writeConcern) : chunk;
            self2.currentChunk.position = self2.currentChunk.data.length();
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = self2.length;
            callback(null, self2);
          });
        }
      }
      function error3(err) {
        if (error3.err)
          return;
        callback(error3.err = err);
      }
    };
    var writeBuffer = function(self2, buffer, close2, callback) {
      if (typeof close2 === "function") {
        callback = close2;
        close2 = null;
      }
      var finalClose = typeof close2 === "boolean" ? close2 : false;
      if (self2.mode !== "w") {
        callback(MongoError.create({
          message: f("file with id %s not opened for writing", self2.referenceBy === REFERENCE_BY_ID ? self2.referenceBy : self2.filename),
          driver: true
        }), null);
      } else {
        if (self2.currentChunk.position + buffer.length >= self2.chunkSize) {
          var previousChunkNumber = self2.currentChunk.chunkNumber;
          var leftOverDataSize = self2.chunkSize - self2.currentChunk.position;
          var firstChunkData = buffer.slice(0, leftOverDataSize);
          var leftOverData = buffer.slice(leftOverDataSize);
          var chunksToWrite = [self2.currentChunk.write(firstChunkData)];
          while (leftOverData.length >= self2.chunkSize) {
            var newChunk = new Chunk2(self2, {n: previousChunkNumber + 1}, self2.writeConcern);
            firstChunkData = leftOverData.slice(0, self2.chunkSize);
            leftOverData = leftOverData.slice(self2.chunkSize);
            previousChunkNumber = previousChunkNumber + 1;
            newChunk.write(firstChunkData);
            chunksToWrite.push(newChunk);
          }
          self2.currentChunk = new Chunk2(self2, {n: previousChunkNumber + 1}, self2.writeConcern);
          if (leftOverData.length > 0)
            self2.currentChunk.write(leftOverData);
          self2.position = self2.position + buffer.length;
          var numberOfChunksToWrite = chunksToWrite.length;
          for (var i = 0; i < chunksToWrite.length; i++) {
            chunksToWrite[i].save({}, function(err) {
              if (err)
                return callback(err);
              numberOfChunksToWrite = numberOfChunksToWrite - 1;
              if (numberOfChunksToWrite <= 0) {
                if (finalClose) {
                  return self2.close(function(err2) {
                    callback(err2, self2);
                  });
                }
                return callback(null, self2);
              }
            });
          }
        } else {
          self2.position = self2.position + buffer.length;
          self2.currentChunk.write(buffer);
          if (finalClose) {
            return self2.close(function(err) {
              callback(err, self2);
            });
          }
          return callback(null, self2);
        }
      }
    };
    var buildMongoObject = function(self2, callback) {
      var mongoObject = {
        _id: self2.fileId,
        filename: self2.filename,
        contentType: self2.contentType,
        length: self2.position ? self2.position : 0,
        chunkSize: self2.chunkSize,
        uploadDate: self2.uploadDate,
        aliases: self2.aliases,
        metadata: self2.metadata
      };
      var md5Command = {filemd5: self2.fileId, root: self2.root};
      self2.db.command(md5Command, function(err, results) {
        if (err)
          return callback(err);
        mongoObject.md5 = results.md5;
        callback(null, mongoObject);
      });
    };
    var nthChunk = function(self2, chunkNumber, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || self2.writeConcern;
      options2.readPreference = self2.readPreference;
      self2.chunkCollection().findOne({files_id: self2.fileId, n: chunkNumber}, options2, function(err, chunk) {
        if (err)
          return callback(err);
        var finalChunk = chunk == null ? {} : chunk;
        callback(null, new Chunk2(self2, finalChunk, self2.writeConcern));
      });
    };
    var lastChunkNumber = function(self2) {
      return Math.floor((self2.length ? self2.length - 1 : 0) / self2.chunkSize);
    };
    var deleteChunks = function(self2, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || self2.writeConcern;
      if (self2.fileId != null) {
        self2.chunkCollection().remove({files_id: self2.fileId}, options2, function(err) {
          if (err)
            return callback(err, false);
          callback(null, true);
        });
      } else {
        callback(null, true);
      }
    };
    GridStore.DEFAULT_ROOT_COLLECTION = "fs";
    GridStore.DEFAULT_CONTENT_TYPE = "binary/octet-stream";
    GridStore.IO_SEEK_SET = 0;
    GridStore.IO_SEEK_CUR = 1;
    GridStore.IO_SEEK_END = 2;
    GridStore.exist = function(db, fileIdObject, rootCollection, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      rootCollection = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, exists, [db, fileIdObject, rootCollection, options2, callback], {skipSessions: true});
    };
    var exists = function(db, fileIdObject, rootCollection, options2, callback) {
      var readPreference = options2.readPreference || ReadPreference.PRIMARY;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      db.collection(rootCollectionFinal + ".files", function(err, collection) {
        if (err)
          return callback(err);
        var query = typeof fileIdObject === "string" || Object.prototype.toString.call(fileIdObject) === "[object RegExp]" ? {filename: fileIdObject} : {_id: fileIdObject};
        if (fileIdObject != null && typeof fileIdObject === "object" && Object.prototype.toString.call(fileIdObject) !== "[object RegExp]") {
          query = fileIdObject;
        }
        collection.findOne(query, {readPreference}, function(err2, item) {
          if (err2)
            return callback(err2);
          callback(null, item == null ? false : true);
        });
      });
    };
    GridStore.list = function(db, rootCollection, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      rootCollection = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, list, [db, rootCollection, options2, callback], {
        skipSessions: true
      });
    };
    var list = function(db, rootCollection, options2, callback) {
      if (rootCollection != null && typeof rootCollection === "object") {
        options2 = rootCollection;
        rootCollection = null;
      }
      var readPreference = options2.readPreference || ReadPreference.primary;
      var byId = options2["id"] != null ? options2["id"] : false;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      var items = [];
      db.collection(rootCollectionFinal + ".files", function(err, collection) {
        if (err)
          return callback(err);
        collection.find({}, {readPreference}, function(err2, cursor) {
          if (err2)
            return callback(err2);
          cursor.each(function(err3, item) {
            if (item != null) {
              items.push(byId ? item._id : item.filename);
            } else {
              callback(err3, items);
            }
          });
        });
      });
    };
    GridStore.read = function(db, name2, length, offset, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      length = args.length ? args.shift() : null;
      offset = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : null;
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, readStatic, [db, name2, length, offset, options2, callback], {skipSessions: true});
    };
    var readStatic = function(db, name2, length, offset, options2, callback) {
      new GridStore(db, name2, "r", options2).open(function(err, gridStore) {
        if (err)
          return callback(err);
        if (offset && offset >= gridStore.length)
          return callback("offset larger than size of file", null);
        if (length && length > gridStore.length)
          return callback("length is larger than the size of the file", null);
        if (offset && length && offset + length > gridStore.length)
          return callback("offset and length is larger than the size of the file", null);
        if (offset != null) {
          gridStore.seek(offset, function(err2, gridStore2) {
            if (err2)
              return callback(err2);
            gridStore2.read(length, callback);
          });
        } else {
          gridStore.read(length, callback);
        }
      });
    };
    GridStore.readlines = function(db, name2, separator, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      separator = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : null;
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, readlinesStatic, [db, name2, separator, options2, callback], {skipSessions: true});
    };
    var readlinesStatic = function(db, name2, separator, options2, callback) {
      var finalSeperator = separator == null ? "\n" : separator;
      new GridStore(db, name2, "r", options2).open(function(err, gridStore) {
        if (err)
          return callback(err);
        gridStore.readlines(finalSeperator, callback);
      });
    };
    GridStore.unlink = function(db, names, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : {};
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, unlinkStatic, [this, db, names, options2, callback], {
        skipSessions: true
      });
    };
    var unlinkStatic = function(self2, db, names, options2, callback) {
      var writeConcern = _getWriteConcern(db, options2);
      if (names.constructor === Array) {
        var tc = 0;
        for (var i = 0; i < names.length; i++) {
          ++tc;
          GridStore.unlink(db, names[i], options2, function() {
            if (--tc === 0) {
              callback(null, self2);
            }
          });
        }
      } else {
        new GridStore(db, names, "w", options2).open(function(err, gridStore) {
          if (err)
            return callback(err);
          deleteChunks(gridStore, function(err2) {
            if (err2)
              return callback(err2);
            gridStore.collection(function(err3, collection) {
              if (err3)
                return callback(err3);
              collection.remove({_id: gridStore.fileId}, writeConcern, function(err4) {
                callback(err4, self2);
              });
            });
          });
        });
      }
    };
    var _writeNormal = function(self2, data, close2, options2, callback) {
      if (Buffer2.isBuffer(data)) {
        return writeBuffer(self2, data, close2, callback);
      } else {
        return writeBuffer(self2, Buffer2.from(data, "binary"), close2, callback);
      }
    };
    var _setWriteConcernHash = function(options2) {
      const baseOptions = Object.assign(options2, options2.writeConcern);
      var finalOptions = {};
      if (baseOptions.w != null)
        finalOptions.w = baseOptions.w;
      if (baseOptions.journal === true)
        finalOptions.j = baseOptions.journal;
      if (baseOptions.j === true)
        finalOptions.j = baseOptions.j;
      if (baseOptions.fsync === true)
        finalOptions.fsync = baseOptions.fsync;
      if (baseOptions.wtimeout != null)
        finalOptions.wtimeout = baseOptions.wtimeout;
      return finalOptions;
    };
    var _getWriteConcern = function(self2, options2) {
      var finalOptions = {w: 1};
      options2 = options2 || {};
      if (options2.writeConcern != null || options2.w != null || typeof options2.j === "boolean" || typeof options2.journal === "boolean" || typeof options2.fsync === "boolean") {
        finalOptions = _setWriteConcernHash(options2);
      } else if (options2.safe != null && typeof options2.safe === "object") {
        finalOptions = _setWriteConcernHash(options2.safe);
      } else if (typeof options2.safe === "boolean") {
        finalOptions = {w: options2.safe ? 1 : 0};
      } else if (self2.options.writeConcern != null || self2.options.w != null || typeof self2.options.j === "boolean" || typeof self2.options.journal === "boolean" || typeof self2.options.fsync === "boolean") {
        finalOptions = _setWriteConcernHash(self2.options);
      } else if (self2.safe && (self2.safe.w != null || typeof self2.safe.j === "boolean" || typeof self2.safe.journal === "boolean" || typeof self2.safe.fsync === "boolean")) {
        finalOptions = _setWriteConcernHash(self2.safe);
      } else if (typeof self2.safe === "boolean") {
        finalOptions = {w: self2.safe ? 1 : 0};
      }
      if (finalOptions.w < 1 && (finalOptions.journal === true || finalOptions.j === true || finalOptions.fsync === true))
        throw MongoError.create({
          message: "No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true",
          driver: true
        });
      return finalOptions;
    };
    var GridStoreStream = function(gs) {
      Duplex.call(this);
      this.gs = gs;
      this.endCalled = false;
      this.totalBytesToRead = this.gs.length - this.gs.position;
      this.seekPosition = this.gs.position;
    };
    inherits(GridStoreStream, Duplex);
    GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;
    GridStoreStream.prototype.pipe = function(destination) {
      var self2 = this;
      if (!self2.gs.isOpen) {
        self2.gs.open(function(err) {
          if (err)
            return self2.emit("error", err);
          self2.totalBytesToRead = self2.gs.length - self2.gs.position;
          self2._pipe.apply(self2, [destination]);
        });
      } else {
        self2.totalBytesToRead = self2.gs.length - self2.gs.position;
        self2._pipe.apply(self2, [destination]);
      }
      return destination;
    };
    GridStoreStream.prototype._read = function() {
      var self2 = this;
      var read3 = function() {
        self2.gs.read(length, function(err, buffer) {
          if (err && !self2.endCalled)
            return self2.emit("error", err);
          if (self2.endCalled || buffer == null)
            return self2.push(null);
          if (buffer.length <= self2.totalBytesToRead) {
            self2.totalBytesToRead = self2.totalBytesToRead - buffer.length;
            self2.push(buffer);
          } else if (buffer.length > self2.totalBytesToRead) {
            self2.totalBytesToRead = self2.totalBytesToRead - buffer._index;
            self2.push(buffer.slice(0, buffer._index));
          }
          if (self2.totalBytesToRead <= 0) {
            self2.endCalled = true;
          }
        });
      };
      var length = self2.gs.length < self2.gs.chunkSize ? self2.gs.length - self2.seekPosition : self2.gs.chunkSize;
      if (!self2.gs.isOpen) {
        self2.gs.open(function(err) {
          self2.totalBytesToRead = self2.gs.length - self2.gs.position;
          if (err)
            return self2.emit("error", err);
          read3();
        });
      } else {
        read3();
      }
    };
    GridStoreStream.prototype.destroy = function() {
      this.pause();
      this.endCalled = true;
      this.gs.close();
      this.emit("end");
    };
    GridStoreStream.prototype.write = function(chunk) {
      var self2 = this;
      if (self2.endCalled)
        return self2.emit("error", MongoError.create({message: "attempting to write to stream after end called", driver: true}));
      if (!self2.gs.isOpen) {
        self2.gs.open(function() {
          self2.gs.isOpen = true;
          self2.gs.write(chunk, function() {
            process.nextTick(function() {
              self2.emit("drain");
            });
          });
        });
        return false;
      } else {
        self2.gs.write(chunk, function() {
          self2.emit("drain");
        });
        return true;
      }
    };
    GridStoreStream.prototype.end = function(chunk, encoding, callback) {
      var self2 = this;
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      chunk = args.length ? args.shift() : null;
      encoding = args.length ? args.shift() : null;
      self2.endCalled = true;
      if (chunk) {
        self2.gs.write(chunk, function() {
          self2.gs.close(function() {
            if (typeof callback === "function")
              callback();
            self2.emit("end");
          });
        });
      }
      self2.gs.close(function() {
        if (typeof callback === "function")
          callback();
        self2.emit("end");
      });
    };
    module2.exports = GridStore;
  }
});

// node_modules/mongodb/lib/gridfs-stream/download.js
var require_download = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/download.js"(exports2, module2) {
    "use strict";
    var stream = require("stream");
    var util = require("util");
    module2.exports = GridFSBucketReadStream;
    function GridFSBucketReadStream(chunks, files, readPreference, filter, options2) {
      this.s = {
        bytesRead: 0,
        chunks,
        cursor: null,
        expected: 0,
        files,
        filter,
        init: false,
        expectedEnd: 0,
        file: null,
        options: options2,
        readPreference
      };
      stream.Readable.call(this);
    }
    util.inherits(GridFSBucketReadStream, stream.Readable);
    GridFSBucketReadStream.prototype._read = function() {
      var _this = this;
      if (this.destroyed) {
        return;
      }
      waitForFile(_this, function() {
        doRead(_this);
      });
    };
    GridFSBucketReadStream.prototype.start = function(start) {
      throwIfInitialized(this);
      this.s.options.start = start;
      return this;
    };
    GridFSBucketReadStream.prototype.end = function(end) {
      throwIfInitialized(this);
      this.s.options.end = end;
      return this;
    };
    GridFSBucketReadStream.prototype.abort = function(callback) {
      var _this = this;
      this.push(null);
      this.destroyed = true;
      if (this.s.cursor) {
        this.s.cursor.close(function(error3) {
          _this.emit("close");
          callback && callback(error3);
        });
      } else {
        if (!this.s.init) {
          _this.emit("close");
        }
        callback && callback();
      }
    };
    function throwIfInitialized(self2) {
      if (self2.s.init) {
        throw new Error("You cannot change options after the stream has enteredflowing mode!");
      }
    }
    function doRead(_this) {
      if (_this.destroyed) {
        return;
      }
      _this.s.cursor.next(function(error3, doc2) {
        if (_this.destroyed) {
          return;
        }
        if (error3) {
          return __handleError(_this, error3);
        }
        if (!doc2) {
          _this.push(null);
          process.nextTick(() => {
            _this.s.cursor.close(function(error4) {
              if (error4) {
                __handleError(_this, error4);
                return;
              }
              _this.emit("close");
            });
          });
          return;
        }
        var bytesRemaining = _this.s.file.length - _this.s.bytesRead;
        var expectedN = _this.s.expected++;
        var expectedLength = Math.min(_this.s.file.chunkSize, bytesRemaining);
        if (doc2.n > expectedN) {
          var errmsg = "ChunkIsMissing: Got unexpected n: " + doc2.n + ", expected: " + expectedN;
          return __handleError(_this, new Error(errmsg));
        }
        if (doc2.n < expectedN) {
          errmsg = "ExtraChunk: Got unexpected n: " + doc2.n + ", expected: " + expectedN;
          return __handleError(_this, new Error(errmsg));
        }
        var buf = Buffer.isBuffer(doc2.data) ? doc2.data : doc2.data.buffer;
        if (buf.length !== expectedLength) {
          if (bytesRemaining <= 0) {
            errmsg = "ExtraChunk: Got unexpected n: " + doc2.n;
            return __handleError(_this, new Error(errmsg));
          }
          errmsg = "ChunkIsWrongSize: Got unexpected length: " + buf.length + ", expected: " + expectedLength;
          return __handleError(_this, new Error(errmsg));
        }
        _this.s.bytesRead += buf.length;
        if (buf.length === 0) {
          return _this.push(null);
        }
        var sliceStart = null;
        var sliceEnd = null;
        if (_this.s.bytesToSkip != null) {
          sliceStart = _this.s.bytesToSkip;
          _this.s.bytesToSkip = 0;
        }
        const atEndOfStream = expectedN === _this.s.expectedEnd - 1;
        const bytesLeftToRead = _this.s.options.end - _this.s.bytesToSkip;
        if (atEndOfStream && _this.s.bytesToTrim != null) {
          sliceEnd = _this.s.file.chunkSize - _this.s.bytesToTrim;
        } else if (_this.s.options.end && bytesLeftToRead < doc2.data.length()) {
          sliceEnd = bytesLeftToRead;
        }
        if (sliceStart != null || sliceEnd != null) {
          buf = buf.slice(sliceStart || 0, sliceEnd || buf.length);
        }
        _this.push(buf);
      });
    }
    function init2(self2) {
      var findOneOptions = {};
      if (self2.s.readPreference) {
        findOneOptions.readPreference = self2.s.readPreference;
      }
      if (self2.s.options && self2.s.options.sort) {
        findOneOptions.sort = self2.s.options.sort;
      }
      if (self2.s.options && self2.s.options.skip) {
        findOneOptions.skip = self2.s.options.skip;
      }
      self2.s.files.findOne(self2.s.filter, findOneOptions, function(error3, doc2) {
        if (error3) {
          return __handleError(self2, error3);
        }
        if (!doc2) {
          var identifier = self2.s.filter._id ? self2.s.filter._id.toString() : self2.s.filter.filename;
          var errmsg = "FileNotFound: file " + identifier + " was not found";
          var err = new Error(errmsg);
          err.code = "ENOENT";
          return __handleError(self2, err);
        }
        if (doc2.length <= 0) {
          self2.push(null);
          return;
        }
        if (self2.destroyed) {
          self2.emit("close");
          return;
        }
        try {
          self2.s.bytesToSkip = handleStartOption(self2, doc2, self2.s.options);
        } catch (error4) {
          return __handleError(self2, error4);
        }
        var filter = {files_id: doc2._id};
        if (self2.s.options && self2.s.options.start != null) {
          var skip = Math.floor(self2.s.options.start / doc2.chunkSize);
          if (skip > 0) {
            filter["n"] = {$gte: skip};
          }
        }
        self2.s.cursor = self2.s.chunks.find(filter).sort({n: 1});
        if (self2.s.readPreference) {
          self2.s.cursor.setReadPreference(self2.s.readPreference);
        }
        self2.s.expectedEnd = Math.ceil(doc2.length / doc2.chunkSize);
        self2.s.file = doc2;
        try {
          self2.s.bytesToTrim = handleEndOption(self2, doc2, self2.s.cursor, self2.s.options);
        } catch (error4) {
          return __handleError(self2, error4);
        }
        self2.emit("file", doc2);
      });
    }
    function waitForFile(_this, callback) {
      if (_this.s.file) {
        return callback();
      }
      if (!_this.s.init) {
        init2(_this);
        _this.s.init = true;
      }
      _this.once("file", function() {
        callback();
      });
    }
    function handleStartOption(stream2, doc2, options2) {
      if (options2 && options2.start != null) {
        if (options2.start > doc2.length) {
          throw new Error("Stream start (" + options2.start + ") must not be more than the length of the file (" + doc2.length + ")");
        }
        if (options2.start < 0) {
          throw new Error("Stream start (" + options2.start + ") must not be negative");
        }
        if (options2.end != null && options2.end < options2.start) {
          throw new Error("Stream start (" + options2.start + ") must not be greater than stream end (" + options2.end + ")");
        }
        stream2.s.bytesRead = Math.floor(options2.start / doc2.chunkSize) * doc2.chunkSize;
        stream2.s.expected = Math.floor(options2.start / doc2.chunkSize);
        return options2.start - stream2.s.bytesRead;
      }
    }
    function handleEndOption(stream2, doc2, cursor, options2) {
      if (options2 && options2.end != null) {
        if (options2.end > doc2.length) {
          throw new Error("Stream end (" + options2.end + ") must not be more than the length of the file (" + doc2.length + ")");
        }
        if (options2.start < 0) {
          throw new Error("Stream end (" + options2.end + ") must not be negative");
        }
        var start = options2.start != null ? Math.floor(options2.start / doc2.chunkSize) : 0;
        cursor.limit(Math.ceil(options2.end / doc2.chunkSize) - start);
        stream2.s.expectedEnd = Math.ceil(options2.end / doc2.chunkSize);
        return Math.ceil(options2.end / doc2.chunkSize) * doc2.chunkSize - options2.end;
      }
    }
    function __handleError(_this, error3) {
      _this.emit("error", error3);
    }
  }
});

// node_modules/mongodb/lib/gridfs-stream/upload.js
var require_upload = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/upload.js"(exports2, module2) {
    "use strict";
    var core = require_core();
    var crypto = require("crypto");
    var stream = require("stream");
    var util = require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    var ERROR_NAMESPACE_NOT_FOUND = 26;
    module2.exports = GridFSBucketWriteStream;
    function GridFSBucketWriteStream(bucket, filename, options2) {
      options2 = options2 || {};
      stream.Writable.call(this, options2);
      this.bucket = bucket;
      this.chunks = bucket.s._chunksCollection;
      this.filename = filename;
      this.files = bucket.s._filesCollection;
      this.options = options2;
      this.done = false;
      this.id = options2.id ? options2.id : core.BSON.ObjectId();
      this.chunkSizeBytes = this.options.chunkSizeBytes;
      this.bufToStore = Buffer2.alloc(this.chunkSizeBytes);
      this.length = 0;
      this.md5 = !options2.disableMD5 && crypto.createHash("md5");
      this.n = 0;
      this.pos = 0;
      this.state = {
        streamEnd: false,
        outstandingRequests: 0,
        errored: false,
        aborted: false,
        promiseLibrary: this.bucket.s.promiseLibrary
      };
      if (!this.bucket.s.calledOpenUploadStream) {
        this.bucket.s.calledOpenUploadStream = true;
        var _this = this;
        checkIndexes(this, function() {
          _this.bucket.s.checkedIndexes = true;
          _this.bucket.emit("index");
        });
      }
    }
    util.inherits(GridFSBucketWriteStream, stream.Writable);
    GridFSBucketWriteStream.prototype.write = function(chunk, encoding, callback) {
      var _this = this;
      return waitForIndexes(this, function() {
        return doWrite(_this, chunk, encoding, callback);
      });
    };
    GridFSBucketWriteStream.prototype.abort = function(callback) {
      if (this.state.streamEnd) {
        var error3 = new Error("Cannot abort a stream that has already completed");
        if (typeof callback === "function") {
          return callback(error3);
        }
        return this.state.promiseLibrary.reject(error3);
      }
      if (this.state.aborted) {
        error3 = new Error("Cannot call abort() on a stream twice");
        if (typeof callback === "function") {
          return callback(error3);
        }
        return this.state.promiseLibrary.reject(error3);
      }
      this.state.aborted = true;
      this.chunks.deleteMany({files_id: this.id}, function(error4) {
        if (typeof callback === "function")
          callback(error4);
      });
    };
    GridFSBucketWriteStream.prototype.end = function(chunk, encoding, callback) {
      var _this = this;
      if (typeof chunk === "function") {
        callback = chunk, chunk = null, encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding, encoding = null;
      }
      if (checkAborted(this, callback)) {
        return;
      }
      this.state.streamEnd = true;
      if (callback) {
        this.once("finish", function(result) {
          callback(null, result);
        });
      }
      if (!chunk) {
        waitForIndexes(this, function() {
          writeRemnant(_this);
        });
        return;
      }
      this.write(chunk, encoding, function() {
        writeRemnant(_this);
      });
    };
    function __handleError(_this, error3, callback) {
      if (_this.state.errored) {
        return;
      }
      _this.state.errored = true;
      if (callback) {
        return callback(error3);
      }
      _this.emit("error", error3);
    }
    function createChunkDoc(filesId, n, data) {
      return {
        _id: core.BSON.ObjectId(),
        files_id: filesId,
        n,
        data
      };
    }
    function checkChunksIndex(_this, callback) {
      _this.chunks.listIndexes().toArray(function(error3, indexes) {
        if (error3) {
          if (error3.code === ERROR_NAMESPACE_NOT_FOUND) {
            var index2 = {files_id: 1, n: 1};
            _this.chunks.createIndex(index2, {background: false, unique: true}, function(error4) {
              if (error4) {
                return callback(error4);
              }
              callback();
            });
            return;
          }
          return callback(error3);
        }
        var hasChunksIndex = false;
        indexes.forEach(function(index3) {
          if (index3.key) {
            var keys = Object.keys(index3.key);
            if (keys.length === 2 && index3.key.files_id === 1 && index3.key.n === 1) {
              hasChunksIndex = true;
            }
          }
        });
        if (hasChunksIndex) {
          callback();
        } else {
          index2 = {files_id: 1, n: 1};
          var indexOptions = getWriteOptions(_this);
          indexOptions.background = false;
          indexOptions.unique = true;
          _this.chunks.createIndex(index2, indexOptions, function(error4) {
            if (error4) {
              return callback(error4);
            }
            callback();
          });
        }
      });
    }
    function checkDone(_this, callback) {
      if (_this.done)
        return true;
      if (_this.state.streamEnd && _this.state.outstandingRequests === 0 && !_this.state.errored) {
        _this.done = true;
        var filesDoc = createFilesDoc(_this.id, _this.length, _this.chunkSizeBytes, _this.md5 && _this.md5.digest("hex"), _this.filename, _this.options.contentType, _this.options.aliases, _this.options.metadata);
        if (checkAborted(_this, callback)) {
          return false;
        }
        _this.files.insertOne(filesDoc, getWriteOptions(_this), function(error3) {
          if (error3) {
            return __handleError(_this, error3, callback);
          }
          _this.emit("finish", filesDoc);
          _this.emit("close");
        });
        return true;
      }
      return false;
    }
    function checkIndexes(_this, callback) {
      _this.files.findOne({}, {_id: 1}, function(error3, doc2) {
        if (error3) {
          return callback(error3);
        }
        if (doc2) {
          return callback();
        }
        _this.files.listIndexes().toArray(function(error4, indexes) {
          if (error4) {
            if (error4.code === ERROR_NAMESPACE_NOT_FOUND) {
              var index2 = {filename: 1, uploadDate: 1};
              _this.files.createIndex(index2, {background: false}, function(error5) {
                if (error5) {
                  return callback(error5);
                }
                checkChunksIndex(_this, callback);
              });
              return;
            }
            return callback(error4);
          }
          var hasFileIndex = false;
          indexes.forEach(function(index3) {
            var keys = Object.keys(index3.key);
            if (keys.length === 2 && index3.key.filename === 1 && index3.key.uploadDate === 1) {
              hasFileIndex = true;
            }
          });
          if (hasFileIndex) {
            checkChunksIndex(_this, callback);
          } else {
            index2 = {filename: 1, uploadDate: 1};
            var indexOptions = getWriteOptions(_this);
            indexOptions.background = false;
            _this.files.createIndex(index2, indexOptions, function(error5) {
              if (error5) {
                return callback(error5);
              }
              checkChunksIndex(_this, callback);
            });
          }
        });
      });
    }
    function createFilesDoc(_id, length, chunkSize, md5, filename, contentType, aliases, metadata) {
      var ret = {
        _id,
        length,
        chunkSize,
        uploadDate: new Date(),
        filename
      };
      if (md5) {
        ret.md5 = md5;
      }
      if (contentType) {
        ret.contentType = contentType;
      }
      if (aliases) {
        ret.aliases = aliases;
      }
      if (metadata) {
        ret.metadata = metadata;
      }
      return ret;
    }
    function doWrite(_this, chunk, encoding, callback) {
      if (checkAborted(_this, callback)) {
        return false;
      }
      var inputBuf = Buffer2.isBuffer(chunk) ? chunk : Buffer2.from(chunk, encoding);
      _this.length += inputBuf.length;
      if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {
        inputBuf.copy(_this.bufToStore, _this.pos);
        _this.pos += inputBuf.length;
        callback && callback();
        return true;
      }
      var inputBufRemaining = inputBuf.length;
      var spaceRemaining = _this.chunkSizeBytes - _this.pos;
      var numToCopy = Math.min(spaceRemaining, inputBuf.length);
      var outstandingRequests = 0;
      while (inputBufRemaining > 0) {
        var inputBufPos = inputBuf.length - inputBufRemaining;
        inputBuf.copy(_this.bufToStore, _this.pos, inputBufPos, inputBufPos + numToCopy);
        _this.pos += numToCopy;
        spaceRemaining -= numToCopy;
        if (spaceRemaining === 0) {
          if (_this.md5) {
            _this.md5.update(_this.bufToStore);
          }
          var doc2 = createChunkDoc(_this.id, _this.n, Buffer2.from(_this.bufToStore));
          ++_this.state.outstandingRequests;
          ++outstandingRequests;
          if (checkAborted(_this, callback)) {
            return false;
          }
          _this.chunks.insertOne(doc2, getWriteOptions(_this), function(error3) {
            if (error3) {
              return __handleError(_this, error3);
            }
            --_this.state.outstandingRequests;
            --outstandingRequests;
            if (!outstandingRequests) {
              _this.emit("drain", doc2);
              callback && callback();
              checkDone(_this);
            }
          });
          spaceRemaining = _this.chunkSizeBytes;
          _this.pos = 0;
          ++_this.n;
        }
        inputBufRemaining -= numToCopy;
        numToCopy = Math.min(spaceRemaining, inputBufRemaining);
      }
      return false;
    }
    function getWriteOptions(_this) {
      var obj = {};
      if (_this.options.writeConcern) {
        obj.w = _this.options.writeConcern.w;
        obj.wtimeout = _this.options.writeConcern.wtimeout;
        obj.j = _this.options.writeConcern.j;
      }
      return obj;
    }
    function waitForIndexes(_this, callback) {
      if (_this.bucket.s.checkedIndexes) {
        return callback(false);
      }
      _this.bucket.once("index", function() {
        callback(true);
      });
      return true;
    }
    function writeRemnant(_this, callback) {
      if (_this.pos === 0) {
        return checkDone(_this, callback);
      }
      ++_this.state.outstandingRequests;
      var remnant = Buffer2.alloc(_this.pos);
      _this.bufToStore.copy(remnant, 0, 0, _this.pos);
      if (_this.md5) {
        _this.md5.update(remnant);
      }
      var doc2 = createChunkDoc(_this.id, _this.n, remnant);
      if (checkAborted(_this, callback)) {
        return false;
      }
      _this.chunks.insertOne(doc2, getWriteOptions(_this), function(error3) {
        if (error3) {
          return __handleError(_this, error3);
        }
        --_this.state.outstandingRequests;
        checkDone(_this);
      });
    }
    function checkAborted(_this, callback) {
      if (_this.state.aborted) {
        if (typeof callback === "function") {
          callback(new Error("this stream has been aborted"));
        }
        return true;
      }
      return false;
    }
  }
});

// node_modules/mongodb/lib/gridfs-stream/index.js
var require_gridfs_stream = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/index.js"(exports2, module2) {
    "use strict";
    var Emitter = require("events").EventEmitter;
    var GridFSBucketReadStream = require_download();
    var GridFSBucketWriteStream = require_upload();
    var shallowClone = require_utils4().shallowClone;
    var toError = require_utils4().toError;
    var util = require("util");
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
      bucketName: "fs",
      chunkSizeBytes: 255 * 1024
    };
    module2.exports = GridFSBucket;
    function GridFSBucket(db, options2) {
      Emitter.apply(this);
      this.setMaxListeners(0);
      if (options2 && typeof options2 === "object") {
        options2 = shallowClone(options2);
        var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);
        for (var i = 0; i < keys.length; ++i) {
          if (!options2[keys[i]]) {
            options2[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];
          }
        }
      } else {
        options2 = DEFAULT_GRIDFS_BUCKET_OPTIONS;
      }
      this.s = {
        db,
        options: options2,
        _chunksCollection: db.collection(options2.bucketName + ".chunks"),
        _filesCollection: db.collection(options2.bucketName + ".files"),
        checkedIndexes: false,
        calledOpenUploadStream: false,
        promiseLibrary: db.s.promiseLibrary || Promise
      };
    }
    util.inherits(GridFSBucket, Emitter);
    GridFSBucket.prototype.openUploadStream = function(filename, options2) {
      if (options2) {
        options2 = shallowClone(options2);
      } else {
        options2 = {};
      }
      if (!options2.chunkSizeBytes) {
        options2.chunkSizeBytes = this.s.options.chunkSizeBytes;
      }
      return new GridFSBucketWriteStream(this, filename, options2);
    };
    GridFSBucket.prototype.openUploadStreamWithId = function(id, filename, options2) {
      if (options2) {
        options2 = shallowClone(options2);
      } else {
        options2 = {};
      }
      if (!options2.chunkSizeBytes) {
        options2.chunkSizeBytes = this.s.options.chunkSizeBytes;
      }
      options2.id = id;
      return new GridFSBucketWriteStream(this, filename, options2);
    };
    GridFSBucket.prototype.openDownloadStream = function(id, options2) {
      var filter = {_id: id};
      options2 = {
        start: options2 && options2.start,
        end: options2 && options2.end
      };
      return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options2);
    };
    GridFSBucket.prototype.delete = function(id, callback) {
      return executeLegacyOperation(this.s.db.s.topology, _delete, [this, id, callback], {
        skipSessions: true
      });
    };
    function _delete(_this, id, callback) {
      _this.s._filesCollection.deleteOne({_id: id}, function(error3, res) {
        if (error3) {
          return callback(error3);
        }
        _this.s._chunksCollection.deleteMany({files_id: id}, function(error4) {
          if (error4) {
            return callback(error4);
          }
          if (!res.result.n) {
            var errmsg = "FileNotFound: no file with id " + id + " found";
            return callback(new Error(errmsg));
          }
          callback();
        });
      });
    }
    GridFSBucket.prototype.find = function(filter, options2) {
      filter = filter || {};
      options2 = options2 || {};
      var cursor = this.s._filesCollection.find(filter);
      if (options2.batchSize != null) {
        cursor.batchSize(options2.batchSize);
      }
      if (options2.limit != null) {
        cursor.limit(options2.limit);
      }
      if (options2.maxTimeMS != null) {
        cursor.maxTimeMS(options2.maxTimeMS);
      }
      if (options2.noCursorTimeout != null) {
        cursor.addCursorFlag("noCursorTimeout", options2.noCursorTimeout);
      }
      if (options2.skip != null) {
        cursor.skip(options2.skip);
      }
      if (options2.sort != null) {
        cursor.sort(options2.sort);
      }
      return cursor;
    };
    GridFSBucket.prototype.openDownloadStreamByName = function(filename, options2) {
      var sort = {uploadDate: -1};
      var skip = null;
      if (options2 && options2.revision != null) {
        if (options2.revision >= 0) {
          sort = {uploadDate: 1};
          skip = options2.revision;
        } else {
          skip = -options2.revision - 1;
        }
      }
      var filter = {filename};
      options2 = {
        sort,
        skip,
        start: options2 && options2.start,
        end: options2 && options2.end
      };
      return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options2);
    };
    GridFSBucket.prototype.rename = function(id, filename, callback) {
      return executeLegacyOperation(this.s.db.s.topology, _rename, [this, id, filename, callback], {
        skipSessions: true
      });
    };
    function _rename(_this, id, filename, callback) {
      var filter = {_id: id};
      var update = {$set: {filename}};
      _this.s._filesCollection.updateOne(filter, update, function(error3, res) {
        if (error3) {
          return callback(error3);
        }
        if (!res.result.n) {
          return callback(toError("File with id " + id + " not found"));
        }
        callback();
      });
    }
    GridFSBucket.prototype.drop = function(callback) {
      return executeLegacyOperation(this.s.db.s.topology, _drop, [this, callback], {
        skipSessions: true
      });
    };
    GridFSBucket.prototype.getLogger = function() {
      return this.s.db.s.logger;
    };
    function _drop(_this, callback) {
      _this.s._filesCollection.drop(function(error3) {
        if (error3) {
          return callback(error3);
        }
        _this.s._chunksCollection.drop(function(error4) {
          if (error4) {
            return callback(error4);
          }
          return callback();
        });
      });
    }
  }
});

// node_modules/mongodb/index.js
var require_mongodb = __commonJS({
  "node_modules/mongodb/index.js"(exports2, module2) {
    "use strict";
    var core = require_core();
    var Instrumentation = require_apm2();
    var connect = require_mongo_client().connect;
    connect.MongoError = core.MongoError;
    connect.MongoNetworkError = core.MongoNetworkError;
    connect.MongoTimeoutError = core.MongoTimeoutError;
    connect.MongoServerSelectionError = core.MongoServerSelectionError;
    connect.MongoParseError = core.MongoParseError;
    connect.MongoWriteConcernError = core.MongoWriteConcernError;
    connect.MongoBulkWriteError = require_common2().BulkWriteError;
    connect.BulkWriteError = connect.MongoBulkWriteError;
    connect.Admin = require_admin();
    connect.MongoClient = require_mongo_client();
    connect.Db = require_db();
    connect.Collection = require_collection();
    connect.Server = require_server3();
    connect.ReplSet = require_replset2();
    connect.Mongos = require_mongos2();
    connect.ReadPreference = core.ReadPreference;
    connect.GridStore = require_grid_store();
    connect.Chunk = require_chunk();
    connect.Logger = core.Logger;
    connect.AggregationCursor = require_aggregation_cursor();
    connect.CommandCursor = require_command_cursor();
    connect.Cursor = require_cursor2();
    connect.GridFSBucket = require_gridfs_stream();
    connect.CoreServer = core.Server;
    connect.CoreConnection = core.Connection;
    connect.Binary = core.BSON.Binary;
    connect.Code = core.BSON.Code;
    connect.Map = core.BSON.Map;
    connect.DBRef = core.BSON.DBRef;
    connect.Double = core.BSON.Double;
    connect.Int32 = core.BSON.Int32;
    connect.Long = core.BSON.Long;
    connect.MinKey = core.BSON.MinKey;
    connect.MaxKey = core.BSON.MaxKey;
    connect.ObjectID = core.BSON.ObjectID;
    connect.ObjectId = core.BSON.ObjectID;
    connect.Symbol = core.BSON.Symbol;
    connect.Timestamp = core.BSON.Timestamp;
    connect.BSONRegExp = core.BSON.BSONRegExp;
    connect.Decimal128 = core.BSON.Decimal128;
    connect.connect = connect;
    connect.instrument = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      const instrumentation = new Instrumentation();
      instrumentation.instrument(connect.MongoClient, callback);
      return instrumentation;
    };
    module2.exports = connect;
  }
});

// node_modules/chart.js/dist/chart.js
var require_chart = __commonJS({
  "node_modules/chart.js/dist/chart.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Chart = factory());
    })(exports2, function() {
      "use strict";
      function fontString(pixelSize, fontStyle, fontFamily) {
        return fontStyle + " " + pixelSize + "px " + fontFamily;
      }
      const requestAnimFrame = function() {
        if (typeof window === "undefined") {
          return function(callback2) {
            return callback2();
          };
        }
        return window.requestAnimationFrame;
      }();
      function throttled(fn, thisArg, updateFn) {
        const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
        let ticking = false;
        let args = [];
        return function(...rest) {
          args = updateArgs(rest);
          if (!ticking) {
            ticking = true;
            requestAnimFrame.call(window, () => {
              ticking = false;
              fn.apply(thisArg, args);
            });
          }
        };
      }
      function debounce(fn, delay) {
        let timeout;
        return function() {
          if (delay) {
            clearTimeout(timeout);
            timeout = setTimeout(fn, delay);
          } else {
            fn();
          }
          return delay;
        };
      }
      const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
      const _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
      const _textX = (align, left, right) => align === "right" ? right : align === "center" ? (left + right) / 2 : left;
      class Animator {
        constructor() {
          this._request = null;
          this._charts = new Map();
          this._running = false;
          this._lastDate = void 0;
        }
        _notify(chart, anims, date, type) {
          const callbacks = anims.listeners[type];
          const numSteps = anims.duration;
          callbacks.forEach((fn) => fn({
            chart,
            initial: anims.initial,
            numSteps,
            currentStep: Math.min(date - anims.start, numSteps)
          }));
        }
        _refresh() {
          const me = this;
          if (me._request) {
            return;
          }
          me._running = true;
          me._request = requestAnimFrame.call(window, () => {
            me._update();
            me._request = null;
            if (me._running) {
              me._refresh();
            }
          });
        }
        _update(date = Date.now()) {
          const me = this;
          let remaining = 0;
          me._charts.forEach((anims, chart) => {
            if (!anims.running || !anims.items.length) {
              return;
            }
            const items = anims.items;
            let i = items.length - 1;
            let draw2 = false;
            let item;
            for (; i >= 0; --i) {
              item = items[i];
              if (item._active) {
                if (item._total > anims.duration) {
                  anims.duration = item._total;
                }
                item.tick(date);
                draw2 = true;
              } else {
                items[i] = items[items.length - 1];
                items.pop();
              }
            }
            if (draw2) {
              chart.draw();
              me._notify(chart, anims, date, "progress");
            }
            if (!items.length) {
              anims.running = false;
              me._notify(chart, anims, date, "complete");
              anims.initial = false;
            }
            remaining += items.length;
          });
          me._lastDate = date;
          if (remaining === 0) {
            me._running = false;
          }
        }
        _getAnims(chart) {
          const charts = this._charts;
          let anims = charts.get(chart);
          if (!anims) {
            anims = {
              running: false,
              initial: true,
              items: [],
              listeners: {
                complete: [],
                progress: []
              }
            };
            charts.set(chart, anims);
          }
          return anims;
        }
        listen(chart, event, cb) {
          this._getAnims(chart).listeners[event].push(cb);
        }
        add(chart, items) {
          if (!items || !items.length) {
            return;
          }
          this._getAnims(chart).items.push(...items);
        }
        has(chart) {
          return this._getAnims(chart).items.length > 0;
        }
        start(chart) {
          const anims = this._charts.get(chart);
          if (!anims) {
            return;
          }
          anims.running = true;
          anims.start = Date.now();
          anims.duration = anims.items.reduce((acc, cur2) => Math.max(acc, cur2._duration), 0);
          this._refresh();
        }
        running(chart) {
          if (!this._running) {
            return false;
          }
          const anims = this._charts.get(chart);
          if (!anims || !anims.running || !anims.items.length) {
            return false;
          }
          return true;
        }
        stop(chart) {
          const anims = this._charts.get(chart);
          if (!anims || !anims.items.length) {
            return;
          }
          const items = anims.items;
          let i = items.length - 1;
          for (; i >= 0; --i) {
            items[i].cancel();
          }
          anims.items = [];
          this._notify(chart, anims, Date.now(), "complete");
        }
        remove(chart) {
          return this._charts.delete(chart);
        }
      }
      var animator = new Animator();
      const map = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
      const hex = "0123456789ABCDEF";
      const h1 = (b) => hex[b & 15];
      const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
      const eq = (b) => (b & 240) >> 4 === (b & 15);
      function isShort(v) {
        return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
      }
      function hexParse(str) {
        var len = str.length;
        var ret;
        if (str[0] === "#") {
          if (len === 4 || len === 5) {
            ret = {
              r: 255 & map[str[1]] * 17,
              g: 255 & map[str[2]] * 17,
              b: 255 & map[str[3]] * 17,
              a: len === 5 ? map[str[4]] * 17 : 255
            };
          } else if (len === 7 || len === 9) {
            ret = {
              r: map[str[1]] << 4 | map[str[2]],
              g: map[str[3]] << 4 | map[str[4]],
              b: map[str[5]] << 4 | map[str[6]],
              a: len === 9 ? map[str[7]] << 4 | map[str[8]] : 255
            };
          }
        }
        return ret;
      }
      function hexString(v) {
        var f = isShort(v) ? h1 : h2;
        return v ? "#" + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : "") : v;
      }
      function round(v) {
        return v + 0.5 | 0;
      }
      const lim = (v, l, h) => Math.max(Math.min(v, h), l);
      function p2b(v) {
        return lim(round(v * 2.55), 0, 255);
      }
      function n2b(v) {
        return lim(round(v * 255), 0, 255);
      }
      function b2n(v) {
        return lim(round(v / 2.55) / 100, 0, 1);
      }
      function n2p(v) {
        return lim(round(v * 100), 0, 100);
      }
      const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
      function rgbParse(str) {
        const m = RGB_RE.exec(str);
        let a = 255;
        let r, g, b;
        if (!m) {
          return;
        }
        if (m[7] !== r) {
          const v = +m[7];
          a = 255 & (m[8] ? p2b(v) : v * 255);
        }
        r = +m[1];
        g = +m[3];
        b = +m[5];
        r = 255 & (m[2] ? p2b(r) : r);
        g = 255 & (m[4] ? p2b(g) : g);
        b = 255 & (m[6] ? p2b(b) : b);
        return {
          r,
          g,
          b,
          a
        };
      }
      function rgbString(v) {
        return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
      }
      const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
      function hsl2rgbn(h, s2, l) {
        const a = s2 * Math.min(l, 1 - l);
        const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return [f(0), f(8), f(4)];
      }
      function hsv2rgbn(h, s2, v) {
        const f = (n, k = (n + h / 60) % 6) => v - v * s2 * Math.max(Math.min(k, 4 - k, 1), 0);
        return [f(5), f(3), f(1)];
      }
      function hwb2rgbn(h, w, b) {
        const rgb = hsl2rgbn(h, 1, 0.5);
        let i;
        if (w + b > 1) {
          i = 1 / (w + b);
          w *= i;
          b *= i;
        }
        for (i = 0; i < 3; i++) {
          rgb[i] *= 1 - w - b;
          rgb[i] += w;
        }
        return rgb;
      }
      function rgb2hsl(v) {
        const range = 255;
        const r = v.r / range;
        const g = v.g / range;
        const b = v.b / range;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const l = (max + min) / 2;
        let h, s2, d;
        if (max !== min) {
          d = max - min;
          s2 = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
          h = h * 60 + 0.5;
        }
        return [h | 0, s2 || 0, l];
      }
      function calln(f, a, b, c) {
        return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
      }
      function hsl2rgb(h, s2, l) {
        return calln(hsl2rgbn, h, s2, l);
      }
      function hwb2rgb(h, w, b) {
        return calln(hwb2rgbn, h, w, b);
      }
      function hsv2rgb(h, s2, v) {
        return calln(hsv2rgbn, h, s2, v);
      }
      function hue(h) {
        return (h % 360 + 360) % 360;
      }
      function hueParse(str) {
        const m = HUE_RE.exec(str);
        let a = 255;
        let v;
        if (!m) {
          return;
        }
        if (m[5] !== v) {
          a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
        }
        const h = hue(+m[2]);
        const p1 = +m[3] / 100;
        const p2 = +m[4] / 100;
        if (m[1] === "hwb") {
          v = hwb2rgb(h, p1, p2);
        } else if (m[1] === "hsv") {
          v = hsv2rgb(h, p1, p2);
        } else {
          v = hsl2rgb(h, p1, p2);
        }
        return {
          r: v[0],
          g: v[1],
          b: v[2],
          a
        };
      }
      function rotate(v, deg) {
        var h = rgb2hsl(v);
        h[0] = hue(h[0] + deg);
        h = hsl2rgb(h);
        v.r = h[0];
        v.g = h[1];
        v.b = h[2];
      }
      function hslString(v) {
        if (!v) {
          return;
        }
        const a = rgb2hsl(v);
        const h = a[0];
        const s2 = n2p(a[1]);
        const l = n2p(a[2]);
        return v.a < 255 ? `hsla(${h}, ${s2}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s2}%, ${l}%)`;
      }
      const map$1 = {
        x: "dark",
        Z: "light",
        Y: "re",
        X: "blu",
        W: "gr",
        V: "medium",
        U: "slate",
        A: "ee",
        T: "ol",
        S: "or",
        B: "ra",
        C: "lateg",
        D: "ights",
        R: "in",
        Q: "turquois",
        E: "hi",
        P: "ro",
        O: "al",
        N: "le",
        M: "de",
        L: "yello",
        F: "en",
        K: "ch",
        G: "arks",
        H: "ea",
        I: "ightg",
        J: "wh"
      };
      const names = {
        OiceXe: "f0f8ff",
        antiquewEte: "faebd7",
        aqua: "ffff",
        aquamarRe: "7fffd4",
        azuY: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "0",
        blanKedOmond: "ffebcd",
        Xe: "ff",
        XeviTet: "8a2be2",
        bPwn: "a52a2a",
        burlywood: "deb887",
        caMtXe: "5f9ea0",
        KartYuse: "7fff00",
        KocTate: "d2691e",
        cSO: "ff7f50",
        cSnflowerXe: "6495ed",
        cSnsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "ffff",
        xXe: "8b",
        xcyan: "8b8b",
        xgTMnPd: "b8860b",
        xWay: "a9a9a9",
        xgYF: "6400",
        xgYy: "a9a9a9",
        xkhaki: "bdb76b",
        xmagFta: "8b008b",
        xTivegYF: "556b2f",
        xSange: "ff8c00",
        xScEd: "9932cc",
        xYd: "8b0000",
        xsOmon: "e9967a",
        xsHgYF: "8fbc8f",
        xUXe: "483d8b",
        xUWay: "2f4f4f",
        xUgYy: "2f4f4f",
        xQe: "ced1",
        xviTet: "9400d3",
        dAppRk: "ff1493",
        dApskyXe: "bfff",
        dimWay: "696969",
        dimgYy: "696969",
        dodgerXe: "1e90ff",
        fiYbrick: "b22222",
        flSOwEte: "fffaf0",
        foYstWAn: "228b22",
        fuKsia: "ff00ff",
        gaRsbSo: "dcdcdc",
        ghostwEte: "f8f8ff",
        gTd: "ffd700",
        gTMnPd: "daa520",
        Way: "808080",
        gYF: "8000",
        gYFLw: "adff2f",
        gYy: "808080",
        honeyMw: "f0fff0",
        hotpRk: "ff69b4",
        RdianYd: "cd5c5c",
        Rdigo: "4b0082",
        ivSy: "fffff0",
        khaki: "f0e68c",
        lavFMr: "e6e6fa",
        lavFMrXsh: "fff0f5",
        lawngYF: "7cfc00",
        NmoncEffon: "fffacd",
        ZXe: "add8e6",
        ZcSO: "f08080",
        Zcyan: "e0ffff",
        ZgTMnPdLw: "fafad2",
        ZWay: "d3d3d3",
        ZgYF: "90ee90",
        ZgYy: "d3d3d3",
        ZpRk: "ffb6c1",
        ZsOmon: "ffa07a",
        ZsHgYF: "20b2aa",
        ZskyXe: "87cefa",
        ZUWay: "778899",
        ZUgYy: "778899",
        ZstAlXe: "b0c4de",
        ZLw: "ffffe0",
        lime: "ff00",
        limegYF: "32cd32",
        lRF: "faf0e6",
        magFta: "ff00ff",
        maPon: "800000",
        VaquamarRe: "66cdaa",
        VXe: "cd",
        VScEd: "ba55d3",
        VpurpN: "9370db",
        VsHgYF: "3cb371",
        VUXe: "7b68ee",
        VsprRggYF: "fa9a",
        VQe: "48d1cc",
        VviTetYd: "c71585",
        midnightXe: "191970",
        mRtcYam: "f5fffa",
        mistyPse: "ffe4e1",
        moccasR: "ffe4b5",
        navajowEte: "ffdead",
        navy: "80",
        Tdlace: "fdf5e6",
        Tive: "808000",
        TivedBb: "6b8e23",
        Sange: "ffa500",
        SangeYd: "ff4500",
        ScEd: "da70d6",
        pOegTMnPd: "eee8aa",
        pOegYF: "98fb98",
        pOeQe: "afeeee",
        pOeviTetYd: "db7093",
        papayawEp: "ffefd5",
        pHKpuff: "ffdab9",
        peru: "cd853f",
        pRk: "ffc0cb",
        plum: "dda0dd",
        powMrXe: "b0e0e6",
        purpN: "800080",
        YbeccapurpN: "663399",
        Yd: "ff0000",
        Psybrown: "bc8f8f",
        PyOXe: "4169e1",
        saddNbPwn: "8b4513",
        sOmon: "fa8072",
        sandybPwn: "f4a460",
        sHgYF: "2e8b57",
        sHshell: "fff5ee",
        siFna: "a0522d",
        silver: "c0c0c0",
        skyXe: "87ceeb",
        UXe: "6a5acd",
        UWay: "708090",
        UgYy: "708090",
        snow: "fffafa",
        sprRggYF: "ff7f",
        stAlXe: "4682b4",
        tan: "d2b48c",
        teO: "8080",
        tEstN: "d8bfd8",
        tomato: "ff6347",
        Qe: "40e0d0",
        viTet: "ee82ee",
        JHt: "f5deb3",
        wEte: "ffffff",
        wEtesmoke: "f5f5f5",
        Lw: "ffff00",
        LwgYF: "9acd32"
      };
      function unpack() {
        const unpacked = {};
        const keys = Object.keys(names);
        const tkeys = Object.keys(map$1);
        let i, j, k, ok2, nk;
        for (i = 0; i < keys.length; i++) {
          ok2 = nk = keys[i];
          for (j = 0; j < tkeys.length; j++) {
            k = tkeys[j];
            nk = nk.replace(k, map$1[k]);
          }
          k = parseInt(names[ok2], 16);
          unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
        }
        return unpacked;
      }
      let names$1;
      function nameParse(str) {
        if (!names$1) {
          names$1 = unpack();
          names$1.transparent = [0, 0, 0, 0];
        }
        const a = names$1[str.toLowerCase()];
        return a && {
          r: a[0],
          g: a[1],
          b: a[2],
          a: a.length === 4 ? a[3] : 255
        };
      }
      function modHSL(v, i, ratio) {
        if (v) {
          let tmp = rgb2hsl(v);
          tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
          tmp = hsl2rgb(tmp);
          v.r = tmp[0];
          v.g = tmp[1];
          v.b = tmp[2];
        }
      }
      function clone$1(v, proto) {
        return v ? Object.assign(proto || {}, v) : v;
      }
      function fromObject(input) {
        var v = {r: 0, g: 0, b: 0, a: 255};
        if (Array.isArray(input)) {
          if (input.length >= 3) {
            v = {r: input[0], g: input[1], b: input[2], a: 255};
            if (input.length > 3) {
              v.a = n2b(input[3]);
            }
          }
        } else {
          v = clone$1(input, {r: 0, g: 0, b: 0, a: 1});
          v.a = n2b(v.a);
        }
        return v;
      }
      function functionParse(str) {
        if (str.charAt(0) === "r") {
          return rgbParse(str);
        }
        return hueParse(str);
      }
      class Color {
        constructor(input) {
          if (input instanceof Color) {
            return input;
          }
          const type = typeof input;
          let v;
          if (type === "object") {
            v = fromObject(input);
          } else if (type === "string") {
            v = hexParse(input) || nameParse(input) || functionParse(input);
          }
          this._rgb = v;
          this._valid = !!v;
        }
        get valid() {
          return this._valid;
        }
        get rgb() {
          var v = clone$1(this._rgb);
          if (v) {
            v.a = b2n(v.a);
          }
          return v;
        }
        set rgb(obj) {
          this._rgb = fromObject(obj);
        }
        rgbString() {
          return this._valid ? rgbString(this._rgb) : this._rgb;
        }
        hexString() {
          return this._valid ? hexString(this._rgb) : this._rgb;
        }
        hslString() {
          return this._valid ? hslString(this._rgb) : this._rgb;
        }
        mix(color2, weight) {
          const me = this;
          if (color2) {
            const c1 = me.rgb;
            const c2 = color2.rgb;
            let w2;
            const p = weight === w2 ? 0.5 : weight;
            const w = 2 * p - 1;
            const a = c1.a - c2.a;
            const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
            w2 = 1 - w1;
            c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
            c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
            c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
            c1.a = p * c1.a + (1 - p) * c2.a;
            me.rgb = c1;
          }
          return me;
        }
        clone() {
          return new Color(this.rgb);
        }
        alpha(a) {
          this._rgb.a = n2b(a);
          return this;
        }
        clearer(ratio) {
          const rgb = this._rgb;
          rgb.a *= 1 - ratio;
          return this;
        }
        greyscale() {
          const rgb = this._rgb;
          const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
          rgb.r = rgb.g = rgb.b = val;
          return this;
        }
        opaquer(ratio) {
          const rgb = this._rgb;
          rgb.a *= 1 + ratio;
          return this;
        }
        negate() {
          const v = this._rgb;
          v.r = 255 - v.r;
          v.g = 255 - v.g;
          v.b = 255 - v.b;
          return this;
        }
        lighten(ratio) {
          modHSL(this._rgb, 2, ratio);
          return this;
        }
        darken(ratio) {
          modHSL(this._rgb, 2, -ratio);
          return this;
        }
        saturate(ratio) {
          modHSL(this._rgb, 1, ratio);
          return this;
        }
        desaturate(ratio) {
          modHSL(this._rgb, 1, -ratio);
          return this;
        }
        rotate(deg) {
          rotate(this._rgb, deg);
          return this;
        }
      }
      function index_esm(input) {
        return new Color(input);
      }
      const isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;
      function color(value) {
        return isPatternOrGradient(value) ? value : index_esm(value);
      }
      function getHoverColor(value) {
        return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
      }
      function noop3() {
      }
      const uid = function() {
        let id = 0;
        return function() {
          return id++;
        };
      }();
      function isNullOrUndef(value) {
        return value === null || typeof value === "undefined";
      }
      function isArray(value) {
        if (Array.isArray && Array.isArray(value)) {
          return true;
        }
        const type = Object.prototype.toString.call(value);
        if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
          return true;
        }
        return false;
      }
      function isObject(value) {
        return value !== null && Object.prototype.toString.call(value) === "[object Object]";
      }
      const isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
      function finiteOrDefault(value, defaultValue) {
        return isNumberFinite(value) ? value : defaultValue;
      }
      function valueOrDefault(value, defaultValue) {
        return typeof value === "undefined" ? defaultValue : value;
      }
      const toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
      const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
      function callback(fn, args, thisArg) {
        if (fn && typeof fn.call === "function") {
          return fn.apply(thisArg, args);
        }
      }
      function each2(loopable, fn, thisArg, reverse) {
        let i, len, keys;
        if (isArray(loopable)) {
          len = loopable.length;
          if (reverse) {
            for (i = len - 1; i >= 0; i--) {
              fn.call(thisArg, loopable[i], i);
            }
          } else {
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[i], i);
            }
          }
        } else if (isObject(loopable)) {
          keys = Object.keys(loopable);
          len = keys.length;
          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[keys[i]], keys[i]);
          }
        }
      }
      function _elementsEqual(a0, a1) {
        let i, ilen, v0, v1;
        if (!a0 || !a1 || a0.length !== a1.length) {
          return false;
        }
        for (i = 0, ilen = a0.length; i < ilen; ++i) {
          v0 = a0[i];
          v1 = a1[i];
          if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
            return false;
          }
        }
        return true;
      }
      function clone2(source) {
        if (isArray(source)) {
          return source.map(clone2);
        }
        if (isObject(source)) {
          const target = Object.create(null);
          const keys = Object.keys(source);
          const klen = keys.length;
          let k = 0;
          for (; k < klen; ++k) {
            target[keys[k]] = clone2(source[keys[k]]);
          }
          return target;
        }
        return source;
      }
      function isValidKey(key) {
        return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
      }
      function _merger(key, target, source, options2) {
        if (!isValidKey(key)) {
          return;
        }
        const tval = target[key];
        const sval = source[key];
        if (isObject(tval) && isObject(sval)) {
          merge(tval, sval, options2);
        } else {
          target[key] = clone2(sval);
        }
      }
      function merge(target, source, options2) {
        const sources = isArray(source) ? source : [source];
        const ilen = sources.length;
        if (!isObject(target)) {
          return target;
        }
        options2 = options2 || {};
        const merger = options2.merger || _merger;
        for (let i = 0; i < ilen; ++i) {
          source = sources[i];
          if (!isObject(source)) {
            continue;
          }
          const keys = Object.keys(source);
          for (let k = 0, klen = keys.length; k < klen; ++k) {
            merger(keys[k], target, source, options2);
          }
        }
        return target;
      }
      function mergeIf(target, source) {
        return merge(target, source, {merger: _mergerIf});
      }
      function _mergerIf(key, target, source) {
        if (!isValidKey(key)) {
          return;
        }
        const tval = target[key];
        const sval = source[key];
        if (isObject(tval) && isObject(sval)) {
          mergeIf(tval, sval);
        } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
          target[key] = clone2(sval);
        }
      }
      function _deprecated(scope, value, previous, current) {
        if (value !== void 0) {
          console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
        }
      }
      const emptyString = "";
      const dot = ".";
      function indexOfDotOrLength(key, start) {
        const idx = key.indexOf(dot, start);
        return idx === -1 ? key.length : idx;
      }
      function resolveObjectKey(obj, key) {
        if (key === emptyString) {
          return obj;
        }
        let pos = 0;
        let idx = indexOfDotOrLength(key, pos);
        while (obj && idx > pos) {
          obj = obj[key.substr(pos, idx - pos)];
          pos = idx + 1;
          idx = indexOfDotOrLength(key, pos);
        }
        return obj;
      }
      function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
      const defined = (value) => typeof value !== "undefined";
      const isFunction = (value) => typeof value === "function";
      const setsEqual = (a, b) => {
        if (a.size !== b.size) {
          return false;
        }
        for (const item of a) {
          if (!b.has(item)) {
            return false;
          }
        }
        return true;
      };
      const overrides = Object.create(null);
      const descriptors = Object.create(null);
      function getScope$1(node, key) {
        if (!key) {
          return node;
        }
        const keys = key.split(".");
        for (let i = 0, n = keys.length; i < n; ++i) {
          const k = keys[i];
          node = node[k] || (node[k] = Object.create(null));
        }
        return node;
      }
      function set(root, scope, values) {
        if (typeof scope === "string") {
          return merge(getScope$1(root, scope), values);
        }
        return merge(getScope$1(root, ""), scope);
      }
      class Defaults {
        constructor(_descriptors2) {
          this.animation = void 0;
          this.backgroundColor = "rgba(0,0,0,0.1)";
          this.borderColor = "rgba(0,0,0,0.1)";
          this.color = "#666";
          this.datasets = {};
          this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
          this.elements = {};
          this.events = [
            "mousemove",
            "mouseout",
            "click",
            "touchstart",
            "touchmove"
          ];
          this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: "normal",
            lineHeight: 1.2,
            weight: null
          };
          this.hover = {};
          this.hoverBackgroundColor = (ctx, options2) => getHoverColor(options2.backgroundColor);
          this.hoverBorderColor = (ctx, options2) => getHoverColor(options2.borderColor);
          this.hoverColor = (ctx, options2) => getHoverColor(options2.color);
          this.indexAxis = "x";
          this.interaction = {
            mode: "nearest",
            intersect: true
          };
          this.maintainAspectRatio = true;
          this.onHover = null;
          this.onClick = null;
          this.parsing = true;
          this.plugins = {};
          this.responsive = true;
          this.scale = void 0;
          this.scales = {};
          this.showLine = true;
          this.describe(_descriptors2);
        }
        set(scope, values) {
          return set(this, scope, values);
        }
        get(scope) {
          return getScope$1(this, scope);
        }
        describe(scope, values) {
          return set(descriptors, scope, values);
        }
        override(scope, values) {
          return set(overrides, scope, values);
        }
        route(scope, name2, targetScope, targetName) {
          const scopeObject = getScope$1(this, scope);
          const targetScopeObject = getScope$1(this, targetScope);
          const privateName = "_" + name2;
          Object.defineProperties(scopeObject, {
            [privateName]: {
              value: scopeObject[name2],
              writable: true
            },
            [name2]: {
              enumerable: true,
              get() {
                const local = this[privateName];
                const target = targetScopeObject[targetName];
                if (isObject(local)) {
                  return Object.assign({}, target, local);
                }
                return valueOrDefault(local, target);
              },
              set(value) {
                this[privateName] = value;
              }
            }
          });
        }
      }
      var defaults3 = new Defaults({
        _scriptable: (name2) => !name2.startsWith("on"),
        _indexable: (name2) => name2 !== "events",
        hover: {
          _fallback: "interaction"
        },
        interaction: {
          _scriptable: false,
          _indexable: false
        }
      });
      const PI = Math.PI;
      const TAU = 2 * PI;
      const PITAU = TAU + PI;
      const INFINITY = Number.POSITIVE_INFINITY;
      const RAD_PER_DEG = PI / 180;
      const HALF_PI = PI / 2;
      const QUARTER_PI = PI / 4;
      const TWO_THIRDS_PI = PI * 2 / 3;
      const log10 = Math.log10;
      const sign = Math.sign;
      function niceNum(range) {
        const niceRange = Math.pow(10, Math.floor(log10(range)));
        const fraction = range / niceRange;
        const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
        return niceFraction * niceRange;
      }
      function _factorize(value) {
        const result = [];
        const sqrt = Math.sqrt(value);
        let i;
        for (i = 1; i < sqrt; i++) {
          if (value % i === 0) {
            result.push(i);
            result.push(value / i);
          }
        }
        if (sqrt === (sqrt | 0)) {
          result.push(sqrt);
        }
        result.sort((a, b) => a - b).pop();
        return result;
      }
      function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      }
      function almostEquals(x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
      }
      function almostWhole(x, epsilon) {
        const rounded = Math.round(x);
        return rounded - epsilon <= x && rounded + epsilon >= x;
      }
      function _setMinAndMaxByKey(array, target, property) {
        let i, ilen, value;
        for (i = 0, ilen = array.length; i < ilen; i++) {
          value = array[i][property];
          if (!isNaN(value)) {
            target.min = Math.min(target.min, value);
            target.max = Math.max(target.max, value);
          }
        }
      }
      function toRadians(degrees) {
        return degrees * (PI / 180);
      }
      function toDegrees(radians) {
        return radians * (180 / PI);
      }
      function _decimalPlaces(x) {
        if (!isNumberFinite(x)) {
          return;
        }
        let e = 1;
        let p = 0;
        while (Math.round(x * e) / e !== x) {
          e *= 10;
          p++;
        }
        return p;
      }
      function getAngleFromPoint(centrePoint, anglePoint) {
        const distanceFromXCenter = anglePoint.x - centrePoint.x;
        const distanceFromYCenter = anglePoint.y - centrePoint.y;
        const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
        if (angle < -0.5 * PI) {
          angle += TAU;
        }
        return {
          angle,
          distance: radialDistanceFromCenter
        };
      }
      function distanceBetweenPoints(pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
      }
      function _angleDiff(a, b) {
        return (a - b + PITAU) % TAU - PI;
      }
      function _normalizeAngle(a) {
        return (a % TAU + TAU) % TAU;
      }
      function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
        const a = _normalizeAngle(angle);
        const s2 = _normalizeAngle(start);
        const e = _normalizeAngle(end);
        const angleToStart = _normalizeAngle(s2 - a);
        const angleToEnd = _normalizeAngle(e - a);
        const startToAngle = _normalizeAngle(a - s2);
        const endToAngle = _normalizeAngle(a - e);
        return a === s2 || a === e || sameAngleIsFullCircle && s2 === e || angleToStart > angleToEnd && startToAngle < endToAngle;
      }
      function _limitValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }
      function _int16Range(value) {
        return _limitValue(value, -32768, 32767);
      }
      function toFontString(font) {
        if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
          return null;
        }
        return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
      }
      function _measureText(ctx, data, gc, longest, string2) {
        let textWidth = data[string2];
        if (!textWidth) {
          textWidth = data[string2] = ctx.measureText(string2).width;
          gc.push(string2);
        }
        if (textWidth > longest) {
          longest = textWidth;
        }
        return longest;
      }
      function _longestText(ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        let data = cache.data = cache.data || {};
        let gc = cache.garbageCollect = cache.garbageCollect || [];
        if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font;
        }
        ctx.save();
        ctx.font = font;
        let longest = 0;
        const ilen = arrayOfThings.length;
        let i, j, jlen, thing, nestedThing;
        for (i = 0; i < ilen; i++) {
          thing = arrayOfThings[i];
          if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
            longest = _measureText(ctx, data, gc, longest, thing);
          } else if (isArray(thing)) {
            for (j = 0, jlen = thing.length; j < jlen; j++) {
              nestedThing = thing[j];
              if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
                longest = _measureText(ctx, data, gc, longest, nestedThing);
              }
            }
          }
        }
        ctx.restore();
        const gcLen = gc.length / 2;
        if (gcLen > arrayOfThings.length) {
          for (i = 0; i < gcLen; i++) {
            delete data[gc[i]];
          }
          gc.splice(0, gcLen);
        }
        return longest;
      }
      function _alignPixel(chart, pixel, width) {
        const devicePixelRatio = chart.currentDevicePixelRatio;
        const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
      }
      function clearCanvas(canvas, ctx) {
        ctx = ctx || canvas.getContext("2d");
        ctx.save();
        ctx.resetTransform();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      }
      function drawPoint(ctx, options2, x, y) {
        let type, xOffset, yOffset, size, cornerRadius;
        const style = options2.pointStyle;
        const rotation = options2.rotation;
        const radius = options2.radius;
        let rad = (rotation || 0) * RAD_PER_DEG;
        if (style && typeof style === "object") {
          type = style.toString();
          if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rad);
            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
            ctx.restore();
            return;
          }
        }
        if (isNaN(radius) || radius <= 0) {
          return;
        }
        ctx.beginPath();
        switch (style) {
          default:
            ctx.arc(x, y, radius, 0, TAU);
            ctx.closePath();
            break;
          case "triangle":
            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;
          case "rectRounded":
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;
          case "rect":
            if (!rotation) {
              size = Math.SQRT1_2 * radius;
              ctx.rect(x - size, y - size, 2 * size, 2 * size);
              break;
            }
            rad += QUARTER_PI;
          case "rectRot":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + yOffset, y - xOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            ctx.closePath();
            break;
          case "crossRot":
            rad += QUARTER_PI;
          case "cross":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;
          case "star":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            rad += QUARTER_PI;
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;
          case "line":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;
          case "dash":
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
            break;
        }
        ctx.fill();
        if (options2.borderWidth > 0) {
          ctx.stroke();
        }
      }
      function _isPointInArea(point, area, margin) {
        margin = margin || 0.5;
        return point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
      }
      function clipArea(ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
        ctx.clip();
      }
      function unclipArea(ctx) {
        ctx.restore();
      }
      function _steppedLineTo(ctx, previous, target, flip, mode) {
        if (!previous) {
          return ctx.lineTo(target.x, target.y);
        }
        if (mode === "middle") {
          const midpoint = (previous.x + target.x) / 2;
          ctx.lineTo(midpoint, previous.y);
          ctx.lineTo(midpoint, target.y);
        } else if (mode === "after" !== !!flip) {
          ctx.lineTo(previous.x, target.y);
        } else {
          ctx.lineTo(target.x, previous.y);
        }
        ctx.lineTo(target.x, target.y);
      }
      function _bezierCurveTo(ctx, previous, target, flip) {
        if (!previous) {
          return ctx.lineTo(target.x, target.y);
        }
        ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
      }
      function renderText(ctx, text, x, y, font, opts = {}) {
        const lines = isArray(text) ? text : [text];
        const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
        let i, line;
        ctx.save();
        if (opts.translation) {
          ctx.translate(opts.translation[0], opts.translation[1]);
        }
        if (!isNullOrUndef(opts.rotation)) {
          ctx.rotate(opts.rotation);
        }
        ctx.font = font.string;
        if (opts.color) {
          ctx.fillStyle = opts.color;
        }
        if (opts.textAlign) {
          ctx.textAlign = opts.textAlign;
        }
        if (opts.textBaseline) {
          ctx.textBaseline = opts.textBaseline;
        }
        for (i = 0; i < lines.length; ++i) {
          line = lines[i];
          if (stroke) {
            if (opts.strokeColor) {
              ctx.strokeStyle = opts.strokeColor;
            }
            if (!isNullOrUndef(opts.strokeWidth)) {
              ctx.lineWidth = opts.strokeWidth;
            }
            ctx.strokeText(line, x, y, opts.maxWidth);
          }
          ctx.fillText(line, x, y, opts.maxWidth);
          if (opts.strikethrough || opts.underline) {
            const metrics = ctx.measureText(line);
            const left = x - metrics.actualBoundingBoxLeft;
            const right = x + metrics.actualBoundingBoxRight;
            const top2 = y - metrics.actualBoundingBoxAscent;
            const bottom = y + metrics.actualBoundingBoxDescent;
            const yDecoration = opts.strikethrough ? (top2 + bottom) / 2 : bottom;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.beginPath();
            ctx.lineWidth = opts.decorationWidth || 2;
            ctx.moveTo(left, yDecoration);
            ctx.lineTo(right, yDecoration);
            ctx.stroke();
          }
          y += font.lineHeight;
        }
        ctx.restore();
      }
      function addRoundedRectPath(ctx, rect) {
        const {x, y, w, h, radius} = rect;
        ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
        ctx.lineTo(x, y + h - radius.bottomLeft);
        ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
        ctx.lineTo(x + w - radius.bottomRight, y + h);
        ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
        ctx.lineTo(x + w, y + radius.topRight);
        ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
        ctx.lineTo(x + radius.topLeft, y);
      }
      function _lookup(table, value, cmp) {
        cmp = cmp || ((index2) => table[index2] < value);
        let hi = table.length - 1;
        let lo = 0;
        let mid;
        while (hi - lo > 1) {
          mid = lo + hi >> 1;
          if (cmp(mid)) {
            lo = mid;
          } else {
            hi = mid;
          }
        }
        return {lo, hi};
      }
      const _lookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] < value);
      const _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
      function _filterBetween(values, min, max) {
        let start = 0;
        let end = values.length;
        while (start < end && values[start] < min) {
          start++;
        }
        while (end > start && values[end - 1] > max) {
          end--;
        }
        return start > 0 || end < values.length ? values.slice(start, end) : values;
      }
      const arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
      function listenArrayEvents(array, listener) {
        if (array._chartjs) {
          array._chartjs.listeners.push(listener);
          return;
        }
        Object.defineProperty(array, "_chartjs", {
          configurable: true,
          enumerable: false,
          value: {
            listeners: [listener]
          }
        });
        arrayEvents.forEach((key) => {
          const method = "_onData" + _capitalize(key);
          const base2 = array[key];
          Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value(...args) {
              const res = base2.apply(this, args);
              array._chartjs.listeners.forEach((object) => {
                if (typeof object[method] === "function") {
                  object[method](...args);
                }
              });
              return res;
            }
          });
        });
      }
      function unlistenArrayEvents(array, listener) {
        const stub = array._chartjs;
        if (!stub) {
          return;
        }
        const listeners = stub.listeners;
        const index2 = listeners.indexOf(listener);
        if (index2 !== -1) {
          listeners.splice(index2, 1);
        }
        if (listeners.length > 0) {
          return;
        }
        arrayEvents.forEach((key) => {
          delete array[key];
        });
        delete array._chartjs;
      }
      function _arrayUnique(items) {
        const set2 = new Set();
        let i, ilen;
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          set2.add(items[i]);
        }
        if (set2.size === ilen) {
          return items;
        }
        const result = [];
        set2.forEach((item) => {
          result.push(item);
        });
        return result;
      }
      function _getParentNode(domNode) {
        let parent = domNode.parentNode;
        if (parent && parent.toString() === "[object ShadowRoot]") {
          parent = parent.host;
        }
        return parent;
      }
      function parseMaxStyle(styleValue, node, parentProperty) {
        let valueInPixels;
        if (typeof styleValue === "string") {
          valueInPixels = parseInt(styleValue, 10);
          if (styleValue.indexOf("%") !== -1) {
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
          }
        } else {
          valueInPixels = styleValue;
        }
        return valueInPixels;
      }
      const getComputedStyle2 = (element) => window.getComputedStyle(element, null);
      function getStyle(el, property) {
        return getComputedStyle2(el).getPropertyValue(property);
      }
      const positions = ["top", "right", "bottom", "left"];
      function getPositionedStyle(styles, style, suffix) {
        const result = {};
        suffix = suffix ? "-" + suffix : "";
        for (let i = 0; i < 4; i++) {
          const pos = positions[i];
          result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
        }
        result.width = result.left + result.right;
        result.height = result.top + result.bottom;
        return result;
      }
      const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
      function getCanvasPosition(evt, canvas) {
        const e = evt.native || evt;
        const touches = e.touches;
        const source = touches && touches.length ? touches[0] : e;
        const {offsetX, offsetY} = source;
        let box = false;
        let x, y;
        if (useOffsetPos(offsetX, offsetY, e.target)) {
          x = offsetX;
          y = offsetY;
        } else {
          const rect = canvas.getBoundingClientRect();
          x = source.clientX - rect.left;
          y = source.clientY - rect.top;
          box = true;
        }
        return {x, y, box};
      }
      function getRelativePosition$1(evt, chart) {
        const {canvas, currentDevicePixelRatio} = chart;
        const style = getComputedStyle2(canvas);
        const borderBox = style.boxSizing === "border-box";
        const paddings = getPositionedStyle(style, "padding");
        const borders = getPositionedStyle(style, "border", "width");
        const {x, y, box} = getCanvasPosition(evt, canvas);
        const xOffset = paddings.left + (box && borders.left);
        const yOffset = paddings.top + (box && borders.top);
        let {width, height} = chart;
        if (borderBox) {
          width -= paddings.width + borders.width;
          height -= paddings.height + borders.height;
        }
        return {
          x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
          y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
        };
      }
      function getContainerSize(canvas, width, height) {
        let maxWidth, maxHeight;
        if (width === void 0 || height === void 0) {
          const container = _getParentNode(canvas);
          if (!container) {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
          } else {
            const rect = container.getBoundingClientRect();
            const containerStyle = getComputedStyle2(container);
            const containerBorder = getPositionedStyle(containerStyle, "border", "width");
            const containerPadding = getPositionedStyle(containerStyle, "padding");
            width = rect.width - containerPadding.width - containerBorder.width;
            height = rect.height - containerPadding.height - containerBorder.height;
            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
          }
        }
        return {
          width,
          height,
          maxWidth: maxWidth || INFINITY,
          maxHeight: maxHeight || INFINITY
        };
      }
      const round1 = (v) => Math.round(v * 10) / 10;
      function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
        const style = getComputedStyle2(canvas);
        const margins = getPositionedStyle(style, "margin");
        const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
        const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
        const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
        let {width, height} = containerSize;
        if (style.boxSizing === "content-box") {
          const borders = getPositionedStyle(style, "border", "width");
          const paddings = getPositionedStyle(style, "padding");
          width -= paddings.width + borders.width;
          height -= paddings.height + borders.height;
        }
        width = Math.max(0, width - margins.width);
        height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
        width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
        height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
        if (width && !height) {
          height = round1(width / 2);
        }
        return {
          width,
          height
        };
      }
      function retinaScale(chart, forceRatio, forceStyle) {
        const pixelRatio = forceRatio || 1;
        const deviceHeight = Math.floor(chart.height * pixelRatio);
        const deviceWidth = Math.floor(chart.width * pixelRatio);
        chart.height = deviceHeight / pixelRatio;
        chart.width = deviceWidth / pixelRatio;
        const canvas = chart.canvas;
        if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
          canvas.style.height = `${chart.height}px`;
          canvas.style.width = `${chart.width}px`;
        }
        if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
          chart.currentDevicePixelRatio = pixelRatio;
          canvas.height = deviceHeight;
          canvas.width = deviceWidth;
          chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          return true;
        }
        return false;
      }
      const supportsEventListenerOptions = function() {
        let passiveSupported = false;
        try {
          const options2 = {
            get passive() {
              passiveSupported = true;
              return false;
            }
          };
          window.addEventListener("test", null, options2);
          window.removeEventListener("test", null, options2);
        } catch (e) {
        }
        return passiveSupported;
      }();
      function readUsedSize(element, property) {
        const value = getStyle(element, property);
        const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
        return matches ? +matches[1] : void 0;
      }
      function getRelativePosition(e, chart) {
        if ("native" in e) {
          return {
            x: e.x,
            y: e.y
          };
        }
        return getRelativePosition$1(e, chart);
      }
      function evaluateAllVisibleItems(chart, handler) {
        const metasets = chart.getSortedVisibleDatasetMetas();
        let index2, data, element;
        for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
          ({index: index2, data} = metasets[i]);
          for (let j = 0, jlen = data.length; j < jlen; ++j) {
            element = data[j];
            if (!element.skip) {
              handler(element, index2, j);
            }
          }
        }
      }
      function binarySearch(metaset, axis, value, intersect) {
        const {controller, data, _sorted} = metaset;
        const iScale = controller._cachedMeta.iScale;
        if (iScale && axis === iScale.axis && _sorted && data.length) {
          const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
          if (!intersect) {
            return lookupMethod(data, axis, value);
          } else if (controller._sharedOptions) {
            const el = data[0];
            const range = typeof el.getRange === "function" && el.getRange(axis);
            if (range) {
              const start = lookupMethod(data, axis, value - range);
              const end = lookupMethod(data, axis, value + range);
              return {lo: start.lo, hi: end.hi};
            }
          }
        }
        return {lo: 0, hi: data.length - 1};
      }
      function optimizedEvaluateItems(chart, axis, position, handler, intersect) {
        const metasets = chart.getSortedVisibleDatasetMetas();
        const value = position[axis];
        for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
          const {index: index2, data} = metasets[i];
          const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);
          for (let j = lo; j <= hi; ++j) {
            const element = data[j];
            if (!element.skip) {
              handler(element, index2, j);
            }
          }
        }
      }
      function getDistanceMetricForAxis(axis) {
        const useX = axis.indexOf("x") !== -1;
        const useY = axis.indexOf("y") !== -1;
        return function(pt1, pt2) {
          const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
          const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
          return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
        };
      }
      function getIntersectItems(chart, position, axis, useFinalPosition) {
        const items = [];
        if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
          return items;
        }
        const evaluationFunc = function(element, datasetIndex, index2) {
          if (element.inRange(position.x, position.y, useFinalPosition)) {
            items.push({element, datasetIndex, index: index2});
          }
        };
        optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);
        return items;
      }
      function getNearestItems(chart, position, axis, intersect, useFinalPosition) {
        const distanceMetric = getDistanceMetricForAxis(axis);
        let minDistance = Number.POSITIVE_INFINITY;
        let items = [];
        if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
          return items;
        }
        const evaluationFunc = function(element, datasetIndex, index2) {
          if (intersect && !element.inRange(position.x, position.y, useFinalPosition)) {
            return;
          }
          const center = element.getCenterPoint(useFinalPosition);
          const distance = distanceMetric(position, center);
          if (distance < minDistance) {
            items = [{element, datasetIndex, index: index2}];
            minDistance = distance;
          } else if (distance === minDistance) {
            items.push({element, datasetIndex, index: index2});
          }
        };
        optimizedEvaluateItems(chart, axis, position, evaluationFunc);
        return items;
      }
      function getAxisItems(chart, e, options2, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const items = [];
        const axis = options2.axis;
        const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
        let intersectsItem = false;
        evaluateAllVisibleItems(chart, (element, datasetIndex, index2) => {
          if (element[rangeMethod](position[axis], useFinalPosition)) {
            items.push({element, datasetIndex, index: index2});
          }
          if (element.inRange(position.x, position.y, useFinalPosition)) {
            intersectsItem = true;
          }
        });
        if (options2.intersect && !intersectsItem) {
          return [];
        }
        return items;
      }
      var Interaction = {
        modes: {
          index(chart, e, options2, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options2.axis || "x";
            const items = options2.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
            const elements2 = [];
            if (!items.length) {
              return [];
            }
            chart.getSortedVisibleDatasetMetas().forEach((meta2) => {
              const index2 = items[0].index;
              const element = meta2.data[index2];
              if (element && !element.skip) {
                elements2.push({element, datasetIndex: meta2.index, index: index2});
              }
            });
            return elements2;
          },
          dataset(chart, e, options2, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options2.axis || "xy";
            let items = options2.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
            if (items.length > 0) {
              const datasetIndex = items[0].datasetIndex;
              const data = chart.getDatasetMeta(datasetIndex).data;
              items = [];
              for (let i = 0; i < data.length; ++i) {
                items.push({element: data[i], datasetIndex, index: i});
              }
            }
            return items;
          },
          point(chart, e, options2, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options2.axis || "xy";
            return getIntersectItems(chart, position, axis, useFinalPosition);
          },
          nearest(chart, e, options2, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options2.axis || "xy";
            return getNearestItems(chart, position, axis, options2.intersect, useFinalPosition);
          },
          x(chart, e, options2, useFinalPosition) {
            options2.axis = "x";
            return getAxisItems(chart, e, options2, useFinalPosition);
          },
          y(chart, e, options2, useFinalPosition) {
            options2.axis = "y";
            return getAxisItems(chart, e, options2, useFinalPosition);
          }
        }
      };
      const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
      const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
      function toLineHeight(value, size) {
        const matches = ("" + value).match(LINE_HEIGHT);
        if (!matches || matches[1] === "normal") {
          return size * 1.2;
        }
        value = +matches[2];
        switch (matches[3]) {
          case "px":
            return value;
          case "%":
            value /= 100;
            break;
        }
        return size * value;
      }
      const numberOrZero$1 = (v) => +v || 0;
      function _readValueToProps(value, props) {
        const ret = {};
        const objProps = isObject(props);
        const keys = objProps ? Object.keys(props) : props;
        const read2 = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
        for (const prop of keys) {
          ret[prop] = numberOrZero$1(read2(prop));
        }
        return ret;
      }
      function toTRBL(value) {
        return _readValueToProps(value, {top: "y", right: "x", bottom: "y", left: "x"});
      }
      function toTRBLCorners(value) {
        return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
      }
      function toPadding(value) {
        const obj = toTRBL(value);
        obj.width = obj.left + obj.right;
        obj.height = obj.top + obj.bottom;
        return obj;
      }
      function toFont(options2, fallback) {
        options2 = options2 || {};
        fallback = fallback || defaults3.font;
        let size = valueOrDefault(options2.size, fallback.size);
        if (typeof size === "string") {
          size = parseInt(size, 10);
        }
        let style = valueOrDefault(options2.style, fallback.style);
        if (style && !("" + style).match(FONT_STYLE)) {
          console.warn('Invalid font style specified: "' + style + '"');
          style = "";
        }
        const font = {
          family: valueOrDefault(options2.family, fallback.family),
          lineHeight: toLineHeight(valueOrDefault(options2.lineHeight, fallback.lineHeight), size),
          size,
          style,
          weight: valueOrDefault(options2.weight, fallback.weight),
          string: ""
        };
        font.string = toFontString(font);
        return font;
      }
      function resolve2(inputs, context, index2, info) {
        let cacheable = true;
        let i, ilen, value;
        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
          value = inputs[i];
          if (value === void 0) {
            continue;
          }
          if (context !== void 0 && typeof value === "function") {
            value = value(context);
            cacheable = false;
          }
          if (index2 !== void 0 && isArray(value)) {
            value = value[index2 % value.length];
            cacheable = false;
          }
          if (value !== void 0) {
            if (info && !cacheable) {
              info.cacheable = false;
            }
            return value;
          }
        }
      }
      function _addGrace(minmax, grace) {
        const {min, max} = minmax;
        return {
          min: min - Math.abs(toDimension(grace, min)),
          max: max + toDimension(grace, max)
        };
      }
      const STATIC_POSITIONS = ["left", "top", "right", "bottom"];
      function filterByPosition(array, position) {
        return array.filter((v) => v.pos === position);
      }
      function filterDynamicPositionByAxis(array, axis) {
        return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
      }
      function sortByWeight(array, reverse) {
        return array.sort((a, b) => {
          const v0 = reverse ? b : a;
          const v1 = reverse ? a : b;
          return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
        });
      }
      function wrapBoxes(boxes) {
        const layoutBoxes = [];
        let i, ilen, box;
        for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
          box = boxes[i];
          layoutBoxes.push({
            index: i,
            box,
            pos: box.position,
            horizontal: box.isHorizontal(),
            weight: box.weight
          });
        }
        return layoutBoxes;
      }
      function setLayoutDims(layouts2, params) {
        let i, ilen, layout;
        for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
          layout = layouts2[i];
          if (layout.horizontal) {
            layout.width = layout.box.fullSize && params.availableWidth;
            layout.height = params.hBoxMaxHeight;
          } else {
            layout.width = params.vBoxMaxWidth;
            layout.height = layout.box.fullSize && params.availableHeight;
          }
        }
      }
      function buildLayoutBoxes(boxes) {
        const layoutBoxes = wrapBoxes(boxes);
        const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
        const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
        const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
        const top2 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
        const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
        const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
        const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
        return {
          fullSize,
          leftAndTop: left.concat(top2),
          rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
          chartArea: filterByPosition(layoutBoxes, "chartArea"),
          vertical: left.concat(right).concat(centerVertical),
          horizontal: top2.concat(bottom).concat(centerHorizontal)
        };
      }
      function getCombinedMax(maxPadding, chartArea, a, b) {
        return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
      }
      function updateMaxPadding(maxPadding, boxPadding) {
        maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
        maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
        maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
        maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
      }
      function updateDims(chartArea, params, layout) {
        const box = layout.box;
        const maxPadding = chartArea.maxPadding;
        if (!isObject(layout.pos)) {
          if (layout.size) {
            chartArea[layout.pos] -= layout.size;
          }
          layout.size = layout.horizontal ? box.height : box.width;
          chartArea[layout.pos] += layout.size;
        }
        if (box.getPadding) {
          updateMaxPadding(maxPadding, box.getPadding());
        }
        const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
        const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
        const widthChanged = newWidth !== chartArea.w;
        const heightChanged = newHeight !== chartArea.h;
        chartArea.w = newWidth;
        chartArea.h = newHeight;
        return layout.horizontal ? {same: widthChanged, other: heightChanged} : {same: heightChanged, other: widthChanged};
      }
      function handleMaxPadding(chartArea) {
        const maxPadding = chartArea.maxPadding;
        function updatePos(pos) {
          const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
          chartArea[pos] += change;
          return change;
        }
        chartArea.y += updatePos("top");
        chartArea.x += updatePos("left");
        updatePos("right");
        updatePos("bottom");
      }
      function getMargins(horizontal, chartArea) {
        const maxPadding = chartArea.maxPadding;
        function marginForPositions(positions2) {
          const margin = {left: 0, top: 0, right: 0, bottom: 0};
          positions2.forEach((pos) => {
            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
          });
          return margin;
        }
        return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
      }
      function fitBoxes(boxes, chartArea, params) {
        const refitBoxes = [];
        let i, ilen, layout, box, refit, changed;
        for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
          layout = boxes[i];
          box = layout.box;
          box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
          const {same, other} = updateDims(chartArea, params, layout);
          refit |= same && refitBoxes.length;
          changed = changed || other;
          if (!box.fullSize) {
            refitBoxes.push(layout);
          }
        }
        return refit && fitBoxes(refitBoxes, chartArea, params) || changed;
      }
      function placeBoxes(boxes, chartArea, params) {
        const userPadding = params.padding;
        let x = chartArea.x;
        let y = chartArea.y;
        let i, ilen, layout, box;
        for (i = 0, ilen = boxes.length; i < ilen; ++i) {
          layout = boxes[i];
          box = layout.box;
          if (layout.horizontal) {
            box.left = box.fullSize ? userPadding.left : chartArea.left;
            box.right = box.fullSize ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;
            box.top = y;
            box.bottom = y + box.height;
            box.width = box.right - box.left;
            y = box.bottom;
          } else {
            box.left = x;
            box.right = x + box.width;
            box.top = box.fullSize ? userPadding.top : chartArea.top;
            box.bottom = box.fullSize ? params.outerHeight - userPadding.right : chartArea.top + chartArea.h;
            box.height = box.bottom - box.top;
            x = box.right;
          }
        }
        chartArea.x = x;
        chartArea.y = y;
      }
      defaults3.set("layout", {
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      });
      var layouts = {
        addBox(chart, item) {
          if (!chart.boxes) {
            chart.boxes = [];
          }
          item.fullSize = item.fullSize || false;
          item.position = item.position || "top";
          item.weight = item.weight || 0;
          item._layers = item._layers || function() {
            return [{
              z: 0,
              draw(chartArea) {
                item.draw(chartArea);
              }
            }];
          };
          chart.boxes.push(item);
        },
        removeBox(chart, layoutItem) {
          const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
          if (index2 !== -1) {
            chart.boxes.splice(index2, 1);
          }
        },
        configure(chart, item, options2) {
          item.fullSize = options2.fullSize;
          item.position = options2.position;
          item.weight = options2.weight;
        },
        update(chart, width, height, minPadding) {
          if (!chart) {
            return;
          }
          const padding = toPadding(chart.options.layout.padding);
          const availableWidth = Math.max(width - padding.width, 0);
          const availableHeight = Math.max(height - padding.height, 0);
          const boxes = buildLayoutBoxes(chart.boxes);
          const verticalBoxes = boxes.vertical;
          const horizontalBoxes = boxes.horizontal;
          each2(chart.boxes, (box) => {
            if (typeof box.beforeLayout === "function") {
              box.beforeLayout();
            }
          });
          const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
          const params = Object.freeze({
            outerWidth: width,
            outerHeight: height,
            padding,
            availableWidth,
            availableHeight,
            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
            hBoxMaxHeight: availableHeight / 2
          });
          const maxPadding = Object.assign({}, padding);
          updateMaxPadding(maxPadding, toPadding(minPadding));
          const chartArea = Object.assign({
            maxPadding,
            w: availableWidth,
            h: availableHeight,
            x: padding.left,
            y: padding.top
          }, padding);
          setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
          fitBoxes(boxes.fullSize, chartArea, params);
          fitBoxes(verticalBoxes, chartArea, params);
          if (fitBoxes(horizontalBoxes, chartArea, params)) {
            fitBoxes(verticalBoxes, chartArea, params);
          }
          handleMaxPadding(chartArea);
          placeBoxes(boxes.leftAndTop, chartArea, params);
          chartArea.x += chartArea.w;
          chartArea.y += chartArea.h;
          placeBoxes(boxes.rightAndBottom, chartArea, params);
          chart.chartArea = {
            left: chartArea.left,
            top: chartArea.top,
            right: chartArea.left + chartArea.w,
            bottom: chartArea.top + chartArea.h,
            height: chartArea.h,
            width: chartArea.w
          };
          each2(boxes.chartArea, (layout) => {
            const box = layout.box;
            Object.assign(box, chart.chartArea);
            box.update(chartArea.w, chartArea.h);
          });
        }
      };
      class BasePlatform {
        acquireContext(canvas, aspectRatio) {
        }
        releaseContext(context) {
          return false;
        }
        addEventListener(chart, type, listener) {
        }
        removeEventListener(chart, type, listener) {
        }
        getDevicePixelRatio() {
          return 1;
        }
        getMaximumSize(element, width, height, aspectRatio) {
          width = Math.max(0, width || element.width);
          height = height || element.height;
          return {
            width,
            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
          };
        }
        isAttached(canvas) {
          return true;
        }
      }
      class BasicPlatform extends BasePlatform {
        acquireContext(item) {
          return item && item.getContext && item.getContext("2d") || null;
        }
      }
      const EXPANDO_KEY = "$chartjs";
      const EVENT_TYPES = {
        touchstart: "mousedown",
        touchmove: "mousemove",
        touchend: "mouseup",
        pointerenter: "mouseenter",
        pointerdown: "mousedown",
        pointermove: "mousemove",
        pointerup: "mouseup",
        pointerleave: "mouseout",
        pointerout: "mouseout"
      };
      const isNullOrEmpty = (value) => value === null || value === "";
      function initCanvas(canvas, aspectRatio) {
        const style = canvas.style;
        const renderHeight = canvas.getAttribute("height");
        const renderWidth = canvas.getAttribute("width");
        canvas[EXPANDO_KEY] = {
          initial: {
            height: renderHeight,
            width: renderWidth,
            style: {
              display: style.display,
              height: style.height,
              width: style.width
            }
          }
        };
        style.display = style.display || "block";
        style.boxSizing = style.boxSizing || "border-box";
        if (isNullOrEmpty(renderWidth)) {
          const displayWidth = readUsedSize(canvas, "width");
          if (displayWidth !== void 0) {
            canvas.width = displayWidth;
          }
        }
        if (isNullOrEmpty(renderHeight)) {
          if (canvas.style.height === "") {
            canvas.height = canvas.width / (aspectRatio || 2);
          } else {
            const displayHeight = readUsedSize(canvas, "height");
            if (displayHeight !== void 0) {
              canvas.height = displayHeight;
            }
          }
        }
        return canvas;
      }
      const eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;
      function addListener(node, type, listener) {
        node.addEventListener(type, listener, eventListenerOptions);
      }
      function removeListener(chart, type, listener) {
        chart.canvas.removeEventListener(type, listener, eventListenerOptions);
      }
      function fromNativeEvent(event, chart) {
        const type = EVENT_TYPES[event.type] || event.type;
        const {x, y} = getRelativePosition$1(event, chart);
        return {
          type,
          chart,
          native: event,
          x: x !== void 0 ? x : null,
          y: y !== void 0 ? y : null
        };
      }
      function createAttachObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const container = canvas && _getParentNode(canvas);
        const element = container || canvas;
        const observer = new MutationObserver((entries) => {
          const parent = _getParentNode(element);
          entries.forEach((entry) => {
            for (let i = 0; i < entry.addedNodes.length; i++) {
              const added = entry.addedNodes[i];
              if (added === element || added === parent) {
                listener(entry.target);
              }
            }
          });
        });
        observer.observe(document, {childList: true, subtree: true});
        return observer;
      }
      function createDetachObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const container = canvas && _getParentNode(canvas);
        if (!container) {
          return;
        }
        const observer = new MutationObserver((entries) => {
          entries.forEach((entry) => {
            for (let i = 0; i < entry.removedNodes.length; i++) {
              if (entry.removedNodes[i] === canvas) {
                listener();
                break;
              }
            }
          });
        });
        observer.observe(container, {childList: true});
        return observer;
      }
      const drpListeningCharts = new Map();
      let oldDevicePixelRatio = 0;
      function onWindowResize() {
        const dpr = window.devicePixelRatio;
        if (dpr === oldDevicePixelRatio) {
          return;
        }
        oldDevicePixelRatio = dpr;
        drpListeningCharts.forEach((resize, chart) => {
          if (chart.currentDevicePixelRatio !== dpr) {
            resize();
          }
        });
      }
      function listenDevicePixelRatioChanges(chart, resize) {
        if (!drpListeningCharts.size) {
          window.addEventListener("resize", onWindowResize);
        }
        drpListeningCharts.set(chart, resize);
      }
      function unlistenDevicePixelRatioChanges(chart) {
        drpListeningCharts.delete(chart);
        if (!drpListeningCharts.size) {
          window.removeEventListener("resize", onWindowResize);
        }
      }
      function createResizeObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const container = canvas && _getParentNode(canvas);
        if (!container) {
          return;
        }
        const resize = throttled((width, height) => {
          const w = container.clientWidth;
          listener(width, height);
          if (w < container.clientWidth) {
            listener();
          }
        }, window);
        const observer = new ResizeObserver((entries) => {
          const entry = entries[0];
          const width = entry.contentRect.width;
          const height = entry.contentRect.height;
          if (width === 0 && height === 0) {
            return;
          }
          resize(width, height);
        });
        observer.observe(container);
        listenDevicePixelRatioChanges(chart, resize);
        return observer;
      }
      function releaseObserver(chart, type, observer) {
        if (observer) {
          observer.disconnect();
        }
        if (type === "resize") {
          unlistenDevicePixelRatioChanges(chart);
        }
      }
      function createProxyAndListen(chart, type, listener) {
        const canvas = chart.canvas;
        const proxy = throttled((event) => {
          if (chart.ctx !== null) {
            listener(fromNativeEvent(event, chart));
          }
        }, chart, (args) => {
          const event = args[0];
          return [event, event.offsetX, event.offsetY];
        });
        addListener(canvas, type, proxy);
        return proxy;
      }
      class DomPlatform extends BasePlatform {
        acquireContext(canvas, aspectRatio) {
          const context = canvas && canvas.getContext && canvas.getContext("2d");
          if (context && context.canvas === canvas) {
            initCanvas(canvas, aspectRatio);
            return context;
          }
          return null;
        }
        releaseContext(context) {
          const canvas = context.canvas;
          if (!canvas[EXPANDO_KEY]) {
            return false;
          }
          const initial = canvas[EXPANDO_KEY].initial;
          ["height", "width"].forEach((prop) => {
            const value = initial[prop];
            if (isNullOrUndef(value)) {
              canvas.removeAttribute(prop);
            } else {
              canvas.setAttribute(prop, value);
            }
          });
          const style = initial.style || {};
          Object.keys(style).forEach((key) => {
            canvas.style[key] = style[key];
          });
          canvas.width = canvas.width;
          delete canvas[EXPANDO_KEY];
          return true;
        }
        addEventListener(chart, type, listener) {
          this.removeEventListener(chart, type);
          const proxies = chart.$proxies || (chart.$proxies = {});
          const handlers2 = {
            attach: createAttachObserver,
            detach: createDetachObserver,
            resize: createResizeObserver
          };
          const handler = handlers2[type] || createProxyAndListen;
          proxies[type] = handler(chart, type, listener);
        }
        removeEventListener(chart, type) {
          const proxies = chart.$proxies || (chart.$proxies = {});
          const proxy = proxies[type];
          if (!proxy) {
            return;
          }
          const handlers2 = {
            attach: releaseObserver,
            detach: releaseObserver,
            resize: releaseObserver
          };
          const handler = handlers2[type] || removeListener;
          handler(chart, type, proxy);
          proxies[type] = void 0;
        }
        getDevicePixelRatio() {
          return window.devicePixelRatio;
        }
        getMaximumSize(canvas, width, height, aspectRatio) {
          return getMaximumSize(canvas, width, height, aspectRatio);
        }
        isAttached(canvas) {
          const container = _getParentNode(canvas);
          return !!(container && _getParentNode(container));
        }
      }
      var platforms = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        BasePlatform,
        BasicPlatform,
        DomPlatform
      });
      const atEdge = (t2) => t2 === 0 || t2 === 1;
      const elasticIn = (t2, s2, p) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s2) * TAU / p));
      const elasticOut = (t2, s2, p) => Math.pow(2, -10 * t2) * Math.sin((t2 - s2) * TAU / p) + 1;
      const effects = {
        linear: (t2) => t2,
        easeInQuad: (t2) => t2 * t2,
        easeOutQuad: (t2) => -t2 * (t2 - 2),
        easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
        easeInCubic: (t2) => t2 * t2 * t2,
        easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
        easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
        easeInQuart: (t2) => t2 * t2 * t2 * t2,
        easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
        easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
        easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
        easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
        easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
        easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
        easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
        easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
        easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
        easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
        easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
        easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
        easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
        easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
        easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
        easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
        easeInOutElastic(t2) {
          const s2 = 0.1125;
          const p = 0.45;
          return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s2, p) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s2, p);
        },
        easeInBack(t2) {
          const s2 = 1.70158;
          return t2 * t2 * ((s2 + 1) * t2 - s2);
        },
        easeOutBack(t2) {
          const s2 = 1.70158;
          return (t2 -= 1) * t2 * ((s2 + 1) * t2 + s2) + 1;
        },
        easeInOutBack(t2) {
          let s2 = 1.70158;
          if ((t2 /= 0.5) < 1) {
            return 0.5 * (t2 * t2 * (((s2 *= 1.525) + 1) * t2 - s2));
          }
          return 0.5 * ((t2 -= 2) * t2 * (((s2 *= 1.525) + 1) * t2 + s2) + 2);
        },
        easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
        easeOutBounce(t2) {
          const m = 7.5625;
          const d = 2.75;
          if (t2 < 1 / d) {
            return m * t2 * t2;
          }
          if (t2 < 2 / d) {
            return m * (t2 -= 1.5 / d) * t2 + 0.75;
          }
          if (t2 < 2.5 / d) {
            return m * (t2 -= 2.25 / d) * t2 + 0.9375;
          }
          return m * (t2 -= 2.625 / d) * t2 + 0.984375;
        },
        easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
      };
      const transparent = "transparent";
      const interpolators = {
        boolean(from, to, factor) {
          return factor > 0.5 ? to : from;
        },
        color(from, to, factor) {
          const c0 = color(from || transparent);
          const c1 = c0.valid && color(to || transparent);
          return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
        },
        number(from, to, factor) {
          return from + (to - from) * factor;
        }
      };
      class Animation {
        constructor(cfg, target, prop, to) {
          const currentValue = target[prop];
          to = resolve2([cfg.to, to, currentValue, cfg.from]);
          const from = resolve2([cfg.from, currentValue, to]);
          this._active = true;
          this._fn = cfg.fn || interpolators[cfg.type || typeof from];
          this._easing = effects[cfg.easing] || effects.linear;
          this._start = Math.floor(Date.now() + (cfg.delay || 0));
          this._duration = this._total = Math.floor(cfg.duration);
          this._loop = !!cfg.loop;
          this._target = target;
          this._prop = prop;
          this._from = from;
          this._to = to;
          this._promises = void 0;
        }
        active() {
          return this._active;
        }
        update(cfg, to, date) {
          const me = this;
          if (me._active) {
            me._notify(false);
            const currentValue = me._target[me._prop];
            const elapsed = date - me._start;
            const remain = me._duration - elapsed;
            me._start = date;
            me._duration = Math.floor(Math.max(remain, cfg.duration));
            me._total += elapsed;
            me._loop = !!cfg.loop;
            me._to = resolve2([cfg.to, to, currentValue, cfg.from]);
            me._from = resolve2([cfg.from, currentValue, to]);
          }
        }
        cancel() {
          const me = this;
          if (me._active) {
            me.tick(Date.now());
            me._active = false;
            me._notify(false);
          }
        }
        tick(date) {
          const me = this;
          const elapsed = date - me._start;
          const duration = me._duration;
          const prop = me._prop;
          const from = me._from;
          const loop = me._loop;
          const to = me._to;
          let factor;
          me._active = from !== to && (loop || elapsed < duration);
          if (!me._active) {
            me._target[prop] = to;
            me._notify(true);
            return;
          }
          if (elapsed < 0) {
            me._target[prop] = from;
            return;
          }
          factor = elapsed / duration % 2;
          factor = loop && factor > 1 ? 2 - factor : factor;
          factor = me._easing(Math.min(1, Math.max(0, factor)));
          me._target[prop] = me._fn(from, to, factor);
        }
        wait() {
          const promises = this._promises || (this._promises = []);
          return new Promise((res, rej) => {
            promises.push({res, rej});
          });
        }
        _notify(resolved) {
          const method = resolved ? "res" : "rej";
          const promises = this._promises || [];
          for (let i = 0; i < promises.length; i++) {
            promises[i][method]();
          }
        }
      }
      const numbers = ["x", "y", "borderWidth", "radius", "tension"];
      const colors = ["color", "borderColor", "backgroundColor"];
      defaults3.set("animation", {
        delay: void 0,
        duration: 1e3,
        easing: "easeOutQuart",
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0
      });
      const animationOptions = Object.keys(defaults3.animation);
      defaults3.describe("animation", {
        _fallback: false,
        _indexable: false,
        _scriptable: (name2) => name2 !== "onProgress" && name2 !== "onComplete" && name2 !== "fn"
      });
      defaults3.set("animations", {
        colors: {
          type: "color",
          properties: colors
        },
        numbers: {
          type: "number",
          properties: numbers
        }
      });
      defaults3.describe("animations", {
        _fallback: "animation"
      });
      defaults3.set("transitions", {
        active: {
          animation: {
            duration: 400
          }
        },
        resize: {
          animation: {
            duration: 0
          }
        },
        show: {
          animations: {
            colors: {
              from: "transparent"
            },
            visible: {
              type: "boolean",
              duration: 0
            }
          }
        },
        hide: {
          animations: {
            colors: {
              to: "transparent"
            },
            visible: {
              type: "boolean",
              easing: "linear",
              fn: (v) => v | 0
            }
          }
        }
      });
      class Animations {
        constructor(chart, config2) {
          this._chart = chart;
          this._properties = new Map();
          this.configure(config2);
        }
        configure(config2) {
          if (!isObject(config2)) {
            return;
          }
          const animatedProps = this._properties;
          Object.getOwnPropertyNames(config2).forEach((key) => {
            const cfg = config2[key];
            if (!isObject(cfg)) {
              return;
            }
            const resolved = {};
            for (const option of animationOptions) {
              resolved[option] = cfg[option];
            }
            (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
              if (prop === key || !animatedProps.has(prop)) {
                animatedProps.set(prop, resolved);
              }
            });
          });
        }
        _animateOptions(target, values) {
          const newOptions = values.options;
          const options2 = resolveTargetOptions(target, newOptions);
          if (!options2) {
            return [];
          }
          const animations = this._createAnimations(options2, newOptions);
          if (newOptions.$shared) {
            awaitAll(target.options.$animations, newOptions).then(() => {
              target.options = newOptions;
            }, () => {
            });
          }
          return animations;
        }
        _createAnimations(target, values) {
          const animatedProps = this._properties;
          const animations = [];
          const running = target.$animations || (target.$animations = {});
          const props = Object.keys(values);
          const date = Date.now();
          let i;
          for (i = props.length - 1; i >= 0; --i) {
            const prop = props[i];
            if (prop.charAt(0) === "$") {
              continue;
            }
            if (prop === "options") {
              animations.push(...this._animateOptions(target, values));
              continue;
            }
            const value = values[prop];
            let animation = running[prop];
            const cfg = animatedProps.get(prop);
            if (animation) {
              if (cfg && animation.active()) {
                animation.update(cfg, value, date);
                continue;
              } else {
                animation.cancel();
              }
            }
            if (!cfg || !cfg.duration) {
              target[prop] = value;
              continue;
            }
            running[prop] = animation = new Animation(cfg, target, prop, value);
            animations.push(animation);
          }
          return animations;
        }
        update(target, values) {
          if (this._properties.size === 0) {
            Object.assign(target, values);
            return;
          }
          const animations = this._createAnimations(target, values);
          if (animations.length) {
            animator.add(this._chart, animations);
            return true;
          }
        }
      }
      function awaitAll(animations, properties) {
        const running = [];
        const keys = Object.keys(properties);
        for (let i = 0; i < keys.length; i++) {
          const anim = animations[keys[i]];
          if (anim && anim.active()) {
            running.push(anim.wait());
          }
        }
        return Promise.all(running);
      }
      function resolveTargetOptions(target, newOptions) {
        if (!newOptions) {
          return;
        }
        let options2 = target.options;
        if (!options2) {
          target.options = newOptions;
          return;
        }
        if (options2.$shared) {
          target.options = options2 = Object.assign({}, options2, {$shared: false, $animations: {}});
        }
        return options2;
      }
      function scaleClip(scale, allowedOverflow) {
        const opts = scale && scale.options || {};
        const reverse = opts.reverse;
        const min = opts.min === void 0 ? allowedOverflow : 0;
        const max = opts.max === void 0 ? allowedOverflow : 0;
        return {
          start: reverse ? max : min,
          end: reverse ? min : max
        };
      }
      function defaultClip(xScale, yScale, allowedOverflow) {
        if (allowedOverflow === false) {
          return false;
        }
        const x = scaleClip(xScale, allowedOverflow);
        const y = scaleClip(yScale, allowedOverflow);
        return {
          top: y.end,
          right: x.end,
          bottom: y.start,
          left: x.start
        };
      }
      function toClip(value) {
        let t2, r, b, l;
        if (isObject(value)) {
          t2 = value.top;
          r = value.right;
          b = value.bottom;
          l = value.left;
        } else {
          t2 = r = b = l = value;
        }
        return {
          top: t2,
          right: r,
          bottom: b,
          left: l
        };
      }
      function getSortedDatasetIndices(chart, filterVisible) {
        const keys = [];
        const metasets = chart._getSortedDatasetMetas(filterVisible);
        let i, ilen;
        for (i = 0, ilen = metasets.length; i < ilen; ++i) {
          keys.push(metasets[i].index);
        }
        return keys;
      }
      function applyStack(stack, value, dsIndex, options2) {
        const keys = stack.keys;
        const singleMode = options2.mode === "single";
        let i, ilen, datasetIndex, otherValue;
        if (value === null) {
          return;
        }
        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          datasetIndex = +keys[i];
          if (datasetIndex === dsIndex) {
            if (options2.all) {
              continue;
            }
            break;
          }
          otherValue = stack.values[datasetIndex];
          if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
            value += otherValue;
          }
        }
        return value;
      }
      function convertObjectDataToArray(data) {
        const keys = Object.keys(data);
        const adata = new Array(keys.length);
        let i, ilen, key;
        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          adata[i] = {
            x: key,
            y: data[key]
          };
        }
        return adata;
      }
      function isStacked(scale, meta2) {
        const stacked = scale && scale.options.stacked;
        return stacked || stacked === void 0 && meta2.stack !== void 0;
      }
      function getStackKey(indexScale, valueScale, meta2) {
        return `${indexScale.id}.${valueScale.id}.${meta2.stack || meta2.type}`;
      }
      function getUserBounds(scale) {
        const {min, max, minDefined, maxDefined} = scale.getUserBounds();
        return {
          min: minDefined ? min : Number.NEGATIVE_INFINITY,
          max: maxDefined ? max : Number.POSITIVE_INFINITY
        };
      }
      function getOrCreateStack(stacks, stackKey, indexValue) {
        const subStack = stacks[stackKey] || (stacks[stackKey] = {});
        return subStack[indexValue] || (subStack[indexValue] = {});
      }
      function getLastIndexInStack(stack, vScale, positive) {
        for (const meta2 of vScale.getMatchingVisibleMetas("bar").reverse()) {
          const value = stack[meta2.index];
          if (positive && value > 0 || !positive && value < 0) {
            return meta2.index;
          }
        }
        return null;
      }
      function updateStacks(controller, parsed) {
        const {chart, _cachedMeta: meta2} = controller;
        const stacks = chart._stacks || (chart._stacks = {});
        const {iScale, vScale, index: datasetIndex} = meta2;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const key = getStackKey(iScale, vScale, meta2);
        const ilen = parsed.length;
        let stack;
        for (let i = 0; i < ilen; ++i) {
          const item = parsed[i];
          const {[iAxis]: index2, [vAxis]: value} = item;
          const itemStacks = item._stacks || (item._stacks = {});
          stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
          stack[datasetIndex] = value;
          stack._top = getLastIndexInStack(stack, vScale, true);
          stack._bottom = getLastIndexInStack(stack, vScale, false);
        }
      }
      function getFirstScaleId(chart, axis) {
        const scales2 = chart.scales;
        return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
      }
      function createDatasetContext(parent, index2) {
        return Object.assign(Object.create(parent), {
          active: false,
          dataset: void 0,
          datasetIndex: index2,
          index: index2,
          mode: "default",
          type: "dataset"
        });
      }
      function createDataContext(parent, index2, element) {
        return Object.assign(Object.create(parent), {
          active: false,
          dataIndex: index2,
          parsed: void 0,
          raw: void 0,
          element,
          index: index2,
          mode: "default",
          type: "data"
        });
      }
      function clearStacks(meta2, items) {
        items = items || meta2._parsed;
        for (const parsed of items) {
          const stacks = parsed._stacks;
          if (!stacks || stacks[meta2.vScale.id] === void 0 || stacks[meta2.vScale.id][meta2.index] === void 0) {
            return;
          }
          delete stacks[meta2.vScale.id][meta2.index];
        }
      }
      const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
      const cloneIfNotShared = (cached2, shared) => shared ? cached2 : Object.assign({}, cached2);
      class DatasetController {
        constructor(chart, datasetIndex) {
          this.chart = chart;
          this._ctx = chart.ctx;
          this.index = datasetIndex;
          this._cachedDataOpts = {};
          this._cachedMeta = this.getMeta();
          this._type = this._cachedMeta.type;
          this.options = void 0;
          this._parsing = false;
          this._data = void 0;
          this._objectData = void 0;
          this._sharedOptions = void 0;
          this._drawStart = void 0;
          this._drawCount = void 0;
          this.enableOptionSharing = false;
          this.$context = void 0;
          this._syncList = [];
          this.initialize();
        }
        initialize() {
          const me = this;
          const meta2 = me._cachedMeta;
          me.configure();
          me.linkScales();
          meta2._stacked = isStacked(meta2.vScale, meta2);
          me.addElements();
        }
        updateIndex(datasetIndex) {
          if (this.index !== datasetIndex) {
            clearStacks(this._cachedMeta);
          }
          this.index = datasetIndex;
        }
        linkScales() {
          const me = this;
          const chart = me.chart;
          const meta2 = me._cachedMeta;
          const dataset = me.getDataset();
          const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
          const xid = meta2.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
          const yid = meta2.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
          const rid = meta2.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
          const indexAxis = meta2.indexAxis;
          const iid = meta2.iAxisID = chooseId(indexAxis, xid, yid, rid);
          const vid = meta2.vAxisID = chooseId(indexAxis, yid, xid, rid);
          meta2.xScale = me.getScaleForId(xid);
          meta2.yScale = me.getScaleForId(yid);
          meta2.rScale = me.getScaleForId(rid);
          meta2.iScale = me.getScaleForId(iid);
          meta2.vScale = me.getScaleForId(vid);
        }
        getDataset() {
          return this.chart.data.datasets[this.index];
        }
        getMeta() {
          return this.chart.getDatasetMeta(this.index);
        }
        getScaleForId(scaleID) {
          return this.chart.scales[scaleID];
        }
        _getOtherScale(scale) {
          const meta2 = this._cachedMeta;
          return scale === meta2.iScale ? meta2.vScale : meta2.iScale;
        }
        reset() {
          this._update("reset");
        }
        _destroy() {
          const meta2 = this._cachedMeta;
          if (this._data) {
            unlistenArrayEvents(this._data, this);
          }
          if (meta2._stacked) {
            clearStacks(meta2);
          }
        }
        _dataCheck() {
          const me = this;
          const dataset = me.getDataset();
          const data = dataset.data || (dataset.data = []);
          const _data = me._data;
          if (isObject(data)) {
            me._data = convertObjectDataToArray(data);
          } else if (_data !== data) {
            if (_data) {
              unlistenArrayEvents(_data, me);
              const meta2 = me._cachedMeta;
              clearStacks(meta2);
              meta2._parsed = [];
            }
            if (data && Object.isExtensible(data)) {
              listenArrayEvents(data, me);
            }
            me._syncList = [];
            me._data = data;
          }
        }
        addElements() {
          const me = this;
          const meta2 = me._cachedMeta;
          me._dataCheck();
          if (me.datasetElementType) {
            meta2.dataset = new me.datasetElementType();
          }
        }
        buildOrUpdateElements(resetNewElements) {
          const me = this;
          const meta2 = me._cachedMeta;
          const dataset = me.getDataset();
          let stackChanged = false;
          me._dataCheck();
          const oldStacked = meta2._stacked;
          meta2._stacked = isStacked(meta2.vScale, meta2);
          if (meta2.stack !== dataset.stack) {
            stackChanged = true;
            clearStacks(meta2);
            meta2.stack = dataset.stack;
          }
          me._resyncElements(resetNewElements);
          if (stackChanged || oldStacked !== meta2._stacked) {
            updateStacks(me, meta2._parsed);
          }
        }
        configure() {
          const me = this;
          const config2 = me.chart.config;
          const scopeKeys = config2.datasetScopeKeys(me._type);
          const scopes = config2.getOptionScopes(me.getDataset(), scopeKeys, true);
          me.options = config2.createResolver(scopes, me.getContext());
          me._parsing = me.options.parsing;
        }
        parse(start, count) {
          const me = this;
          const {_cachedMeta: meta2, _data: data} = me;
          const {iScale, _stacked} = meta2;
          const iAxis = iScale.axis;
          let sorted = start === 0 && count === data.length ? true : meta2._sorted;
          let prev = start > 0 && meta2._parsed[start - 1];
          let i, cur2, parsed;
          if (me._parsing === false) {
            meta2._parsed = data;
            meta2._sorted = true;
            parsed = data;
          } else {
            if (isArray(data[start])) {
              parsed = me.parseArrayData(meta2, data, start, count);
            } else if (isObject(data[start])) {
              parsed = me.parseObjectData(meta2, data, start, count);
            } else {
              parsed = me.parsePrimitiveData(meta2, data, start, count);
            }
            const isNotInOrderComparedToPrev = () => cur2[iAxis] === null || prev && cur2[iAxis] < prev[iAxis];
            for (i = 0; i < count; ++i) {
              meta2._parsed[i + start] = cur2 = parsed[i];
              if (sorted) {
                if (isNotInOrderComparedToPrev()) {
                  sorted = false;
                }
                prev = cur2;
              }
            }
            meta2._sorted = sorted;
          }
          if (_stacked) {
            updateStacks(me, parsed);
          }
        }
        parsePrimitiveData(meta2, data, start, count) {
          const {iScale, vScale} = meta2;
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const labels = iScale.getLabels();
          const singleScale = iScale === vScale;
          const parsed = new Array(count);
          let i, ilen, index2;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index2 = i + start;
            parsed[i] = {
              [iAxis]: singleScale || iScale.parse(labels[index2], index2),
              [vAxis]: vScale.parse(data[index2], index2)
            };
          }
          return parsed;
        }
        parseArrayData(meta2, data, start, count) {
          const {xScale, yScale} = meta2;
          const parsed = new Array(count);
          let i, ilen, index2, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index2 = i + start;
            item = data[index2];
            parsed[i] = {
              x: xScale.parse(item[0], index2),
              y: yScale.parse(item[1], index2)
            };
          }
          return parsed;
        }
        parseObjectData(meta2, data, start, count) {
          const {xScale, yScale} = meta2;
          const {xAxisKey = "x", yAxisKey = "y"} = this._parsing;
          const parsed = new Array(count);
          let i, ilen, index2, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index2 = i + start;
            item = data[index2];
            parsed[i] = {
              x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
              y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
            };
          }
          return parsed;
        }
        getParsed(index2) {
          return this._cachedMeta._parsed[index2];
        }
        getDataElement(index2) {
          return this._cachedMeta.data[index2];
        }
        applyStack(scale, parsed, mode) {
          const chart = this.chart;
          const meta2 = this._cachedMeta;
          const value = parsed[scale.axis];
          const stack = {
            keys: getSortedDatasetIndices(chart, true),
            values: parsed._stacks[scale.axis]
          };
          return applyStack(stack, value, meta2.index, {mode});
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
          const parsedValue = parsed[scale.axis];
          let value = parsedValue === null ? NaN : parsedValue;
          const values = stack && parsed._stacks[scale.axis];
          if (stack && values) {
            stack.values = values;
            range.min = Math.min(range.min, value);
            range.max = Math.max(range.max, value);
            value = applyStack(stack, parsedValue, this._cachedMeta.index, {all: true});
          }
          range.min = Math.min(range.min, value);
          range.max = Math.max(range.max, value);
        }
        getMinMax(scale, canStack) {
          const me = this;
          const meta2 = me._cachedMeta;
          const _parsed = meta2._parsed;
          const sorted = meta2._sorted && scale === meta2.iScale;
          const ilen = _parsed.length;
          const otherScale = me._getOtherScale(scale);
          const stack = canStack && meta2._stacked && {keys: getSortedDatasetIndices(me.chart, true), values: null};
          const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};
          const {min: otherMin, max: otherMax} = getUserBounds(otherScale);
          let i, value, parsed, otherValue;
          function _skip() {
            parsed = _parsed[i];
            value = parsed[scale.axis];
            otherValue = parsed[otherScale.axis];
            return !isNumberFinite(value) || otherMin > otherValue || otherMax < otherValue;
          }
          for (i = 0; i < ilen; ++i) {
            if (_skip()) {
              continue;
            }
            me.updateRangeFromParsed(range, scale, parsed, stack);
            if (sorted) {
              break;
            }
          }
          if (sorted) {
            for (i = ilen - 1; i >= 0; --i) {
              if (_skip()) {
                continue;
              }
              me.updateRangeFromParsed(range, scale, parsed, stack);
              break;
            }
          }
          return range;
        }
        getAllParsedValues(scale) {
          const parsed = this._cachedMeta._parsed;
          const values = [];
          let i, ilen, value;
          for (i = 0, ilen = parsed.length; i < ilen; ++i) {
            value = parsed[i][scale.axis];
            if (isNumberFinite(value)) {
              values.push(value);
            }
          }
          return values;
        }
        getMaxOverflow() {
          return false;
        }
        getLabelAndValue(index2) {
          const me = this;
          const meta2 = me._cachedMeta;
          const iScale = meta2.iScale;
          const vScale = meta2.vScale;
          const parsed = me.getParsed(index2);
          return {
            label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
            value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
          };
        }
        _update(mode) {
          const me = this;
          const meta2 = me._cachedMeta;
          me.configure();
          me._cachedDataOpts = {};
          me.update(mode || "default");
          meta2._clip = toClip(valueOrDefault(me.options.clip, defaultClip(meta2.xScale, meta2.yScale, me.getMaxOverflow())));
        }
        update(mode) {
        }
        draw() {
          const me = this;
          const ctx = me._ctx;
          const chart = me.chart;
          const meta2 = me._cachedMeta;
          const elements2 = meta2.data || [];
          const area = chart.chartArea;
          const active = [];
          const start = me._drawStart || 0;
          const count = me._drawCount || elements2.length - start;
          let i;
          if (meta2.dataset) {
            meta2.dataset.draw(ctx, area, start, count);
          }
          for (i = start; i < start + count; ++i) {
            const element = elements2[i];
            if (element.active) {
              active.push(element);
            } else {
              element.draw(ctx, area);
            }
          }
          for (i = 0; i < active.length; ++i) {
            active[i].draw(ctx, area);
          }
        }
        getStyle(index2, active) {
          const mode = active ? "active" : "default";
          return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
        }
        getContext(index2, active, mode) {
          const me = this;
          const dataset = me.getDataset();
          let context;
          if (index2 >= 0 && index2 < me._cachedMeta.data.length) {
            const element = me._cachedMeta.data[index2];
            context = element.$context || (element.$context = createDataContext(me.getContext(), index2, element));
            context.parsed = me.getParsed(index2);
            context.raw = dataset.data[index2];
            context.index = context.dataIndex = index2;
          } else {
            context = me.$context || (me.$context = createDatasetContext(me.chart.getContext(), me.index));
            context.dataset = dataset;
            context.index = context.datasetIndex = me.index;
          }
          context.active = !!active;
          context.mode = mode;
          return context;
        }
        resolveDatasetElementOptions(mode) {
          return this._resolveElementOptions(this.datasetElementType.id, mode);
        }
        resolveDataElementOptions(index2, mode) {
          return this._resolveElementOptions(this.dataElementType.id, mode, index2);
        }
        _resolveElementOptions(elementType, mode = "default", index2) {
          const me = this;
          const active = mode === "active";
          const cache = me._cachedDataOpts;
          const cacheKey = elementType + "-" + mode;
          const cached2 = cache[cacheKey];
          const sharing = me.enableOptionSharing && defined(index2);
          if (cached2) {
            return cloneIfNotShared(cached2, sharing);
          }
          const config2 = me.chart.config;
          const scopeKeys = config2.datasetElementScopeKeys(me._type, elementType);
          const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
          const scopes = config2.getOptionScopes(me.getDataset(), scopeKeys);
          const names2 = Object.keys(defaults3.elements[elementType]);
          const context = () => me.getContext(index2, active);
          const values = config2.resolveNamedOptions(scopes, names2, context, prefixes);
          if (values.$shared) {
            values.$shared = sharing;
            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
          }
          return values;
        }
        _resolveAnimations(index2, transition, active) {
          const me = this;
          const chart = me.chart;
          const cache = me._cachedDataOpts;
          const cacheKey = `animation-${transition}`;
          const cached2 = cache[cacheKey];
          if (cached2) {
            return cached2;
          }
          let options2;
          if (chart.options.animation !== false) {
            const config2 = me.chart.config;
            const scopeKeys = config2.datasetAnimationScopeKeys(me._type, transition);
            const scopes = config2.getOptionScopes(me.getDataset(), scopeKeys);
            options2 = config2.createResolver(scopes, me.getContext(index2, active, transition));
          }
          const animations = new Animations(chart, options2 && options2.animations);
          if (options2 && options2._cacheable) {
            cache[cacheKey] = Object.freeze(animations);
          }
          return animations;
        }
        getSharedOptions(options2) {
          if (!options2.$shared) {
            return;
          }
          return this._sharedOptions || (this._sharedOptions = Object.assign({}, options2));
        }
        includeOptions(mode, sharedOptions) {
          return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
        }
        updateElement(element, index2, properties, mode) {
          if (isDirectUpdateMode(mode)) {
            Object.assign(element, properties);
          } else {
            this._resolveAnimations(index2, mode).update(element, properties);
          }
        }
        updateSharedOptions(sharedOptions, mode, newOptions) {
          if (sharedOptions && !isDirectUpdateMode(mode)) {
            this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
          }
        }
        _setStyle(element, index2, mode, active) {
          element.active = active;
          const options2 = this.getStyle(index2, active);
          this._resolveAnimations(index2, mode, active).update(element, {
            options: !active && this.getSharedOptions(options2) || options2
          });
        }
        removeHoverStyle(element, datasetIndex, index2) {
          this._setStyle(element, index2, "active", false);
        }
        setHoverStyle(element, datasetIndex, index2) {
          this._setStyle(element, index2, "active", true);
        }
        _removeDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          if (element) {
            this._setStyle(element, void 0, "active", false);
          }
        }
        _setDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          if (element) {
            this._setStyle(element, void 0, "active", true);
          }
        }
        _resyncElements(resetNewElements) {
          const me = this;
          const data = me._data;
          const elements2 = me._cachedMeta.data;
          for (const [method, arg1, arg2] of me._syncList) {
            me[method](arg1, arg2);
          }
          me._syncList = [];
          const numMeta = elements2.length;
          const numData = data.length;
          const count = Math.min(numData, numMeta);
          if (numData > numMeta) {
            me._insertElements(numMeta, numData - numMeta, resetNewElements);
          } else if (numData < numMeta) {
            me._removeElements(numData, numMeta - numData);
          }
          if (count) {
            me.parse(0, count);
          }
        }
        _insertElements(start, count, resetNewElements = true) {
          const me = this;
          const meta2 = me._cachedMeta;
          const data = meta2.data;
          const end = start + count;
          let i;
          const move = (arr) => {
            arr.length += count;
            for (i = arr.length - 1; i >= end; i--) {
              arr[i] = arr[i - count];
            }
          };
          move(data);
          for (i = start; i < end; ++i) {
            data[i] = new me.dataElementType();
          }
          if (me._parsing) {
            move(meta2._parsed);
          }
          me.parse(start, count);
          if (resetNewElements) {
            me.updateElements(data, start, count, "reset");
          }
        }
        updateElements(element, start, count, mode) {
        }
        _removeElements(start, count) {
          const me = this;
          const meta2 = me._cachedMeta;
          if (me._parsing) {
            const removed = meta2._parsed.splice(start, count);
            if (meta2._stacked) {
              clearStacks(meta2, removed);
            }
          }
          meta2.data.splice(start, count);
        }
        _onDataPush() {
          const count = arguments.length;
          this._syncList.push(["_insertElements", this.getDataset().data.length - count, count]);
        }
        _onDataPop() {
          this._syncList.push(["_removeElements", this._cachedMeta.data.length - 1, 1]);
        }
        _onDataShift() {
          this._syncList.push(["_removeElements", 0, 1]);
        }
        _onDataSplice(start, count) {
          this._syncList.push(["_removeElements", start, count]);
          this._syncList.push(["_insertElements", start, arguments.length - 2]);
        }
        _onDataUnshift() {
          this._syncList.push(["_insertElements", 0, arguments.length]);
        }
      }
      DatasetController.defaults = {};
      DatasetController.prototype.datasetElementType = null;
      DatasetController.prototype.dataElementType = null;
      class Element {
        constructor() {
          this.x = void 0;
          this.y = void 0;
          this.active = false;
          this.options = void 0;
          this.$animations = void 0;
        }
        tooltipPosition(useFinalPosition) {
          const {x, y} = this.getProps(["x", "y"], useFinalPosition);
          return {x, y};
        }
        hasValue() {
          return isNumber(this.x) && isNumber(this.y);
        }
        getProps(props, final) {
          const me = this;
          const anims = this.$animations;
          if (!final || !anims) {
            return me;
          }
          const ret = {};
          props.forEach((prop) => {
            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : me[prop];
          });
          return ret;
        }
      }
      Element.defaults = {};
      Element.defaultRoutes = void 0;
      const intlCache = new Map();
      function getNumberFormat(locale, options2) {
        options2 = options2 || {};
        const cacheKey = locale + JSON.stringify(options2);
        let formatter = intlCache.get(cacheKey);
        if (!formatter) {
          formatter = new Intl.NumberFormat(locale, options2);
          intlCache.set(cacheKey, formatter);
        }
        return formatter;
      }
      function formatNumber2(num, locale, options2) {
        return getNumberFormat(locale, options2).format(num);
      }
      const formatters = {
        values(value) {
          return isArray(value) ? value : "" + value;
        },
        numeric(tickValue, index2, ticks) {
          if (tickValue === 0) {
            return "0";
          }
          const locale = this.chart.options.locale;
          let notation;
          let delta = tickValue;
          if (ticks.length > 1) {
            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
            if (maxTick < 1e-4 || maxTick > 1e15) {
              notation = "scientific";
            }
            delta = calculateDelta(tickValue, ticks);
          }
          const logDelta = log10(Math.abs(delta));
          const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
          const options2 = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};
          Object.assign(options2, this.options.ticks.format);
          return formatNumber2(tickValue, locale, options2);
        },
        logarithmic(tickValue, index2, ticks) {
          if (tickValue === 0) {
            return "0";
          }
          const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
          if (remain === 1 || remain === 2 || remain === 5) {
            return formatters.numeric.call(this, tickValue, index2, ticks);
          }
          return "";
        }
      };
      function calculateDelta(tickValue, ticks) {
        let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
        if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
          delta = tickValue - Math.floor(tickValue);
        }
        return delta;
      }
      var Ticks = {formatters};
      defaults3.set("scale", {
        display: true,
        offset: false,
        reverse: false,
        beginAtZero: false,
        bounds: "ticks",
        grace: 0,
        grid: {
          display: true,
          lineWidth: 1,
          drawBorder: true,
          drawOnChartArea: true,
          drawTicks: true,
          tickLength: 8,
          tickWidth: (_ctx, options2) => options2.lineWidth,
          tickColor: (_ctx, options2) => options2.color,
          offset: false,
          borderDash: [],
          borderDashOffset: 0,
          borderWidth: 1
        },
        title: {
          display: false,
          text: "",
          padding: {
            top: 4,
            bottom: 4
          }
        },
        ticks: {
          minRotation: 0,
          maxRotation: 50,
          mirror: false,
          textStrokeWidth: 0,
          textStrokeColor: "",
          padding: 3,
          display: true,
          autoSkip: true,
          autoSkipPadding: 3,
          labelOffset: 0,
          callback: Ticks.formatters.values,
          minor: {},
          major: {},
          align: "center",
          crossAlign: "near",
          showLabelBackdrop: false,
          backdropColor: "rgba(255, 255, 255, 0.75)",
          backdropPadding: 2
        }
      });
      defaults3.route("scale.ticks", "color", "", "color");
      defaults3.route("scale.grid", "color", "", "borderColor");
      defaults3.route("scale.grid", "borderColor", "", "borderColor");
      defaults3.route("scale.title", "color", "", "color");
      defaults3.describe("scale", {
        _fallback: false,
        _scriptable: (name2) => !name2.startsWith("before") && !name2.startsWith("after") && name2 !== "callback" && name2 !== "parser",
        _indexable: (name2) => name2 !== "borderDash" && name2 !== "tickBorderDash"
      });
      defaults3.describe("scales", {
        _fallback: "scale"
      });
      function autoSkip(scale, ticks) {
        const tickOpts = scale.options.ticks;
        const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
        const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
        const numMajorIndices = majorIndices.length;
        const first = majorIndices[0];
        const last = majorIndices[numMajorIndices - 1];
        const newTicks = [];
        if (numMajorIndices > ticksLimit) {
          skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
          return newTicks;
        }
        const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
        if (numMajorIndices > 0) {
          let i, ilen;
          const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
          skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
          for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
          }
          skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
          return newTicks;
        }
        skip(ticks, newTicks, spacing);
        return newTicks;
      }
      function determineMaxTicks(scale) {
        const offset = scale.options.offset;
        const tickLength = scale._tickSize();
        const maxScale = scale._length / tickLength + (offset ? 0 : 1);
        const maxChart = scale._maxLength / tickLength;
        return Math.floor(Math.min(maxScale, maxChart));
      }
      function calculateSpacing(majorIndices, ticks, ticksLimit) {
        const evenMajorSpacing = getEvenSpacing(majorIndices);
        const spacing = ticks.length / ticksLimit;
        if (!evenMajorSpacing) {
          return Math.max(spacing, 1);
        }
        const factors = _factorize(evenMajorSpacing);
        for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
          const factor = factors[i];
          if (factor > spacing) {
            return factor;
          }
        }
        return Math.max(spacing, 1);
      }
      function getMajorIndices(ticks) {
        const result = [];
        let i, ilen;
        for (i = 0, ilen = ticks.length; i < ilen; i++) {
          if (ticks[i].major) {
            result.push(i);
          }
        }
        return result;
      }
      function skipMajors(ticks, newTicks, majorIndices, spacing) {
        let count = 0;
        let next = majorIndices[0];
        let i;
        spacing = Math.ceil(spacing);
        for (i = 0; i < ticks.length; i++) {
          if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = majorIndices[count * spacing];
          }
        }
      }
      function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
        const start = valueOrDefault(majorStart, 0);
        const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
        let count = 0;
        let length, i, next;
        spacing = Math.ceil(spacing);
        if (majorEnd) {
          length = majorEnd - majorStart;
          spacing = length / Math.floor(length / spacing);
        }
        next = start;
        while (next < 0) {
          count++;
          next = Math.round(start + count * spacing);
        }
        for (i = Math.max(start, 0); i < end; i++) {
          if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = Math.round(start + count * spacing);
          }
        }
      }
      function getEvenSpacing(arr) {
        const len = arr.length;
        let i, diff;
        if (len < 2) {
          return false;
        }
        for (diff = arr[0], i = 1; i < len; ++i) {
          if (arr[i] - arr[i - 1] !== diff) {
            return false;
          }
        }
        return diff;
      }
      const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
      const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
      function sample(arr, numItems) {
        const result = [];
        const increment = arr.length / numItems;
        const len = arr.length;
        let i = 0;
        for (; i < len; i += increment) {
          result.push(arr[Math.floor(i)]);
        }
        return result;
      }
      function getPixelForGridLine(scale, index2, offsetGridLines) {
        const length = scale.ticks.length;
        const validIndex2 = Math.min(index2, length - 1);
        const start = scale._startPixel;
        const end = scale._endPixel;
        const epsilon = 1e-6;
        let lineValue = scale.getPixelForTick(validIndex2);
        let offset;
        if (offsetGridLines) {
          if (length === 1) {
            offset = Math.max(lineValue - start, end - lineValue);
          } else if (index2 === 0) {
            offset = (scale.getPixelForTick(1) - lineValue) / 2;
          } else {
            offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
          }
          lineValue += validIndex2 < index2 ? offset : -offset;
          if (lineValue < start - epsilon || lineValue > end + epsilon) {
            return;
          }
        }
        return lineValue;
      }
      function garbageCollect(caches, length) {
        each2(caches, (cache) => {
          const gc = cache.gc;
          const gcLen = gc.length / 2;
          let i;
          if (gcLen > length) {
            for (i = 0; i < gcLen; ++i) {
              delete cache.data[gc[i]];
            }
            gc.splice(0, gcLen);
          }
        });
      }
      function getTickMarkLength(options2) {
        return options2.drawTicks ? options2.tickLength : 0;
      }
      function getTitleHeight(options2, fallback) {
        if (!options2.display) {
          return 0;
        }
        const font = toFont(options2.font, fallback);
        const padding = toPadding(options2.padding);
        const lines = isArray(options2.text) ? options2.text.length : 1;
        return lines * font.lineHeight + padding.height;
      }
      function createScaleContext(parent, scale) {
        return Object.assign(Object.create(parent), {
          scale,
          type: "scale"
        });
      }
      function createTickContext(parent, index2, tick2) {
        return Object.assign(Object.create(parent), {
          tick: tick2,
          index: index2,
          type: "tick"
        });
      }
      function titleAlign(align, position, reverse) {
        let ret = _toLeftRightCenter(align);
        if (reverse && position !== "right" || !reverse && position === "right") {
          ret = reverseAlign(ret);
        }
        return ret;
      }
      function titleArgs(scale, offset, position, align) {
        const {top: top2, left, bottom, right} = scale;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        if (scale.isHorizontal()) {
          titleX = _alignStartEnd(align, left, right);
          titleY = offsetFromEdge(scale, position, offset);
          maxWidth = right - left;
        } else {
          titleX = offsetFromEdge(scale, position, offset);
          titleY = _alignStartEnd(align, bottom, top2);
          rotation = position === "left" ? -HALF_PI : HALF_PI;
        }
        return {titleX, titleY, maxWidth, rotation};
      }
      class Scale extends Element {
        constructor(cfg) {
          super();
          this.id = cfg.id;
          this.type = cfg.type;
          this.options = void 0;
          this.ctx = cfg.ctx;
          this.chart = cfg.chart;
          this.top = void 0;
          this.bottom = void 0;
          this.left = void 0;
          this.right = void 0;
          this.width = void 0;
          this.height = void 0;
          this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          };
          this.maxWidth = void 0;
          this.maxHeight = void 0;
          this.paddingTop = void 0;
          this.paddingBottom = void 0;
          this.paddingLeft = void 0;
          this.paddingRight = void 0;
          this.axis = void 0;
          this.labelRotation = void 0;
          this.min = void 0;
          this.max = void 0;
          this._range = void 0;
          this.ticks = [];
          this._gridLineItems = null;
          this._labelItems = null;
          this._labelSizes = null;
          this._length = 0;
          this._maxLength = 0;
          this._longestTextCache = {};
          this._startPixel = void 0;
          this._endPixel = void 0;
          this._reversePixels = false;
          this._userMax = void 0;
          this._userMin = void 0;
          this._suggestedMax = void 0;
          this._suggestedMin = void 0;
          this._ticksLength = 0;
          this._borderValue = 0;
          this._cache = {};
          this._dataLimitsCached = false;
          this.$context = void 0;
        }
        init(options2) {
          const me = this;
          me.options = options2.setContext(me.getContext());
          me.axis = options2.axis;
          me._userMin = me.parse(options2.min);
          me._userMax = me.parse(options2.max);
          me._suggestedMin = me.parse(options2.suggestedMin);
          me._suggestedMax = me.parse(options2.suggestedMax);
        }
        parse(raw, index2) {
          return raw;
        }
        getUserBounds() {
          let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;
          _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
          _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
          _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
          _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
          return {
            min: finiteOrDefault(_userMin, _suggestedMin),
            max: finiteOrDefault(_userMax, _suggestedMax),
            minDefined: isNumberFinite(_userMin),
            maxDefined: isNumberFinite(_userMax)
          };
        }
        getMinMax(canStack) {
          const me = this;
          let {min, max, minDefined, maxDefined} = me.getUserBounds();
          let range;
          if (minDefined && maxDefined) {
            return {min, max};
          }
          const metas = me.getMatchingVisibleMetas();
          for (let i = 0, ilen = metas.length; i < ilen; ++i) {
            range = metas[i].controller.getMinMax(me, canStack);
            if (!minDefined) {
              min = Math.min(min, range.min);
            }
            if (!maxDefined) {
              max = Math.max(max, range.max);
            }
          }
          return {
            min: finiteOrDefault(min, finiteOrDefault(max, min)),
            max: finiteOrDefault(max, finiteOrDefault(min, max))
          };
        }
        getPadding() {
          const me = this;
          return {
            left: me.paddingLeft || 0,
            top: me.paddingTop || 0,
            right: me.paddingRight || 0,
            bottom: me.paddingBottom || 0
          };
        }
        getTicks() {
          return this.ticks;
        }
        getLabels() {
          const data = this.chart.data;
          return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
        }
        beforeLayout() {
          this._cache = {};
          this._dataLimitsCached = false;
        }
        beforeUpdate() {
          callback(this.options.beforeUpdate, [this]);
        }
        update(maxWidth, maxHeight, margins) {
          const me = this;
          const tickOpts = me.options.ticks;
          const sampleSize = tickOpts.sampleSize;
          me.beforeUpdate();
          me.maxWidth = maxWidth;
          me.maxHeight = maxHeight;
          me._margins = margins = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }, margins);
          me.ticks = null;
          me._labelSizes = null;
          me._gridLineItems = null;
          me._labelItems = null;
          me.beforeSetDimensions();
          me.setDimensions();
          me.afterSetDimensions();
          me._maxLength = me.isHorizontal() ? me.width + margins.left + margins.right : me.height + margins.top + margins.bottom;
          if (!me._dataLimitsCached) {
            me.beforeDataLimits();
            me.determineDataLimits();
            me.afterDataLimits();
            me._range = _addGrace(me, me.options.grace);
            me._dataLimitsCached = true;
          }
          me.beforeBuildTicks();
          me.ticks = me.buildTicks() || [];
          me.afterBuildTicks();
          const samplingEnabled = sampleSize < me.ticks.length;
          me._convertTicksToLabels(samplingEnabled ? sample(me.ticks, sampleSize) : me.ticks);
          me.configure();
          me.beforeCalculateLabelRotation();
          me.calculateLabelRotation();
          me.afterCalculateLabelRotation();
          if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
            me.ticks = autoSkip(me, me.ticks);
            me._labelSizes = null;
          }
          if (samplingEnabled) {
            me._convertTicksToLabels(me.ticks);
          }
          me.beforeFit();
          me.fit();
          me.afterFit();
          me.afterUpdate();
        }
        configure() {
          const me = this;
          let reversePixels = me.options.reverse;
          let startPixel, endPixel;
          if (me.isHorizontal()) {
            startPixel = me.left;
            endPixel = me.right;
          } else {
            startPixel = me.top;
            endPixel = me.bottom;
            reversePixels = !reversePixels;
          }
          me._startPixel = startPixel;
          me._endPixel = endPixel;
          me._reversePixels = reversePixels;
          me._length = endPixel - startPixel;
          me._alignToPixels = me.options.alignToPixels;
        }
        afterUpdate() {
          callback(this.options.afterUpdate, [this]);
        }
        beforeSetDimensions() {
          callback(this.options.beforeSetDimensions, [this]);
        }
        setDimensions() {
          const me = this;
          if (me.isHorizontal()) {
            me.width = me.maxWidth;
            me.left = 0;
            me.right = me.width;
          } else {
            me.height = me.maxHeight;
            me.top = 0;
            me.bottom = me.height;
          }
          me.paddingLeft = 0;
          me.paddingTop = 0;
          me.paddingRight = 0;
          me.paddingBottom = 0;
        }
        afterSetDimensions() {
          callback(this.options.afterSetDimensions, [this]);
        }
        _callHooks(name2) {
          const me = this;
          me.chart.notifyPlugins(name2, me.getContext());
          callback(me.options[name2], [me]);
        }
        beforeDataLimits() {
          this._callHooks("beforeDataLimits");
        }
        determineDataLimits() {
        }
        afterDataLimits() {
          this._callHooks("afterDataLimits");
        }
        beforeBuildTicks() {
          this._callHooks("beforeBuildTicks");
        }
        buildTicks() {
          return [];
        }
        afterBuildTicks() {
          this._callHooks("afterBuildTicks");
        }
        beforeTickToLabelConversion() {
          callback(this.options.beforeTickToLabelConversion, [this]);
        }
        generateTickLabels(ticks) {
          const me = this;
          const tickOpts = me.options.ticks;
          let i, ilen, tick2;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            tick2 = ticks[i];
            tick2.label = callback(tickOpts.callback, [tick2.value, i, ticks], me);
          }
          for (i = 0; i < ilen; i++) {
            if (isNullOrUndef(ticks[i].label)) {
              ticks.splice(i, 1);
              ilen--;
              i--;
            }
          }
        }
        afterTickToLabelConversion() {
          callback(this.options.afterTickToLabelConversion, [this]);
        }
        beforeCalculateLabelRotation() {
          callback(this.options.beforeCalculateLabelRotation, [this]);
        }
        calculateLabelRotation() {
          const me = this;
          const options2 = me.options;
          const tickOpts = options2.ticks;
          const numTicks = me.ticks.length;
          const minRotation = tickOpts.minRotation || 0;
          const maxRotation = tickOpts.maxRotation;
          let labelRotation = minRotation;
          let tickWidth, maxHeight, maxLabelDiagonal;
          if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {
            me.labelRotation = minRotation;
            return;
          }
          const labelSizes = me._getLabelSizes();
          const maxLabelWidth = labelSizes.widest.width;
          const maxLabelHeight = labelSizes.highest.height;
          const maxWidth = _limitValue(me.chart.width - maxLabelWidth, 0, me.maxWidth);
          tickWidth = options2.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);
          if (maxLabelWidth + 6 > tickWidth) {
            tickWidth = maxWidth / (numTicks - (options2.offset ? 0.5 : 1));
            maxHeight = me.maxHeight - getTickMarkLength(options2.grid) - tickOpts.padding - getTitleHeight(options2.title, me.chart.options.font);
            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
            labelRotation = toDegrees(Math.min(Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)), Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)));
            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
          }
          me.labelRotation = labelRotation;
        }
        afterCalculateLabelRotation() {
          callback(this.options.afterCalculateLabelRotation, [this]);
        }
        beforeFit() {
          callback(this.options.beforeFit, [this]);
        }
        fit() {
          const me = this;
          const minSize = {
            width: 0,
            height: 0
          };
          const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = me;
          const display = me._isVisible();
          const isHorizontal = me.isHorizontal();
          if (display) {
            const titleHeight = getTitleHeight(titleOpts, chart.options.font);
            if (isHorizontal) {
              minSize.width = me.maxWidth;
              minSize.height = getTickMarkLength(gridOpts) + titleHeight;
            } else {
              minSize.height = me.maxHeight;
              minSize.width = getTickMarkLength(gridOpts) + titleHeight;
            }
            if (tickOpts.display && me.ticks.length) {
              const {first, last, widest, highest} = me._getLabelSizes();
              const tickPadding = tickOpts.padding * 2;
              const angleRadians = toRadians(me.labelRotation);
              const cos = Math.cos(angleRadians);
              const sin = Math.sin(angleRadians);
              if (isHorizontal) {
                const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
              } else {
                const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth + tickPadding);
              }
              me._calculatePadding(first, last, sin, cos);
            }
          }
          me._handleMargins();
          if (isHorizontal) {
            me.width = me._length = chart.width - me._margins.left - me._margins.right;
            me.height = minSize.height;
          } else {
            me.width = minSize.width;
            me.height = me._length = chart.height - me._margins.top - me._margins.bottom;
          }
        }
        _calculatePadding(first, last, sin, cos) {
          const me = this;
          const {ticks: {align, padding}, position} = me.options;
          const isRotated = me.labelRotation !== 0;
          const labelsBelowTicks = position !== "top" && me.axis === "x";
          if (me.isHorizontal()) {
            const offsetLeft = me.getPixelForTick(0) - me.left;
            const offsetRight = me.right - me.getPixelForTick(me.ticks.length - 1);
            let paddingLeft = 0;
            let paddingRight = 0;
            if (isRotated) {
              if (labelsBelowTicks) {
                paddingLeft = cos * first.width;
                paddingRight = sin * last.height;
              } else {
                paddingLeft = sin * first.height;
                paddingRight = cos * last.width;
              }
            } else if (align === "start") {
              paddingRight = last.width;
            } else if (align === "end") {
              paddingLeft = first.width;
            } else {
              paddingLeft = first.width / 2;
              paddingRight = last.width / 2;
            }
            me.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * me.width / (me.width - offsetLeft), 0);
            me.paddingRight = Math.max((paddingRight - offsetRight + padding) * me.width / (me.width - offsetRight), 0);
          } else {
            let paddingTop = last.height / 2;
            let paddingBottom = first.height / 2;
            if (align === "start") {
              paddingTop = 0;
              paddingBottom = first.height;
            } else if (align === "end") {
              paddingTop = last.height;
              paddingBottom = 0;
            }
            me.paddingTop = paddingTop + padding;
            me.paddingBottom = paddingBottom + padding;
          }
        }
        _handleMargins() {
          const me = this;
          if (me._margins) {
            me._margins.left = Math.max(me.paddingLeft, me._margins.left);
            me._margins.top = Math.max(me.paddingTop, me._margins.top);
            me._margins.right = Math.max(me.paddingRight, me._margins.right);
            me._margins.bottom = Math.max(me.paddingBottom, me._margins.bottom);
          }
        }
        afterFit() {
          callback(this.options.afterFit, [this]);
        }
        isHorizontal() {
          const {axis, position} = this.options;
          return position === "top" || position === "bottom" || axis === "x";
        }
        isFullSize() {
          return this.options.fullSize;
        }
        _convertTicksToLabels(ticks) {
          const me = this;
          me.beforeTickToLabelConversion();
          me.generateTickLabels(ticks);
          me.afterTickToLabelConversion();
        }
        _getLabelSizes() {
          const me = this;
          let labelSizes = me._labelSizes;
          if (!labelSizes) {
            const sampleSize = me.options.ticks.sampleSize;
            let ticks = me.ticks;
            if (sampleSize < ticks.length) {
              ticks = sample(ticks, sampleSize);
            }
            me._labelSizes = labelSizes = me._computeLabelSizes(ticks, ticks.length);
          }
          return labelSizes;
        }
        _computeLabelSizes(ticks, length) {
          const {ctx, _longestTextCache: caches} = this;
          const widths = [];
          const heights = [];
          let widestLabelSize = 0;
          let highestLabelSize = 0;
          let i, j, jlen, label, tickFont, fontString2, cache, lineHeight, width, height, nestedLabel;
          for (i = 0; i < length; ++i) {
            label = ticks[i].label;
            tickFont = this._resolveTickFontOptions(i);
            ctx.font = fontString2 = tickFont.string;
            cache = caches[fontString2] = caches[fontString2] || {data: {}, gc: []};
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!isNullOrUndef(label) && !isArray(label)) {
              width = _measureText(ctx, cache.data, cache.gc, width, label);
              height = lineHeight;
            } else if (isArray(label)) {
              for (j = 0, jlen = label.length; j < jlen; ++j) {
                nestedLabel = label[j];
                if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                  width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                  height += lineHeight;
                }
              }
            }
            widths.push(width);
            heights.push(height);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
          }
          garbageCollect(caches, length);
          const widest = widths.indexOf(widestLabelSize);
          const highest = heights.indexOf(highestLabelSize);
          const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});
          return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest),
            widths,
            heights
          };
        }
        getLabelForValue(value) {
          return value;
        }
        getPixelForValue(value, index2) {
          return NaN;
        }
        getValueForPixel(pixel) {
        }
        getPixelForTick(index2) {
          const ticks = this.ticks;
          if (index2 < 0 || index2 > ticks.length - 1) {
            return null;
          }
          return this.getPixelForValue(ticks[index2].value);
        }
        getPixelForDecimal(decimal) {
          const me = this;
          if (me._reversePixels) {
            decimal = 1 - decimal;
          }
          const pixel = me._startPixel + decimal * me._length;
          return _int16Range(me._alignToPixels ? _alignPixel(me.chart, pixel, 0) : pixel);
        }
        getDecimalForPixel(pixel) {
          const decimal = (pixel - this._startPixel) / this._length;
          return this._reversePixels ? 1 - decimal : decimal;
        }
        getBasePixel() {
          return this.getPixelForValue(this.getBaseValue());
        }
        getBaseValue() {
          const {min, max} = this;
          return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
        }
        getContext(index2) {
          const me = this;
          const ticks = me.ticks || [];
          if (index2 >= 0 && index2 < ticks.length) {
            const tick2 = ticks[index2];
            return tick2.$context || (tick2.$context = createTickContext(me.getContext(), index2, tick2));
          }
          return me.$context || (me.$context = createScaleContext(me.chart.getContext(), me));
        }
        _tickSize() {
          const me = this;
          const optionTicks = me.options.ticks;
          const rot = toRadians(me.labelRotation);
          const cos = Math.abs(Math.cos(rot));
          const sin = Math.abs(Math.sin(rot));
          const labelSizes = me._getLabelSizes();
          const padding = optionTicks.autoSkipPadding || 0;
          const w = labelSizes ? labelSizes.widest.width + padding : 0;
          const h = labelSizes ? labelSizes.highest.height + padding : 0;
          return me.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
        }
        _isVisible() {
          const display = this.options.display;
          if (display !== "auto") {
            return !!display;
          }
          return this.getMatchingVisibleMetas().length > 0;
        }
        _computeGridLineItems(chartArea) {
          const me = this;
          const axis = me.axis;
          const chart = me.chart;
          const options2 = me.options;
          const {grid, position} = options2;
          const offset = grid.offset;
          const isHorizontal = me.isHorizontal();
          const ticks = me.ticks;
          const ticksLength = ticks.length + (offset ? 1 : 0);
          const tl = getTickMarkLength(grid);
          const items = [];
          const borderOpts = grid.setContext(me.getContext());
          const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
          const axisHalfWidth = axisWidth / 2;
          const alignBorderValue = function(pixel) {
            return _alignPixel(chart, pixel, axisWidth);
          };
          let borderValue, i, lineValue, alignedLineValue;
          let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
          if (position === "top") {
            borderValue = alignBorderValue(me.bottom);
            ty1 = me.bottom - tl;
            ty2 = borderValue - axisHalfWidth;
            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
            y2 = chartArea.bottom;
          } else if (position === "bottom") {
            borderValue = alignBorderValue(me.top);
            y1 = chartArea.top;
            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
            ty1 = borderValue + axisHalfWidth;
            ty2 = me.top + tl;
          } else if (position === "left") {
            borderValue = alignBorderValue(me.right);
            tx1 = me.right - tl;
            tx2 = borderValue - axisHalfWidth;
            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
            x2 = chartArea.right;
          } else if (position === "right") {
            borderValue = alignBorderValue(me.left);
            x1 = chartArea.left;
            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
            tx1 = borderValue + axisHalfWidth;
            tx2 = me.left + tl;
          } else if (axis === "x") {
            if (position === "center") {
              borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
            } else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));
            }
            y1 = chartArea.top;
            y2 = chartArea.bottom;
            ty1 = borderValue + axisHalfWidth;
            ty2 = ty1 + tl;
          } else if (axis === "y") {
            if (position === "center") {
              borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
            } else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));
            }
            tx1 = borderValue - axisHalfWidth;
            tx2 = tx1 - tl;
            x1 = chartArea.left;
            x2 = chartArea.right;
          }
          for (i = 0; i < ticksLength; ++i) {
            const optsAtIndex = grid.setContext(me.getContext(i));
            const lineWidth = optsAtIndex.lineWidth;
            const lineColor = optsAtIndex.color;
            const borderDash = grid.borderDash || [];
            const borderDashOffset = optsAtIndex.borderDashOffset;
            const tickWidth = optsAtIndex.tickWidth;
            const tickColor = optsAtIndex.tickColor;
            const tickBorderDash = optsAtIndex.tickBorderDash || [];
            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
            lineValue = getPixelForGridLine(me, i, offset);
            if (lineValue === void 0) {
              continue;
            }
            alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
            if (isHorizontal) {
              tx1 = tx2 = x1 = x2 = alignedLineValue;
            } else {
              ty1 = ty2 = y1 = y2 = alignedLineValue;
            }
            items.push({
              tx1,
              ty1,
              tx2,
              ty2,
              x1,
              y1,
              x2,
              y2,
              width: lineWidth,
              color: lineColor,
              borderDash,
              borderDashOffset,
              tickWidth,
              tickColor,
              tickBorderDash,
              tickBorderDashOffset
            });
          }
          me._ticksLength = ticksLength;
          me._borderValue = borderValue;
          return items;
        }
        _computeLabelItems(chartArea) {
          const me = this;
          const axis = me.axis;
          const options2 = me.options;
          const {position, ticks: optionTicks} = options2;
          const isHorizontal = me.isHorizontal();
          const ticks = me.ticks;
          const {align, crossAlign, padding, mirror} = optionTicks;
          const tl = getTickMarkLength(options2.grid);
          const tickAndPadding = tl + padding;
          const hTickAndPadding = mirror ? -padding : tickAndPadding;
          const rotation = -toRadians(me.labelRotation);
          const items = [];
          let i, ilen, tick2, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
          let textBaseline = "middle";
          if (position === "top") {
            y = me.bottom - hTickAndPadding;
            textAlign = me._getXAxisLabelAlignment();
          } else if (position === "bottom") {
            y = me.top + hTickAndPadding;
            textAlign = me._getXAxisLabelAlignment();
          } else if (position === "left") {
            const ret = me._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
          } else if (position === "right") {
            const ret = me._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
          } else if (axis === "x") {
            if (position === "center") {
              y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
            } else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              y = me.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
            }
            textAlign = me._getXAxisLabelAlignment();
          } else if (axis === "y") {
            if (position === "center") {
              x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
            } else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              x = me.chart.scales[positionAxisID].getPixelForValue(value);
            }
            textAlign = me._getYAxisLabelAlignment(tl).textAlign;
          }
          if (axis === "y") {
            if (align === "start") {
              textBaseline = "top";
            } else if (align === "end") {
              textBaseline = "bottom";
            }
          }
          const labelSizes = me._getLabelSizes();
          for (i = 0, ilen = ticks.length; i < ilen; ++i) {
            tick2 = ticks[i];
            label = tick2.label;
            const optsAtIndex = optionTicks.setContext(me.getContext(i));
            pixel = me.getPixelForTick(i) + optionTicks.labelOffset;
            font = me._resolveTickFontOptions(i);
            lineHeight = font.lineHeight;
            lineCount = isArray(label) ? label.length : 1;
            const halfCount = lineCount / 2;
            const color2 = optsAtIndex.color;
            const strokeColor = optsAtIndex.textStrokeColor;
            const strokeWidth = optsAtIndex.textStrokeWidth;
            if (isHorizontal) {
              x = pixel;
              if (position === "top") {
                if (crossAlign === "near" || rotation !== 0) {
                  textOffset = -lineCount * lineHeight + lineHeight / 2;
                } else if (crossAlign === "center") {
                  textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                } else {
                  textOffset = -labelSizes.highest.height + lineHeight / 2;
                }
              } else {
                if (crossAlign === "near" || rotation !== 0) {
                  textOffset = lineHeight / 2;
                } else if (crossAlign === "center") {
                  textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                } else {
                  textOffset = labelSizes.highest.height - lineCount * lineHeight;
                }
              }
              if (mirror) {
                textOffset *= -1;
              }
            } else {
              y = pixel;
              textOffset = (1 - lineCount) * lineHeight / 2;
            }
            let backdrop;
            if (optsAtIndex.showLabelBackdrop) {
              const labelPadding = toPadding(optsAtIndex.backdropPadding);
              const height = labelSizes.heights[i];
              const width = labelSizes.widths[i];
              let top2 = y + textOffset - labelPadding.top;
              let left = x - labelPadding.left;
              switch (textBaseline) {
                case "middle":
                  top2 -= height / 2;
                  break;
                case "bottom":
                  top2 -= height;
                  break;
              }
              switch (textAlign) {
                case "center":
                  left -= width / 2;
                  break;
                case "right":
                  left -= width;
                  break;
              }
              backdrop = {
                left,
                top: top2,
                width: width + labelPadding.width,
                height: height + labelPadding.height,
                color: optsAtIndex.backdropColor
              };
            }
            items.push({
              rotation,
              label,
              font,
              color: color2,
              strokeColor,
              strokeWidth,
              textOffset,
              textAlign,
              textBaseline,
              translation: [x, y],
              backdrop
            });
          }
          return items;
        }
        _getXAxisLabelAlignment() {
          const me = this;
          const {position, ticks} = me.options;
          const rotation = -toRadians(me.labelRotation);
          if (rotation) {
            return position === "top" ? "left" : "right";
          }
          let align = "center";
          if (ticks.align === "start") {
            align = "left";
          } else if (ticks.align === "end") {
            align = "right";
          }
          return align;
        }
        _getYAxisLabelAlignment(tl) {
          const me = this;
          const {position, ticks: {crossAlign, mirror, padding}} = me.options;
          const labelSizes = me._getLabelSizes();
          const tickAndPadding = tl + padding;
          const widest = labelSizes.widest.width;
          let textAlign;
          let x;
          if (position === "left") {
            if (mirror) {
              textAlign = "left";
              x = me.right + padding;
            } else {
              x = me.right - tickAndPadding;
              if (crossAlign === "near") {
                textAlign = "right";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x -= widest / 2;
              } else {
                textAlign = "left";
                x = me.left;
              }
            }
          } else if (position === "right") {
            if (mirror) {
              textAlign = "right";
              x = me.left + padding;
            } else {
              x = me.left + tickAndPadding;
              if (crossAlign === "near") {
                textAlign = "left";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x += widest / 2;
              } else {
                textAlign = "right";
                x = me.right;
              }
            }
          } else {
            textAlign = "right";
          }
          return {textAlign, x};
        }
        _computeLabelArea() {
          const me = this;
          if (me.options.ticks.mirror) {
            return;
          }
          const chart = me.chart;
          const position = me.options.position;
          if (position === "left" || position === "right") {
            return {top: 0, left: me.left, bottom: chart.height, right: me.right};
          }
          if (position === "top" || position === "bottom") {
            return {top: me.top, left: 0, bottom: me.bottom, right: chart.width};
          }
        }
        drawBackground() {
          const {ctx, options: {backgroundColor}, left, top: top2, width, height} = this;
          if (backgroundColor) {
            ctx.save();
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(left, top2, width, height);
            ctx.restore();
          }
        }
        getLineWidthForValue(value) {
          const me = this;
          const grid = me.options.grid;
          if (!me._isVisible() || !grid.display) {
            return 0;
          }
          const ticks = me.ticks;
          const index2 = ticks.findIndex((t2) => t2.value === value);
          if (index2 >= 0) {
            const opts = grid.setContext(me.getContext(index2));
            return opts.lineWidth;
          }
          return 0;
        }
        drawGrid(chartArea) {
          const me = this;
          const grid = me.options.grid;
          const ctx = me.ctx;
          const items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));
          let i, ilen;
          const drawLine = (p1, p2, style) => {
            if (!style.width || !style.color) {
              return;
            }
            ctx.save();
            ctx.lineWidth = style.width;
            ctx.strokeStyle = style.color;
            ctx.setLineDash(style.borderDash || []);
            ctx.lineDashOffset = style.borderDashOffset;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.restore();
          };
          if (grid.display) {
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              const item = items[i];
              if (grid.drawOnChartArea) {
                drawLine({x: item.x1, y: item.y1}, {x: item.x2, y: item.y2}, item);
              }
              if (grid.drawTicks) {
                drawLine({x: item.tx1, y: item.ty1}, {x: item.tx2, y: item.ty2}, {
                  color: item.tickColor,
                  width: item.tickWidth,
                  borderDash: item.tickBorderDash,
                  borderDashOffset: item.tickBorderDashOffset
                });
              }
            }
          }
        }
        drawBorder() {
          const me = this;
          const {chart, ctx, options: {grid}} = me;
          const borderOpts = grid.setContext(me.getContext());
          const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
          if (!axisWidth) {
            return;
          }
          const lastLineWidth = grid.setContext(me.getContext(0)).lineWidth;
          const borderValue = me._borderValue;
          let x1, x2, y1, y2;
          if (me.isHorizontal()) {
            x1 = _alignPixel(chart, me.left, axisWidth) - axisWidth / 2;
            x2 = _alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
          } else {
            y1 = _alignPixel(chart, me.top, axisWidth) - axisWidth / 2;
            y2 = _alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
          }
          ctx.save();
          ctx.lineWidth = borderOpts.borderWidth;
          ctx.strokeStyle = borderOpts.borderColor;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.restore();
        }
        drawLabels(chartArea) {
          const me = this;
          const optionTicks = me.options.ticks;
          if (!optionTicks.display) {
            return;
          }
          const ctx = me.ctx;
          const area = me._computeLabelArea();
          if (area) {
            clipArea(ctx, area);
          }
          const items = me._labelItems || (me._labelItems = me._computeLabelItems(chartArea));
          let i, ilen;
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            const item = items[i];
            const tickFont = item.font;
            const label = item.label;
            if (item.backdrop) {
              ctx.fillStyle = item.backdrop.color;
              ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
            }
            let y = item.textOffset;
            renderText(ctx, label, 0, y, tickFont, item);
          }
          if (area) {
            unclipArea(ctx);
          }
        }
        drawTitle() {
          const {ctx, options: {position, title, reverse}} = this;
          if (!title.display) {
            return;
          }
          const font = toFont(title.font);
          const padding = toPadding(title.padding);
          const align = title.align;
          let offset = font.lineHeight / 2;
          if (position === "bottom") {
            offset += padding.bottom;
            if (isArray(title.text)) {
              offset += font.lineHeight * (title.text.length - 1);
            }
          } else {
            offset += padding.top;
          }
          const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);
          renderText(ctx, title.text, 0, 0, font, {
            color: title.color,
            maxWidth,
            rotation,
            textAlign: titleAlign(align, position, reverse),
            textBaseline: "middle",
            translation: [titleX, titleY]
          });
        }
        draw(chartArea) {
          const me = this;
          if (!me._isVisible()) {
            return;
          }
          me.drawBackground();
          me.drawGrid(chartArea);
          me.drawBorder();
          me.drawTitle();
          me.drawLabels(chartArea);
        }
        _layers() {
          const me = this;
          const opts = me.options;
          const tz = opts.ticks && opts.ticks.z || 0;
          const gz = opts.grid && opts.grid.z || 0;
          if (!me._isVisible() || me.draw !== Scale.prototype.draw) {
            return [{
              z: tz,
              draw(chartArea) {
                me.draw(chartArea);
              }
            }];
          }
          return [{
            z: gz,
            draw(chartArea) {
              me.drawBackground();
              me.drawGrid(chartArea);
              me.drawTitle();
            }
          }, {
            z: gz + 1,
            draw() {
              me.drawBorder();
            }
          }, {
            z: tz,
            draw(chartArea) {
              me.drawLabels(chartArea);
            }
          }];
        }
        getMatchingVisibleMetas(type) {
          const me = this;
          const metas = me.chart.getSortedVisibleDatasetMetas();
          const axisID = me.axis + "AxisID";
          const result = [];
          let i, ilen;
          for (i = 0, ilen = metas.length; i < ilen; ++i) {
            const meta2 = metas[i];
            if (meta2[axisID] === me.id && (!type || meta2.type === type)) {
              result.push(meta2);
            }
          }
          return result;
        }
        _resolveTickFontOptions(index2) {
          const opts = this.options.ticks.setContext(this.getContext(index2));
          return toFont(opts.font);
        }
        _maxDigits() {
          const me = this;
          const fontSize = me._resolveTickFontOptions(0).lineHeight;
          return (me.isHorizontal() ? me.width : me.height) / fontSize;
        }
      }
      function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget2 = () => scopes[0]) {
        if (!defined(fallback)) {
          fallback = _resolve("_fallback", scopes);
        }
        const cache = {
          [Symbol.toStringTag]: "Object",
          _cacheable: true,
          _scopes: scopes,
          _rootScopes: rootScopes,
          _fallback: fallback,
          _getTarget: getTarget2,
          override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
        };
        return new Proxy(cache, {
          deleteProperty(target, prop) {
            delete target[prop];
            delete target._keys;
            delete scopes[0][prop];
            return true;
          },
          get(target, prop) {
            return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
          },
          getOwnPropertyDescriptor(target, prop) {
            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
          },
          getPrototypeOf() {
            return Reflect.getPrototypeOf(scopes[0]);
          },
          has(target, prop) {
            return getKeysFromAllScopes(target).includes(prop);
          },
          ownKeys(target) {
            return getKeysFromAllScopes(target);
          },
          set(target, prop, value) {
            const storage = target._storage || (target._storage = getTarget2());
            storage[prop] = value;
            delete target[prop];
            delete target._keys;
            return true;
          }
        });
      }
      function _attachContext(proxy, context, subProxy, descriptorDefaults) {
        const cache = {
          _cacheable: false,
          _proxy: proxy,
          _context: context,
          _subProxy: subProxy,
          _stack: new Set(),
          _descriptors: _descriptors(proxy, descriptorDefaults),
          setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
          override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
        };
        return new Proxy(cache, {
          deleteProperty(target, prop) {
            delete target[prop];
            delete proxy[prop];
            return true;
          },
          get(target, prop, receiver) {
            return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
          },
          getOwnPropertyDescriptor(target, prop) {
            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
          },
          getPrototypeOf() {
            return Reflect.getPrototypeOf(proxy);
          },
          has(target, prop) {
            return Reflect.has(proxy, prop);
          },
          ownKeys() {
            return Reflect.ownKeys(proxy);
          },
          set(target, prop, value) {
            proxy[prop] = value;
            delete target[prop];
            return true;
          }
        });
      }
      function _descriptors(proxy, defaults4 = {scriptable: true, indexable: true}) {
        const {_scriptable = defaults4.scriptable, _indexable = defaults4.indexable, _allKeys = defaults4.allKeys} = proxy;
        return {
          allKeys: _allKeys,
          scriptable: _scriptable,
          indexable: _indexable,
          isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
          isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
        };
      }
      const readKey = (prefix, name2) => prefix ? prefix + _capitalize(name2) : name2;
      const needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters";
      function _cached(target, prop, resolve3) {
        let value = target[prop];
        if (defined(value)) {
          return value;
        }
        value = resolve3();
        if (defined(value)) {
          target[prop] = value;
        }
        return value;
      }
      function _resolveWithContext(target, prop, receiver) {
        const {_proxy, _context, _subProxy, _descriptors: descriptors2} = target;
        let value = _proxy[prop];
        if (isFunction(value) && descriptors2.isScriptable(prop)) {
          value = _resolveScriptable(prop, value, target, receiver);
        }
        if (isArray(value) && value.length) {
          value = _resolveArray(prop, value, target, descriptors2.isIndexable);
        }
        if (needsSubResolver(prop, value)) {
          value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
        }
        return value;
      }
      function _resolveScriptable(prop, value, target, receiver) {
        const {_proxy, _context, _subProxy, _stack} = target;
        if (_stack.has(prop)) {
          throw new Error("Recursion detected: " + [..._stack].join("->") + "->" + prop);
        }
        _stack.add(prop);
        value = value(_context, _subProxy || receiver);
        _stack.delete(prop);
        if (isObject(value)) {
          value = createSubResolver(_proxy._scopes, _proxy, prop, value);
        }
        return value;
      }
      function _resolveArray(prop, value, target, isIndexable) {
        const {_proxy, _context, _subProxy, _descriptors: descriptors2} = target;
        if (defined(_context.index) && isIndexable(prop)) {
          value = value[_context.index % value.length];
        } else if (isObject(value[0])) {
          const arr = value;
          const scopes = _proxy._scopes.filter((s2) => s2 !== arr);
          value = [];
          for (const item of arr) {
            const resolver = createSubResolver(scopes, _proxy, prop, item);
            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
          }
        }
        return value;
      }
      function resolveFallback(fallback, prop, value) {
        return isFunction(fallback) ? fallback(prop, value) : fallback;
      }
      const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
      function addScopes(set2, parentScopes, key, parentFallback) {
        for (const parent of parentScopes) {
          const scope = getScope(key, parent);
          if (scope) {
            set2.add(scope);
            const fallback = resolveFallback(scope._fallback, key, scope);
            if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
              return fallback;
            }
          } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
            return null;
          }
        }
        return false;
      }
      function createSubResolver(parentScopes, resolver, prop, value) {
        const rootScopes = resolver._rootScopes;
        const fallback = resolveFallback(resolver._fallback, prop, value);
        const allScopes = [...parentScopes, ...rootScopes];
        const set2 = new Set();
        set2.add(value);
        let key = addScopesFromKey(set2, allScopes, prop, fallback || prop);
        if (key === null) {
          return false;
        }
        if (defined(fallback) && fallback !== prop) {
          key = addScopesFromKey(set2, allScopes, fallback, key);
          if (key === null) {
            return false;
          }
        }
        return _createResolver([...set2], [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
      }
      function addScopesFromKey(set2, allScopes, key, fallback) {
        while (key) {
          key = addScopes(set2, allScopes, key, fallback);
        }
        return key;
      }
      function subGetTarget(resolver, prop, value) {
        const parent = resolver._getTarget();
        if (!(prop in parent)) {
          parent[prop] = {};
        }
        const target = parent[prop];
        if (isArray(target) && isObject(value)) {
          return value;
        }
        return target;
      }
      function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
        let value;
        for (const prefix of prefixes) {
          value = _resolve(readKey(prefix, prop), scopes);
          if (defined(value)) {
            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
          }
        }
      }
      function _resolve(key, scopes) {
        for (const scope of scopes) {
          if (!scope) {
            continue;
          }
          const value = scope[key];
          if (defined(value)) {
            return value;
          }
        }
      }
      function getKeysFromAllScopes(target) {
        let keys = target._keys;
        if (!keys) {
          keys = target._keys = resolveKeysFromAllScopes(target._scopes);
        }
        return keys;
      }
      function resolveKeysFromAllScopes(scopes) {
        const set2 = new Set();
        for (const scope of scopes) {
          for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
            set2.add(key);
          }
        }
        return [...set2];
      }
      const EPSILON = Number.EPSILON || 1e-14;
      const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
      const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
      function splineCurve(firstPoint, middlePoint, afterPoint, t2) {
        const previous = firstPoint.skip ? middlePoint : firstPoint;
        const current = middlePoint;
        const next = afterPoint.skip ? middlePoint : afterPoint;
        const d01 = distanceBetweenPoints(current, previous);
        const d12 = distanceBetweenPoints(next, current);
        let s01 = d01 / (d01 + d12);
        let s12 = d12 / (d01 + d12);
        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        const fa = t2 * s01;
        const fb = t2 * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
          }
        };
      }
      function monotoneAdjust(points, deltaK, mK) {
        const pointsLen = points.length;
        let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for (let i = 0; i < pointsLen - 1; ++i) {
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);
          if (!pointCurrent || !pointAfter) {
            continue;
          }
          if (almostEquals(deltaK[i], 0, EPSILON)) {
            mK[i] = mK[i + 1] = 0;
            continue;
          }
          alphaK = mK[i] / deltaK[i];
          betaK = mK[i + 1] / deltaK[i];
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
          if (squaredMagnitude <= 9) {
            continue;
          }
          tauK = 3 / Math.sqrt(squaredMagnitude);
          mK[i] = alphaK * tauK * deltaK[i];
          mK[i + 1] = betaK * tauK * deltaK[i];
        }
      }
      function monotoneCompute(points, mK, indexAxis = "x") {
        const valueAxis = getValueAxis(indexAxis);
        const pointsLen = points.length;
        let delta, pointBefore, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for (let i = 0; i < pointsLen; ++i) {
          pointBefore = pointCurrent;
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);
          if (!pointCurrent) {
            continue;
          }
          const iPixel = pointCurrent[indexAxis];
          const vPixel = pointCurrent[valueAxis];
          if (pointBefore) {
            delta = (iPixel - pointBefore[indexAxis]) / 3;
            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
          }
          if (pointAfter) {
            delta = (pointAfter[indexAxis] - iPixel) / 3;
            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
          }
        }
      }
      function splineCurveMonotone(points, indexAxis = "x") {
        const valueAxis = getValueAxis(indexAxis);
        const pointsLen = points.length;
        const deltaK = Array(pointsLen).fill(0);
        const mK = Array(pointsLen);
        let i, pointBefore, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for (i = 0; i < pointsLen; ++i) {
          pointBefore = pointCurrent;
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);
          if (!pointCurrent) {
            continue;
          }
          if (pointAfter) {
            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
          }
          mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
        }
        monotoneAdjust(points, deltaK, mK);
        monotoneCompute(points, mK, indexAxis);
      }
      function capControlPoint(pt, min, max) {
        return Math.max(Math.min(pt, max), min);
      }
      function capBezierPoints(points, area) {
        let i, ilen, point, inArea, inAreaPrev;
        let inAreaNext = _isPointInArea(points[0], area);
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          inAreaPrev = inArea;
          inArea = inAreaNext;
          inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
          if (!inArea) {
            continue;
          }
          point = points[i];
          if (inAreaPrev) {
            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
          }
          if (inAreaNext) {
            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
          }
        }
      }
      function _updateBezierControlPoints(points, options2, area, loop, indexAxis) {
        let i, ilen, point, controlPoints;
        if (options2.spanGaps) {
          points = points.filter((pt) => !pt.skip);
        }
        if (options2.cubicInterpolationMode === "monotone") {
          splineCurveMonotone(points, indexAxis);
        } else {
          let prev = loop ? points[points.length - 1] : points[0];
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            point = points[i];
            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options2.tension);
            point.cp1x = controlPoints.previous.x;
            point.cp1y = controlPoints.previous.y;
            point.cp2x = controlPoints.next.x;
            point.cp2y = controlPoints.next.y;
            prev = point;
          }
        }
        if (options2.capBezierPoints) {
          capBezierPoints(points, area);
        }
      }
      function _pointInLine(p1, p2, t2, mode) {
        return {
          x: p1.x + t2 * (p2.x - p1.x),
          y: p1.y + t2 * (p2.y - p1.y)
        };
      }
      function _steppedInterpolation(p1, p2, t2, mode) {
        return {
          x: p1.x + t2 * (p2.x - p1.x),
          y: mode === "middle" ? t2 < 0.5 ? p1.y : p2.y : mode === "after" ? t2 < 1 ? p1.y : p2.y : t2 > 0 ? p2.y : p1.y
        };
      }
      function _bezierInterpolation(p1, p2, t2, mode) {
        const cp1 = {x: p1.cp2x, y: p1.cp2y};
        const cp2 = {x: p2.cp1x, y: p2.cp1y};
        const a = _pointInLine(p1, cp1, t2);
        const b = _pointInLine(cp1, cp2, t2);
        const c = _pointInLine(cp2, p2, t2);
        const d = _pointInLine(a, b, t2);
        const e = _pointInLine(b, c, t2);
        return _pointInLine(d, e, t2);
      }
      const getRightToLeftAdapter = function(rectX, width) {
        return {
          x(x) {
            return rectX + rectX + width - x;
          },
          setWidth(w) {
            width = w;
          },
          textAlign(align) {
            if (align === "center") {
              return align;
            }
            return align === "right" ? "left" : "right";
          },
          xPlus(x, value) {
            return x - value;
          },
          leftForLtr(x, itemWidth) {
            return x - itemWidth;
          }
        };
      };
      const getLeftToRightAdapter = function() {
        return {
          x(x) {
            return x;
          },
          setWidth(w) {
          },
          textAlign(align) {
            return align;
          },
          xPlus(x, value) {
            return x + value;
          },
          leftForLtr(x, _itemWidth) {
            return x;
          }
        };
      };
      function getRtlAdapter(rtl, rectX, width) {
        return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
      }
      function overrideTextDirection(ctx, direction) {
        let style, original;
        if (direction === "ltr" || direction === "rtl") {
          style = ctx.canvas.style;
          original = [
            style.getPropertyValue("direction"),
            style.getPropertyPriority("direction")
          ];
          style.setProperty("direction", direction, "important");
          ctx.prevTextDirection = original;
        }
      }
      function restoreTextDirection(ctx, original) {
        if (original !== void 0) {
          delete ctx.prevTextDirection;
          ctx.canvas.style.setProperty("direction", original[0], original[1]);
        }
      }
      function propertyFn(property) {
        if (property === "angle") {
          return {
            between: _angleBetween,
            compare: _angleDiff,
            normalize: _normalizeAngle
          };
        }
        return {
          between: (n, s2, e) => n >= Math.min(s2, e) && n <= Math.max(e, s2),
          compare: (a, b) => a - b,
          normalize: (x) => x
        };
      }
      function normalizeSegment({start, end, count, loop, style}) {
        return {
          start: start % count,
          end: end % count,
          loop: loop && (end - start + 1) % count === 0,
          style
        };
      }
      function getSegment(segment, points, bounds) {
        const {property, start: startBound, end: endBound} = bounds;
        const {between, normalize: normalize2} = propertyFn(property);
        const count = points.length;
        let {start, end, loop} = segment;
        let i, ilen;
        if (loop) {
          start += count;
          end += count;
          for (i = 0, ilen = count; i < ilen; ++i) {
            if (!between(normalize2(points[start % count][property]), startBound, endBound)) {
              break;
            }
            start--;
            end--;
          }
          start %= count;
          end %= count;
        }
        if (end < start) {
          end += count;
        }
        return {start, end, loop, style: segment.style};
      }
      function _boundSegment(segment, points, bounds) {
        if (!bounds) {
          return [segment];
        }
        const {property, start: startBound, end: endBound} = bounds;
        const count = points.length;
        const {compare: compare2, between, normalize: normalize2} = propertyFn(property);
        const {start, end, loop, style} = getSegment(segment, points, bounds);
        const result = [];
        let inside2 = false;
        let subStart = null;
        let value, point, prevValue;
        const startIsBefore = () => between(startBound, prevValue, value) && compare2(startBound, prevValue) !== 0;
        const endIsBefore = () => compare2(endBound, value) === 0 || between(endBound, prevValue, value);
        const shouldStart = () => inside2 || startIsBefore();
        const shouldStop = () => !inside2 || endIsBefore();
        for (let i = start, prev = start; i <= end; ++i) {
          point = points[i % count];
          if (point.skip) {
            continue;
          }
          value = normalize2(point[property]);
          if (value === prevValue) {
            continue;
          }
          inside2 = between(value, startBound, endBound);
          if (subStart === null && shouldStart()) {
            subStart = compare2(value, startBound) === 0 ? i : prev;
          }
          if (subStart !== null && shouldStop()) {
            result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));
            subStart = null;
          }
          prev = i;
          prevValue = value;
        }
        if (subStart !== null) {
          result.push(normalizeSegment({start: subStart, end, loop, count, style}));
        }
        return result;
      }
      function _boundSegments(line, bounds) {
        const result = [];
        const segments = line.segments;
        for (let i = 0; i < segments.length; i++) {
          const sub = _boundSegment(segments[i], line.points, bounds);
          if (sub.length) {
            result.push(...sub);
          }
        }
        return result;
      }
      function findStartAndEnd(points, count, loop, spanGaps) {
        let start = 0;
        let end = count - 1;
        if (loop && !spanGaps) {
          while (start < count && !points[start].skip) {
            start++;
          }
        }
        while (start < count && points[start].skip) {
          start++;
        }
        start %= count;
        if (loop) {
          end += start;
        }
        while (end > start && points[end % count].skip) {
          end--;
        }
        end %= count;
        return {start, end};
      }
      function solidSegments(points, start, max, loop) {
        const count = points.length;
        const result = [];
        let last = start;
        let prev = points[start];
        let end;
        for (end = start + 1; end <= max; ++end) {
          const cur2 = points[end % count];
          if (cur2.skip || cur2.stop) {
            if (!prev.skip) {
              loop = false;
              result.push({start: start % count, end: (end - 1) % count, loop});
              start = last = cur2.stop ? end : null;
            }
          } else {
            last = end;
            if (prev.skip) {
              start = end;
            }
          }
          prev = cur2;
        }
        if (last !== null) {
          result.push({start: start % count, end: last % count, loop});
        }
        return result;
      }
      function _computeSegments(line, segmentOptions) {
        const points = line.points;
        const spanGaps = line.options.spanGaps;
        const count = points.length;
        if (!count) {
          return [];
        }
        const loop = !!line._loop;
        const {start, end} = findStartAndEnd(points, count, loop, spanGaps);
        if (spanGaps === true) {
          return splitByStyles([{start, end, loop}], points, segmentOptions);
        }
        const max = end < start ? end + count : end;
        const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
        return splitByStyles(solidSegments(points, start, max, completeLoop), points, segmentOptions);
      }
      function splitByStyles(segments, points, segmentOptions) {
        if (!segmentOptions || !segmentOptions.setContext || !points) {
          return segments;
        }
        return doSplitByStyles(segments, points, segmentOptions);
      }
      function doSplitByStyles(segments, points, segmentOptions) {
        const count = points.length;
        const result = [];
        let start = segments[0].start;
        let i = start;
        for (const segment of segments) {
          let prevStyle, style;
          let prev = points[start % count];
          for (i = start + 1; i <= segment.end; i++) {
            const pt = points[i % count];
            style = readStyle(segmentOptions.setContext({type: "segment", p0: prev, p1: pt}));
            if (styleChanged(style, prevStyle)) {
              result.push({start, end: i - 1, loop: segment.loop, style: prevStyle});
              prevStyle = style;
              start = i - 1;
            }
            prev = pt;
            prevStyle = style;
          }
          if (start < i - 1) {
            result.push({start, end: i - 1, loop: segment.loop, style});
            start = i - 1;
          }
        }
        return result;
      }
      function readStyle(options2) {
        return {
          backgroundColor: options2.backgroundColor,
          borderCapStyle: options2.borderCapStyle,
          borderDash: options2.borderDash,
          borderDashOffset: options2.borderDashOffset,
          borderJoinStyle: options2.borderJoinStyle,
          borderWidth: options2.borderWidth,
          borderColor: options2.borderColor
        };
      }
      function styleChanged(style, prevStyle) {
        return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
      }
      var helpers = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        easingEffects: effects,
        color,
        getHoverColor,
        noop: noop3,
        uid,
        isNullOrUndef,
        isArray,
        isObject,
        isFinite: isNumberFinite,
        finiteOrDefault,
        valueOrDefault,
        toPercentage,
        toDimension,
        callback,
        each: each2,
        _elementsEqual,
        clone: clone2,
        _merger,
        merge,
        mergeIf,
        _mergerIf,
        _deprecated,
        resolveObjectKey,
        _capitalize,
        defined,
        isFunction,
        setsEqual,
        toFontString,
        _measureText,
        _longestText,
        _alignPixel,
        clearCanvas,
        drawPoint,
        _isPointInArea,
        clipArea,
        unclipArea,
        _steppedLineTo,
        _bezierCurveTo,
        renderText,
        addRoundedRectPath,
        _lookup,
        _lookupByKey,
        _rlookupByKey,
        _filterBetween,
        listenArrayEvents,
        unlistenArrayEvents,
        _arrayUnique,
        _createResolver,
        _attachContext,
        _descriptors,
        splineCurve,
        splineCurveMonotone,
        _updateBezierControlPoints,
        _getParentNode,
        getStyle,
        getRelativePosition: getRelativePosition$1,
        getMaximumSize,
        retinaScale,
        supportsEventListenerOptions,
        readUsedSize,
        fontString,
        requestAnimFrame,
        throttled,
        debounce,
        _toLeftRightCenter,
        _alignStartEnd,
        _textX,
        _pointInLine,
        _steppedInterpolation,
        _bezierInterpolation,
        formatNumber: formatNumber2,
        toLineHeight,
        _readValueToProps,
        toTRBL,
        toTRBLCorners,
        toPadding,
        toFont,
        resolve: resolve2,
        _addGrace,
        PI,
        TAU,
        PITAU,
        INFINITY,
        RAD_PER_DEG,
        HALF_PI,
        QUARTER_PI,
        TWO_THIRDS_PI,
        log10,
        sign,
        niceNum,
        _factorize,
        isNumber,
        almostEquals,
        almostWhole,
        _setMinAndMaxByKey,
        toRadians,
        toDegrees,
        _decimalPlaces,
        getAngleFromPoint,
        distanceBetweenPoints,
        _angleDiff,
        _normalizeAngle,
        _angleBetween,
        _limitValue,
        _int16Range,
        getRtlAdapter,
        overrideTextDirection,
        restoreTextDirection,
        _boundSegment,
        _boundSegments,
        _computeSegments
      });
      class TypedRegistry {
        constructor(type, scope, override) {
          this.type = type;
          this.scope = scope;
          this.override = override;
          this.items = Object.create(null);
        }
        isForType(type) {
          return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
        }
        register(item) {
          const me = this;
          const proto = Object.getPrototypeOf(item);
          let parentScope;
          if (isIChartComponent(proto)) {
            parentScope = me.register(proto);
          }
          const items = me.items;
          const id = item.id;
          const scope = me.scope + "." + id;
          if (!id) {
            throw new Error("class does not have id: " + item);
          }
          if (id in items) {
            return scope;
          }
          items[id] = item;
          registerDefaults(item, scope, parentScope);
          if (me.override) {
            defaults3.override(item.id, item.overrides);
          }
          return scope;
        }
        get(id) {
          return this.items[id];
        }
        unregister(item) {
          const items = this.items;
          const id = item.id;
          const scope = this.scope;
          if (id in items) {
            delete items[id];
          }
          if (scope && id in defaults3[scope]) {
            delete defaults3[scope][id];
            if (this.override) {
              delete overrides[id];
            }
          }
        }
      }
      function registerDefaults(item, scope, parentScope) {
        const itemDefaults = merge(Object.create(null), [
          parentScope ? defaults3.get(parentScope) : {},
          defaults3.get(scope),
          item.defaults
        ]);
        defaults3.set(scope, itemDefaults);
        if (item.defaultRoutes) {
          routeDefaults(scope, item.defaultRoutes);
        }
        if (item.descriptors) {
          defaults3.describe(scope, item.descriptors);
        }
      }
      function routeDefaults(scope, routes) {
        Object.keys(routes).forEach((property) => {
          const propertyParts = property.split(".");
          const sourceName = propertyParts.pop();
          const sourceScope = [scope].concat(propertyParts).join(".");
          const parts = routes[property].split(".");
          const targetName = parts.pop();
          const targetScope = parts.join(".");
          defaults3.route(sourceScope, sourceName, targetScope, targetName);
        });
      }
      function isIChartComponent(proto) {
        return "id" in proto && "defaults" in proto;
      }
      class Registry {
        constructor() {
          this.controllers = new TypedRegistry(DatasetController, "datasets", true);
          this.elements = new TypedRegistry(Element, "elements");
          this.plugins = new TypedRegistry(Object, "plugins");
          this.scales = new TypedRegistry(Scale, "scales");
          this._typedRegistries = [this.controllers, this.scales, this.elements];
        }
        add(...args) {
          this._each("register", args);
        }
        remove(...args) {
          this._each("unregister", args);
        }
        addControllers(...args) {
          this._each("register", args, this.controllers);
        }
        addElements(...args) {
          this._each("register", args, this.elements);
        }
        addPlugins(...args) {
          this._each("register", args, this.plugins);
        }
        addScales(...args) {
          this._each("register", args, this.scales);
        }
        getController(id) {
          return this._get(id, this.controllers, "controller");
        }
        getElement(id) {
          return this._get(id, this.elements, "element");
        }
        getPlugin(id) {
          return this._get(id, this.plugins, "plugin");
        }
        getScale(id) {
          return this._get(id, this.scales, "scale");
        }
        removeControllers(...args) {
          this._each("unregister", args, this.controllers);
        }
        removeElements(...args) {
          this._each("unregister", args, this.elements);
        }
        removePlugins(...args) {
          this._each("unregister", args, this.plugins);
        }
        removeScales(...args) {
          this._each("unregister", args, this.scales);
        }
        _each(method, args, typedRegistry) {
          const me = this;
          [...args].forEach((arg) => {
            const reg = typedRegistry || me._getRegistryForType(arg);
            if (typedRegistry || reg.isForType(arg) || reg === me.plugins && arg.id) {
              me._exec(method, reg, arg);
            } else {
              each2(arg, (item) => {
                const itemReg = typedRegistry || me._getRegistryForType(item);
                me._exec(method, itemReg, item);
              });
            }
          });
        }
        _exec(method, registry2, component) {
          const camelMethod = _capitalize(method);
          callback(component["before" + camelMethod], [], component);
          registry2[method](component);
          callback(component["after" + camelMethod], [], component);
        }
        _getRegistryForType(type) {
          for (let i = 0; i < this._typedRegistries.length; i++) {
            const reg = this._typedRegistries[i];
            if (reg.isForType(type)) {
              return reg;
            }
          }
          return this.plugins;
        }
        _get(id, typedRegistry, type) {
          const item = typedRegistry.get(id);
          if (item === void 0) {
            throw new Error('"' + id + '" is not a registered ' + type + ".");
          }
          return item;
        }
      }
      var registry = new Registry();
      class PluginService {
        constructor() {
          this._init = [];
        }
        notify(chart, hook, args, filter) {
          const me = this;
          if (hook === "beforeInit") {
            me._init = me._createDescriptors(chart, true);
            me._notify(me._init, chart, "install");
          }
          const descriptors2 = filter ? me._descriptors(chart).filter(filter) : me._descriptors(chart);
          const result = me._notify(descriptors2, chart, hook, args);
          if (hook === "destroy") {
            me._notify(descriptors2, chart, "stop");
            me._notify(me._init, chart, "uninstall");
          }
          return result;
        }
        _notify(descriptors2, chart, hook, args) {
          args = args || {};
          for (const descriptor of descriptors2) {
            const plugin = descriptor.plugin;
            const method = plugin[hook];
            const params = [chart, args, descriptor.options];
            if (callback(method, params, plugin) === false && args.cancelable) {
              return false;
            }
          }
          return true;
        }
        invalidate() {
          if (!isNullOrUndef(this._cache)) {
            this._oldCache = this._cache;
            this._cache = void 0;
          }
        }
        _descriptors(chart) {
          if (this._cache) {
            return this._cache;
          }
          const descriptors2 = this._cache = this._createDescriptors(chart);
          this._notifyStateChanges(chart);
          return descriptors2;
        }
        _createDescriptors(chart, all) {
          const config2 = chart && chart.config;
          const options2 = valueOrDefault(config2.options && config2.options.plugins, {});
          const plugins2 = allPlugins(config2);
          return options2 === false && !all ? [] : createDescriptors(chart, plugins2, options2, all);
        }
        _notifyStateChanges(chart) {
          const previousDescriptors = this._oldCache || [];
          const descriptors2 = this._cache;
          const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
          this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
          this._notify(diff(descriptors2, previousDescriptors), chart, "start");
        }
      }
      function allPlugins(config2) {
        const plugins2 = [];
        const keys = Object.keys(registry.plugins.items);
        for (let i = 0; i < keys.length; i++) {
          plugins2.push(registry.getPlugin(keys[i]));
        }
        const local = config2.plugins || [];
        for (let i = 0; i < local.length; i++) {
          const plugin = local[i];
          if (plugins2.indexOf(plugin) === -1) {
            plugins2.push(plugin);
          }
        }
        return plugins2;
      }
      function getOpts(options2, all) {
        if (!all && options2 === false) {
          return null;
        }
        if (options2 === true) {
          return {};
        }
        return options2;
      }
      function createDescriptors(chart, plugins2, options2, all) {
        const result = [];
        const context = chart.getContext();
        for (let i = 0; i < plugins2.length; i++) {
          const plugin = plugins2[i];
          const id = plugin.id;
          const opts = getOpts(options2[id], all);
          if (opts === null) {
            continue;
          }
          result.push({
            plugin,
            options: pluginOpts(chart.config, plugin, opts, context)
          });
        }
        return result;
      }
      function pluginOpts(config2, plugin, opts, context) {
        const keys = config2.pluginScopeKeys(plugin);
        const scopes = config2.getOptionScopes(opts, keys);
        return config2.createResolver(scopes, context, [""], {scriptable: false, indexable: false, allKeys: true});
      }
      function getIndexAxis(type, options2) {
        const datasetDefaults = defaults3.datasets[type] || {};
        const datasetOptions = (options2.datasets || {})[type] || {};
        return datasetOptions.indexAxis || options2.indexAxis || datasetDefaults.indexAxis || "x";
      }
      function getAxisFromDefaultScaleID(id, indexAxis) {
        let axis = id;
        if (id === "_index_") {
          axis = indexAxis;
        } else if (id === "_value_") {
          axis = indexAxis === "x" ? "y" : "x";
        }
        return axis;
      }
      function getDefaultScaleIDFromAxis(axis, indexAxis) {
        return axis === indexAxis ? "_index_" : "_value_";
      }
      function axisFromPosition(position) {
        if (position === "top" || position === "bottom") {
          return "x";
        }
        if (position === "left" || position === "right") {
          return "y";
        }
      }
      function determineAxis(id, scaleOptions) {
        if (id === "x" || id === "y") {
          return id;
        }
        return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
      }
      function mergeScaleConfig(config2, options2) {
        const chartDefaults = overrides[config2.type] || {scales: {}};
        const configScales = options2.scales || {};
        const chartIndexAxis = getIndexAxis(config2.type, options2);
        const firstIDs = Object.create(null);
        const scales2 = Object.create(null);
        Object.keys(configScales).forEach((id) => {
          const scaleConf = configScales[id];
          const axis = determineAxis(id, scaleConf);
          const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
          const defaultScaleOptions = chartDefaults.scales || {};
          firstIDs[axis] = firstIDs[axis] || id;
          scales2[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
        });
        config2.data.datasets.forEach((dataset) => {
          const type = dataset.type || config2.type;
          const indexAxis = dataset.indexAxis || getIndexAxis(type, options2);
          const datasetDefaults = overrides[type] || {};
          const defaultScaleOptions = datasetDefaults.scales || {};
          Object.keys(defaultScaleOptions).forEach((defaultID) => {
            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
            const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
            scales2[id] = scales2[id] || Object.create(null);
            mergeIf(scales2[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);
          });
        });
        Object.keys(scales2).forEach((key) => {
          const scale = scales2[key];
          mergeIf(scale, [defaults3.scales[scale.type], defaults3.scale]);
        });
        return scales2;
      }
      function initOptions(config2) {
        const options2 = config2.options || (config2.options = {});
        options2.plugins = valueOrDefault(options2.plugins, {});
        options2.scales = mergeScaleConfig(config2, options2);
      }
      function initData(data) {
        data = data || {};
        data.datasets = data.datasets || [];
        data.labels = data.labels || [];
        return data;
      }
      function initConfig(config2) {
        config2 = config2 || {};
        config2.data = initData(config2.data);
        initOptions(config2);
        return config2;
      }
      const keyCache = new Map();
      const keysCached = new Set();
      function cachedKeys(cacheKey, generate) {
        let keys = keyCache.get(cacheKey);
        if (!keys) {
          keys = generate();
          keyCache.set(cacheKey, keys);
          keysCached.add(keys);
        }
        return keys;
      }
      const addIfFound = (set2, obj, key) => {
        const opts = resolveObjectKey(obj, key);
        if (opts !== void 0) {
          set2.add(opts);
        }
      };
      class Config {
        constructor(config2) {
          this._config = initConfig(config2);
          this._scopeCache = new Map();
          this._resolverCache = new Map();
        }
        get type() {
          return this._config.type;
        }
        set type(type) {
          this._config.type = type;
        }
        get data() {
          return this._config.data;
        }
        set data(data) {
          this._config.data = initData(data);
        }
        get options() {
          return this._config.options;
        }
        set options(options2) {
          this._config.options = options2;
        }
        get plugins() {
          return this._config.plugins;
        }
        update() {
          const config2 = this._config;
          this.clearCache();
          initOptions(config2);
        }
        clearCache() {
          this._scopeCache.clear();
          this._resolverCache.clear();
        }
        datasetScopeKeys(datasetType) {
          return cachedKeys(datasetType, () => [[
            `datasets.${datasetType}`,
            ""
          ]]);
        }
        datasetAnimationScopeKeys(datasetType, transition) {
          return cachedKeys(`${datasetType}.transition.${transition}`, () => [
            [
              `datasets.${datasetType}.transitions.${transition}`,
              `transitions.${transition}`
            ],
            [
              `datasets.${datasetType}`,
              ""
            ]
          ]);
        }
        datasetElementScopeKeys(datasetType, elementType) {
          return cachedKeys(`${datasetType}-${elementType}`, () => [[
            `datasets.${datasetType}.elements.${elementType}`,
            `datasets.${datasetType}`,
            `elements.${elementType}`,
            ""
          ]]);
        }
        pluginScopeKeys(plugin) {
          const id = plugin.id;
          const type = this.type;
          return cachedKeys(`${type}-plugin-${id}`, () => [[
            `plugins.${id}`,
            ...plugin.additionalOptionScopes || []
          ]]);
        }
        _cachedScopes(mainScope, resetCache) {
          const _scopeCache = this._scopeCache;
          let cache = _scopeCache.get(mainScope);
          if (!cache || resetCache) {
            cache = new Map();
            _scopeCache.set(mainScope, cache);
          }
          return cache;
        }
        getOptionScopes(mainScope, keyLists, resetCache) {
          const {options: options2, type} = this;
          const cache = this._cachedScopes(mainScope, resetCache);
          const cached2 = cache.get(keyLists);
          if (cached2) {
            return cached2;
          }
          const scopes = new Set();
          keyLists.forEach((keys) => {
            if (mainScope) {
              scopes.add(mainScope);
              keys.forEach((key) => addIfFound(scopes, mainScope, key));
            }
            keys.forEach((key) => addIfFound(scopes, options2, key));
            keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
            keys.forEach((key) => addIfFound(scopes, defaults3, key));
            keys.forEach((key) => addIfFound(scopes, descriptors, key));
          });
          const array = [...scopes];
          if (keysCached.has(keyLists)) {
            cache.set(keyLists, array);
          }
          return array;
        }
        chartOptionScopes() {
          const {options: options2, type} = this;
          return [
            options2,
            overrides[type] || {},
            defaults3.datasets[type] || {},
            {type},
            defaults3,
            descriptors
          ];
        }
        resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
          const result = {$shared: true};
          const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);
          let options2 = resolver;
          if (needContext(resolver, names2)) {
            result.$shared = false;
            context = isFunction(context) ? context() : context;
            const subResolver = this.createResolver(scopes, context, subPrefixes);
            options2 = _attachContext(resolver, context, subResolver);
          }
          for (const prop of names2) {
            result[prop] = options2[prop];
          }
          return result;
        }
        createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
          const {resolver} = getResolver(this._resolverCache, scopes, prefixes);
          return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
        }
      }
      function getResolver(resolverCache, scopes, prefixes) {
        let cache = resolverCache.get(scopes);
        if (!cache) {
          cache = new Map();
          resolverCache.set(scopes, cache);
        }
        const cacheKey = prefixes.join();
        let cached2 = cache.get(cacheKey);
        if (!cached2) {
          const resolver = _createResolver(scopes, prefixes);
          cached2 = {
            resolver,
            subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
          };
          cache.set(cacheKey, cached2);
        }
        return cached2;
      }
      function needContext(proxy, names2) {
        const {isScriptable, isIndexable} = _descriptors(proxy);
        for (const prop of names2) {
          if (isScriptable(prop) && isFunction(proxy[prop]) || isIndexable(prop) && isArray(proxy[prop])) {
            return true;
          }
        }
        return false;
      }
      var version = "3.3.0";
      const KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
      function positionIsHorizontal(position, axis) {
        return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
      }
      function compare2Level(l1, l2) {
        return function(a, b) {
          return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
        };
      }
      function onAnimationsComplete(context) {
        const chart = context.chart;
        const animationOptions2 = chart.options.animation;
        chart.notifyPlugins("afterRender");
        callback(animationOptions2 && animationOptions2.onComplete, [context], chart);
      }
      function onAnimationProgress(context) {
        const chart = context.chart;
        const animationOptions2 = chart.options.animation;
        callback(animationOptions2 && animationOptions2.onProgress, [context], chart);
      }
      function isDomSupported() {
        return typeof window !== "undefined" && typeof document !== "undefined";
      }
      function getCanvas(item) {
        if (isDomSupported() && typeof item === "string") {
          item = document.getElementById(item);
        } else if (item && item.length) {
          item = item[0];
        }
        if (item && item.canvas) {
          item = item.canvas;
        }
        return item;
      }
      const instances = {};
      const getChart = (key) => {
        const canvas = getCanvas(key);
        return Object.values(instances).filter((c) => c.canvas === canvas).pop();
      };
      class Chart {
        constructor(item, config2) {
          const me = this;
          this.config = config2 = new Config(config2);
          const initialCanvas = getCanvas(item);
          const existingChart = getChart(initialCanvas);
          if (existingChart) {
            throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas can be reused.");
          }
          const options2 = config2.createResolver(config2.chartOptionScopes(), me.getContext());
          this.platform = me._initializePlatform(initialCanvas, config2);
          const context = me.platform.acquireContext(initialCanvas, options2.aspectRatio);
          const canvas = context && context.canvas;
          const height = canvas && canvas.height;
          const width = canvas && canvas.width;
          this.id = uid();
          this.ctx = context;
          this.canvas = canvas;
          this.width = width;
          this.height = height;
          this._options = options2;
          this._aspectRatio = this.aspectRatio;
          this._layers = [];
          this._metasets = [];
          this._stacks = void 0;
          this.boxes = [];
          this.currentDevicePixelRatio = void 0;
          this.chartArea = void 0;
          this._active = [];
          this._lastEvent = void 0;
          this._listeners = {};
          this._responsiveListeners = void 0;
          this._sortedMetasets = [];
          this.scales = {};
          this.scale = void 0;
          this._plugins = new PluginService();
          this.$proxies = {};
          this._hiddenIndices = {};
          this.attached = false;
          this._animationsDisabled = void 0;
          this.$context = void 0;
          this._doResize = debounce(() => this.update("resize"), options2.resizeDelay || 0);
          instances[me.id] = me;
          if (!context || !canvas) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
          }
          animator.listen(me, "complete", onAnimationsComplete);
          animator.listen(me, "progress", onAnimationProgress);
          me._initialize();
          if (me.attached) {
            me.update();
          }
        }
        get aspectRatio() {
          const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;
          if (!isNullOrUndef(aspectRatio)) {
            return aspectRatio;
          }
          if (maintainAspectRatio && _aspectRatio) {
            return _aspectRatio;
          }
          return height ? width / height : null;
        }
        get data() {
          return this.config.data;
        }
        set data(data) {
          this.config.data = data;
        }
        get options() {
          return this._options;
        }
        set options(options2) {
          this.config.options = options2;
        }
        _initialize() {
          const me = this;
          me.notifyPlugins("beforeInit");
          if (me.options.responsive) {
            me.resize();
          } else {
            retinaScale(me, me.options.devicePixelRatio);
          }
          me.bindEvents();
          me.notifyPlugins("afterInit");
          return me;
        }
        _initializePlatform(canvas, config2) {
          if (config2.platform) {
            return new config2.platform();
          } else if (!isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
            return new BasicPlatform();
          }
          return new DomPlatform();
        }
        clear() {
          clearCanvas(this.canvas, this.ctx);
          return this;
        }
        stop() {
          animator.stop(this);
          return this;
        }
        resize(width, height) {
          if (!animator.running(this)) {
            this._resize(width, height);
          } else {
            this._resizeBeforeDraw = {width, height};
          }
        }
        _resize(width, height) {
          const me = this;
          const options2 = me.options;
          const canvas = me.canvas;
          const aspectRatio = options2.maintainAspectRatio && me.aspectRatio;
          const newSize = me.platform.getMaximumSize(canvas, width, height, aspectRatio);
          const newRatio = options2.devicePixelRatio || me.platform.getDevicePixelRatio();
          me.width = newSize.width;
          me.height = newSize.height;
          me._aspectRatio = me.aspectRatio;
          if (!retinaScale(me, newRatio, true)) {
            return;
          }
          me.notifyPlugins("resize", {size: newSize});
          callback(options2.onResize, [me, newSize], me);
          if (me.attached) {
            if (me._doResize()) {
              me.render();
            }
          }
        }
        ensureScalesHaveIDs() {
          const options2 = this.options;
          const scalesOptions = options2.scales || {};
          each2(scalesOptions, (axisOptions, axisID) => {
            axisOptions.id = axisID;
          });
        }
        buildOrUpdateScales() {
          const me = this;
          const options2 = me.options;
          const scaleOpts = options2.scales;
          const scales2 = me.scales;
          const updated = Object.keys(scales2).reduce((obj, id) => {
            obj[id] = false;
            return obj;
          }, {});
          let items = [];
          if (scaleOpts) {
            items = items.concat(Object.keys(scaleOpts).map((id) => {
              const scaleOptions = scaleOpts[id];
              const axis = determineAxis(id, scaleOptions);
              const isRadial = axis === "r";
              const isHorizontal = axis === "x";
              return {
                options: scaleOptions,
                dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
              };
            }));
          }
          each2(items, (item) => {
            const scaleOptions = item.options;
            const id = scaleOptions.id;
            const axis = determineAxis(id, scaleOptions);
            const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
            if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
              scaleOptions.position = item.dposition;
            }
            updated[id] = true;
            let scale = null;
            if (id in scales2 && scales2[id].type === scaleType) {
              scale = scales2[id];
            } else {
              const scaleClass = registry.getScale(scaleType);
              scale = new scaleClass({
                id,
                type: scaleType,
                ctx: me.ctx,
                chart: me
              });
              scales2[scale.id] = scale;
            }
            scale.init(scaleOptions, options2);
          });
          each2(updated, (hasUpdated, id) => {
            if (!hasUpdated) {
              delete scales2[id];
            }
          });
          each2(scales2, (scale) => {
            layouts.configure(me, scale, scale.options);
            layouts.addBox(me, scale);
          });
        }
        _updateMetasetIndex(meta2, index2) {
          const metasets = this._metasets;
          const oldIndex = meta2.index;
          if (oldIndex !== index2) {
            metasets[oldIndex] = metasets[index2];
            metasets[index2] = meta2;
            meta2.index = index2;
          }
        }
        _updateMetasets() {
          const me = this;
          const metasets = me._metasets;
          const numData = me.data.datasets.length;
          const numMeta = metasets.length;
          if (numMeta > numData) {
            for (let i = numData; i < numMeta; ++i) {
              me._destroyDatasetMeta(i);
            }
            metasets.splice(numData, numMeta - numData);
          }
          me._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
        }
        _removeUnreferencedMetasets() {
          const me = this;
          const {_metasets: metasets, data: {datasets}} = me;
          if (metasets.length > datasets.length) {
            delete me._stacks;
          }
          metasets.forEach((meta2, index2) => {
            if (datasets.filter((x) => x === meta2._dataset).length === 0) {
              me._destroyDatasetMeta(index2);
            }
          });
        }
        buildOrUpdateControllers() {
          const me = this;
          const newControllers = [];
          const datasets = me.data.datasets;
          let i, ilen;
          me._removeUnreferencedMetasets();
          for (i = 0, ilen = datasets.length; i < ilen; i++) {
            const dataset = datasets[i];
            let meta2 = me.getDatasetMeta(i);
            const type = dataset.type || me.config.type;
            if (meta2.type && meta2.type !== type) {
              me._destroyDatasetMeta(i);
              meta2 = me.getDatasetMeta(i);
            }
            meta2.type = type;
            meta2.indexAxis = dataset.indexAxis || getIndexAxis(type, me.options);
            meta2.order = dataset.order || 0;
            me._updateMetasetIndex(meta2, i);
            meta2.label = "" + dataset.label;
            meta2.visible = me.isDatasetVisible(i);
            if (meta2.controller) {
              meta2.controller.updateIndex(i);
              meta2.controller.linkScales();
            } else {
              const ControllerClass = registry.getController(type);
              const {datasetElementType, dataElementType} = defaults3.datasets[type];
              Object.assign(ControllerClass.prototype, {
                dataElementType: registry.getElement(dataElementType),
                datasetElementType: datasetElementType && registry.getElement(datasetElementType)
              });
              meta2.controller = new ControllerClass(me, i);
              newControllers.push(meta2.controller);
            }
          }
          me._updateMetasets();
          return newControllers;
        }
        _resetElements() {
          const me = this;
          each2(me.data.datasets, (dataset, datasetIndex) => {
            me.getDatasetMeta(datasetIndex).controller.reset();
          }, me);
        }
        reset() {
          this._resetElements();
          this.notifyPlugins("reset");
        }
        update(mode) {
          const me = this;
          const config2 = me.config;
          config2.update();
          me._options = config2.createResolver(config2.chartOptionScopes(), me.getContext());
          each2(me.scales, (scale) => {
            layouts.removeBox(me, scale);
          });
          const animsDisabled = me._animationsDisabled = !me.options.animation;
          me.ensureScalesHaveIDs();
          me.buildOrUpdateScales();
          const existingEvents = new Set(Object.keys(me._listeners));
          const newEvents = new Set(me.options.events);
          if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== me.options.responsive) {
            me.unbindEvents();
            me.bindEvents();
          }
          me._plugins.invalidate();
          if (me.notifyPlugins("beforeUpdate", {mode, cancelable: true}) === false) {
            return;
          }
          const newControllers = me.buildOrUpdateControllers();
          me.notifyPlugins("beforeElementsUpdate");
          let minPadding = 0;
          for (let i = 0, ilen = me.data.datasets.length; i < ilen; i++) {
            const {controller} = me.getDatasetMeta(i);
            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
            controller.buildOrUpdateElements(reset);
            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
          }
          me._minPadding = minPadding;
          me._updateLayout(minPadding);
          if (!animsDisabled) {
            each2(newControllers, (controller) => {
              controller.reset();
            });
          }
          me._updateDatasets(mode);
          me.notifyPlugins("afterUpdate", {mode});
          me._layers.sort(compare2Level("z", "_idx"));
          if (me._lastEvent) {
            me._eventHandler(me._lastEvent, true);
          }
          me.render();
        }
        _updateLayout(minPadding) {
          const me = this;
          if (me.notifyPlugins("beforeLayout", {cancelable: true}) === false) {
            return;
          }
          layouts.update(me, me.width, me.height, minPadding);
          const area = me.chartArea;
          const noArea = area.width <= 0 || area.height <= 0;
          me._layers = [];
          each2(me.boxes, (box) => {
            if (noArea && box.position === "chartArea") {
              return;
            }
            if (box.configure) {
              box.configure();
            }
            me._layers.push(...box._layers());
          }, me);
          me._layers.forEach((item, index2) => {
            item._idx = index2;
          });
          me.notifyPlugins("afterLayout");
        }
        _updateDatasets(mode) {
          const me = this;
          const isFunction2 = typeof mode === "function";
          if (me.notifyPlugins("beforeDatasetsUpdate", {mode, cancelable: true}) === false) {
            return;
          }
          for (let i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
            me._updateDataset(i, isFunction2 ? mode({datasetIndex: i}) : mode);
          }
          me.notifyPlugins("afterDatasetsUpdate", {mode});
        }
        _updateDataset(index2, mode) {
          const me = this;
          const meta2 = me.getDatasetMeta(index2);
          const args = {meta: meta2, index: index2, mode, cancelable: true};
          if (me.notifyPlugins("beforeDatasetUpdate", args) === false) {
            return;
          }
          meta2.controller._update(mode);
          args.cancelable = false;
          me.notifyPlugins("afterDatasetUpdate", args);
        }
        render() {
          const me = this;
          if (me.notifyPlugins("beforeRender", {cancelable: true}) === false) {
            return;
          }
          if (animator.has(me)) {
            if (me.attached && !animator.running(me)) {
              animator.start(me);
            }
          } else {
            me.draw();
            onAnimationsComplete({chart: me});
          }
        }
        draw() {
          const me = this;
          let i;
          if (me._resizeBeforeDraw) {
            const {width, height} = me._resizeBeforeDraw;
            me._resize(width, height);
            me._resizeBeforeDraw = null;
          }
          me.clear();
          if (me.width <= 0 || me.height <= 0) {
            return;
          }
          if (me.notifyPlugins("beforeDraw", {cancelable: true}) === false) {
            return;
          }
          const layers = me._layers;
          for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
            layers[i].draw(me.chartArea);
          }
          me._drawDatasets();
          for (; i < layers.length; ++i) {
            layers[i].draw(me.chartArea);
          }
          me.notifyPlugins("afterDraw");
        }
        _getSortedDatasetMetas(filterVisible) {
          const me = this;
          const metasets = me._sortedMetasets;
          const result = [];
          let i, ilen;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            const meta2 = metasets[i];
            if (!filterVisible || meta2.visible) {
              result.push(meta2);
            }
          }
          return result;
        }
        getSortedVisibleDatasetMetas() {
          return this._getSortedDatasetMetas(true);
        }
        _drawDatasets() {
          const me = this;
          if (me.notifyPlugins("beforeDatasetsDraw", {cancelable: true}) === false) {
            return;
          }
          const metasets = me.getSortedVisibleDatasetMetas();
          for (let i = metasets.length - 1; i >= 0; --i) {
            me._drawDataset(metasets[i]);
          }
          me.notifyPlugins("afterDatasetsDraw");
        }
        _drawDataset(meta2) {
          const me = this;
          const ctx = me.ctx;
          const clip = meta2._clip;
          const area = me.chartArea;
          const args = {
            meta: meta2,
            index: meta2.index,
            cancelable: true
          };
          if (me.notifyPlugins("beforeDatasetDraw", args) === false) {
            return;
          }
          clipArea(ctx, {
            left: clip.left === false ? 0 : area.left - clip.left,
            right: clip.right === false ? me.width : area.right + clip.right,
            top: clip.top === false ? 0 : area.top - clip.top,
            bottom: clip.bottom === false ? me.height : area.bottom + clip.bottom
          });
          meta2.controller.draw();
          unclipArea(ctx);
          args.cancelable = false;
          me.notifyPlugins("afterDatasetDraw", args);
        }
        getElementsAtEventForMode(e, mode, options2, useFinalPosition) {
          const method = Interaction.modes[mode];
          if (typeof method === "function") {
            return method(this, e, options2, useFinalPosition);
          }
          return [];
        }
        getDatasetMeta(datasetIndex) {
          const me = this;
          const dataset = me.data.datasets[datasetIndex];
          const metasets = me._metasets;
          let meta2 = metasets.filter((x) => x && x._dataset === dataset).pop();
          if (!meta2) {
            meta2 = metasets[datasetIndex] = {
              type: null,
              data: [],
              dataset: null,
              controller: null,
              hidden: null,
              xAxisID: null,
              yAxisID: null,
              order: dataset && dataset.order || 0,
              index: datasetIndex,
              _dataset: dataset,
              _parsed: [],
              _sorted: false
            };
          }
          return meta2;
        }
        getContext() {
          return this.$context || (this.$context = {chart: this, type: "chart"});
        }
        getVisibleDatasetCount() {
          return this.getSortedVisibleDatasetMetas().length;
        }
        isDatasetVisible(datasetIndex) {
          const dataset = this.data.datasets[datasetIndex];
          if (!dataset) {
            return false;
          }
          const meta2 = this.getDatasetMeta(datasetIndex);
          return typeof meta2.hidden === "boolean" ? !meta2.hidden : !dataset.hidden;
        }
        setDatasetVisibility(datasetIndex, visible) {
          const meta2 = this.getDatasetMeta(datasetIndex);
          meta2.hidden = !visible;
        }
        toggleDataVisibility(index2) {
          this._hiddenIndices[index2] = !this._hiddenIndices[index2];
        }
        getDataVisibility(index2) {
          return !this._hiddenIndices[index2];
        }
        _updateDatasetVisibility(datasetIndex, visible) {
          const me = this;
          const mode = visible ? "show" : "hide";
          const meta2 = me.getDatasetMeta(datasetIndex);
          const anims = meta2.controller._resolveAnimations(void 0, mode);
          me.setDatasetVisibility(datasetIndex, visible);
          anims.update(meta2, {visible});
          me.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
        }
        hide(datasetIndex) {
          this._updateDatasetVisibility(datasetIndex, false);
        }
        show(datasetIndex) {
          this._updateDatasetVisibility(datasetIndex, true);
        }
        _destroyDatasetMeta(datasetIndex) {
          const me = this;
          const meta2 = me._metasets && me._metasets[datasetIndex];
          if (meta2 && meta2.controller) {
            meta2.controller._destroy();
            delete me._metasets[datasetIndex];
          }
        }
        destroy() {
          const me = this;
          const {canvas, ctx} = me;
          let i, ilen;
          me.stop();
          animator.remove(me);
          for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
            me._destroyDatasetMeta(i);
          }
          me.config.clearCache();
          if (canvas) {
            me.unbindEvents();
            clearCanvas(canvas, ctx);
            me.platform.releaseContext(ctx);
            me.canvas = null;
            me.ctx = null;
          }
          me.notifyPlugins("destroy");
          delete instances[me.id];
        }
        toBase64Image(...args) {
          return this.canvas.toDataURL(...args);
        }
        bindEvents() {
          this.bindUserEvents();
          if (this.options.responsive) {
            this.bindResponsiveEvents();
          } else {
            this.attached = true;
          }
        }
        bindUserEvents() {
          const me = this;
          const listeners = me._listeners;
          const platform = me.platform;
          const _add = (type, listener2) => {
            platform.addEventListener(me, type, listener2);
            listeners[type] = listener2;
          };
          const listener = function(e, x, y) {
            e.offsetX = x;
            e.offsetY = y;
            me._eventHandler(e);
          };
          each2(me.options.events, (type) => _add(type, listener));
        }
        bindResponsiveEvents() {
          const me = this;
          if (!me._responsiveListeners) {
            me._responsiveListeners = {};
          }
          const listeners = me._responsiveListeners;
          const platform = me.platform;
          const _add = (type, listener2) => {
            platform.addEventListener(me, type, listener2);
            listeners[type] = listener2;
          };
          const _remove = (type, listener2) => {
            if (listeners[type]) {
              platform.removeEventListener(me, type, listener2);
              delete listeners[type];
            }
          };
          const listener = (width, height) => {
            if (me.canvas) {
              me.resize(width, height);
            }
          };
          let detached;
          const attached = () => {
            _remove("attach", attached);
            me.attached = true;
            me.resize();
            _add("resize", listener);
            _add("detach", detached);
          };
          detached = () => {
            me.attached = false;
            _remove("resize", listener);
            _add("attach", attached);
          };
          if (platform.isAttached(me.canvas)) {
            attached();
          } else {
            detached();
          }
        }
        unbindEvents() {
          const me = this;
          each2(me._listeners, (listener, type) => {
            me.platform.removeEventListener(me, type, listener);
          });
          me._listeners = {};
          each2(me._responsiveListeners, (listener, type) => {
            me.platform.removeEventListener(me, type, listener);
          });
          me._responsiveListeners = void 0;
        }
        updateHoverStyle(items, mode, enabled) {
          const prefix = enabled ? "set" : "remove";
          let meta2, item, i, ilen;
          if (mode === "dataset") {
            meta2 = this.getDatasetMeta(items[0].datasetIndex);
            meta2.controller["_" + prefix + "DatasetHoverStyle"]();
          }
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            item = items[i];
            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
            if (controller) {
              controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
            }
          }
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(activeElements) {
          const me = this;
          const lastActive = me._active || [];
          const active = activeElements.map(({datasetIndex, index: index2}) => {
            const meta2 = me.getDatasetMeta(datasetIndex);
            if (!meta2) {
              throw new Error("No dataset found at index " + datasetIndex);
            }
            return {
              datasetIndex,
              element: meta2.data[index2],
              index: index2
            };
          });
          const changed = !_elementsEqual(active, lastActive);
          if (changed) {
            me._active = active;
            me._updateHoverStyles(active, lastActive);
          }
        }
        notifyPlugins(hook, args, filter) {
          return this._plugins.notify(this, hook, args, filter);
        }
        _updateHoverStyles(active, lastActive, replay) {
          const me = this;
          const hoverOptions = me.options.hover;
          const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
          const deactivated = diff(lastActive, active);
          const activated = replay ? active : diff(active, lastActive);
          if (deactivated.length) {
            me.updateHoverStyle(deactivated, hoverOptions.mode, false);
          }
          if (activated.length && hoverOptions.mode) {
            me.updateHoverStyle(activated, hoverOptions.mode, true);
          }
        }
        _eventHandler(e, replay) {
          const me = this;
          const args = {event: e, replay, cancelable: true};
          const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.type);
          if (me.notifyPlugins("beforeEvent", args, eventFilter) === false) {
            return;
          }
          const changed = me._handleEvent(e, replay);
          args.cancelable = false;
          me.notifyPlugins("afterEvent", args, eventFilter);
          if (changed || args.changed) {
            me.render();
          }
          return me;
        }
        _handleEvent(e, replay) {
          const me = this;
          const {_active: lastActive = [], options: options2} = me;
          const hoverOptions = options2.hover;
          const useFinalPosition = replay;
          let active = [];
          let changed = false;
          let lastEvent = null;
          if (e.type !== "mouseout") {
            active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
            lastEvent = e.type === "click" ? me._lastEvent : e;
          }
          me._lastEvent = null;
          if (_isPointInArea(e, me.chartArea, me._minPadding)) {
            callback(options2.onHover, [e, active, me], me);
            if (e.type === "mouseup" || e.type === "click" || e.type === "contextmenu") {
              callback(options2.onClick, [e, active, me], me);
            }
          }
          changed = !_elementsEqual(active, lastActive);
          if (changed || replay) {
            me._active = active;
            me._updateHoverStyles(active, lastActive, replay);
          }
          me._lastEvent = lastEvent;
          return changed;
        }
      }
      const invalidatePlugins = () => each2(Chart.instances, (chart) => chart._plugins.invalidate());
      const enumerable = true;
      Object.defineProperties(Chart, {
        defaults: {
          enumerable,
          value: defaults3
        },
        instances: {
          enumerable,
          value: instances
        },
        overrides: {
          enumerable,
          value: overrides
        },
        registry: {
          enumerable,
          value: registry
        },
        version: {
          enumerable,
          value: version
        },
        getChart: {
          enumerable,
          value: getChart
        },
        register: {
          enumerable,
          value: (...items) => {
            registry.add(...items);
            invalidatePlugins();
          }
        },
        unregister: {
          enumerable,
          value: (...items) => {
            registry.remove(...items);
            invalidatePlugins();
          }
        }
      });
      function abstract() {
        throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
      }
      class DateAdapter {
        constructor(options2) {
          this.options = options2 || {};
        }
        formats() {
          return abstract();
        }
        parse(value, format2) {
          return abstract();
        }
        format(timestamp, format2) {
          return abstract();
        }
        add(timestamp, amount, unit) {
          return abstract();
        }
        diff(a, b, unit) {
          return abstract();
        }
        startOf(timestamp, unit, weekday) {
          return abstract();
        }
        endOf(timestamp, unit) {
          return abstract();
        }
      }
      DateAdapter.override = function(members) {
        Object.assign(DateAdapter.prototype, members);
      };
      var _adapters = {
        _date: DateAdapter
      };
      function getAllScaleValues(scale) {
        if (!scale._cache.$bar) {
          const metas = scale.getMatchingVisibleMetas("bar");
          let values = [];
          for (let i = 0, ilen = metas.length; i < ilen; i++) {
            values = values.concat(metas[i].controller.getAllParsedValues(scale));
          }
          scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
        }
        return scale._cache.$bar;
      }
      function computeMinSampleSize(scale) {
        const values = getAllScaleValues(scale);
        let min = scale._length;
        let i, ilen, curr, prev;
        const updateMinAndPrev = () => {
          if (curr === 32767 || curr === -32768) {
            return;
          }
          if (defined(prev)) {
            min = Math.min(min, Math.abs(curr - prev) || min);
          }
          prev = curr;
        };
        for (i = 0, ilen = values.length; i < ilen; ++i) {
          curr = scale.getPixelForValue(values[i]);
          updateMinAndPrev();
        }
        prev = void 0;
        for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
          curr = scale.getPixelForTick(i);
          updateMinAndPrev();
        }
        return min;
      }
      function computeFitCategoryTraits(index2, ruler, options2, stackCount) {
        const thickness = options2.barThickness;
        let size, ratio;
        if (isNullOrUndef(thickness)) {
          size = ruler.min * options2.categoryPercentage;
          ratio = options2.barPercentage;
        } else {
          size = thickness * stackCount;
          ratio = 1;
        }
        return {
          chunk: size / stackCount,
          ratio,
          start: ruler.pixels[index2] - size / 2
        };
      }
      function computeFlexCategoryTraits(index2, ruler, options2, stackCount) {
        const pixels = ruler.pixels;
        const curr = pixels[index2];
        let prev = index2 > 0 ? pixels[index2 - 1] : null;
        let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
        const percent = options2.categoryPercentage;
        if (prev === null) {
          prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
        }
        if (next === null) {
          next = curr + curr - prev;
        }
        const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
        const size = Math.abs(next - prev) / 2 * percent;
        return {
          chunk: size / stackCount,
          ratio: options2.barPercentage,
          start
        };
      }
      function parseFloatBar(entry, item, vScale, i) {
        const startValue = vScale.parse(entry[0], i);
        const endValue = vScale.parse(entry[1], i);
        const min = Math.min(startValue, endValue);
        const max = Math.max(startValue, endValue);
        let barStart = min;
        let barEnd = max;
        if (Math.abs(min) > Math.abs(max)) {
          barStart = max;
          barEnd = min;
        }
        item[vScale.axis] = barEnd;
        item._custom = {
          barStart,
          barEnd,
          start: startValue,
          end: endValue,
          min,
          max
        };
      }
      function parseValue(entry, item, vScale, i) {
        if (isArray(entry)) {
          parseFloatBar(entry, item, vScale, i);
        } else {
          item[vScale.axis] = vScale.parse(entry, i);
        }
        return item;
      }
      function parseArrayOrPrimitive(meta2, data, start, count) {
        const iScale = meta2.iScale;
        const vScale = meta2.vScale;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = [];
        let i, ilen, item, entry;
        for (i = start, ilen = start + count; i < ilen; ++i) {
          entry = data[i];
          item = {};
          item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
          parsed.push(parseValue(entry, item, vScale, i));
        }
        return parsed;
      }
      function isFloatBar(custom) {
        return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
      }
      class BarController extends DatasetController {
        parsePrimitiveData(meta2, data, start, count) {
          return parseArrayOrPrimitive(meta2, data, start, count);
        }
        parseArrayData(meta2, data, start, count) {
          return parseArrayOrPrimitive(meta2, data, start, count);
        }
        parseObjectData(meta2, data, start, count) {
          const {iScale, vScale} = meta2;
          const {xAxisKey = "x", yAxisKey = "y"} = this._parsing;
          const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
          const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
          const parsed = [];
          let i, ilen, item, obj;
          for (i = start, ilen = start + count; i < ilen; ++i) {
            obj = data[i];
            item = {};
            item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
            parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
          }
          return parsed;
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
          super.updateRangeFromParsed(range, scale, parsed, stack);
          const custom = parsed._custom;
          if (custom && scale === this._cachedMeta.vScale) {
            range.min = Math.min(range.min, custom.min);
            range.max = Math.max(range.max, custom.max);
          }
        }
        getLabelAndValue(index2) {
          const me = this;
          const meta2 = me._cachedMeta;
          const {iScale, vScale} = meta2;
          const parsed = me.getParsed(index2);
          const custom = parsed._custom;
          const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
          return {
            label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
            value
          };
        }
        initialize() {
          const me = this;
          me.enableOptionSharing = true;
          super.initialize();
          const meta2 = me._cachedMeta;
          meta2.stack = me.getDataset().stack;
        }
        update(mode) {
          const me = this;
          const meta2 = me._cachedMeta;
          me.updateElements(meta2.data, 0, meta2.data.length, mode);
        }
        updateElements(bars, start, count, mode) {
          const me = this;
          const reset = mode === "reset";
          const vScale = me._cachedMeta.vScale;
          const base2 = vScale.getBasePixel();
          const horizontal = vScale.isHorizontal();
          const ruler = me._getRuler();
          const firstOpts = me.resolveDataElementOptions(start, mode);
          const sharedOptions = me.getSharedOptions(firstOpts);
          const includeOptions = me.includeOptions(mode, sharedOptions);
          me.updateSharedOptions(sharedOptions, mode, firstOpts);
          for (let i = start; i < start + count; i++) {
            const parsed = me.getParsed(i);
            const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base: base2, head: base2} : me._calculateBarValuePixels(i);
            const ipixels = me._calculateBarIndexPixels(i, ruler);
            const stack = (parsed._stacks || {})[vScale.axis];
            const properties = {
              horizontal,
              base: vpixels.base,
              enableBorderRadius: !stack || isFloatBar(parsed._custom) || (me.index === stack._top || me.index === stack._bottom),
              x: horizontal ? vpixels.head : ipixels.center,
              y: horizontal ? ipixels.center : vpixels.head,
              height: horizontal ? ipixels.size : void 0,
              width: horizontal ? void 0 : ipixels.size
            };
            if (includeOptions) {
              properties.options = sharedOptions || me.resolveDataElementOptions(i, mode);
            }
            me.updateElement(bars[i], i, properties, mode);
          }
        }
        _getStacks(last, dataIndex) {
          const me = this;
          const meta2 = me._cachedMeta;
          const iScale = meta2.iScale;
          const metasets = iScale.getMatchingVisibleMetas(me._type);
          const stacked = iScale.options.stacked;
          const ilen = metasets.length;
          const stacks = [];
          let i, item;
          for (i = 0; i < ilen; ++i) {
            item = metasets[i];
            if (typeof dataIndex !== "undefined") {
              const val = item.controller.getParsed(dataIndex)[item.controller._cachedMeta.vScale.axis];
              if (isNullOrUndef(val) || isNaN(val)) {
                continue;
              }
            }
            if (stacked === false || stacks.indexOf(item.stack) === -1 || stacked === void 0 && item.stack === void 0) {
              stacks.push(item.stack);
            }
            if (item.index === last) {
              break;
            }
          }
          if (!stacks.length) {
            stacks.push(void 0);
          }
          return stacks;
        }
        _getStackCount(index2) {
          return this._getStacks(void 0, index2).length;
        }
        _getStackIndex(datasetIndex, name2, dataIndex) {
          const stacks = this._getStacks(datasetIndex, dataIndex);
          const index2 = name2 !== void 0 ? stacks.indexOf(name2) : -1;
          return index2 === -1 ? stacks.length - 1 : index2;
        }
        _getRuler() {
          const me = this;
          const opts = me.options;
          const meta2 = me._cachedMeta;
          const iScale = meta2.iScale;
          const pixels = [];
          let i, ilen;
          for (i = 0, ilen = meta2.data.length; i < ilen; ++i) {
            pixels.push(iScale.getPixelForValue(me.getParsed(i)[iScale.axis], i));
          }
          const barThickness = opts.barThickness;
          const min = barThickness || computeMinSampleSize(iScale);
          return {
            min,
            pixels,
            start: iScale._startPixel,
            end: iScale._endPixel,
            stackCount: me._getStackCount(),
            scale: iScale,
            grouped: opts.grouped,
            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
          };
        }
        _calculateBarValuePixels(index2) {
          const me = this;
          const {vScale, _stacked} = me._cachedMeta;
          const {base: baseValue, minBarLength} = me.options;
          const parsed = me.getParsed(index2);
          const custom = parsed._custom;
          const floating = isFloatBar(custom);
          let value = parsed[vScale.axis];
          let start = 0;
          let length = _stacked ? me.applyStack(vScale, parsed, _stacked) : value;
          let head, size;
          if (length !== value) {
            start = length - value;
            length = value;
          }
          if (floating) {
            value = custom.barStart;
            length = custom.barEnd - custom.barStart;
            if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
              start = 0;
            }
            start += value;
          }
          const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
          let base2 = vScale.getPixelForValue(startValue);
          if (this.chart.getDataVisibility(index2)) {
            head = vScale.getPixelForValue(start + length);
          } else {
            head = base2;
          }
          size = head - base2;
          if (minBarLength !== void 0 && Math.abs(size) < minBarLength) {
            size = size < 0 ? -minBarLength : minBarLength;
            if (value === 0) {
              base2 -= size / 2;
            }
            head = base2 + size;
          }
          const actualBase = baseValue || 0;
          if (base2 === vScale.getPixelForValue(actualBase)) {
            const halfGrid = vScale.getLineWidthForValue(actualBase) / 2;
            if (size > 0) {
              base2 += halfGrid;
              size -= halfGrid;
            } else if (size < 0) {
              base2 -= halfGrid;
              size += halfGrid;
            }
          }
          return {
            size,
            base: base2,
            head,
            center: head + size / 2
          };
        }
        _calculateBarIndexPixels(index2, ruler) {
          const me = this;
          const scale = ruler.scale;
          const options2 = me.options;
          const skipNull = options2.skipNull;
          const maxBarThickness = valueOrDefault(options2.maxBarThickness, Infinity);
          let center, size;
          if (ruler.grouped) {
            const stackCount = skipNull ? me._getStackCount(index2) : ruler.stackCount;
            const range = options2.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options2, stackCount) : computeFitCategoryTraits(index2, ruler, options2, stackCount);
            const stackIndex = me._getStackIndex(me.index, me._cachedMeta.stack, skipNull ? index2 : void 0);
            center = range.start + range.chunk * stackIndex + range.chunk / 2;
            size = Math.min(maxBarThickness, range.chunk * range.ratio);
          } else {
            center = scale.getPixelForValue(me.getParsed(index2)[scale.axis], index2);
            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
          }
          return {
            base: center - size / 2,
            head: center + size / 2,
            center,
            size
          };
        }
        draw() {
          const me = this;
          const chart = me.chart;
          const meta2 = me._cachedMeta;
          const vScale = meta2.vScale;
          const rects = meta2.data;
          const ilen = rects.length;
          let i = 0;
          clipArea(chart.ctx, chart.chartArea);
          for (; i < ilen; ++i) {
            if (me.getParsed(i)[vScale.axis] !== null) {
              rects[i].draw(me._ctx);
            }
          }
          unclipArea(chart.ctx);
        }
      }
      BarController.id = "bar";
      BarController.defaults = {
        datasetElementType: false,
        dataElementType: "bar",
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        grouped: true,
        animations: {
          numbers: {
            type: "number",
            properties: ["x", "y", "base", "width", "height"]
          }
        }
      };
      BarController.overrides = {
        interaction: {
          mode: "index"
        },
        scales: {
          _index_: {
            type: "category",
            offset: true,
            grid: {
              offset: true
            }
          },
          _value_: {
            type: "linear",
            beginAtZero: true
          }
        }
      };
      class BubbleController extends DatasetController {
        initialize() {
          this.enableOptionSharing = true;
          super.initialize();
        }
        parseObjectData(meta2, data, start, count) {
          const {xScale, yScale} = meta2;
          const {xAxisKey = "x", yAxisKey = "y"} = this._parsing;
          const parsed = [];
          let i, ilen, item;
          for (i = start, ilen = start + count; i < ilen; ++i) {
            item = data[i];
            parsed.push({
              x: xScale.parse(resolveObjectKey(item, xAxisKey), i),
              y: yScale.parse(resolveObjectKey(item, yAxisKey), i),
              _custom: item && item.r && +item.r
            });
          }
          return parsed;
        }
        getMaxOverflow() {
          const {data, _parsed} = this._cachedMeta;
          let max = 0;
          for (let i = data.length - 1; i >= 0; --i) {
            max = Math.max(max, data[i].size() / 2, _parsed[i]._custom);
          }
          return max > 0 && max;
        }
        getLabelAndValue(index2) {
          const me = this;
          const meta2 = me._cachedMeta;
          const {xScale, yScale} = meta2;
          const parsed = me.getParsed(index2);
          const x = xScale.getLabelForValue(parsed.x);
          const y = yScale.getLabelForValue(parsed.y);
          const r = parsed._custom;
          return {
            label: meta2.label,
            value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
          };
        }
        update(mode) {
          const me = this;
          const points = me._cachedMeta.data;
          me.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start, count, mode) {
          const me = this;
          const reset = mode === "reset";
          const {iScale, vScale} = me._cachedMeta;
          const firstOpts = me.resolveDataElementOptions(start, mode);
          const sharedOptions = me.getSharedOptions(firstOpts);
          const includeOptions = me.includeOptions(mode, sharedOptions);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          for (let i = start; i < start + count; i++) {
            const point = points[i];
            const parsed = !reset && me.getParsed(i);
            const properties = {};
            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
            properties.skip = isNaN(iPixel) || isNaN(vPixel);
            if (includeOptions) {
              properties.options = me.resolveDataElementOptions(i, mode);
              if (reset) {
                properties.options.radius = 0;
              }
            }
            me.updateElement(point, i, properties, mode);
          }
          me.updateSharedOptions(sharedOptions, mode, firstOpts);
        }
        resolveDataElementOptions(index2, mode) {
          const parsed = this.getParsed(index2);
          let values = super.resolveDataElementOptions(index2, mode);
          if (values.$shared) {
            values = Object.assign({}, values, {$shared: false});
          }
          const radius = values.radius;
          if (mode !== "active") {
            values.radius = 0;
          }
          values.radius += valueOrDefault(parsed && parsed._custom, radius);
          return values;
        }
      }
      BubbleController.id = "bubble";
      BubbleController.defaults = {
        datasetElementType: false,
        dataElementType: "point",
        animations: {
          numbers: {
            type: "number",
            properties: ["x", "y", "borderWidth", "radius"]
          }
        }
      };
      BubbleController.overrides = {
        scales: {
          x: {
            type: "linear"
          },
          y: {
            type: "linear"
          }
        },
        plugins: {
          tooltip: {
            callbacks: {
              title() {
                return "";
              }
            }
          }
        }
      };
      function getRatioAndOffset(rotation, circumference, cutout) {
        let ratioX = 1;
        let ratioY = 1;
        let offsetX = 0;
        let offsetY = 0;
        if (circumference < TAU) {
          const startAngle = rotation;
          const endAngle = startAngle + circumference;
          const startX = Math.cos(startAngle);
          const startY = Math.sin(startAngle);
          const endX = Math.cos(endAngle);
          const endY = Math.sin(endAngle);
          const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
          const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
          const maxX = calcMax(0, startX, endX);
          const maxY = calcMax(HALF_PI, startY, endY);
          const minX = calcMin(PI, startX, endX);
          const minY = calcMin(PI + HALF_PI, startY, endY);
          ratioX = (maxX - minX) / 2;
          ratioY = (maxY - minY) / 2;
          offsetX = -(maxX + minX) / 2;
          offsetY = -(maxY + minY) / 2;
        }
        return {ratioX, ratioY, offsetX, offsetY};
      }
      class DoughnutController extends DatasetController {
        constructor(chart, datasetIndex) {
          super(chart, datasetIndex);
          this.enableOptionSharing = true;
          this.innerRadius = void 0;
          this.outerRadius = void 0;
          this.offsetX = void 0;
          this.offsetY = void 0;
        }
        linkScales() {
        }
        parse(start, count) {
          const data = this.getDataset().data;
          const meta2 = this._cachedMeta;
          let i, ilen;
          for (i = start, ilen = start + count; i < ilen; ++i) {
            meta2._parsed[i] = +data[i];
          }
        }
        _getRotation() {
          return toRadians(this.options.rotation - 90);
        }
        _getCircumference() {
          return toRadians(this.options.circumference);
        }
        _getRotationExtents() {
          let min = TAU;
          let max = -TAU;
          const me = this;
          for (let i = 0; i < me.chart.data.datasets.length; ++i) {
            if (me.chart.isDatasetVisible(i)) {
              const controller = me.chart.getDatasetMeta(i).controller;
              const rotation = controller._getRotation();
              const circumference = controller._getCircumference();
              min = Math.min(min, rotation);
              max = Math.max(max, rotation + circumference);
            }
          }
          return {
            rotation: min,
            circumference: max - min
          };
        }
        update(mode) {
          const me = this;
          const chart = me.chart;
          const {chartArea} = chart;
          const meta2 = me._cachedMeta;
          const arcs = meta2.data;
          const spacing = me.getMaxBorderWidth() + me.getMaxOffset(arcs);
          const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
          const cutout = Math.min(toPercentage(me.options.cutout, maxSize), 1);
          const chartWeight = me._getRingWeight(me.index);
          const {circumference, rotation} = me._getRotationExtents();
          const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);
          const maxWidth = (chartArea.width - spacing) / ratioX;
          const maxHeight = (chartArea.height - spacing) / ratioY;
          const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
          const outerRadius = toDimension(me.options.radius, maxRadius);
          const innerRadius = Math.max(outerRadius * cutout, 0);
          const radiusLength = (outerRadius - innerRadius) / me._getVisibleDatasetWeightTotal();
          me.offsetX = offsetX * outerRadius;
          me.offsetY = offsetY * outerRadius;
          meta2.total = me.calculateTotal();
          me.outerRadius = outerRadius - radiusLength * me._getRingWeightOffset(me.index);
          me.innerRadius = Math.max(me.outerRadius - radiusLength * chartWeight, 0);
          me.updateElements(arcs, 0, arcs.length, mode);
        }
        _circumference(i, reset) {
          const me = this;
          const opts = me.options;
          const meta2 = me._cachedMeta;
          const circumference = me._getCircumference();
          if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta2._parsed[i] === null) {
            return 0;
          }
          return me.calculateCircumference(meta2._parsed[i] * circumference / TAU);
        }
        updateElements(arcs, start, count, mode) {
          const me = this;
          const reset = mode === "reset";
          const chart = me.chart;
          const chartArea = chart.chartArea;
          const opts = chart.options;
          const animationOpts = opts.animation;
          const centerX = (chartArea.left + chartArea.right) / 2;
          const centerY = (chartArea.top + chartArea.bottom) / 2;
          const animateScale = reset && animationOpts.animateScale;
          const innerRadius = animateScale ? 0 : me.innerRadius;
          const outerRadius = animateScale ? 0 : me.outerRadius;
          const firstOpts = me.resolveDataElementOptions(start, mode);
          const sharedOptions = me.getSharedOptions(firstOpts);
          const includeOptions = me.includeOptions(mode, sharedOptions);
          let startAngle = me._getRotation();
          let i;
          for (i = 0; i < start; ++i) {
            startAngle += me._circumference(i, reset);
          }
          for (i = start; i < start + count; ++i) {
            const circumference = me._circumference(i, reset);
            const arc = arcs[i];
            const properties = {
              x: centerX + me.offsetX,
              y: centerY + me.offsetY,
              startAngle,
              endAngle: startAngle + circumference,
              circumference,
              outerRadius,
              innerRadius
            };
            if (includeOptions) {
              properties.options = sharedOptions || me.resolveDataElementOptions(i, mode);
            }
            startAngle += circumference;
            me.updateElement(arc, i, properties, mode);
          }
          me.updateSharedOptions(sharedOptions, mode, firstOpts);
        }
        calculateTotal() {
          const meta2 = this._cachedMeta;
          const metaData = meta2.data;
          let total = 0;
          let i;
          for (i = 0; i < metaData.length; i++) {
            const value = meta2._parsed[i];
            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i)) {
              total += Math.abs(value);
            }
          }
          return total;
        }
        calculateCircumference(value) {
          const total = this._cachedMeta.total;
          if (total > 0 && !isNaN(value)) {
            return TAU * (Math.abs(value) / total);
          }
          return 0;
        }
        getLabelAndValue(index2) {
          const me = this;
          const meta2 = me._cachedMeta;
          const chart = me.chart;
          const labels = chart.data.labels || [];
          const value = formatNumber2(meta2._parsed[index2], chart.options.locale);
          return {
            label: labels[index2] || "",
            value
          };
        }
        getMaxBorderWidth(arcs) {
          const me = this;
          let max = 0;
          const chart = me.chart;
          let i, ilen, meta2, controller, options2;
          if (!arcs) {
            for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
              if (chart.isDatasetVisible(i)) {
                meta2 = chart.getDatasetMeta(i);
                arcs = meta2.data;
                controller = meta2.controller;
                if (controller !== me) {
                  controller.configure();
                }
                break;
              }
            }
          }
          if (!arcs) {
            return 0;
          }
          for (i = 0, ilen = arcs.length; i < ilen; ++i) {
            options2 = controller.resolveDataElementOptions(i);
            if (options2.borderAlign !== "inner") {
              max = Math.max(max, options2.borderWidth || 0, options2.hoverBorderWidth || 0);
            }
          }
          return max;
        }
        getMaxOffset(arcs) {
          let max = 0;
          for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
            const options2 = this.resolveDataElementOptions(i);
            max = Math.max(max, options2.offset || 0, options2.hoverOffset || 0);
          }
          return max;
        }
        _getRingWeightOffset(datasetIndex) {
          let ringWeightOffset = 0;
          for (let i = 0; i < datasetIndex; ++i) {
            if (this.chart.isDatasetVisible(i)) {
              ringWeightOffset += this._getRingWeight(i);
            }
          }
          return ringWeightOffset;
        }
        _getRingWeight(datasetIndex) {
          return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
        }
        _getVisibleDatasetWeightTotal() {
          return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
        }
      }
      DoughnutController.id = "doughnut";
      DoughnutController.defaults = {
        datasetElementType: false,
        dataElementType: "arc",
        animation: {
          animateRotate: true,
          animateScale: false
        },
        animations: {
          numbers: {
            type: "number",
            properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth"]
          }
        },
        cutout: "50%",
        rotation: 0,
        circumference: 360,
        radius: "100%",
        indexAxis: "r"
      };
      DoughnutController.overrides = {
        aspectRatio: 1,
        plugins: {
          legend: {
            labels: {
              generateLabels(chart) {
                const data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  return data.labels.map((label, i) => {
                    const meta2 = chart.getDatasetMeta(0);
                    const style = meta2.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      hidden: !chart.getDataVisibility(i),
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick(e, legendItem, legend) {
              legend.chart.toggleDataVisibility(legendItem.index);
              legend.chart.update();
            }
          },
          tooltip: {
            callbacks: {
              title() {
                return "";
              },
              label(tooltipItem) {
                let dataLabel = tooltipItem.label;
                const value = ": " + tooltipItem.formattedValue;
                if (isArray(dataLabel)) {
                  dataLabel = dataLabel.slice();
                  dataLabel[0] += value;
                } else {
                  dataLabel += value;
                }
                return dataLabel;
              }
            }
          }
        }
      };
      class LineController extends DatasetController {
        initialize() {
          this.enableOptionSharing = true;
          super.initialize();
        }
        update(mode) {
          const me = this;
          const meta2 = me._cachedMeta;
          const {dataset: line, data: points = [], _dataset} = meta2;
          const animationsDisabled = me.chart._animationsDisabled;
          let {start, count} = getStartAndCountOfVisiblePoints(meta2, points, animationsDisabled);
          me._drawStart = start;
          me._drawCount = count;
          if (scaleRangesChanged(meta2)) {
            start = 0;
            count = points.length;
          }
          line._decimated = !!_dataset._decimated;
          line.points = points;
          const options2 = me.resolveDatasetElementOptions(mode);
          if (!me.options.showLine) {
            options2.borderWidth = 0;
          }
          options2.segment = me.options.segment;
          me.updateElement(line, void 0, {
            animated: !animationsDisabled,
            options: options2
          }, mode);
          me.updateElements(points, start, count, mode);
        }
        updateElements(points, start, count, mode) {
          const me = this;
          const reset = mode === "reset";
          const {iScale, vScale, _stacked} = me._cachedMeta;
          const firstOpts = me.resolveDataElementOptions(start, mode);
          const sharedOptions = me.getSharedOptions(firstOpts);
          const includeOptions = me.includeOptions(mode, sharedOptions);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const spanGaps = me.options.spanGaps;
          const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
          const directUpdate = me.chart._animationsDisabled || reset || mode === "none";
          let prevParsed = start > 0 && me.getParsed(start - 1);
          for (let i = start; i < start + count; ++i) {
            const point = points[i];
            const parsed = me.getParsed(i);
            const properties = directUpdate ? point : {};
            const nullData = isNullOrUndef(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? me.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && parsed[iAxis] - prevParsed[iAxis] > maxGapLength;
            properties.parsed = parsed;
            if (includeOptions) {
              properties.options = sharedOptions || me.resolveDataElementOptions(i, mode);
            }
            if (!directUpdate) {
              me.updateElement(point, i, properties, mode);
            }
            prevParsed = parsed;
          }
          me.updateSharedOptions(sharedOptions, mode, firstOpts);
        }
        getMaxOverflow() {
          const me = this;
          const meta2 = me._cachedMeta;
          const dataset = meta2.dataset;
          const border = dataset.options && dataset.options.borderWidth || 0;
          const data = meta2.data || [];
          if (!data.length) {
            return border;
          }
          const firstPoint = data[0].size(me.resolveDataElementOptions(0));
          const lastPoint = data[data.length - 1].size(me.resolveDataElementOptions(data.length - 1));
          return Math.max(border, firstPoint, lastPoint) / 2;
        }
        draw() {
          const meta2 = this._cachedMeta;
          meta2.dataset.updateControlPoints(this.chart.chartArea, meta2.iScale.axis);
          super.draw();
        }
      }
      LineController.id = "line";
      LineController.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        showLine: true,
        spanGaps: false
      };
      LineController.overrides = {
        scales: {
          _index_: {
            type: "category"
          },
          _value_: {
            type: "linear"
          }
        }
      };
      function getStartAndCountOfVisiblePoints(meta2, points, animationsDisabled) {
        const pointCount = points.length;
        let start = 0;
        let count = pointCount;
        if (meta2._sorted) {
          const {iScale, _parsed} = meta2;
          const axis = iScale.axis;
          const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
          if (minDefined) {
            start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
          }
          if (maxDefined) {
            count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1), start, pointCount) - start;
          } else {
            count = pointCount - start;
          }
        }
        return {start, count};
      }
      function scaleRangesChanged(meta2) {
        const {xScale, yScale, _scaleRanges} = meta2;
        const newRanges = {
          xmin: xScale.min,
          xmax: xScale.max,
          ymin: yScale.min,
          ymax: yScale.max
        };
        if (!_scaleRanges) {
          meta2._scaleRanges = newRanges;
          return true;
        }
        const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
        Object.assign(_scaleRanges, newRanges);
        return changed;
      }
      class PolarAreaController extends DatasetController {
        constructor(chart, datasetIndex) {
          super(chart, datasetIndex);
          this.innerRadius = void 0;
          this.outerRadius = void 0;
        }
        getLabelAndValue(index2) {
          const me = this;
          const meta2 = me._cachedMeta;
          const chart = me.chart;
          const labels = chart.data.labels || [];
          const value = formatNumber2(meta2._parsed[index2].r, chart.options.locale);
          return {
            label: labels[index2] || "",
            value
          };
        }
        update(mode) {
          const arcs = this._cachedMeta.data;
          this._updateRadius();
          this.updateElements(arcs, 0, arcs.length, mode);
        }
        _updateRadius() {
          const me = this;
          const chart = me.chart;
          const chartArea = chart.chartArea;
          const opts = chart.options;
          const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
          const outerRadius = Math.max(minSize / 2, 0);
          const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
          const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
          me.outerRadius = outerRadius - radiusLength * me.index;
          me.innerRadius = me.outerRadius - radiusLength;
        }
        updateElements(arcs, start, count, mode) {
          const me = this;
          const reset = mode === "reset";
          const chart = me.chart;
          const dataset = me.getDataset();
          const opts = chart.options;
          const animationOpts = opts.animation;
          const scale = me._cachedMeta.rScale;
          const centerX = scale.xCenter;
          const centerY = scale.yCenter;
          const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
          let angle = datasetStartAngle;
          let i;
          const defaultAngle = 360 / me.countVisibleElements();
          for (i = 0; i < start; ++i) {
            angle += me._computeAngle(i, mode, defaultAngle);
          }
          for (i = start; i < start + count; i++) {
            const arc = arcs[i];
            let startAngle = angle;
            let endAngle = angle + me._computeAngle(i, mode, defaultAngle);
            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;
            angle = endAngle;
            if (reset) {
              if (animationOpts.animateScale) {
                outerRadius = 0;
              }
              if (animationOpts.animateRotate) {
                startAngle = endAngle = datasetStartAngle;
              }
            }
            const properties = {
              x: centerX,
              y: centerY,
              innerRadius: 0,
              outerRadius,
              startAngle,
              endAngle,
              options: me.resolveDataElementOptions(i, mode)
            };
            me.updateElement(arc, i, properties, mode);
          }
        }
        countVisibleElements() {
          const dataset = this.getDataset();
          const meta2 = this._cachedMeta;
          let count = 0;
          meta2.data.forEach((element, index2) => {
            if (!isNaN(dataset.data[index2]) && this.chart.getDataVisibility(index2)) {
              count++;
            }
          });
          return count;
        }
        _computeAngle(index2, mode, defaultAngle) {
          return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
        }
      }
      PolarAreaController.id = "polarArea";
      PolarAreaController.defaults = {
        dataElementType: "arc",
        animation: {
          animateRotate: true,
          animateScale: true
        },
        animations: {
          numbers: {
            type: "number",
            properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
          }
        },
        indexAxis: "r",
        startAngle: 0
      };
      PolarAreaController.overrides = {
        aspectRatio: 1,
        plugins: {
          legend: {
            labels: {
              generateLabels(chart) {
                const data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  return data.labels.map((label, i) => {
                    const meta2 = chart.getDatasetMeta(0);
                    const style = meta2.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      hidden: !chart.getDataVisibility(i),
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick(e, legendItem, legend) {
              legend.chart.toggleDataVisibility(legendItem.index);
              legend.chart.update();
            }
          },
          tooltip: {
            callbacks: {
              title() {
                return "";
              },
              label(context) {
                return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
              }
            }
          }
        },
        scales: {
          r: {
            type: "radialLinear",
            angleLines: {
              display: false
            },
            beginAtZero: true,
            grid: {
              circular: true
            },
            pointLabels: {
              display: false
            },
            startAngle: 0
          }
        }
      };
      class PieController extends DoughnutController {
      }
      PieController.id = "pie";
      PieController.defaults = {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: "100%"
      };
      class RadarController extends DatasetController {
        getLabelAndValue(index2) {
          const me = this;
          const vScale = me._cachedMeta.vScale;
          const parsed = me.getParsed(index2);
          return {
            label: vScale.getLabels()[index2],
            value: "" + vScale.getLabelForValue(parsed[vScale.axis])
          };
        }
        update(mode) {
          const me = this;
          const meta2 = me._cachedMeta;
          const line = meta2.dataset;
          const points = meta2.data || [];
          const labels = meta2.iScale.getLabels();
          line.points = points;
          if (mode !== "resize") {
            const options2 = me.resolveDatasetElementOptions(mode);
            if (!me.options.showLine) {
              options2.borderWidth = 0;
            }
            const properties = {
              _loop: true,
              _fullLoop: labels.length === points.length,
              options: options2
            };
            me.updateElement(line, void 0, properties, mode);
          }
          me.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start, count, mode) {
          const me = this;
          const dataset = me.getDataset();
          const scale = me._cachedMeta.rScale;
          const reset = mode === "reset";
          for (let i = start; i < start + count; i++) {
            const point = points[i];
            const options2 = me.resolveDataElementOptions(i, mode);
            const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);
            const x = reset ? scale.xCenter : pointPosition.x;
            const y = reset ? scale.yCenter : pointPosition.y;
            const properties = {
              x,
              y,
              angle: pointPosition.angle,
              skip: isNaN(x) || isNaN(y),
              options: options2
            };
            me.updateElement(point, i, properties, mode);
          }
        }
      }
      RadarController.id = "radar";
      RadarController.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        indexAxis: "r",
        showLine: true,
        elements: {
          line: {
            fill: "start"
          }
        }
      };
      RadarController.overrides = {
        aspectRatio: 1,
        scales: {
          r: {
            type: "radialLinear"
          }
        }
      };
      class ScatterController extends LineController {
      }
      ScatterController.id = "scatter";
      ScatterController.defaults = {
        showLine: false,
        fill: false
      };
      ScatterController.overrides = {
        interaction: {
          mode: "point"
        },
        plugins: {
          tooltip: {
            callbacks: {
              title() {
                return "";
              },
              label(item) {
                return "(" + item.label + ", " + item.formattedValue + ")";
              }
            }
          }
        },
        scales: {
          x: {
            type: "linear"
          },
          y: {
            type: "linear"
          }
        }
      };
      var controllers = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        BarController,
        BubbleController,
        DoughnutController,
        LineController,
        PolarAreaController,
        PieController,
        RadarController,
        ScatterController
      });
      function clipArc(ctx, element) {
        const {startAngle, endAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;
        let angleMargin = pixelMargin / outerRadius;
        ctx.beginPath();
        ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
        if (innerRadius > pixelMargin) {
          angleMargin = pixelMargin / innerRadius;
          ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
        } else {
          ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
        }
        ctx.closePath();
        ctx.clip();
      }
      function toRadiusCorners(value) {
        return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
      }
      function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
        const o = toRadiusCorners(arc.options.borderRadius);
        const halfThickness = (outerRadius - innerRadius) / 2;
        const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
        const computeOuterLimit = (val) => {
          const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
          return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
        };
        return {
          outerStart: computeOuterLimit(o.outerStart),
          outerEnd: computeOuterLimit(o.outerEnd),
          innerStart: _limitValue(o.innerStart, 0, innerLimit),
          innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
        };
      }
      function rThetaToXY(r, theta, x, y) {
        return {
          x: x + r * Math.cos(theta),
          y: y + r * Math.sin(theta)
        };
      }
      function pathArc(ctx, element, offset) {
        const {x, y, startAngle: start, endAngle: end, pixelMargin, innerRadius: innerR} = element;
        const outerRadius = Math.max(element.outerRadius + offset - pixelMargin, 0);
        const innerRadius = innerR > 0 ? innerR + offset + pixelMargin : 0;
        const alpha = end - start;
        const beta = Math.max(1e-3, alpha * outerRadius - offset / PI) / outerRadius;
        const angleOffset = (alpha - beta) / 2;
        const startAngle = start + angleOffset;
        const endAngle = end - angleOffset;
        const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
        const outerStartAdjustedRadius = outerRadius - outerStart;
        const outerEndAdjustedRadius = outerRadius - outerEnd;
        const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
        const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
        const innerStartAdjustedRadius = innerRadius + innerStart;
        const innerEndAdjustedRadius = innerRadius + innerEnd;
        const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
        const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
        ctx.beginPath();
        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
        if (outerEnd > 0) {
          const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
          ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
        }
        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
        ctx.lineTo(p4.x, p4.y);
        if (innerEnd > 0) {
          const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
          ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
        }
        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
        if (innerStart > 0) {
          const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
          ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
        }
        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
        ctx.lineTo(p8.x, p8.y);
        if (outerStart > 0) {
          const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
          ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
        }
        ctx.closePath();
      }
      function drawArc(ctx, element, offset) {
        if (element.fullCircles) {
          element.endAngle = element.startAngle + TAU;
          pathArc(ctx, element, offset);
          for (let i = 0; i < element.fullCircles; ++i) {
            ctx.fill();
          }
        }
        if (!isNaN(element.circumference)) {
          element.endAngle = element.startAngle + element.circumference % TAU;
        }
        pathArc(ctx, element, offset);
        ctx.fill();
      }
      function drawFullCircleBorders(ctx, element, inner) {
        const {x, y, startAngle, endAngle, pixelMargin} = element;
        const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
        const innerRadius = element.innerRadius + pixelMargin;
        let i;
        if (inner) {
          element.endAngle = element.startAngle + TAU;
          clipArc(ctx, element);
          element.endAngle = endAngle;
          if (element.endAngle === element.startAngle) {
            element.endAngle += TAU;
            element.fullCircles--;
          }
        }
        ctx.beginPath();
        ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
        for (i = 0; i < element.fullCircles; ++i) {
          ctx.stroke();
        }
        ctx.beginPath();
        ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
        for (i = 0; i < element.fullCircles; ++i) {
          ctx.stroke();
        }
      }
      function drawBorder(ctx, element, offset) {
        const {options: options2} = element;
        const inner = options2.borderAlign === "inner";
        if (!options2.borderWidth) {
          return;
        }
        if (inner) {
          ctx.lineWidth = options2.borderWidth * 2;
          ctx.lineJoin = "round";
        } else {
          ctx.lineWidth = options2.borderWidth;
          ctx.lineJoin = "bevel";
        }
        if (element.fullCircles) {
          drawFullCircleBorders(ctx, element, inner);
        }
        if (inner) {
          clipArc(ctx, element);
        }
        pathArc(ctx, element, offset);
        ctx.stroke();
      }
      class ArcElement extends Element {
        constructor(cfg) {
          super();
          this.options = void 0;
          this.circumference = void 0;
          this.startAngle = void 0;
          this.endAngle = void 0;
          this.innerRadius = void 0;
          this.outerRadius = void 0;
          this.pixelMargin = 0;
          this.fullCircles = 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        inRange(chartX, chartY, useFinalPosition) {
          const point = this.getProps(["x", "y"], useFinalPosition);
          const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});
          const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius",
            "circumference"
          ], useFinalPosition);
          const betweenAngles = circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
          const withinRadius = distance >= innerRadius && distance <= outerRadius;
          return betweenAngles && withinRadius;
        }
        getCenterPoint(useFinalPosition) {
          const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([
            "x",
            "y",
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius"
          ], useFinalPosition);
          const halfAngle = (startAngle + endAngle) / 2;
          const halfRadius = (innerRadius + outerRadius) / 2;
          return {
            x: x + Math.cos(halfAngle) * halfRadius,
            y: y + Math.sin(halfAngle) * halfRadius
          };
        }
        tooltipPosition(useFinalPosition) {
          return this.getCenterPoint(useFinalPosition);
        }
        draw(ctx) {
          const me = this;
          const options2 = me.options;
          const offset = (options2.offset || 0) / 2;
          me.pixelMargin = options2.borderAlign === "inner" ? 0.33 : 0;
          me.fullCircles = Math.floor(me.circumference / TAU);
          if (me.circumference === 0 || me.innerRadius < 0 || me.outerRadius < 0) {
            return;
          }
          ctx.save();
          let radiusOffset = 0;
          if (offset) {
            radiusOffset = offset / 2;
            const halfAngle = (me.startAngle + me.endAngle) / 2;
            ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
            if (me.circumference >= PI) {
              radiusOffset = offset;
            }
          }
          ctx.fillStyle = options2.backgroundColor;
          ctx.strokeStyle = options2.borderColor;
          drawArc(ctx, me, radiusOffset);
          drawBorder(ctx, me, radiusOffset);
          ctx.restore();
        }
      }
      ArcElement.id = "arc";
      ArcElement.defaults = {
        borderAlign: "center",
        borderColor: "#fff",
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        angle: void 0
      };
      ArcElement.defaultRoutes = {
        backgroundColor: "backgroundColor"
      };
      function setStyle(ctx, options2, style = options2) {
        ctx.lineCap = valueOrDefault(style.borderCapStyle, options2.borderCapStyle);
        ctx.setLineDash(valueOrDefault(style.borderDash, options2.borderDash));
        ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options2.borderDashOffset);
        ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options2.borderJoinStyle);
        ctx.lineWidth = valueOrDefault(style.borderWidth, options2.borderWidth);
        ctx.strokeStyle = valueOrDefault(style.borderColor, options2.borderColor);
      }
      function lineTo(ctx, previous, target) {
        ctx.lineTo(target.x, target.y);
      }
      function getLineMethod(options2) {
        if (options2.stepped) {
          return _steppedLineTo;
        }
        if (options2.tension || options2.cubicInterpolationMode === "monotone") {
          return _bezierCurveTo;
        }
        return lineTo;
      }
      function pathVars(points, segment, params = {}) {
        const count = points.length;
        const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;
        const {start: segmentStart, end: segmentEnd} = segment;
        const start = Math.max(paramsStart, segmentStart);
        const end = Math.min(paramsEnd, segmentEnd);
        const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
        return {
          count,
          start,
          loop: segment.loop,
          ilen: end < start && !outside ? count + end - start : end - start
        };
      }
      function pathSegment(ctx, line, segment, params) {
        const {points, options: options2} = line;
        const {count, start, loop, ilen} = pathVars(points, segment, params);
        const lineMethod = getLineMethod(options2);
        let {move = true, reverse} = params || {};
        let i, point, prev;
        for (i = 0; i <= ilen; ++i) {
          point = points[(start + (reverse ? ilen - i : i)) % count];
          if (point.skip) {
            continue;
          } else if (move) {
            ctx.moveTo(point.x, point.y);
            move = false;
          } else {
            lineMethod(ctx, prev, point, reverse, options2.stepped);
          }
          prev = point;
        }
        if (loop) {
          point = points[(start + (reverse ? ilen : 0)) % count];
          lineMethod(ctx, prev, point, reverse, options2.stepped);
        }
        return !!loop;
      }
      function fastPathSegment(ctx, line, segment, params) {
        const points = line.points;
        const {count, start, ilen} = pathVars(points, segment, params);
        const {move = true, reverse} = params || {};
        let avgX = 0;
        let countX = 0;
        let i, point, prevX, minY, maxY, lastY;
        const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
        const drawX = () => {
          if (minY !== maxY) {
            ctx.lineTo(avgX, maxY);
            ctx.lineTo(avgX, minY);
            ctx.lineTo(avgX, lastY);
          }
        };
        if (move) {
          point = points[pointIndex(0)];
          ctx.moveTo(point.x, point.y);
        }
        for (i = 0; i <= ilen; ++i) {
          point = points[pointIndex(i)];
          if (point.skip) {
            continue;
          }
          const x = point.x;
          const y = point.y;
          const truncX = x | 0;
          if (truncX === prevX) {
            if (y < minY) {
              minY = y;
            } else if (y > maxY) {
              maxY = y;
            }
            avgX = (countX * avgX + x) / ++countX;
          } else {
            drawX();
            ctx.lineTo(x, y);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
          }
          lastY = y;
        }
        drawX();
      }
      function _getSegmentMethod(line) {
        const opts = line.options;
        const borderDash = opts.borderDash && opts.borderDash.length;
        const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
        return useFastPath ? fastPathSegment : pathSegment;
      }
      function _getInterpolationMethod(options2) {
        if (options2.stepped) {
          return _steppedInterpolation;
        }
        if (options2.tension || options2.cubicInterpolationMode === "monotone") {
          return _bezierInterpolation;
        }
        return _pointInLine;
      }
      function strokePathWithCache(ctx, line, start, count) {
        let path = line._path;
        if (!path) {
          path = line._path = new Path2D();
          if (line.path(path, start, count)) {
            path.closePath();
          }
        }
        setStyle(ctx, line.options);
        ctx.stroke(path);
      }
      function strokePathDirect(ctx, line, start, count) {
        const {segments, options: options2} = line;
        const segmentMethod = _getSegmentMethod(line);
        for (const segment of segments) {
          setStyle(ctx, options2, segment.style);
          ctx.beginPath();
          if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {
            ctx.closePath();
          }
          ctx.stroke();
        }
      }
      const usePath2D = typeof Path2D === "function";
      function draw(ctx, line, start, count) {
        if (usePath2D && line.segments.length === 1) {
          strokePathWithCache(ctx, line, start, count);
        } else {
          strokePathDirect(ctx, line, start, count);
        }
      }
      class LineElement extends Element {
        constructor(cfg) {
          super();
          this.animated = true;
          this.options = void 0;
          this._loop = void 0;
          this._fullLoop = void 0;
          this._path = void 0;
          this._points = void 0;
          this._segments = void 0;
          this._decimated = false;
          this._pointsUpdated = false;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        updateControlPoints(chartArea, indexAxis) {
          const me = this;
          const options2 = me.options;
          if ((options2.tension || options2.cubicInterpolationMode === "monotone") && !options2.stepped && !me._pointsUpdated) {
            const loop = options2.spanGaps ? me._loop : me._fullLoop;
            _updateBezierControlPoints(me._points, options2, chartArea, loop, indexAxis);
            me._pointsUpdated = true;
          }
        }
        set points(points) {
          const me = this;
          me._points = points;
          delete me._segments;
          delete me._path;
          me._pointsUpdated = false;
        }
        get points() {
          return this._points;
        }
        get segments() {
          return this._segments || (this._segments = _computeSegments(this, this.options.segment));
        }
        first() {
          const segments = this.segments;
          const points = this.points;
          return segments.length && points[segments[0].start];
        }
        last() {
          const segments = this.segments;
          const points = this.points;
          const count = segments.length;
          return count && points[segments[count - 1].end];
        }
        interpolate(point, property) {
          const me = this;
          const options2 = me.options;
          const value = point[property];
          const points = me.points;
          const segments = _boundSegments(me, {property, start: value, end: value});
          if (!segments.length) {
            return;
          }
          const result = [];
          const _interpolate = _getInterpolationMethod(options2);
          let i, ilen;
          for (i = 0, ilen = segments.length; i < ilen; ++i) {
            const {start, end} = segments[i];
            const p1 = points[start];
            const p2 = points[end];
            if (p1 === p2) {
              result.push(p1);
              continue;
            }
            const t2 = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
            const interpolated = _interpolate(p1, p2, t2, options2.stepped);
            interpolated[property] = point[property];
            result.push(interpolated);
          }
          return result.length === 1 ? result[0] : result;
        }
        pathSegment(ctx, segment, params) {
          const segmentMethod = _getSegmentMethod(this);
          return segmentMethod(ctx, this, segment, params);
        }
        path(ctx, start, count) {
          const me = this;
          const segments = me.segments;
          const segmentMethod = _getSegmentMethod(me);
          let loop = me._loop;
          start = start || 0;
          count = count || me.points.length - start;
          for (const segment of segments) {
            loop &= segmentMethod(ctx, me, segment, {start, end: start + count - 1});
          }
          return !!loop;
        }
        draw(ctx, chartArea, start, count) {
          const me = this;
          const options2 = me.options || {};
          const points = me.points || [];
          if (!points.length || !options2.borderWidth) {
            return;
          }
          ctx.save();
          draw(ctx, me, start, count);
          ctx.restore();
          if (me.animated) {
            me._pointsUpdated = false;
            me._path = void 0;
          }
        }
      }
      LineElement.id = "line";
      LineElement.defaults = {
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderWidth: 3,
        capBezierPoints: true,
        cubicInterpolationMode: "default",
        fill: false,
        spanGaps: false,
        stepped: false,
        tension: 0
      };
      LineElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      };
      LineElement.descriptors = {
        _scriptable: true,
        _indexable: (name2) => name2 !== "borderDash" && name2 !== "fill"
      };
      function inRange$1(el, pos, axis, useFinalPosition) {
        const options2 = el.options;
        const {[axis]: value} = el.getProps([axis], useFinalPosition);
        return Math.abs(pos - value) < options2.radius + options2.hitRadius;
      }
      class PointElement extends Element {
        constructor(cfg) {
          super();
          this.options = void 0;
          this.parsed = void 0;
          this.skip = void 0;
          this.stop = void 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        inRange(mouseX, mouseY, useFinalPosition) {
          const options2 = this.options;
          const {x, y} = this.getProps(["x", "y"], useFinalPosition);
          return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options2.hitRadius + options2.radius, 2);
        }
        inXRange(mouseX, useFinalPosition) {
          return inRange$1(this, mouseX, "x", useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
          return inRange$1(this, mouseY, "y", useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
          const {x, y} = this.getProps(["x", "y"], useFinalPosition);
          return {x, y};
        }
        size(options2) {
          options2 = options2 || this.options || {};
          let radius = options2.radius || 0;
          radius = Math.max(radius, radius && options2.hoverRadius || 0);
          const borderWidth = radius && options2.borderWidth || 0;
          return (radius + borderWidth) * 2;
        }
        draw(ctx) {
          const me = this;
          const options2 = me.options;
          if (me.skip || options2.radius < 0.1) {
            return;
          }
          ctx.strokeStyle = options2.borderColor;
          ctx.lineWidth = options2.borderWidth;
          ctx.fillStyle = options2.backgroundColor;
          drawPoint(ctx, options2, me.x, me.y);
        }
        getRange() {
          const options2 = this.options || {};
          return options2.radius + options2.hitRadius;
        }
      }
      PointElement.id = "point";
      PointElement.defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: "circle",
        radius: 3,
        rotation: 0
      };
      PointElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      };
      function getBarBounds(bar, useFinalPosition) {
        const {x, y, base: base2, width, height} = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
        let left, right, top2, bottom, half;
        if (bar.horizontal) {
          half = height / 2;
          left = Math.min(x, base2);
          right = Math.max(x, base2);
          top2 = y - half;
          bottom = y + half;
        } else {
          half = width / 2;
          left = x - half;
          right = x + half;
          top2 = Math.min(y, base2);
          bottom = Math.max(y, base2);
        }
        return {left, top: top2, right, bottom};
      }
      function parseBorderSkipped(bar) {
        let edge = bar.options.borderSkipped;
        const res = {};
        if (!edge) {
          return res;
        }
        edge = bar.horizontal ? parseEdge(edge, "left", "right", bar.base > bar.x) : parseEdge(edge, "bottom", "top", bar.base < bar.y);
        res[edge] = true;
        return res;
      }
      function parseEdge(edge, a, b, reverse) {
        if (reverse) {
          edge = swap(edge, a, b);
          edge = startEnd(edge, b, a);
        } else {
          edge = startEnd(edge, a, b);
        }
        return edge;
      }
      function swap(orig, v1, v2) {
        return orig === v1 ? v2 : orig === v2 ? v1 : orig;
      }
      function startEnd(v, start, end) {
        return v === "start" ? start : v === "end" ? end : v;
      }
      function skipOrLimit(skip2, value, min, max) {
        return skip2 ? 0 : Math.max(Math.min(value, max), min);
      }
      function parseBorderWidth(bar, maxW, maxH) {
        const value = bar.options.borderWidth;
        const skip2 = parseBorderSkipped(bar);
        const o = toTRBL(value);
        return {
          t: skipOrLimit(skip2.top, o.top, 0, maxH),
          r: skipOrLimit(skip2.right, o.right, 0, maxW),
          b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
          l: skipOrLimit(skip2.left, o.left, 0, maxW)
        };
      }
      function parseBorderRadius(bar, maxW, maxH) {
        const {enableBorderRadius} = bar.getProps(["enableBorderRadius"]);
        const value = bar.options.borderRadius;
        const o = toTRBLCorners(value);
        const maxR = Math.min(maxW, maxH);
        const skip2 = parseBorderSkipped(bar);
        const enableBorder = enableBorderRadius || isObject(value);
        return {
          topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
          topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
          bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
          bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
        };
      }
      function boundingRects(bar) {
        const bounds = getBarBounds(bar);
        const width = bounds.right - bounds.left;
        const height = bounds.bottom - bounds.top;
        const border = parseBorderWidth(bar, width / 2, height / 2);
        const radius = parseBorderRadius(bar, width / 2, height / 2);
        return {
          outer: {
            x: bounds.left,
            y: bounds.top,
            w: width,
            h: height,
            radius
          },
          inner: {
            x: bounds.left + border.l,
            y: bounds.top + border.t,
            w: width - border.l - border.r,
            h: height - border.t - border.b,
            radius: {
              topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
              topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
              bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
              bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
            }
          }
        };
      }
      function inRange(bar, x, y, useFinalPosition) {
        const skipX = x === null;
        const skipY = y === null;
        const skipBoth = skipX && skipY;
        const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
        return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
      }
      function hasRadius(radius) {
        return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
      }
      function addNormalRectPath(ctx, rect) {
        ctx.rect(rect.x, rect.y, rect.w, rect.h);
      }
      class BarElement extends Element {
        constructor(cfg) {
          super();
          this.options = void 0;
          this.horizontal = void 0;
          this.base = void 0;
          this.width = void 0;
          this.height = void 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        draw(ctx) {
          const options2 = this.options;
          const {inner, outer} = boundingRects(this);
          const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
          ctx.save();
          if (outer.w !== inner.w || outer.h !== inner.h) {
            ctx.beginPath();
            addRectPath(ctx, outer);
            ctx.clip();
            addRectPath(ctx, inner);
            ctx.fillStyle = options2.borderColor;
            ctx.fill("evenodd");
          }
          ctx.beginPath();
          addRectPath(ctx, inner);
          ctx.fillStyle = options2.backgroundColor;
          ctx.fill();
          ctx.restore();
        }
        inRange(mouseX, mouseY, useFinalPosition) {
          return inRange(this, mouseX, mouseY, useFinalPosition);
        }
        inXRange(mouseX, useFinalPosition) {
          return inRange(this, mouseX, null, useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
          return inRange(this, null, mouseY, useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
          const {x, y, base: base2, horizontal} = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
          return {
            x: horizontal ? (x + base2) / 2 : x,
            y: horizontal ? y : (y + base2) / 2
          };
        }
        getRange(axis) {
          return axis === "x" ? this.width / 2 : this.height / 2;
        }
      }
      BarElement.id = "bar";
      BarElement.defaults = {
        borderSkipped: "start",
        borderWidth: 0,
        borderRadius: 0,
        enableBorderRadius: true,
        pointStyle: void 0
      };
      BarElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      };
      var elements = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ArcElement,
        LineElement,
        PointElement,
        BarElement
      });
      function lttbDecimation(data, start, count, availableWidth, options2) {
        const samples = options2.samples || availableWidth;
        if (samples >= count) {
          return data.slice(start, start + count);
        }
        const decimated = [];
        const bucketWidth = (count - 2) / (samples - 2);
        let sampledIndex = 0;
        const endIndex = start + count - 1;
        let a = start;
        let i, maxAreaPoint, maxArea, area, nextA;
        decimated[sampledIndex++] = data[a];
        for (i = 0; i < samples - 2; i++) {
          let avgX = 0;
          let avgY = 0;
          let j;
          const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
          const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
          const avgRangeLength = avgRangeEnd - avgRangeStart;
          for (j = avgRangeStart; j < avgRangeEnd; j++) {
            avgX += data[j].x;
            avgY += data[j].y;
          }
          avgX /= avgRangeLength;
          avgY /= avgRangeLength;
          const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
          const rangeTo = Math.floor((i + 1) * bucketWidth) + 1 + start;
          const {x: pointAx, y: pointAy} = data[a];
          maxArea = area = -1;
          for (j = rangeOffs; j < rangeTo; j++) {
            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
            if (area > maxArea) {
              maxArea = area;
              maxAreaPoint = data[j];
              nextA = j;
            }
          }
          decimated[sampledIndex++] = maxAreaPoint;
          a = nextA;
        }
        decimated[sampledIndex++] = data[endIndex];
        return decimated;
      }
      function minMaxDecimation(data, start, count, availableWidth) {
        let avgX = 0;
        let countX = 0;
        let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
        const decimated = [];
        const endIndex = start + count - 1;
        const xMin = data[start].x;
        const xMax = data[endIndex].x;
        const dx = xMax - xMin;
        for (i = start; i < start + count; ++i) {
          point = data[i];
          x = (point.x - xMin) / dx * availableWidth;
          y = point.y;
          const truncX = x | 0;
          if (truncX === prevX) {
            if (y < minY) {
              minY = y;
              minIndex = i;
            } else if (y > maxY) {
              maxY = y;
              maxIndex = i;
            }
            avgX = (countX * avgX + point.x) / ++countX;
          } else {
            const lastIndex = i - 1;
            if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
              const intermediateIndex1 = Math.min(minIndex, maxIndex);
              const intermediateIndex2 = Math.max(minIndex, maxIndex);
              if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                decimated.push({
                  ...data[intermediateIndex1],
                  x: avgX
                });
              }
              if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                decimated.push({
                  ...data[intermediateIndex2],
                  x: avgX
                });
              }
            }
            if (i > 0 && lastIndex !== startIndex) {
              decimated.push(data[lastIndex]);
            }
            decimated.push(point);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
            minIndex = maxIndex = startIndex = i;
          }
        }
        return decimated;
      }
      function cleanDecimatedDataset(dataset) {
        if (dataset._decimated) {
          const data = dataset._data;
          delete dataset._decimated;
          delete dataset._data;
          Object.defineProperty(dataset, "data", {value: data});
        }
      }
      function cleanDecimatedData(chart) {
        chart.data.datasets.forEach((dataset) => {
          cleanDecimatedDataset(dataset);
        });
      }
      function getStartAndCountOfVisiblePointsSimplified(meta2, points) {
        const pointCount = points.length;
        let start = 0;
        let count;
        const {iScale} = meta2;
        const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
        if (minDefined) {
          start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
        }
        if (maxDefined) {
          count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
        } else {
          count = pointCount - start;
        }
        return {start, count};
      }
      var plugin_decimation = {
        id: "decimation",
        defaults: {
          algorithm: "min-max",
          enabled: false
        },
        beforeElementsUpdate: (chart, args, options2) => {
          if (!options2.enabled) {
            cleanDecimatedData(chart);
            return;
          }
          const availableWidth = chart.width;
          chart.data.datasets.forEach((dataset, datasetIndex) => {
            const {_data, indexAxis} = dataset;
            const meta2 = chart.getDatasetMeta(datasetIndex);
            const data = _data || dataset.data;
            if (resolve2([indexAxis, chart.options.indexAxis]) === "y") {
              return;
            }
            if (meta2.type !== "line") {
              return;
            }
            const xAxis = chart.scales[meta2.xAxisID];
            if (xAxis.type !== "linear" && xAxis.type !== "time") {
              return;
            }
            if (chart.options.parsing) {
              return;
            }
            let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta2, data);
            if (count <= 4 * availableWidth) {
              cleanDecimatedDataset(dataset);
              return;
            }
            if (isNullOrUndef(_data)) {
              dataset._data = data;
              delete dataset.data;
              Object.defineProperty(dataset, "data", {
                configurable: true,
                enumerable: true,
                get: function() {
                  return this._decimated;
                },
                set: function(d) {
                  this._data = d;
                }
              });
            }
            let decimated;
            switch (options2.algorithm) {
              case "lttb":
                decimated = lttbDecimation(data, start, count, availableWidth, options2);
                break;
              case "min-max":
                decimated = minMaxDecimation(data, start, count, availableWidth);
                break;
              default:
                throw new Error(`Unsupported decimation algorithm '${options2.algorithm}'`);
            }
            dataset._decimated = decimated;
          });
        },
        destroy(chart) {
          cleanDecimatedData(chart);
        }
      };
      function getLineByIndex(chart, index2) {
        const meta2 = chart.getDatasetMeta(index2);
        const visible = meta2 && chart.isDatasetVisible(index2);
        return visible ? meta2.dataset : null;
      }
      function parseFillOption(line) {
        const options2 = line.options;
        const fillOption = options2.fill;
        let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
        if (fill === void 0) {
          fill = !!options2.backgroundColor;
        }
        if (fill === false || fill === null) {
          return false;
        }
        if (fill === true) {
          return "origin";
        }
        return fill;
      }
      function decodeFill(line, index2, count) {
        const fill = parseFillOption(line);
        if (isObject(fill)) {
          return isNaN(fill.value) ? false : fill;
        }
        let target = parseFloat(fill);
        if (isNumberFinite(target) && Math.floor(target) === target) {
          if (fill[0] === "-" || fill[0] === "+") {
            target = index2 + target;
          }
          if (target === index2 || target < 0 || target >= count) {
            return false;
          }
          return target;
        }
        return ["origin", "start", "end", "stack"].indexOf(fill) >= 0 && fill;
      }
      function computeLinearBoundary(source) {
        const {scale = {}, fill} = source;
        let target = null;
        let horizontal;
        if (fill === "start") {
          target = scale.bottom;
        } else if (fill === "end") {
          target = scale.top;
        } else if (isObject(fill)) {
          target = scale.getPixelForValue(fill.value);
        } else if (scale.getBasePixel) {
          target = scale.getBasePixel();
        }
        if (isNumberFinite(target)) {
          horizontal = scale.isHorizontal();
          return {
            x: horizontal ? target : null,
            y: horizontal ? null : target
          };
        }
        return null;
      }
      class simpleArc {
        constructor(opts) {
          this.x = opts.x;
          this.y = opts.y;
          this.radius = opts.radius;
        }
        pathSegment(ctx, bounds, opts) {
          const {x, y, radius} = this;
          bounds = bounds || {start: 0, end: TAU};
          ctx.arc(x, y, radius, bounds.end, bounds.start, true);
          return !opts.bounds;
        }
        interpolate(point) {
          const {x, y, radius} = this;
          const angle = point.angle;
          return {
            x: x + Math.cos(angle) * radius,
            y: y + Math.sin(angle) * radius,
            angle
          };
        }
      }
      function computeCircularBoundary(source) {
        const {scale, fill} = source;
        const options2 = scale.options;
        const length = scale.getLabels().length;
        const target = [];
        const start = options2.reverse ? scale.max : scale.min;
        const end = options2.reverse ? scale.min : scale.max;
        let i, center, value;
        if (fill === "start") {
          value = start;
        } else if (fill === "end") {
          value = end;
        } else if (isObject(fill)) {
          value = fill.value;
        } else {
          value = scale.getBaseValue();
        }
        if (options2.grid.circular) {
          center = scale.getPointPositionForValue(0, start);
          return new simpleArc({
            x: center.x,
            y: center.y,
            radius: scale.getDistanceFromCenterForValue(value)
          });
        }
        for (i = 0; i < length; ++i) {
          target.push(scale.getPointPositionForValue(i, value));
        }
        return target;
      }
      function computeBoundary(source) {
        const scale = source.scale || {};
        if (scale.getPointPositionForValue) {
          return computeCircularBoundary(source);
        }
        return computeLinearBoundary(source);
      }
      function pointsFromSegments(boundary, line) {
        const {x = null, y = null} = boundary || {};
        const linePoints = line.points;
        const points = [];
        line.segments.forEach((segment) => {
          const first = linePoints[segment.start];
          const last = linePoints[segment.end];
          if (y !== null) {
            points.push({x: first.x, y});
            points.push({x: last.x, y});
          } else if (x !== null) {
            points.push({x, y: first.y});
            points.push({x, y: last.y});
          }
        });
        return points;
      }
      function buildStackLine(source) {
        const {chart, scale, index: index2, line} = source;
        const points = [];
        const segments = line.segments;
        const sourcePoints = line.points;
        const linesBelow = getLinesBelow(chart, index2);
        linesBelow.push(createBoundaryLine({x: null, y: scale.bottom}, line));
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i];
          for (let j = segment.start; j <= segment.end; j++) {
            addPointsBelow(points, sourcePoints[j], linesBelow);
          }
        }
        return new LineElement({points, options: {}});
      }
      const isLineAndNotInHideAnimation = (meta2) => meta2.type === "line" && !meta2.hidden;
      function getLinesBelow(chart, index2) {
        const below = [];
        const metas = chart.getSortedVisibleDatasetMetas();
        for (let i = 0; i < metas.length; i++) {
          const meta2 = metas[i];
          if (meta2.index === index2) {
            break;
          }
          if (isLineAndNotInHideAnimation(meta2)) {
            below.unshift(meta2.dataset);
          }
        }
        return below;
      }
      function addPointsBelow(points, sourcePoint, linesBelow) {
        const postponed = [];
        for (let j = 0; j < linesBelow.length; j++) {
          const line = linesBelow[j];
          const {first, last, point} = findPoint(line, sourcePoint, "x");
          if (!point || first && last) {
            continue;
          }
          if (first) {
            postponed.unshift(point);
          } else {
            points.push(point);
            if (!last) {
              break;
            }
          }
        }
        points.push(...postponed);
      }
      function findPoint(line, sourcePoint, property) {
        const point = line.interpolate(sourcePoint, property);
        if (!point) {
          return {};
        }
        const pointValue = point[property];
        const segments = line.segments;
        const linePoints = line.points;
        let first = false;
        let last = false;
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i];
          const firstValue = linePoints[segment.start][property];
          const lastValue = linePoints[segment.end][property];
          if (pointValue >= firstValue && pointValue <= lastValue) {
            first = pointValue === firstValue;
            last = pointValue === lastValue;
            break;
          }
        }
        return {first, last, point};
      }
      function getTarget(source) {
        const {chart, fill, line} = source;
        if (isNumberFinite(fill)) {
          return getLineByIndex(chart, fill);
        }
        if (fill === "stack") {
          return buildStackLine(source);
        }
        const boundary = computeBoundary(source);
        if (boundary instanceof simpleArc) {
          return boundary;
        }
        return createBoundaryLine(boundary, line);
      }
      function createBoundaryLine(boundary, line) {
        let points = [];
        let _loop = false;
        if (isArray(boundary)) {
          _loop = true;
          points = boundary;
        } else {
          points = pointsFromSegments(boundary, line);
        }
        return points.length ? new LineElement({
          points,
          options: {tension: 0},
          _loop,
          _fullLoop: _loop
        }) : null;
      }
      function resolveTarget(sources, index2, propagate) {
        const source = sources[index2];
        let fill = source.fill;
        const visited = [index2];
        let target;
        if (!propagate) {
          return fill;
        }
        while (fill !== false && visited.indexOf(fill) === -1) {
          if (!isNumberFinite(fill)) {
            return fill;
          }
          target = sources[fill];
          if (!target) {
            return false;
          }
          if (target.visible) {
            return fill;
          }
          visited.push(fill);
          fill = target.fill;
        }
        return false;
      }
      function _clip(ctx, target, clipY) {
        ctx.beginPath();
        target.path(ctx);
        ctx.lineTo(target.last().x, clipY);
        ctx.lineTo(target.first().x, clipY);
        ctx.closePath();
        ctx.clip();
      }
      function getBounds(property, first, last, loop) {
        if (loop) {
          return;
        }
        let start = first[property];
        let end = last[property];
        if (property === "angle") {
          start = _normalizeAngle(start);
          end = _normalizeAngle(end);
        }
        return {property, start, end};
      }
      function _getEdge(a, b, prop, fn) {
        if (a && b) {
          return fn(a[prop], b[prop]);
        }
        return a ? a[prop] : b ? b[prop] : 0;
      }
      function _segments(line, target, property) {
        const segments = line.segments;
        const points = line.points;
        const tpoints = target.points;
        const parts = [];
        for (const segment of segments) {
          const bounds = getBounds(property, points[segment.start], points[segment.end], segment.loop);
          if (!target.segments) {
            parts.push({
              source: segment,
              target: bounds,
              start: points[segment.start],
              end: points[segment.end]
            });
            continue;
          }
          const targetSegments = _boundSegments(target, bounds);
          for (const tgt of targetSegments) {
            const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
            const fillSources = _boundSegment(segment, points, subBounds);
            for (const fillSource of fillSources) {
              parts.push({
                source: fillSource,
                target: tgt,
                start: {
                  [property]: _getEdge(bounds, subBounds, "start", Math.max)
                },
                end: {
                  [property]: _getEdge(bounds, subBounds, "end", Math.min)
                }
              });
            }
          }
        }
        return parts;
      }
      function clipBounds(ctx, scale, bounds) {
        const {top: top2, bottom} = scale.chart.chartArea;
        const {property, start, end} = bounds || {};
        if (property === "x") {
          ctx.beginPath();
          ctx.rect(start, top2, end - start, bottom - top2);
          ctx.clip();
        }
      }
      function interpolatedLineTo(ctx, target, point, property) {
        const interpolatedPoint = target.interpolate(point, property);
        if (interpolatedPoint) {
          ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
        }
      }
      function _fill(ctx, cfg) {
        const {line, target, property, color: color2, scale} = cfg;
        const segments = _segments(line, target, property);
        for (const {source: src2, target: tgt, start, end} of segments) {
          const {style: {backgroundColor = color2} = {}} = src2;
          ctx.save();
          ctx.fillStyle = backgroundColor;
          clipBounds(ctx, scale, getBounds(property, start, end));
          ctx.beginPath();
          const lineLoop = !!line.pathSegment(ctx, src2);
          if (lineLoop) {
            ctx.closePath();
          } else {
            interpolatedLineTo(ctx, target, end, property);
          }
          const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});
          const loop = lineLoop && targetLoop;
          if (!loop) {
            interpolatedLineTo(ctx, target, start, property);
          }
          ctx.closePath();
          ctx.fill(loop ? "evenodd" : "nonzero");
          ctx.restore();
        }
      }
      function doFill(ctx, cfg) {
        const {line, target, above, below, area, scale} = cfg;
        const property = line._loop ? "angle" : cfg.axis;
        ctx.save();
        if (property === "x" && below !== above) {
          _clip(ctx, target, area.top);
          _fill(ctx, {line, target, color: above, scale, property});
          ctx.restore();
          ctx.save();
          _clip(ctx, target, area.bottom);
        }
        _fill(ctx, {line, target, color: below, scale, property});
        ctx.restore();
      }
      function drawfill(ctx, source, area) {
        const target = getTarget(source);
        const {line, scale, axis} = source;
        const lineOpts = line.options;
        const fillOption = lineOpts.fill;
        const color2 = lineOpts.backgroundColor;
        const {above = color2, below = color2} = fillOption || {};
        if (target && line.points.length) {
          clipArea(ctx, area);
          doFill(ctx, {line, target, above, below, area, scale, axis});
          unclipArea(ctx);
        }
      }
      var plugin_filler = {
        id: "filler",
        afterDatasetsUpdate(chart, _args, options2) {
          const count = (chart.data.datasets || []).length;
          const sources = [];
          let meta2, i, line, source;
          for (i = 0; i < count; ++i) {
            meta2 = chart.getDatasetMeta(i);
            line = meta2.dataset;
            source = null;
            if (line && line.options && line instanceof LineElement) {
              source = {
                visible: chart.isDatasetVisible(i),
                index: i,
                fill: decodeFill(line, i, count),
                chart,
                axis: meta2.controller.options.indexAxis,
                scale: meta2.vScale,
                line
              };
            }
            meta2.$filler = source;
            sources.push(source);
          }
          for (i = 0; i < count; ++i) {
            source = sources[i];
            if (!source || source.fill === false) {
              continue;
            }
            source.fill = resolveTarget(sources, i, options2.propagate);
          }
        },
        beforeDraw(chart, _args, options2) {
          const draw2 = options2.drawTime === "beforeDraw";
          const metasets = chart.getSortedVisibleDatasetMetas();
          const area = chart.chartArea;
          for (let i = metasets.length - 1; i >= 0; --i) {
            const source = metasets[i].$filler;
            if (!source) {
              continue;
            }
            source.line.updateControlPoints(area, source.axis);
            if (draw2) {
              drawfill(chart.ctx, source, area);
            }
          }
        },
        beforeDatasetsDraw(chart, _args, options2) {
          if (options2.drawTime !== "beforeDatasetsDraw") {
            return;
          }
          const metasets = chart.getSortedVisibleDatasetMetas();
          for (let i = metasets.length - 1; i >= 0; --i) {
            const source = metasets[i].$filler;
            if (source) {
              drawfill(chart.ctx, source, chart.chartArea);
            }
          }
        },
        beforeDatasetDraw(chart, args, options2) {
          const source = args.meta.$filler;
          if (!source || source.fill === false || options2.drawTime !== "beforeDatasetDraw") {
            return;
          }
          drawfill(chart.ctx, source, chart.chartArea);
        },
        defaults: {
          propagate: true,
          drawTime: "beforeDatasetDraw"
        }
      };
      const getBoxSize = (labelOpts, fontSize) => {
        let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;
        if (labelOpts.usePointStyle) {
          boxHeight = Math.min(boxHeight, fontSize);
          boxWidth = Math.min(boxWidth, fontSize);
        }
        return {
          boxWidth,
          boxHeight,
          itemHeight: Math.max(fontSize, boxHeight)
        };
      };
      const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
      class Legend extends Element {
        constructor(config2) {
          super();
          this._added = false;
          this.legendHitBoxes = [];
          this._hoveredItem = null;
          this.doughnutMode = false;
          this.chart = config2.chart;
          this.options = config2.options;
          this.ctx = config2.ctx;
          this.legendItems = void 0;
          this.columnSizes = void 0;
          this.lineWidths = void 0;
          this.maxHeight = void 0;
          this.maxWidth = void 0;
          this.top = void 0;
          this.bottom = void 0;
          this.left = void 0;
          this.right = void 0;
          this.height = void 0;
          this.width = void 0;
          this._margins = void 0;
          this.position = void 0;
          this.weight = void 0;
          this.fullSize = void 0;
        }
        update(maxWidth, maxHeight, margins) {
          const me = this;
          me.maxWidth = maxWidth;
          me.maxHeight = maxHeight;
          me._margins = margins;
          me.setDimensions();
          me.buildLabels();
          me.fit();
        }
        setDimensions() {
          const me = this;
          if (me.isHorizontal()) {
            me.width = me.maxWidth;
            me.left = 0;
            me.right = me.width;
          } else {
            me.height = me.maxHeight;
            me.top = 0;
            me.bottom = me.height;
          }
        }
        buildLabels() {
          const me = this;
          const labelOpts = me.options.labels || {};
          let legendItems = callback(labelOpts.generateLabels, [me.chart], me) || [];
          if (labelOpts.filter) {
            legendItems = legendItems.filter((item) => labelOpts.filter(item, me.chart.data));
          }
          if (labelOpts.sort) {
            legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, me.chart.data));
          }
          if (me.options.reverse) {
            legendItems.reverse();
          }
          me.legendItems = legendItems;
        }
        fit() {
          const me = this;
          const {options: options2, ctx} = me;
          if (!options2.display) {
            me.width = me.height = 0;
            return;
          }
          const labelOpts = options2.labels;
          const labelFont = toFont(labelOpts.font);
          const fontSize = labelFont.size;
          const titleHeight = me._computeTitleHeight();
          const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);
          let width, height;
          ctx.font = labelFont.string;
          if (me.isHorizontal()) {
            width = me.maxWidth;
            height = me._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
          } else {
            height = me.maxHeight;
            width = me._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
          }
          me.width = Math.min(width, options2.maxWidth || me.maxWidth);
          me.height = Math.min(height, options2.maxHeight || me.maxHeight);
        }
        _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
          const me = this;
          const {ctx, maxWidth, options: {labels: {padding}}} = me;
          const hitboxes = me.legendHitBoxes = [];
          const lineWidths = me.lineWidths = [0];
          const lineHeight = itemHeight + padding;
          let totalHeight = titleHeight;
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";
          let row = -1;
          let top2 = -lineHeight;
          me.legendItems.forEach((legendItem, i) => {
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
              totalHeight += lineHeight;
              lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
              top2 += lineHeight;
              row++;
            }
            hitboxes[i] = {left: 0, top: top2, row, width: itemWidth, height: itemHeight};
            lineWidths[lineWidths.length - 1] += itemWidth + padding;
          });
          return totalHeight;
        }
        _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
          const me = this;
          const {ctx, maxHeight, options: {labels: {padding}}} = me;
          const hitboxes = me.legendHitBoxes = [];
          const columnSizes = me.columnSizes = [];
          const heightLimit = maxHeight - titleHeight;
          let totalWidth = padding;
          let currentColWidth = 0;
          let currentColHeight = 0;
          let left = 0;
          let top2 = 0;
          let col = 0;
          me.legendItems.forEach((legendItem, i) => {
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i > 0 && currentColHeight + fontSize + 2 * padding > heightLimit) {
              totalWidth += currentColWidth + padding;
              columnSizes.push({width: currentColWidth, height: currentColHeight});
              left += currentColWidth + padding;
              col++;
              top2 = 0;
              currentColWidth = currentColHeight = 0;
            }
            currentColWidth = Math.max(currentColWidth, itemWidth);
            currentColHeight += fontSize + padding;
            hitboxes[i] = {left, top: top2, col, width: itemWidth, height: itemHeight};
            top2 += itemHeight + padding;
          });
          totalWidth += currentColWidth;
          columnSizes.push({width: currentColWidth, height: currentColHeight});
          return totalWidth;
        }
        adjustHitBoxes() {
          const me = this;
          if (!me.options.display) {
            return;
          }
          const titleHeight = me._computeTitleHeight();
          const {legendHitBoxes: hitboxes, options: {align, labels: {padding}}} = me;
          if (this.isHorizontal()) {
            let row = 0;
            let left = _alignStartEnd(align, me.left + padding, me.right - me.lineWidths[row]);
            for (const hitbox of hitboxes) {
              if (row !== hitbox.row) {
                row = hitbox.row;
                left = _alignStartEnd(align, me.left + padding, me.right - me.lineWidths[row]);
              }
              hitbox.top += me.top + titleHeight + padding;
              hitbox.left = left;
              left += hitbox.width + padding;
            }
          } else {
            let col = 0;
            let top2 = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);
            for (const hitbox of hitboxes) {
              if (hitbox.col !== col) {
                col = hitbox.col;
                top2 = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);
              }
              hitbox.top = top2;
              hitbox.left += me.left + padding;
              top2 += hitbox.height + padding;
            }
          }
        }
        isHorizontal() {
          return this.options.position === "top" || this.options.position === "bottom";
        }
        draw() {
          const me = this;
          if (me.options.display) {
            const ctx = me.ctx;
            clipArea(ctx, me);
            me._draw();
            unclipArea(ctx);
          }
        }
        _draw() {
          const me = this;
          const {options: opts, columnSizes, lineWidths, ctx} = me;
          const {align, labels: labelOpts} = opts;
          const defaultColor = defaults3.color;
          const rtlHelper = getRtlAdapter(opts.rtl, me.left, me.width);
          const labelFont = toFont(labelOpts.font);
          const {color: fontColor, padding} = labelOpts;
          const fontSize = labelFont.size;
          const halfFontSize = fontSize / 2;
          let cursor;
          me.drawTitle();
          ctx.textAlign = rtlHelper.textAlign("left");
          ctx.textBaseline = "middle";
          ctx.lineWidth = 0.5;
          ctx.font = labelFont.string;
          const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);
          const drawLegendBox = function(x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
              return;
            }
            ctx.save();
            const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
            ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
            ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
            if (labelOpts.usePointStyle) {
              const drawOptions = {
                radius: boxWidth * Math.SQRT2 / 2,
                pointStyle: legendItem.pointStyle,
                rotation: legendItem.rotation,
                borderWidth: lineWidth
              };
              const centerX = rtlHelper.xPlus(x, boxWidth / 2);
              const centerY = y + halfFontSize;
              drawPoint(ctx, drawOptions, centerX, centerY);
            } else {
              const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
              const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
              const borderRadius = toTRBLCorners(legendItem.borderRadius);
              ctx.beginPath();
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                addRoundedRectPath(ctx, {
                  x: xBoxLeft,
                  y: yBoxTop,
                  w: boxWidth,
                  h: boxHeight,
                  radius: borderRadius
                });
              } else {
                ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
              }
              ctx.fill();
              if (lineWidth !== 0) {
                ctx.stroke();
              }
            }
            ctx.restore();
          };
          const fillText = function(x, y, legendItem) {
            renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
              strikethrough: legendItem.hidden,
              textAlign: legendItem.textAlign
            });
          };
          const isHorizontal = me.isHorizontal();
          const titleHeight = this._computeTitleHeight();
          if (isHorizontal) {
            cursor = {
              x: _alignStartEnd(align, me.left + padding, me.right - lineWidths[0]),
              y: me.top + padding + titleHeight,
              line: 0
            };
          } else {
            cursor = {
              x: me.left + padding,
              y: _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - columnSizes[0].height),
              line: 0
            };
          }
          overrideTextDirection(me.ctx, opts.textDirection);
          const lineHeight = itemHeight + padding;
          me.legendItems.forEach((legendItem, i) => {
            ctx.strokeStyle = legendItem.fontColor || fontColor;
            ctx.fillStyle = legendItem.fontColor || fontColor;
            const textWidth = ctx.measureText(legendItem.text).width;
            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
            const width = boxWidth + fontSize / 2 + textWidth;
            let x = cursor.x;
            let y = cursor.y;
            rtlHelper.setWidth(me.width);
            if (isHorizontal) {
              if (i > 0 && x + width + padding > me.right) {
                y = cursor.y += lineHeight;
                cursor.line++;
                x = cursor.x = _alignStartEnd(align, me.left + padding, me.right - lineWidths[cursor.line]);
              }
            } else if (i > 0 && y + lineHeight > me.bottom) {
              x = cursor.x = x + columnSizes[cursor.line].width + padding;
              cursor.line++;
              y = cursor.y = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - columnSizes[cursor.line].height);
            }
            const realX = rtlHelper.x(x);
            drawLegendBox(realX, y, legendItem);
            x = _textX(textAlign, x + boxWidth + halfFontSize, me.right);
            fillText(rtlHelper.x(x), y, legendItem);
            if (isHorizontal) {
              cursor.x += width + padding;
            } else {
              cursor.y += lineHeight;
            }
          });
          restoreTextDirection(me.ctx, opts.textDirection);
        }
        drawTitle() {
          const me = this;
          const opts = me.options;
          const titleOpts = opts.title;
          const titleFont = toFont(titleOpts.font);
          const titlePadding = toPadding(titleOpts.padding);
          if (!titleOpts.display) {
            return;
          }
          const rtlHelper = getRtlAdapter(opts.rtl, me.left, me.width);
          const ctx = me.ctx;
          const position = titleOpts.position;
          const halfFontSize = titleFont.size / 2;
          const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
          let y;
          let left = me.left;
          let maxWidth = me.width;
          if (this.isHorizontal()) {
            maxWidth = Math.max(...me.lineWidths);
            y = me.top + topPaddingPlusHalfFontSize;
            left = _alignStartEnd(opts.align, left, me.right - maxWidth);
          } else {
            const maxHeight = me.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
            y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, me.top, me.bottom - maxHeight - opts.labels.padding - me._computeTitleHeight());
          }
          const x = _alignStartEnd(position, left, left + maxWidth);
          ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
          ctx.textBaseline = "middle";
          ctx.strokeStyle = titleOpts.color;
          ctx.fillStyle = titleOpts.color;
          ctx.font = titleFont.string;
          renderText(ctx, titleOpts.text, x, y, titleFont);
        }
        _computeTitleHeight() {
          const titleOpts = this.options.title;
          const titleFont = toFont(titleOpts.font);
          const titlePadding = toPadding(titleOpts.padding);
          return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
        }
        _getLegendItemAt(x, y) {
          const me = this;
          let i, hitBox, lh;
          if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
            lh = me.legendHitBoxes;
            for (i = 0; i < lh.length; ++i) {
              hitBox = lh[i];
              if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
                return me.legendItems[i];
              }
            }
          }
          return null;
        }
        handleEvent(e) {
          const me = this;
          const opts = me.options;
          if (!isListened(e.type, opts)) {
            return;
          }
          const hoveredItem = me._getLegendItemAt(e.x, e.y);
          if (e.type === "mousemove") {
            const previous = me._hoveredItem;
            const sameItem = itemsEqual(previous, hoveredItem);
            if (previous && !sameItem) {
              callback(opts.onLeave, [e, previous, me], me);
            }
            me._hoveredItem = hoveredItem;
            if (hoveredItem && !sameItem) {
              callback(opts.onHover, [e, hoveredItem, me], me);
            }
          } else if (hoveredItem) {
            callback(opts.onClick, [e, hoveredItem, me], me);
          }
        }
      }
      function isListened(type, opts) {
        if (type === "mousemove" && (opts.onHover || opts.onLeave)) {
          return true;
        }
        if (opts.onClick && (type === "click" || type === "mouseup")) {
          return true;
        }
        return false;
      }
      var plugin_legend = {
        id: "legend",
        _element: Legend,
        start(chart, _args, options2) {
          const legend = chart.legend = new Legend({ctx: chart.ctx, options: options2, chart});
          layouts.configure(chart, legend, options2);
          layouts.addBox(chart, legend);
        },
        stop(chart) {
          layouts.removeBox(chart, chart.legend);
          delete chart.legend;
        },
        beforeUpdate(chart, _args, options2) {
          const legend = chart.legend;
          layouts.configure(chart, legend, options2);
          legend.options = options2;
        },
        afterUpdate(chart) {
          const legend = chart.legend;
          legend.buildLabels();
          legend.adjustHitBoxes();
        },
        afterEvent(chart, args) {
          if (!args.replay) {
            chart.legend.handleEvent(args.event);
          }
        },
        defaults: {
          display: true,
          position: "top",
          align: "center",
          fullSize: true,
          reverse: false,
          weight: 1e3,
          onClick(e, legendItem, legend) {
            const index2 = legendItem.datasetIndex;
            const ci = legend.chart;
            if (ci.isDatasetVisible(index2)) {
              ci.hide(index2);
              legendItem.hidden = true;
            } else {
              ci.show(index2);
              legendItem.hidden = false;
            }
          },
          onHover: null,
          onLeave: null,
          labels: {
            color: (ctx) => ctx.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels(chart) {
              const datasets = chart.data.datasets;
              const {labels: {usePointStyle, pointStyle, textAlign, color: color2}} = chart.legend.options;
              return chart._getSortedDatasetMetas().map((meta2) => {
                const style = meta2.controller.getStyle(usePointStyle ? 0 : void 0);
                const borderWidth = toPadding(style.borderWidth);
                return {
                  text: datasets[meta2.index].label,
                  fillStyle: style.backgroundColor,
                  fontColor: color2,
                  hidden: !meta2.visible,
                  lineCap: style.borderCapStyle,
                  lineDash: style.borderDash,
                  lineDashOffset: style.borderDashOffset,
                  lineJoin: style.borderJoinStyle,
                  lineWidth: (borderWidth.width + borderWidth.height) / 4,
                  strokeStyle: style.borderColor,
                  pointStyle: pointStyle || style.pointStyle,
                  rotation: style.rotation,
                  textAlign: textAlign || style.textAlign,
                  borderRadius: 0,
                  datasetIndex: meta2.index
                };
              }, this);
            }
          },
          title: {
            color: (ctx) => ctx.chart.options.color,
            display: false,
            position: "center",
            text: ""
          }
        },
        descriptors: {
          _scriptable: (name2) => !name2.startsWith("on"),
          labels: {
            _scriptable: (name2) => !["generateLabels", "filter", "sort"].includes(name2)
          }
        }
      };
      class Title extends Element {
        constructor(config2) {
          super();
          this.chart = config2.chart;
          this.options = config2.options;
          this.ctx = config2.ctx;
          this._padding = void 0;
          this.top = void 0;
          this.bottom = void 0;
          this.left = void 0;
          this.right = void 0;
          this.width = void 0;
          this.height = void 0;
          this.position = void 0;
          this.weight = void 0;
          this.fullSize = void 0;
        }
        update(maxWidth, maxHeight) {
          const me = this;
          const opts = me.options;
          me.left = 0;
          me.top = 0;
          if (!opts.display) {
            me.width = me.height = me.right = me.bottom = 0;
            return;
          }
          me.width = me.right = maxWidth;
          me.height = me.bottom = maxHeight;
          const lineCount = isArray(opts.text) ? opts.text.length : 1;
          me._padding = toPadding(opts.padding);
          const textSize = lineCount * toFont(opts.font).lineHeight + me._padding.height;
          if (me.isHorizontal()) {
            me.height = textSize;
          } else {
            me.width = textSize;
          }
        }
        isHorizontal() {
          const pos = this.options.position;
          return pos === "top" || pos === "bottom";
        }
        _drawArgs(offset) {
          const {top: top2, left, bottom, right, options: options2} = this;
          const align = options2.align;
          let rotation = 0;
          let maxWidth, titleX, titleY;
          if (this.isHorizontal()) {
            titleX = _alignStartEnd(align, left, right);
            titleY = top2 + offset;
            maxWidth = right - left;
          } else {
            if (options2.position === "left") {
              titleX = left + offset;
              titleY = _alignStartEnd(align, bottom, top2);
              rotation = PI * -0.5;
            } else {
              titleX = right - offset;
              titleY = _alignStartEnd(align, top2, bottom);
              rotation = PI * 0.5;
            }
            maxWidth = bottom - top2;
          }
          return {titleX, titleY, maxWidth, rotation};
        }
        draw() {
          const me = this;
          const ctx = me.ctx;
          const opts = me.options;
          if (!opts.display) {
            return;
          }
          const fontOpts = toFont(opts.font);
          const lineHeight = fontOpts.lineHeight;
          const offset = lineHeight / 2 + me._padding.top;
          const {titleX, titleY, maxWidth, rotation} = me._drawArgs(offset);
          renderText(ctx, opts.text, 0, 0, fontOpts, {
            color: opts.color,
            maxWidth,
            rotation,
            textAlign: _toLeftRightCenter(opts.align),
            textBaseline: "middle",
            translation: [titleX, titleY]
          });
        }
      }
      function createTitle(chart, titleOpts) {
        const title = new Title({
          ctx: chart.ctx,
          options: titleOpts,
          chart
        });
        layouts.configure(chart, title, titleOpts);
        layouts.addBox(chart, title);
        chart.titleBlock = title;
      }
      var plugin_title = {
        id: "title",
        _element: Title,
        start(chart, _args, options2) {
          createTitle(chart, options2);
        },
        stop(chart) {
          const titleBlock = chart.titleBlock;
          layouts.removeBox(chart, titleBlock);
          delete chart.titleBlock;
        },
        beforeUpdate(chart, _args, options2) {
          const title = chart.titleBlock;
          layouts.configure(chart, title, options2);
          title.options = options2;
        },
        defaults: {
          align: "center",
          display: false,
          font: {
            weight: "bold"
          },
          fullSize: true,
          padding: 10,
          position: "top",
          text: "",
          weight: 2e3
        },
        defaultRoutes: {
          color: "color"
        },
        descriptors: {
          _scriptable: true,
          _indexable: false
        }
      };
      const positioners = {
        average(items) {
          if (!items.length) {
            return false;
          }
          let i, len;
          let x = 0;
          let y = 0;
          let count = 0;
          for (i = 0, len = items.length; i < len; ++i) {
            const el = items[i].element;
            if (el && el.hasValue()) {
              const pos = el.tooltipPosition();
              x += pos.x;
              y += pos.y;
              ++count;
            }
          }
          return {
            x: x / count,
            y: y / count
          };
        },
        nearest(items, eventPosition) {
          if (!items.length) {
            return false;
          }
          let x = eventPosition.x;
          let y = eventPosition.y;
          let minDistance = Number.POSITIVE_INFINITY;
          let i, len, nearestElement;
          for (i = 0, len = items.length; i < len; ++i) {
            const el = items[i].element;
            if (el && el.hasValue()) {
              const center = el.getCenterPoint();
              const d = distanceBetweenPoints(eventPosition, center);
              if (d < minDistance) {
                minDistance = d;
                nearestElement = el;
              }
            }
          }
          if (nearestElement) {
            const tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y;
          }
          return {
            x,
            y
          };
        }
      };
      function pushOrConcat(base2, toPush) {
        if (toPush) {
          if (isArray(toPush)) {
            Array.prototype.push.apply(base2, toPush);
          } else {
            base2.push(toPush);
          }
        }
        return base2;
      }
      function splitNewlines(str) {
        if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
          return str.split("\n");
        }
        return str;
      }
      function createTooltipItem(chart, item) {
        const {element, datasetIndex, index: index2} = item;
        const controller = chart.getDatasetMeta(datasetIndex).controller;
        const {label, value} = controller.getLabelAndValue(index2);
        return {
          chart,
          label,
          parsed: controller.getParsed(index2),
          raw: chart.data.datasets[datasetIndex].data[index2],
          formattedValue: value,
          dataset: controller.getDataset(),
          dataIndex: index2,
          datasetIndex,
          element
        };
      }
      function getTooltipSize(tooltip, options2) {
        const ctx = tooltip._chart.ctx;
        const {body, footer, title} = tooltip;
        const {boxWidth, boxHeight} = options2;
        const bodyFont = toFont(options2.bodyFont);
        const titleFont = toFont(options2.titleFont);
        const footerFont = toFont(options2.footerFont);
        const titleLineCount = title.length;
        const footerLineCount = footer.length;
        const bodyLineItemCount = body.length;
        const padding = toPadding(options2.padding);
        let height = padding.height;
        let width = 0;
        let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
        combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
        if (titleLineCount) {
          height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options2.titleSpacing + options2.titleMarginBottom;
        }
        if (combinedBodyLength) {
          const bodyLineHeight = options2.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
          height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options2.bodySpacing;
        }
        if (footerLineCount) {
          height += options2.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options2.footerSpacing;
        }
        let widthPadding = 0;
        const maxLineWidth = function(line) {
          width = Math.max(width, ctx.measureText(line).width + widthPadding);
        };
        ctx.save();
        ctx.font = titleFont.string;
        each2(tooltip.title, maxLineWidth);
        ctx.font = bodyFont.string;
        each2(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
        widthPadding = options2.displayColors ? boxWidth + 2 : 0;
        each2(body, (bodyItem) => {
          each2(bodyItem.before, maxLineWidth);
          each2(bodyItem.lines, maxLineWidth);
          each2(bodyItem.after, maxLineWidth);
        });
        widthPadding = 0;
        ctx.font = footerFont.string;
        each2(tooltip.footer, maxLineWidth);
        ctx.restore();
        width += padding.width;
        return {width, height};
      }
      function determineYAlign(chart, size) {
        const {y, height} = size;
        if (y < height / 2) {
          return "top";
        } else if (y > chart.height - height / 2) {
          return "bottom";
        }
        return "center";
      }
      function doesNotFitWithAlign(xAlign, chart, options2, size) {
        const {x, width} = size;
        const caret = options2.caretSize + options2.caretPadding;
        if (xAlign === "left" && x + width + caret > chart.width) {
          return true;
        }
        if (xAlign === "right" && x - width - caret < 0) {
          return true;
        }
      }
      function determineXAlign(chart, options2, size, yAlign) {
        const {x, width} = size;
        const {width: chartWidth, chartArea: {left, right}} = chart;
        let xAlign = "center";
        if (yAlign === "center") {
          xAlign = x <= (left + right) / 2 ? "left" : "right";
        } else if (x <= width / 2) {
          xAlign = "left";
        } else if (x >= chartWidth - width / 2) {
          xAlign = "right";
        }
        if (doesNotFitWithAlign(xAlign, chart, options2, size)) {
          xAlign = "center";
        }
        return xAlign;
      }
      function determineAlignment(chart, options2, size) {
        const yAlign = options2.yAlign || determineYAlign(chart, size);
        return {
          xAlign: options2.xAlign || determineXAlign(chart, options2, size, yAlign),
          yAlign
        };
      }
      function alignX(size, xAlign) {
        let {x, width} = size;
        if (xAlign === "right") {
          x -= width;
        } else if (xAlign === "center") {
          x -= width / 2;
        }
        return x;
      }
      function alignY(size, yAlign, paddingAndSize) {
        let {y, height} = size;
        if (yAlign === "top") {
          y += paddingAndSize;
        } else if (yAlign === "bottom") {
          y -= height + paddingAndSize;
        } else {
          y -= height / 2;
        }
        return y;
      }
      function getBackgroundPoint(options2, size, alignment, chart) {
        const {caretSize, caretPadding, cornerRadius} = options2;
        const {xAlign, yAlign} = alignment;
        const paddingAndSize = caretSize + caretPadding;
        const radiusAndPadding = cornerRadius + caretPadding;
        let x = alignX(size, xAlign);
        const y = alignY(size, yAlign, paddingAndSize);
        if (yAlign === "center") {
          if (xAlign === "left") {
            x += paddingAndSize;
          } else if (xAlign === "right") {
            x -= paddingAndSize;
          }
        } else if (xAlign === "left") {
          x -= radiusAndPadding;
        } else if (xAlign === "right") {
          x += radiusAndPadding;
        }
        return {
          x: _limitValue(x, 0, chart.width - size.width),
          y: _limitValue(y, 0, chart.height - size.height)
        };
      }
      function getAlignedX(tooltip, align, options2) {
        const padding = toPadding(options2.padding);
        return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
      }
      function getBeforeAfterBodyLines(callback2) {
        return pushOrConcat([], splitNewlines(callback2));
      }
      function createTooltipContext(parent, tooltip, tooltipItems) {
        return Object.assign(Object.create(parent), {
          tooltip,
          tooltipItems,
          type: "tooltip"
        });
      }
      function overrideCallbacks(callbacks, context) {
        const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
        return override ? callbacks.override(override) : callbacks;
      }
      class Tooltip2 extends Element {
        constructor(config2) {
          super();
          this.opacity = 0;
          this._active = [];
          this._chart = config2._chart;
          this._eventPosition = void 0;
          this._size = void 0;
          this._cachedAnimations = void 0;
          this._tooltipItems = [];
          this.$animations = void 0;
          this.$context = void 0;
          this.options = config2.options;
          this.dataPoints = void 0;
          this.title = void 0;
          this.beforeBody = void 0;
          this.body = void 0;
          this.afterBody = void 0;
          this.footer = void 0;
          this.xAlign = void 0;
          this.yAlign = void 0;
          this.x = void 0;
          this.y = void 0;
          this.height = void 0;
          this.width = void 0;
          this.caretX = void 0;
          this.caretY = void 0;
          this.labelColors = void 0;
          this.labelPointStyles = void 0;
          this.labelTextColors = void 0;
        }
        initialize(options2) {
          this.options = options2;
          this._cachedAnimations = void 0;
          this.$context = void 0;
        }
        _resolveAnimations() {
          const me = this;
          const cached2 = me._cachedAnimations;
          if (cached2) {
            return cached2;
          }
          const chart = me._chart;
          const options2 = me.options.setContext(me.getContext());
          const opts = options2.enabled && chart.options.animation && options2.animations;
          const animations = new Animations(me._chart, opts);
          if (opts._cacheable) {
            me._cachedAnimations = Object.freeze(animations);
          }
          return animations;
        }
        getContext() {
          const me = this;
          return me.$context || (me.$context = createTooltipContext(me._chart.getContext(), me, me._tooltipItems));
        }
        getTitle(context, options2) {
          const me = this;
          const {callbacks} = options2;
          const beforeTitle = callbacks.beforeTitle.apply(me, [context]);
          const title = callbacks.title.apply(me, [context]);
          const afterTitle = callbacks.afterTitle.apply(me, [context]);
          let lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeTitle));
          lines = pushOrConcat(lines, splitNewlines(title));
          lines = pushOrConcat(lines, splitNewlines(afterTitle));
          return lines;
        }
        getBeforeBody(tooltipItems, options2) {
          return getBeforeAfterBodyLines(options2.callbacks.beforeBody.apply(this, [tooltipItems]));
        }
        getBody(tooltipItems, options2) {
          const me = this;
          const {callbacks} = options2;
          const bodyItems = [];
          each2(tooltipItems, (context) => {
            const bodyItem = {
              before: [],
              lines: [],
              after: []
            };
            const scoped = overrideCallbacks(callbacks, context);
            pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(me, context)));
            pushOrConcat(bodyItem.lines, scoped.label.call(me, context));
            pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(me, context)));
            bodyItems.push(bodyItem);
          });
          return bodyItems;
        }
        getAfterBody(tooltipItems, options2) {
          return getBeforeAfterBodyLines(options2.callbacks.afterBody.apply(this, [tooltipItems]));
        }
        getFooter(tooltipItems, options2) {
          const me = this;
          const {callbacks} = options2;
          const beforeFooter = callbacks.beforeFooter.apply(me, [tooltipItems]);
          const footer = callbacks.footer.apply(me, [tooltipItems]);
          const afterFooter = callbacks.afterFooter.apply(me, [tooltipItems]);
          let lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeFooter));
          lines = pushOrConcat(lines, splitNewlines(footer));
          lines = pushOrConcat(lines, splitNewlines(afterFooter));
          return lines;
        }
        _createItems(options2) {
          const me = this;
          const active = me._active;
          const data = me._chart.data;
          const labelColors = [];
          const labelPointStyles = [];
          const labelTextColors = [];
          let tooltipItems = [];
          let i, len;
          for (i = 0, len = active.length; i < len; ++i) {
            tooltipItems.push(createTooltipItem(me._chart, active[i]));
          }
          if (options2.filter) {
            tooltipItems = tooltipItems.filter((element, index2, array) => options2.filter(element, index2, array, data));
          }
          if (options2.itemSort) {
            tooltipItems = tooltipItems.sort((a, b) => options2.itemSort(a, b, data));
          }
          each2(tooltipItems, (context) => {
            const scoped = overrideCallbacks(options2.callbacks, context);
            labelColors.push(scoped.labelColor.call(me, context));
            labelPointStyles.push(scoped.labelPointStyle.call(me, context));
            labelTextColors.push(scoped.labelTextColor.call(me, context));
          });
          me.labelColors = labelColors;
          me.labelPointStyles = labelPointStyles;
          me.labelTextColors = labelTextColors;
          me.dataPoints = tooltipItems;
          return tooltipItems;
        }
        update(changed, replay) {
          const me = this;
          const options2 = me.options.setContext(me.getContext());
          const active = me._active;
          let properties;
          let tooltipItems = [];
          if (!active.length) {
            if (me.opacity !== 0) {
              properties = {
                opacity: 0
              };
            }
          } else {
            const position = positioners[options2.position].call(me, active, me._eventPosition);
            tooltipItems = me._createItems(options2);
            me.title = me.getTitle(tooltipItems, options2);
            me.beforeBody = me.getBeforeBody(tooltipItems, options2);
            me.body = me.getBody(tooltipItems, options2);
            me.afterBody = me.getAfterBody(tooltipItems, options2);
            me.footer = me.getFooter(tooltipItems, options2);
            const size = me._size = getTooltipSize(me, options2);
            const positionAndSize = Object.assign({}, position, size);
            const alignment = determineAlignment(me._chart, options2, positionAndSize);
            const backgroundPoint = getBackgroundPoint(options2, positionAndSize, alignment, me._chart);
            me.xAlign = alignment.xAlign;
            me.yAlign = alignment.yAlign;
            properties = {
              opacity: 1,
              x: backgroundPoint.x,
              y: backgroundPoint.y,
              width: size.width,
              height: size.height,
              caretX: position.x,
              caretY: position.y
            };
          }
          me._tooltipItems = tooltipItems;
          me.$context = void 0;
          if (properties) {
            me._resolveAnimations().update(me, properties);
          }
          if (changed && options2.external) {
            options2.external.call(me, {chart: me._chart, tooltip: me, replay});
          }
        }
        drawCaret(tooltipPoint, ctx, size, options2) {
          const caretPosition = this.getCaretPosition(tooltipPoint, size, options2);
          ctx.lineTo(caretPosition.x1, caretPosition.y1);
          ctx.lineTo(caretPosition.x2, caretPosition.y2);
          ctx.lineTo(caretPosition.x3, caretPosition.y3);
        }
        getCaretPosition(tooltipPoint, size, options2) {
          const {xAlign, yAlign} = this;
          const {cornerRadius, caretSize} = options2;
          const {x: ptX, y: ptY} = tooltipPoint;
          const {width, height} = size;
          let x1, x2, x3, y1, y2, y3;
          if (yAlign === "center") {
            y2 = ptY + height / 2;
            if (xAlign === "left") {
              x1 = ptX;
              x2 = x1 - caretSize;
              y1 = y2 + caretSize;
              y3 = y2 - caretSize;
            } else {
              x1 = ptX + width;
              x2 = x1 + caretSize;
              y1 = y2 - caretSize;
              y3 = y2 + caretSize;
            }
            x3 = x1;
          } else {
            if (xAlign === "left") {
              x2 = ptX + cornerRadius + caretSize;
            } else if (xAlign === "right") {
              x2 = ptX + width - cornerRadius - caretSize;
            } else {
              x2 = this.caretX;
            }
            if (yAlign === "top") {
              y1 = ptY;
              y2 = y1 - caretSize;
              x1 = x2 - caretSize;
              x3 = x2 + caretSize;
            } else {
              y1 = ptY + height;
              y2 = y1 + caretSize;
              x1 = x2 + caretSize;
              x3 = x2 - caretSize;
            }
            y3 = y1;
          }
          return {x1, x2, x3, y1, y2, y3};
        }
        drawTitle(pt, ctx, options2) {
          const me = this;
          const title = me.title;
          const length = title.length;
          let titleFont, titleSpacing, i;
          if (length) {
            const rtlHelper = getRtlAdapter(options2.rtl, me.x, me.width);
            pt.x = getAlignedX(me, options2.titleAlign, options2);
            ctx.textAlign = rtlHelper.textAlign(options2.titleAlign);
            ctx.textBaseline = "middle";
            titleFont = toFont(options2.titleFont);
            titleSpacing = options2.titleSpacing;
            ctx.fillStyle = options2.titleColor;
            ctx.font = titleFont.string;
            for (i = 0; i < length; ++i) {
              ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
              pt.y += titleFont.lineHeight + titleSpacing;
              if (i + 1 === length) {
                pt.y += options2.titleMarginBottom - titleSpacing;
              }
            }
          }
        }
        _drawColorBox(ctx, pt, i, rtlHelper, options2) {
          const me = this;
          const labelColors = me.labelColors[i];
          const labelPointStyle = me.labelPointStyles[i];
          const {boxHeight, boxWidth} = options2;
          const bodyFont = toFont(options2.bodyFont);
          const colorX = getAlignedX(me, "left", options2);
          const rtlColorX = rtlHelper.x(colorX);
          const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
          const colorY = pt.y + yOffSet;
          if (options2.usePointStyle) {
            const drawOptions = {
              radius: Math.min(boxWidth, boxHeight) / 2,
              pointStyle: labelPointStyle.pointStyle,
              rotation: labelPointStyle.rotation,
              borderWidth: 1
            };
            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
            const centerY = colorY + boxHeight / 2;
            ctx.strokeStyle = options2.multiKeyBackground;
            ctx.fillStyle = options2.multiKeyBackground;
            drawPoint(ctx, drawOptions, centerX, centerY);
            ctx.strokeStyle = labelColors.borderColor;
            ctx.fillStyle = labelColors.backgroundColor;
            drawPoint(ctx, drawOptions, centerX, centerY);
          } else {
            ctx.lineWidth = labelColors.borderWidth || 1;
            ctx.strokeStyle = labelColors.borderColor;
            ctx.setLineDash(labelColors.borderDash || []);
            ctx.lineDashOffset = labelColors.borderDashOffset || 0;
            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
            const borderRadius = toTRBLCorners(labelColors.borderRadius);
            if (Object.values(borderRadius).some((v) => v !== 0)) {
              ctx.beginPath();
              ctx.fillStyle = options2.multiKeyBackground;
              addRoundedRectPath(ctx, {
                x: outerX,
                y: colorY,
                w: boxWidth,
                h: boxHeight,
                radius: borderRadius
              });
              ctx.fill();
              ctx.stroke();
              ctx.fillStyle = labelColors.backgroundColor;
              ctx.beginPath();
              addRoundedRectPath(ctx, {
                x: innerX,
                y: colorY + 1,
                w: boxWidth - 2,
                h: boxHeight - 2,
                radius: borderRadius
              });
              ctx.fill();
            } else {
              ctx.fillStyle = options2.multiKeyBackground;
              ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
              ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
              ctx.fillStyle = labelColors.backgroundColor;
              ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
            }
          }
          ctx.fillStyle = me.labelTextColors[i];
        }
        drawBody(pt, ctx, options2) {
          const me = this;
          const {body} = me;
          const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth} = options2;
          const bodyFont = toFont(options2.bodyFont);
          let bodyLineHeight = bodyFont.lineHeight;
          let xLinePadding = 0;
          const rtlHelper = getRtlAdapter(options2.rtl, me.x, me.width);
          const fillLineOfText = function(line) {
            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
            pt.y += bodyLineHeight + bodySpacing;
          };
          const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
          let bodyItem, textColor, lines, i, j, ilen, jlen;
          ctx.textAlign = bodyAlign;
          ctx.textBaseline = "middle";
          ctx.font = bodyFont.string;
          pt.x = getAlignedX(me, bodyAlignForCalculation, options2);
          ctx.fillStyle = options2.bodyColor;
          each2(me.beforeBody, fillLineOfText);
          xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + 1 : boxWidth + 2 : 0;
          for (i = 0, ilen = body.length; i < ilen; ++i) {
            bodyItem = body[i];
            textColor = me.labelTextColors[i];
            ctx.fillStyle = textColor;
            each2(bodyItem.before, fillLineOfText);
            lines = bodyItem.lines;
            if (displayColors && lines.length) {
              me._drawColorBox(ctx, pt, i, rtlHelper, options2);
              bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
            }
            for (j = 0, jlen = lines.length; j < jlen; ++j) {
              fillLineOfText(lines[j]);
              bodyLineHeight = bodyFont.lineHeight;
            }
            each2(bodyItem.after, fillLineOfText);
          }
          xLinePadding = 0;
          bodyLineHeight = bodyFont.lineHeight;
          each2(me.afterBody, fillLineOfText);
          pt.y -= bodySpacing;
        }
        drawFooter(pt, ctx, options2) {
          const me = this;
          const footer = me.footer;
          const length = footer.length;
          let footerFont, i;
          if (length) {
            const rtlHelper = getRtlAdapter(options2.rtl, me.x, me.width);
            pt.x = getAlignedX(me, options2.footerAlign, options2);
            pt.y += options2.footerMarginTop;
            ctx.textAlign = rtlHelper.textAlign(options2.footerAlign);
            ctx.textBaseline = "middle";
            footerFont = toFont(options2.footerFont);
            ctx.fillStyle = options2.footerColor;
            ctx.font = footerFont.string;
            for (i = 0; i < length; ++i) {
              ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
              pt.y += footerFont.lineHeight + options2.footerSpacing;
            }
          }
        }
        drawBackground(pt, ctx, tooltipSize, options2) {
          const {xAlign, yAlign} = this;
          const {x, y} = pt;
          const {width, height} = tooltipSize;
          const radius = options2.cornerRadius;
          ctx.fillStyle = options2.backgroundColor;
          ctx.strokeStyle = options2.borderColor;
          ctx.lineWidth = options2.borderWidth;
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          if (yAlign === "top") {
            this.drawCaret(pt, ctx, tooltipSize, options2);
          }
          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
          if (yAlign === "center" && xAlign === "right") {
            this.drawCaret(pt, ctx, tooltipSize, options2);
          }
          ctx.lineTo(x + width, y + height - radius);
          ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
          if (yAlign === "bottom") {
            this.drawCaret(pt, ctx, tooltipSize, options2);
          }
          ctx.lineTo(x + radius, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
          if (yAlign === "center" && xAlign === "left") {
            this.drawCaret(pt, ctx, tooltipSize, options2);
          }
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
          ctx.fill();
          if (options2.borderWidth > 0) {
            ctx.stroke();
          }
        }
        _updateAnimationTarget(options2) {
          const me = this;
          const chart = me._chart;
          const anims = me.$animations;
          const animX = anims && anims.x;
          const animY = anims && anims.y;
          if (animX || animY) {
            const position = positioners[options2.position].call(me, me._active, me._eventPosition);
            if (!position) {
              return;
            }
            const size = me._size = getTooltipSize(me, options2);
            const positionAndSize = Object.assign({}, position, me._size);
            const alignment = determineAlignment(chart, options2, positionAndSize);
            const point = getBackgroundPoint(options2, positionAndSize, alignment, chart);
            if (animX._to !== point.x || animY._to !== point.y) {
              me.xAlign = alignment.xAlign;
              me.yAlign = alignment.yAlign;
              me.width = size.width;
              me.height = size.height;
              me.caretX = position.x;
              me.caretY = position.y;
              me._resolveAnimations().update(me, point);
            }
          }
        }
        draw(ctx) {
          const me = this;
          const options2 = me.options.setContext(me.getContext());
          let opacity = me.opacity;
          if (!opacity) {
            return;
          }
          me._updateAnimationTarget(options2);
          const tooltipSize = {
            width: me.width,
            height: me.height
          };
          const pt = {
            x: me.x,
            y: me.y
          };
          opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
          const padding = toPadding(options2.padding);
          const hasTooltipContent = me.title.length || me.beforeBody.length || me.body.length || me.afterBody.length || me.footer.length;
          if (options2.enabled && hasTooltipContent) {
            ctx.save();
            ctx.globalAlpha = opacity;
            me.drawBackground(pt, ctx, tooltipSize, options2);
            overrideTextDirection(ctx, options2.textDirection);
            pt.y += padding.top;
            me.drawTitle(pt, ctx, options2);
            me.drawBody(pt, ctx, options2);
            me.drawFooter(pt, ctx, options2);
            restoreTextDirection(ctx, options2.textDirection);
            ctx.restore();
          }
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(activeElements, eventPosition) {
          const me = this;
          const lastActive = me._active;
          const active = activeElements.map(({datasetIndex, index: index2}) => {
            const meta2 = me._chart.getDatasetMeta(datasetIndex);
            if (!meta2) {
              throw new Error("Cannot find a dataset at index " + datasetIndex);
            }
            return {
              datasetIndex,
              element: meta2.data[index2],
              index: index2
            };
          });
          const changed = !_elementsEqual(lastActive, active);
          const positionChanged = me._positionChanged(active, eventPosition);
          if (changed || positionChanged) {
            me._active = active;
            me._eventPosition = eventPosition;
            me.update(true);
          }
        }
        handleEvent(e, replay) {
          const me = this;
          const options2 = me.options;
          const lastActive = me._active || [];
          let changed = false;
          let active = [];
          if (e.type !== "mouseout") {
            active = me._chart.getElementsAtEventForMode(e, options2.mode, options2, replay);
            if (options2.reverse) {
              active.reverse();
            }
          }
          const positionChanged = me._positionChanged(active, e);
          changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
          if (changed) {
            me._active = active;
            if (options2.enabled || options2.external) {
              me._eventPosition = {
                x: e.x,
                y: e.y
              };
              me.update(true, replay);
            }
          }
          return changed;
        }
        _positionChanged(active, e) {
          const {caretX, caretY, options: options2} = this;
          const position = positioners[options2.position].call(this, active, e);
          return position !== false && (caretX !== position.x || caretY !== position.y);
        }
      }
      Tooltip2.positioners = positioners;
      var plugin_tooltip = {
        id: "tooltip",
        _element: Tooltip2,
        positioners,
        afterInit(chart, _args, options2) {
          if (options2) {
            chart.tooltip = new Tooltip2({_chart: chart, options: options2});
          }
        },
        beforeUpdate(chart, _args, options2) {
          if (chart.tooltip) {
            chart.tooltip.initialize(options2);
          }
        },
        reset(chart, _args, options2) {
          if (chart.tooltip) {
            chart.tooltip.initialize(options2);
          }
        },
        afterDraw(chart) {
          const tooltip = chart.tooltip;
          const args = {
            tooltip
          };
          if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
            return;
          }
          if (tooltip) {
            tooltip.draw(chart.ctx);
          }
          chart.notifyPlugins("afterTooltipDraw", args);
        },
        afterEvent(chart, args) {
          if (chart.tooltip) {
            const useFinalPosition = args.replay;
            if (chart.tooltip.handleEvent(args.event, useFinalPosition)) {
              args.changed = true;
            }
          }
        },
        defaults: {
          enabled: true,
          external: null,
          position: "average",
          backgroundColor: "rgba(0,0,0,0.8)",
          titleColor: "#fff",
          titleFont: {
            weight: "bold"
          },
          titleSpacing: 2,
          titleMarginBottom: 6,
          titleAlign: "left",
          bodyColor: "#fff",
          bodySpacing: 2,
          bodyFont: {},
          bodyAlign: "left",
          footerColor: "#fff",
          footerSpacing: 2,
          footerMarginTop: 6,
          footerFont: {
            weight: "bold"
          },
          footerAlign: "left",
          padding: 6,
          caretPadding: 2,
          caretSize: 5,
          cornerRadius: 6,
          boxHeight: (ctx, opts) => opts.bodyFont.size,
          boxWidth: (ctx, opts) => opts.bodyFont.size,
          multiKeyBackground: "#fff",
          displayColors: true,
          borderColor: "rgba(0,0,0,0)",
          borderWidth: 0,
          animation: {
            duration: 400,
            easing: "easeOutQuart"
          },
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "width", "height", "caretX", "caretY"]
            },
            opacity: {
              easing: "linear",
              duration: 200
            }
          },
          callbacks: {
            beforeTitle: noop3,
            title(tooltipItems) {
              if (tooltipItems.length > 0) {
                const item = tooltipItems[0];
                const labels = item.chart.data.labels;
                const labelCount = labels ? labels.length : 0;
                if (this && this.options && this.options.mode === "dataset") {
                  return item.dataset.label || "";
                } else if (item.label) {
                  return item.label;
                } else if (labelCount > 0 && item.dataIndex < labelCount) {
                  return labels[item.dataIndex];
                }
              }
              return "";
            },
            afterTitle: noop3,
            beforeBody: noop3,
            beforeLabel: noop3,
            label(tooltipItem) {
              if (this && this.options && this.options.mode === "dataset") {
                return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
              }
              let label = tooltipItem.dataset.label || "";
              if (label) {
                label += ": ";
              }
              const value = tooltipItem.formattedValue;
              if (!isNullOrUndef(value)) {
                label += value;
              }
              return label;
            },
            labelColor(tooltipItem) {
              const meta2 = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
              const options2 = meta2.controller.getStyle(tooltipItem.dataIndex);
              return {
                borderColor: options2.borderColor,
                backgroundColor: options2.backgroundColor,
                borderWidth: options2.borderWidth,
                borderDash: options2.borderDash,
                borderDashOffset: options2.borderDashOffset,
                borderRadius: 0
              };
            },
            labelTextColor() {
              return this.options.bodyColor;
            },
            labelPointStyle(tooltipItem) {
              const meta2 = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
              const options2 = meta2.controller.getStyle(tooltipItem.dataIndex);
              return {
                pointStyle: options2.pointStyle,
                rotation: options2.rotation
              };
            },
            afterLabel: noop3,
            afterBody: noop3,
            beforeFooter: noop3,
            footer: noop3,
            afterFooter: noop3
          }
        },
        defaultRoutes: {
          bodyFont: "font",
          footerFont: "font",
          titleFont: "font"
        },
        descriptors: {
          _scriptable: (name2) => name2 !== "filter" && name2 !== "itemSort" && name2 !== "external",
          _indexable: false,
          callbacks: {
            _scriptable: false,
            _indexable: false
          },
          animation: {
            _fallback: false
          },
          animations: {
            _fallback: "animation"
          }
        },
        additionalOptionScopes: ["interaction"]
      };
      var plugins = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        Decimation: plugin_decimation,
        Filler: plugin_filler,
        Legend: plugin_legend,
        Title: plugin_title,
        Tooltip: plugin_tooltip
      });
      const addIfString = (labels, raw, index2) => typeof raw === "string" ? labels.push(raw) - 1 : isNaN(raw) ? null : index2;
      function findOrAddLabel(labels, raw, index2) {
        const first = labels.indexOf(raw);
        if (first === -1) {
          return addIfString(labels, raw, index2);
        }
        const last = labels.lastIndexOf(raw);
        return first !== last ? index2 : first;
      }
      const validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
      class CategoryScale extends Scale {
        constructor(cfg) {
          super(cfg);
          this._startValue = void 0;
          this._valueRange = 0;
        }
        parse(raw, index2) {
          if (isNullOrUndef(raw)) {
            return null;
          }
          const labels = this.getLabels();
          index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw));
          return validIndex(index2, labels.length - 1);
        }
        determineDataLimits() {
          const me = this;
          const {minDefined, maxDefined} = me.getUserBounds();
          let {min, max} = me.getMinMax(true);
          if (me.options.bounds === "ticks") {
            if (!minDefined) {
              min = 0;
            }
            if (!maxDefined) {
              max = me.getLabels().length - 1;
            }
          }
          me.min = min;
          me.max = max;
        }
        buildTicks() {
          const me = this;
          const min = me.min;
          const max = me.max;
          const offset = me.options.offset;
          const ticks = [];
          let labels = me.getLabels();
          labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
          me._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
          me._startValue = me.min - (offset ? 0.5 : 0);
          for (let value = min; value <= max; value++) {
            ticks.push({value});
          }
          return ticks;
        }
        getLabelForValue(value) {
          const me = this;
          const labels = me.getLabels();
          if (value >= 0 && value < labels.length) {
            return labels[value];
          }
          return value;
        }
        configure() {
          const me = this;
          super.configure();
          if (!me.isHorizontal()) {
            me._reversePixels = !me._reversePixels;
          }
        }
        getPixelForValue(value) {
          const me = this;
          if (typeof value !== "number") {
            value = me.parse(value);
          }
          return value === null ? NaN : me.getPixelForDecimal((value - me._startValue) / me._valueRange);
        }
        getPixelForTick(index2) {
          const me = this;
          const ticks = me.ticks;
          if (index2 < 0 || index2 > ticks.length - 1) {
            return null;
          }
          return me.getPixelForValue(ticks[index2].value);
        }
        getValueForPixel(pixel) {
          const me = this;
          return Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);
        }
        getBasePixel() {
          return this.bottom;
        }
      }
      CategoryScale.id = "category";
      CategoryScale.defaults = {
        ticks: {
          callback: CategoryScale.prototype.getLabelForValue
        }
      };
      function generateTicks$1(generationOptions, dataRange) {
        const ticks = [];
        const MIN_SPACING = 1e-14;
        const {step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;
        const unit = step || 1;
        const maxSpaces = maxTicks - 1;
        const {min: rmin, max: rmax} = dataRange;
        const minDefined = !isNullOrUndef(min);
        const maxDefined = !isNullOrUndef(max);
        const countDefined = !isNullOrUndef(count);
        const minSpacing = (rmax - rmin) / (maxDigits + 1);
        let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
        let factor, niceMin, niceMax, numSpaces;
        if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
          return [{value: rmin}, {value: rmax}];
        }
        numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
        if (numSpaces > maxSpaces) {
          spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
        }
        if (!isNullOrUndef(precision)) {
          factor = Math.pow(10, precision);
          spacing = Math.ceil(spacing * factor) / factor;
        }
        niceMin = Math.floor(rmin / spacing) * spacing;
        niceMax = Math.ceil(rmax / spacing) * spacing;
        if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
          numSpaces = Math.min((max - min) / spacing, maxTicks);
          spacing = (max - min) / numSpaces;
          niceMin = min;
          niceMax = max;
        } else if (countDefined) {
          niceMin = minDefined ? min : niceMin;
          niceMax = maxDefined ? max : niceMax;
          numSpaces = count - 1;
          spacing = (niceMax - niceMin) / numSpaces;
        } else {
          numSpaces = (niceMax - niceMin) / spacing;
          if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
            numSpaces = Math.round(numSpaces);
          } else {
            numSpaces = Math.ceil(numSpaces);
          }
        }
        const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
        factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
        niceMin = Math.round(niceMin * factor) / factor;
        niceMax = Math.round(niceMax * factor) / factor;
        let j = 0;
        if (minDefined) {
          if (includeBounds && niceMin !== min) {
            ticks.push({value: min});
            if (niceMin < min) {
              j++;
            }
            if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
              j++;
            }
          } else if (niceMin < min) {
            j++;
          }
        }
        for (; j < numSpaces; ++j) {
          ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});
        }
        if (maxDefined && includeBounds && niceMax !== max) {
          if (almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
            ticks[ticks.length - 1].value = max;
          } else {
            ticks.push({value: max});
          }
        } else if (!maxDefined || niceMax === max) {
          ticks.push({value: niceMax});
        }
        return ticks;
      }
      function relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {
        const rad = toRadians(minRotation);
        const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
        const length = 0.75 * minSpacing * ("" + value).length;
        return Math.min(minSpacing / ratio, length);
      }
      class LinearScaleBase extends Scale {
        constructor(cfg) {
          super(cfg);
          this.start = void 0;
          this.end = void 0;
          this._startValue = void 0;
          this._endValue = void 0;
          this._valueRange = 0;
        }
        parse(raw, index2) {
          if (isNullOrUndef(raw)) {
            return null;
          }
          if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
            return null;
          }
          return +raw;
        }
        handleTickRangeOptions() {
          const me = this;
          const {beginAtZero} = me.options;
          const {minDefined, maxDefined} = me.getUserBounds();
          let {min, max} = me;
          const setMin = (v) => min = minDefined ? min : v;
          const setMax = (v) => max = maxDefined ? max : v;
          if (beginAtZero) {
            const minSign = sign(min);
            const maxSign = sign(max);
            if (minSign < 0 && maxSign < 0) {
              setMax(0);
            } else if (minSign > 0 && maxSign > 0) {
              setMin(0);
            }
          }
          if (min === max) {
            setMax(max + 1);
            if (!beginAtZero) {
              setMin(min - 1);
            }
          }
          me.min = min;
          me.max = max;
        }
        getTickLimit() {
          const me = this;
          const tickOpts = me.options.ticks;
          let {maxTicksLimit, stepSize} = tickOpts;
          let maxTicks;
          if (stepSize) {
            maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
          } else {
            maxTicks = me.computeTickLimit();
            maxTicksLimit = maxTicksLimit || 11;
          }
          if (maxTicksLimit) {
            maxTicks = Math.min(maxTicksLimit, maxTicks);
          }
          return maxTicks;
        }
        computeTickLimit() {
          return Number.POSITIVE_INFINITY;
        }
        buildTicks() {
          const me = this;
          const opts = me.options;
          const tickOpts = opts.ticks;
          let maxTicks = me.getTickLimit();
          maxTicks = Math.max(2, maxTicks);
          const numericGeneratorOptions = {
            maxTicks,
            min: opts.min,
            max: opts.max,
            precision: tickOpts.precision,
            step: tickOpts.stepSize,
            count: tickOpts.count,
            maxDigits: me._maxDigits(),
            horizontal: me.isHorizontal(),
            minRotation: tickOpts.minRotation || 0,
            includeBounds: tickOpts.includeBounds !== false
          };
          const dataRange = me._range || me;
          const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
          if (opts.bounds === "ticks") {
            _setMinAndMaxByKey(ticks, me, "value");
          }
          if (opts.reverse) {
            ticks.reverse();
            me.start = me.max;
            me.end = me.min;
          } else {
            me.start = me.min;
            me.end = me.max;
          }
          return ticks;
        }
        configure() {
          const me = this;
          const ticks = me.ticks;
          let start = me.min;
          let end = me.max;
          super.configure();
          if (me.options.offset && ticks.length) {
            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
            start -= offset;
            end += offset;
          }
          me._startValue = start;
          me._endValue = end;
          me._valueRange = end - start;
        }
        getLabelForValue(value) {
          return formatNumber2(value, this.chart.options.locale);
        }
      }
      class LinearScale extends LinearScaleBase {
        determineDataLimits() {
          const me = this;
          const {min, max} = me.getMinMax(true);
          me.min = isNumberFinite(min) ? min : 0;
          me.max = isNumberFinite(max) ? max : 1;
          me.handleTickRangeOptions();
        }
        computeTickLimit() {
          const me = this;
          const horizontal = me.isHorizontal();
          const length = horizontal ? me.width : me.height;
          const minRotation = toRadians(me.options.ticks.minRotation);
          const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
          const tickFont = me._resolveTickFontOptions(0);
          return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
        }
        getPixelForValue(value) {
          return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
        }
        getValueForPixel(pixel) {
          return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
        }
      }
      LinearScale.id = "linear";
      LinearScale.defaults = {
        ticks: {
          callback: Ticks.formatters.numeric
        }
      };
      function isMajor(tickVal) {
        const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
        return remain === 1;
      }
      function generateTicks(generationOptions, dataRange) {
        const endExp = Math.floor(log10(dataRange.max));
        const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
        const ticks = [];
        let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
        let exp = Math.floor(log10(tickVal));
        let significand = Math.floor(tickVal / Math.pow(10, exp));
        let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
        do {
          ticks.push({value: tickVal, major: isMajor(tickVal)});
          ++significand;
          if (significand === 10) {
            significand = 1;
            ++exp;
            precision = exp >= 0 ? 1 : precision;
          }
          tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
        } while (exp < endExp || exp === endExp && significand < endSignificand);
        const lastTick = finiteOrDefault(generationOptions.max, tickVal);
        ticks.push({value: lastTick, major: isMajor(tickVal)});
        return ticks;
      }
      class LogarithmicScale extends Scale {
        constructor(cfg) {
          super(cfg);
          this.start = void 0;
          this.end = void 0;
          this._startValue = void 0;
          this._valueRange = 0;
        }
        parse(raw, index2) {
          const value = LinearScaleBase.prototype.parse.apply(this, [raw, index2]);
          if (value === 0) {
            this._zero = true;
            return void 0;
          }
          return isNumberFinite(value) && value > 0 ? value : null;
        }
        determineDataLimits() {
          const me = this;
          const {min, max} = me.getMinMax(true);
          me.min = isNumberFinite(min) ? Math.max(0, min) : null;
          me.max = isNumberFinite(max) ? Math.max(0, max) : null;
          if (me.options.beginAtZero) {
            me._zero = true;
          }
          me.handleTickRangeOptions();
        }
        handleTickRangeOptions() {
          const me = this;
          const {minDefined, maxDefined} = me.getUserBounds();
          let min = me.min;
          let max = me.max;
          const setMin = (v) => min = minDefined ? min : v;
          const setMax = (v) => max = maxDefined ? max : v;
          const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
          if (min === max) {
            if (min <= 0) {
              setMin(1);
              setMax(10);
            } else {
              setMin(exp(min, -1));
              setMax(exp(max, 1));
            }
          }
          if (min <= 0) {
            setMin(exp(max, -1));
          }
          if (max <= 0) {
            setMax(exp(min, 1));
          }
          if (me._zero && me.min !== me._suggestedMin && min === exp(me.min, 0)) {
            setMin(exp(min, -1));
          }
          me.min = min;
          me.max = max;
        }
        buildTicks() {
          const me = this;
          const opts = me.options;
          const generationOptions = {
            min: me._userMin,
            max: me._userMax
          };
          const ticks = generateTicks(generationOptions, me);
          if (opts.bounds === "ticks") {
            _setMinAndMaxByKey(ticks, me, "value");
          }
          if (opts.reverse) {
            ticks.reverse();
            me.start = me.max;
            me.end = me.min;
          } else {
            me.start = me.min;
            me.end = me.max;
          }
          return ticks;
        }
        getLabelForValue(value) {
          return value === void 0 ? "0" : formatNumber2(value, this.chart.options.locale);
        }
        configure() {
          const me = this;
          const start = me.min;
          super.configure();
          me._startValue = log10(start);
          me._valueRange = log10(me.max) - log10(start);
        }
        getPixelForValue(value) {
          const me = this;
          if (value === void 0 || value === 0) {
            value = me.min;
          }
          if (value === null || isNaN(value)) {
            return NaN;
          }
          return me.getPixelForDecimal(value === me.min ? 0 : (log10(value) - me._startValue) / me._valueRange);
        }
        getValueForPixel(pixel) {
          const me = this;
          const decimal = me.getDecimalForPixel(pixel);
          return Math.pow(10, me._startValue + decimal * me._valueRange);
        }
      }
      LogarithmicScale.id = "logarithmic";
      LogarithmicScale.defaults = {
        ticks: {
          callback: Ticks.formatters.logarithmic,
          major: {
            enabled: true
          }
        }
      };
      function getTickBackdropHeight(opts) {
        const tickOpts = opts.ticks;
        if (tickOpts.display && opts.display) {
          const padding = toPadding(tickOpts.backdropPadding);
          return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults3.font.size) + padding.height;
        }
        return 0;
      }
      function measureLabelSize(ctx, lineHeight, label) {
        if (isArray(label)) {
          return {
            w: _longestText(ctx, ctx.font, label),
            h: label.length * lineHeight
          };
        }
        return {
          w: ctx.measureText(label).width,
          h: lineHeight
        };
      }
      function determineLimits(angle, pos, size, min, max) {
        if (angle === min || angle === max) {
          return {
            start: pos - size / 2,
            end: pos + size / 2
          };
        } else if (angle < min || angle > max) {
          return {
            start: pos - size,
            end: pos
          };
        }
        return {
          start: pos,
          end: pos + size
        };
      }
      function fitWithPointLabels(scale) {
        const furthestLimits = {
          l: 0,
          r: scale.width,
          t: 0,
          b: scale.height - scale.paddingTop
        };
        const furthestAngles = {};
        let i, textSize, pointPosition;
        const labelSizes = [];
        const padding = [];
        const valueCount = scale.getLabels().length;
        for (i = 0; i < valueCount; i++) {
          const opts2 = scale.options.pointLabels.setContext(scale.getContext(i));
          padding[i] = opts2.padding;
          pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i]);
          const plFont = toFont(opts2.font);
          scale.ctx.font = plFont.string;
          textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale._pointLabels[i]);
          labelSizes[i] = textSize;
          const angleRadians = scale.getIndexAngle(i);
          const angle = toDegrees(angleRadians);
          const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
          const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
          if (hLimits.start < furthestLimits.l) {
            furthestLimits.l = hLimits.start;
            furthestAngles.l = angleRadians;
          }
          if (hLimits.end > furthestLimits.r) {
            furthestLimits.r = hLimits.end;
            furthestAngles.r = angleRadians;
          }
          if (vLimits.start < furthestLimits.t) {
            furthestLimits.t = vLimits.start;
            furthestAngles.t = angleRadians;
          }
          if (vLimits.end > furthestLimits.b) {
            furthestLimits.b = vLimits.end;
            furthestAngles.b = angleRadians;
          }
        }
        scale._setReductions(scale.drawingArea, furthestLimits, furthestAngles);
        scale._pointLabelItems = [];
        const opts = scale.options;
        const tickBackdropHeight = getTickBackdropHeight(opts);
        const outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);
        for (i = 0; i < valueCount; i++) {
          const extra = i === 0 ? tickBackdropHeight / 2 : 0;
          const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i]);
          const angle = toDegrees(scale.getIndexAngle(i));
          const size = labelSizes[i];
          adjustPointPositionForLabelHeight(angle, size, pointLabelPosition);
          const textAlign = getTextAlignForAngle(angle);
          let left;
          if (textAlign === "left") {
            left = pointLabelPosition.x;
          } else if (textAlign === "center") {
            left = pointLabelPosition.x - size.w / 2;
          } else {
            left = pointLabelPosition.x - size.w;
          }
          const right = left + size.w;
          scale._pointLabelItems[i] = {
            x: pointLabelPosition.x,
            y: pointLabelPosition.y,
            textAlign,
            left,
            top: pointLabelPosition.y,
            right,
            bottom: pointLabelPosition.y + size.h
          };
        }
      }
      function getTextAlignForAngle(angle) {
        if (angle === 0 || angle === 180) {
          return "center";
        } else if (angle < 180) {
          return "left";
        }
        return "right";
      }
      function adjustPointPositionForLabelHeight(angle, textSize, position) {
        if (angle === 90 || angle === 270) {
          position.y -= textSize.h / 2;
        } else if (angle > 270 || angle < 90) {
          position.y -= textSize.h;
        }
      }
      function drawPointLabels(scale, labelCount) {
        const {ctx, options: {pointLabels}} = scale;
        for (let i = labelCount - 1; i >= 0; i--) {
          const optsAtIndex = pointLabels.setContext(scale.getContext(i));
          const plFont = toFont(optsAtIndex.font);
          const {x, y, textAlign, left, top: top2, right, bottom} = scale._pointLabelItems[i];
          const {backdropColor} = optsAtIndex;
          if (!isNullOrUndef(backdropColor)) {
            const padding = toPadding(optsAtIndex.backdropPadding);
            ctx.fillStyle = backdropColor;
            ctx.fillRect(left - padding.left, top2 - padding.top, right - left + padding.width, bottom - top2 + padding.height);
          }
          renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
            color: optsAtIndex.color,
            textAlign,
            textBaseline: "middle"
          });
        }
      }
      function pathRadiusLine(scale, radius, circular, labelCount) {
        const {ctx} = scale;
        if (circular) {
          ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
        } else {
          let pointPosition = scale.getPointPosition(0, radius);
          ctx.moveTo(pointPosition.x, pointPosition.y);
          for (let i = 1; i < labelCount; i++) {
            pointPosition = scale.getPointPosition(i, radius);
            ctx.lineTo(pointPosition.x, pointPosition.y);
          }
        }
      }
      function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
        const ctx = scale.ctx;
        const circular = gridLineOpts.circular;
        const {color: color2, lineWidth} = gridLineOpts;
        if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
          return;
        }
        ctx.save();
        ctx.strokeStyle = color2;
        ctx.lineWidth = lineWidth;
        ctx.setLineDash(gridLineOpts.borderDash);
        ctx.lineDashOffset = gridLineOpts.borderDashOffset;
        ctx.beginPath();
        pathRadiusLine(scale, radius, circular, labelCount);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }
      function numberOrZero(param) {
        return isNumber(param) ? param : 0;
      }
      class RadialLinearScale extends LinearScaleBase {
        constructor(cfg) {
          super(cfg);
          this.xCenter = void 0;
          this.yCenter = void 0;
          this.drawingArea = void 0;
          this._pointLabels = [];
          this._pointLabelItems = [];
        }
        setDimensions() {
          const me = this;
          me.width = me.maxWidth;
          me.height = me.maxHeight;
          me.paddingTop = getTickBackdropHeight(me.options) / 2;
          me.xCenter = Math.floor(me.width / 2);
          me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
          me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
        }
        determineDataLimits() {
          const me = this;
          const {min, max} = me.getMinMax(false);
          me.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
          me.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
          me.handleTickRangeOptions();
        }
        computeTickLimit() {
          return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
        }
        generateTickLabels(ticks) {
          const me = this;
          LinearScaleBase.prototype.generateTickLabels.call(me, ticks);
          me._pointLabels = me.getLabels().map((value, index2) => {
            const label = callback(me.options.pointLabels.callback, [value, index2], me);
            return label || label === 0 ? label : "";
          });
        }
        fit() {
          const me = this;
          const opts = me.options;
          if (opts.display && opts.pointLabels.display) {
            fitWithPointLabels(me);
          } else {
            me.setCenterPoint(0, 0, 0, 0);
          }
        }
        _setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {
          const me = this;
          let radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
          let radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
          let radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
          let radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
          radiusReductionLeft = numberOrZero(radiusReductionLeft);
          radiusReductionRight = numberOrZero(radiusReductionRight);
          radiusReductionTop = numberOrZero(radiusReductionTop);
          radiusReductionBottom = numberOrZero(radiusReductionBottom);
          me.drawingArea = Math.max(largestPossibleRadius / 2, Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2)));
          me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
        }
        setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
          const me = this;
          const maxRight = me.width - rightMovement - me.drawingArea;
          const maxLeft = leftMovement + me.drawingArea;
          const maxTop = topMovement + me.drawingArea;
          const maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
          me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
          me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
        }
        getIndexAngle(index2) {
          const angleMultiplier = TAU / this.getLabels().length;
          const startAngle = this.options.startAngle || 0;
          return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
        }
        getDistanceFromCenterForValue(value) {
          const me = this;
          if (isNullOrUndef(value)) {
            return NaN;
          }
          const scalingFactor = me.drawingArea / (me.max - me.min);
          if (me.options.reverse) {
            return (me.max - value) * scalingFactor;
          }
          return (value - me.min) * scalingFactor;
        }
        getValueForDistanceFromCenter(distance) {
          if (isNullOrUndef(distance)) {
            return NaN;
          }
          const me = this;
          const scaledDistance = distance / (me.drawingArea / (me.max - me.min));
          return me.options.reverse ? me.max - scaledDistance : me.min + scaledDistance;
        }
        getPointPosition(index2, distanceFromCenter) {
          const me = this;
          const angle = me.getIndexAngle(index2) - HALF_PI;
          return {
            x: Math.cos(angle) * distanceFromCenter + me.xCenter,
            y: Math.sin(angle) * distanceFromCenter + me.yCenter,
            angle
          };
        }
        getPointPositionForValue(index2, value) {
          return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
        }
        getBasePosition(index2) {
          return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
        }
        getPointLabelPosition(index2) {
          const {left, top: top2, right, bottom} = this._pointLabelItems[index2];
          return {
            left,
            top: top2,
            right,
            bottom
          };
        }
        drawBackground() {
          const me = this;
          const {backgroundColor, grid: {circular}} = me.options;
          if (backgroundColor) {
            const ctx = me.ctx;
            ctx.save();
            ctx.beginPath();
            pathRadiusLine(me, me.getDistanceFromCenterForValue(me._endValue), circular, me.getLabels().length);
            ctx.closePath();
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
          }
        }
        drawGrid() {
          const me = this;
          const ctx = me.ctx;
          const opts = me.options;
          const {angleLines, grid} = opts;
          const labelCount = me.getLabels().length;
          let i, offset, position;
          if (opts.pointLabels.display) {
            drawPointLabels(me, labelCount);
          }
          if (grid.display) {
            me.ticks.forEach((tick2, index2) => {
              if (index2 !== 0) {
                offset = me.getDistanceFromCenterForValue(tick2.value);
                const optsAtIndex = grid.setContext(me.getContext(index2 - 1));
                drawRadiusLine(me, optsAtIndex, offset, labelCount);
              }
            });
          }
          if (angleLines.display) {
            ctx.save();
            for (i = me.getLabels().length - 1; i >= 0; i--) {
              const optsAtIndex = angleLines.setContext(me.getContext(i));
              const {color: color2, lineWidth} = optsAtIndex;
              if (!lineWidth || !color2) {
                continue;
              }
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = color2;
              ctx.setLineDash(optsAtIndex.borderDash);
              ctx.lineDashOffset = optsAtIndex.borderDashOffset;
              offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);
              position = me.getPointPosition(i, offset);
              ctx.beginPath();
              ctx.moveTo(me.xCenter, me.yCenter);
              ctx.lineTo(position.x, position.y);
              ctx.stroke();
            }
            ctx.restore();
          }
        }
        drawBorder() {
        }
        drawLabels() {
          const me = this;
          const ctx = me.ctx;
          const opts = me.options;
          const tickOpts = opts.ticks;
          if (!tickOpts.display) {
            return;
          }
          const startAngle = me.getIndexAngle(0);
          let offset, width;
          ctx.save();
          ctx.translate(me.xCenter, me.yCenter);
          ctx.rotate(startAngle);
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          me.ticks.forEach((tick2, index2) => {
            if (index2 === 0 && !opts.reverse) {
              return;
            }
            const optsAtIndex = tickOpts.setContext(me.getContext(index2));
            const tickFont = toFont(optsAtIndex.font);
            offset = me.getDistanceFromCenterForValue(me.ticks[index2].value);
            if (optsAtIndex.showLabelBackdrop) {
              width = ctx.measureText(tick2.label).width;
              ctx.fillStyle = optsAtIndex.backdropColor;
              const padding = toPadding(optsAtIndex.backdropPadding);
              ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
            }
            renderText(ctx, tick2.label, 0, -offset, tickFont, {
              color: optsAtIndex.color
            });
          });
          ctx.restore();
        }
        drawTitle() {
        }
      }
      RadialLinearScale.id = "radialLinear";
      RadialLinearScale.defaults = {
        display: true,
        animate: true,
        position: "chartArea",
        angleLines: {
          display: true,
          lineWidth: 1,
          borderDash: [],
          borderDashOffset: 0
        },
        grid: {
          circular: false
        },
        startAngle: 0,
        ticks: {
          showLabelBackdrop: true,
          callback: Ticks.formatters.numeric
        },
        pointLabels: {
          backdropColor: void 0,
          backdropPadding: 2,
          display: true,
          font: {
            size: 10
          },
          callback(label) {
            return label;
          },
          padding: 5
        }
      };
      RadialLinearScale.defaultRoutes = {
        "angleLines.color": "borderColor",
        "pointLabels.color": "color",
        "ticks.color": "color"
      };
      RadialLinearScale.descriptors = {
        angleLines: {
          _fallback: "grid"
        }
      };
      const INTERVALS = {
        millisecond: {common: true, size: 1, steps: 1e3},
        second: {common: true, size: 1e3, steps: 60},
        minute: {common: true, size: 6e4, steps: 60},
        hour: {common: true, size: 36e5, steps: 24},
        day: {common: true, size: 864e5, steps: 30},
        week: {common: false, size: 6048e5, steps: 4},
        month: {common: true, size: 2628e6, steps: 12},
        quarter: {common: false, size: 7884e6, steps: 4},
        year: {common: true, size: 3154e7}
      };
      const UNITS = Object.keys(INTERVALS);
      function sorter(a, b) {
        return a - b;
      }
      function parse(scale, input) {
        if (isNullOrUndef(input)) {
          return null;
        }
        const adapter = scale._adapter;
        const {parser: parser2, round: round2, isoWeekday} = scale._parseOpts;
        let value = input;
        if (typeof parser2 === "function") {
          value = parser2(value);
        }
        if (!isNumberFinite(value)) {
          value = typeof parser2 === "string" ? adapter.parse(value, parser2) : adapter.parse(value);
        }
        if (value === null) {
          return null;
        }
        if (round2) {
          value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
        }
        return +value;
      }
      function determineUnitForAutoTicks(minUnit, min, max, capacity) {
        const ilen = UNITS.length;
        for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
          const interval = INTERVALS[UNITS[i]];
          const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
          if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
            return UNITS[i];
          }
        }
        return UNITS[ilen - 1];
      }
      function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
        for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
          const unit = UNITS[i];
          if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
            return unit;
          }
        }
        return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
      }
      function determineMajorUnit(unit) {
        for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
          if (INTERVALS[UNITS[i]].common) {
            return UNITS[i];
          }
        }
      }
      function addTick(ticks, time, timestamps) {
        if (!timestamps) {
          ticks[time] = true;
        } else if (timestamps.length) {
          const {lo, hi} = _lookup(timestamps, time);
          const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
          ticks[timestamp] = true;
        }
      }
      function setMajorTicks(scale, ticks, map2, majorUnit) {
        const adapter = scale._adapter;
        const first = +adapter.startOf(ticks[0].value, majorUnit);
        const last = ticks[ticks.length - 1].value;
        let major, index2;
        for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
          index2 = map2[major];
          if (index2 >= 0) {
            ticks[index2].major = true;
          }
        }
        return ticks;
      }
      function ticksFromTimestamps(scale, values, majorUnit) {
        const ticks = [];
        const map2 = {};
        const ilen = values.length;
        let i, value;
        for (i = 0; i < ilen; ++i) {
          value = values[i];
          map2[value] = i;
          ticks.push({
            value,
            major: false
          });
        }
        return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
      }
      class TimeScale extends Scale {
        constructor(props) {
          super(props);
          this._cache = {
            data: [],
            labels: [],
            all: []
          };
          this._unit = "day";
          this._majorUnit = void 0;
          this._offsets = {};
          this._normalized = false;
          this._parseOpts = void 0;
        }
        init(scaleOpts, opts) {
          const time = scaleOpts.time || (scaleOpts.time = {});
          const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);
          mergeIf(time.displayFormats, adapter.formats());
          this._parseOpts = {
            parser: time.parser,
            round: time.round,
            isoWeekday: time.isoWeekday
          };
          super.init(scaleOpts);
          this._normalized = opts.normalized;
        }
        parse(raw, index2) {
          if (raw === void 0) {
            return null;
          }
          return parse(this, raw);
        }
        beforeLayout() {
          super.beforeLayout();
          this._cache = {
            data: [],
            labels: [],
            all: []
          };
        }
        determineDataLimits() {
          const me = this;
          const options2 = me.options;
          const adapter = me._adapter;
          const unit = options2.time.unit || "day";
          let {min, max, minDefined, maxDefined} = me.getUserBounds();
          function _applyBounds(bounds) {
            if (!minDefined && !isNaN(bounds.min)) {
              min = Math.min(min, bounds.min);
            }
            if (!maxDefined && !isNaN(bounds.max)) {
              max = Math.max(max, bounds.max);
            }
          }
          if (!minDefined || !maxDefined) {
            _applyBounds(me._getLabelBounds());
            if (options2.bounds !== "ticks" || options2.ticks.source !== "labels") {
              _applyBounds(me.getMinMax(false));
            }
          }
          min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
          max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
          me.min = Math.min(min, max - 1);
          me.max = Math.max(min + 1, max);
        }
        _getLabelBounds() {
          const arr = this.getLabelTimestamps();
          let min = Number.POSITIVE_INFINITY;
          let max = Number.NEGATIVE_INFINITY;
          if (arr.length) {
            min = arr[0];
            max = arr[arr.length - 1];
          }
          return {min, max};
        }
        buildTicks() {
          const me = this;
          const options2 = me.options;
          const timeOpts = options2.time;
          const tickOpts = options2.ticks;
          const timestamps = tickOpts.source === "labels" ? me.getLabelTimestamps() : me._generate();
          if (options2.bounds === "ticks" && timestamps.length) {
            me.min = me._userMin || timestamps[0];
            me.max = me._userMax || timestamps[timestamps.length - 1];
          }
          const min = me.min;
          const max = me.max;
          const ticks = _filterBetween(timestamps, min, max);
          me._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, me._getLabelCapacity(min)) : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));
          me._majorUnit = !tickOpts.major.enabled || me._unit === "year" ? void 0 : determineMajorUnit(me._unit);
          me.initOffsets(timestamps);
          if (options2.reverse) {
            ticks.reverse();
          }
          return ticksFromTimestamps(me, ticks, me._majorUnit);
        }
        initOffsets(timestamps) {
          const me = this;
          let start = 0;
          let end = 0;
          let first, last;
          if (me.options.offset && timestamps.length) {
            first = me.getDecimalForValue(timestamps[0]);
            if (timestamps.length === 1) {
              start = 1 - first;
            } else {
              start = (me.getDecimalForValue(timestamps[1]) - first) / 2;
            }
            last = me.getDecimalForValue(timestamps[timestamps.length - 1]);
            if (timestamps.length === 1) {
              end = last;
            } else {
              end = (last - me.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
            }
          }
          const limit = timestamps.length < 3 ? 0.5 : 0.25;
          start = _limitValue(start, 0, limit);
          end = _limitValue(end, 0, limit);
          me._offsets = {start, end, factor: 1 / (start + 1 + end)};
        }
        _generate() {
          const me = this;
          const adapter = me._adapter;
          const min = me.min;
          const max = me.max;
          const options2 = me.options;
          const timeOpts = options2.time;
          const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, me._getLabelCapacity(min));
          const stepSize = valueOrDefault(timeOpts.stepSize, 1);
          const weekday = minor === "week" ? timeOpts.isoWeekday : false;
          const hasWeekday = isNumber(weekday) || weekday === true;
          const ticks = {};
          let first = min;
          let time, count;
          if (hasWeekday) {
            first = +adapter.startOf(first, "isoWeek", weekday);
          }
          first = +adapter.startOf(first, hasWeekday ? "day" : minor);
          if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
            throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
          }
          const timestamps = options2.ticks.source === "data" && me.getDataTimestamps();
          for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
            addTick(ticks, time, timestamps);
          }
          if (time === max || options2.bounds === "ticks" || count === 1) {
            addTick(ticks, time, timestamps);
          }
          return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
        }
        getLabelForValue(value) {
          const me = this;
          const adapter = me._adapter;
          const timeOpts = me.options.time;
          if (timeOpts.tooltipFormat) {
            return adapter.format(value, timeOpts.tooltipFormat);
          }
          return adapter.format(value, timeOpts.displayFormats.datetime);
        }
        _tickFormatFunction(time, index2, ticks, format2) {
          const me = this;
          const options2 = me.options;
          const formats = options2.time.displayFormats;
          const unit = me._unit;
          const majorUnit = me._majorUnit;
          const minorFormat = unit && formats[unit];
          const majorFormat = majorUnit && formats[majorUnit];
          const tick2 = ticks[index2];
          const major = majorUnit && majorFormat && tick2 && tick2.major;
          const label = me._adapter.format(time, format2 || (major ? majorFormat : minorFormat));
          const formatter = options2.ticks.callback;
          return formatter ? callback(formatter, [label, index2, ticks], me) : label;
        }
        generateTickLabels(ticks) {
          let i, ilen, tick2;
          for (i = 0, ilen = ticks.length; i < ilen; ++i) {
            tick2 = ticks[i];
            tick2.label = this._tickFormatFunction(tick2.value, i, ticks);
          }
        }
        getDecimalForValue(value) {
          const me = this;
          return value === null ? NaN : (value - me.min) / (me.max - me.min);
        }
        getPixelForValue(value) {
          const me = this;
          const offsets = me._offsets;
          const pos = me.getDecimalForValue(value);
          return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);
        }
        getValueForPixel(pixel) {
          const me = this;
          const offsets = me._offsets;
          const pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
          return me.min + pos * (me.max - me.min);
        }
        _getLabelSize(label) {
          const me = this;
          const ticksOpts = me.options.ticks;
          const tickLabelWidth = me.ctx.measureText(label).width;
          const angle = toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
          const cosRotation = Math.cos(angle);
          const sinRotation = Math.sin(angle);
          const tickFontSize = me._resolveTickFontOptions(0).size;
          return {
            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
          };
        }
        _getLabelCapacity(exampleTime) {
          const me = this;
          const timeOpts = me.options.time;
          const displayFormats = timeOpts.displayFormats;
          const format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
          const exampleLabel = me._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format2);
          const size = me._getLabelSize(exampleLabel);
          const capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h) - 1;
          return capacity > 0 ? capacity : 1;
        }
        getDataTimestamps() {
          const me = this;
          let timestamps = me._cache.data || [];
          let i, ilen;
          if (timestamps.length) {
            return timestamps;
          }
          const metas = me.getMatchingVisibleMetas();
          if (me._normalized && metas.length) {
            return me._cache.data = metas[0].controller.getAllParsedValues(me);
          }
          for (i = 0, ilen = metas.length; i < ilen; ++i) {
            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(me));
          }
          return me._cache.data = me.normalize(timestamps);
        }
        getLabelTimestamps() {
          const me = this;
          const timestamps = me._cache.labels || [];
          let i, ilen;
          if (timestamps.length) {
            return timestamps;
          }
          const labels = me.getLabels();
          for (i = 0, ilen = labels.length; i < ilen; ++i) {
            timestamps.push(parse(me, labels[i]));
          }
          return me._cache.labels = me._normalized ? timestamps : me.normalize(timestamps);
        }
        normalize(values) {
          return _arrayUnique(values.sort(sorter));
        }
      }
      TimeScale.id = "time";
      TimeScale.defaults = {
        bounds: "data",
        adapters: {},
        time: {
          parser: false,
          unit: false,
          round: false,
          isoWeekday: false,
          minUnit: "millisecond",
          displayFormats: {}
        },
        ticks: {
          source: "auto",
          major: {
            enabled: false
          }
        }
      };
      function interpolate(table, val, reverse) {
        let prevSource, nextSource, prevTarget, nextTarget;
        if (reverse) {
          prevSource = Math.floor(val);
          nextSource = Math.ceil(val);
          prevTarget = table[prevSource];
          nextTarget = table[nextSource];
        } else {
          const result = _lookup(table, val);
          prevTarget = result.lo;
          nextTarget = result.hi;
          prevSource = table[prevTarget];
          nextSource = table[nextTarget];
        }
        const span = nextSource - prevSource;
        return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
      }
      class TimeSeriesScale extends TimeScale {
        constructor(props) {
          super(props);
          this._table = [];
          this._maxIndex = void 0;
        }
        initOffsets() {
          const me = this;
          const timestamps = me._getTimestampsForTable();
          me._table = me.buildLookupTable(timestamps);
          me._maxIndex = me._table.length - 1;
          super.initOffsets(timestamps);
        }
        buildLookupTable(timestamps) {
          const me = this;
          const {min, max} = me;
          if (!timestamps.length) {
            return [
              {time: min, pos: 0},
              {time: max, pos: 1}
            ];
          }
          const items = [min];
          let i, ilen, curr;
          for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
            curr = timestamps[i];
            if (curr > min && curr < max) {
              items.push(curr);
            }
          }
          items.push(max);
          return items;
        }
        _getTimestampsForTable() {
          const me = this;
          let timestamps = me._cache.all || [];
          if (timestamps.length) {
            return timestamps;
          }
          const data = me.getDataTimestamps();
          const label = me.getLabelTimestamps();
          if (data.length && label.length) {
            timestamps = me.normalize(data.concat(label));
          } else {
            timestamps = data.length ? data : label;
          }
          timestamps = me._cache.all = timestamps;
          return timestamps;
        }
        getPixelForValue(value, index2) {
          const me = this;
          const offsets = me._offsets;
          const pos = me._normalized && me._maxIndex > 0 && !isNullOrUndef(index2) ? index2 / me._maxIndex : me.getDecimalForValue(value);
          return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);
        }
        getDecimalForValue(value) {
          return interpolate(this._table, value) / this._maxIndex;
        }
        getValueForPixel(pixel) {
          const me = this;
          const offsets = me._offsets;
          const decimal = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
          return interpolate(me._table, decimal * this._maxIndex, true);
        }
      }
      TimeSeriesScale.id = "timeseries";
      TimeSeriesScale.defaults = TimeScale.defaults;
      var scales = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        CategoryScale,
        LinearScale,
        LogarithmicScale,
        RadialLinearScale,
        TimeScale,
        TimeSeriesScale
      });
      Chart.register(controllers, scales, elements, plugins);
      Chart.helpers = {...helpers};
      Chart._adapters = _adapters;
      Chart.Animation = Animation;
      Chart.Animations = Animations;
      Chart.animator = animator;
      Chart.controllers = registry.controllers.items;
      Chart.DatasetController = DatasetController;
      Chart.Element = Element;
      Chart.elements = elements;
      Chart.Interaction = Interaction;
      Chart.layouts = layouts;
      Chart.platforms = platforms;
      Chart.Scale = Scale;
      Chart.Ticks = Ticks;
      Object.assign(Chart, controllers, scales, elements, plugins, platforms);
      Chart.Chart = Chart;
      if (typeof window !== "undefined") {
        window.Chart = Chart;
      }
      return Chart;
    });
  }
});

// node_modules/chart.js/auto/auto.js
var require_auto = __commonJS({
  "node_modules/chart.js/auto/auto.js"(exports2, module2) {
    module2.exports = require_chart();
  }
});

// .svelte-kit/vercel/entry.js
__markAsModule(exports);
__export(exports, {
  default: () => entry_default
});

// node_modules/@sveltejs/kit/dist/node.js
function getRawBody(req) {
  return new Promise((fulfil, reject) => {
    const h = req.headers;
    if (!h["content-type"]) {
      fulfil(null);
      return;
    }
    req.on("error", reject);
    const length = Number(h["content-length"]);
    let data;
    if (!isNaN(length)) {
      data = new Uint8Array(length);
      let i = 0;
      req.on("data", (chunk) => {
        data.set(chunk, i);
        i += chunk.length;
      });
    } else {
      if (h["transfer-encoding"] === void 0) {
        fulfil(null);
        return;
      }
      data = new Uint8Array(0);
      req.on("data", (chunk) => {
        const new_data = new Uint8Array(data.length + chunk.length);
        new_data.set(data);
        new_data.set(chunk, data.length);
        data = new_data;
      });
    }
    req.on("end", () => {
      const [type] = h["content-type"].split(/;\s*/);
      if (type === "application/octet-stream") {
        fulfil(data);
      }
      const decoder = new TextDecoder(h["content-encoding"] || "utf-8");
      fulfil(decoder.decode(data));
    });
  });
}

// node_modules/@sveltejs/kit/dist/install-fetch.js
var import_http = __toModule(require("http"));
var import_https = __toModule(require("https"));
var import_zlib = __toModule(require("zlib"));
var import_stream = __toModule(require("stream"));
var import_util = __toModule(require("util"));
var import_crypto = __toModule(require("crypto"));
var import_url = __toModule(require("url"));
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta2 = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta2[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta2.length; i++) {
    if (meta2[i] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta2[i]}`;
      if (meta2[i].indexOf("charset=") === 0) {
        charset = meta2[i].substring(8);
      }
    }
  }
  if (!meta2[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
var src = dataUriToBuffer;
var {Readable} = import_stream.default;
var wm = new WeakMap();
async function* read(parts) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else {
      yield part;
    }
  }
}
var Blob = class {
  constructor(blobParts = [], options2 = {}) {
    let size = 0;
    const parts = blobParts.map((element) => {
      let buffer;
      if (element instanceof Buffer) {
        buffer = element;
      } else if (ArrayBuffer.isView(element)) {
        buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
      } else if (element instanceof ArrayBuffer) {
        buffer = Buffer.from(element);
      } else if (element instanceof Blob) {
        buffer = element;
      } else {
        buffer = Buffer.from(typeof element === "string" ? element : String(element));
      }
      size += buffer.length || buffer.size || 0;
      return buffer;
    });
    const type = options2.type === void 0 ? "" : String(options2.type).toLowerCase();
    wm.set(this, {
      type: /[^\u0020-\u007E]/.test(type) ? "" : type,
      size,
      parts
    });
  }
  get size() {
    return wm.get(this).size;
  }
  get type() {
    return wm.get(this).type;
  }
  async text() {
    return Buffer.from(await this.arrayBuffer()).toString();
  }
  async arrayBuffer() {
    const data = new Uint8Array(this.size);
    let offset = 0;
    for await (const chunk of this.stream()) {
      data.set(chunk, offset);
      offset += chunk.length;
    }
    return data.buffer;
  }
  stream() {
    return Readable.from(read(wm.get(this).parts));
  }
  slice(start = 0, end = this.size, type = "") {
    const {size} = this;
    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
    const span = Math.max(relativeEnd - relativeStart, 0);
    const parts = wm.get(this).parts.values();
    const blobParts = [];
    let added = 0;
    for (const part of parts) {
      const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
      if (relativeStart && size2 <= relativeStart) {
        relativeStart -= size2;
        relativeEnd -= size2;
      } else {
        const chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
        blobParts.push(chunk);
        added += ArrayBuffer.isView(chunk) ? chunk.byteLength : chunk.size;
        relativeStart = 0;
        if (added >= span) {
          break;
        }
      }
    }
    const blob = new Blob([], {type: String(type).toLowerCase()});
    Object.assign(wm.get(blob), {size: span, parts: blobParts});
    return blob;
  }
  get [Symbol.toStringTag]() {
    return "Blob";
  }
  static [Symbol.hasInstance](object) {
    return object && typeof object === "object" && typeof object.stream === "function" && object.stream.length === 0 && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
  }
};
Object.defineProperties(Blob.prototype, {
  size: {enumerable: true},
  type: {enumerable: true},
  slice: {enumerable: true}
});
var fetchBlob = Blob;
var FetchBaseError = class extends Error {
  constructor(message, type) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};
var FetchError = class extends FetchBaseError {
  constructor(message, type, systemError) {
    super(message, type);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
};
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
var isBlob = (object) => {
  return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
var isAbortSignal = (object) => {
  return typeof object === "object" && object[NAME] === "AbortSignal";
};
var carriage = "\r\n";
var dashes = "-".repeat(2);
var carriageLength = Buffer.byteLength(carriage);
var getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
function getHeader(boundary, name2, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name2}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
var getBoundary = () => (0, import_crypto.randomBytes)(8).toString("hex");
async function* formDataIterator(form, boundary) {
  for (const [name2, value] of form) {
    yield getHeader(boundary, name2, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name2, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name2, value));
    if (isBlob(value)) {
      length += value.size;
    } else {
      length += Buffer.byteLength(String(value));
    }
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
var INTERNALS$2 = Symbol("Body internals");
var Body = class {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      body = null;
    } else if (isURLSearchParameters(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (import_util.types.isAnyArrayBuffer(body)) {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_stream.default)
      ;
    else if (isFormData(body)) {
      boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
      body = import_stream.default.Readable.from(formDataIterator(body, boundary));
    } else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS$2] = {
      body,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof import_stream.default) {
      body.on("error", (err) => {
        const error3 = err instanceof FetchBaseError ? err : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, "system", err);
        this[INTERNALS$2].error = error3;
      });
    }
  }
  get body() {
    return this[INTERNALS$2].body;
  }
  get bodyUsed() {
    return this[INTERNALS$2].disturbed;
  }
  async arrayBuffer() {
    const {buffer, byteOffset, byteLength} = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async blob() {
    const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
    const buf = await this.buffer();
    return new fetchBlob([buf], {
      type: ct
    });
  }
  async json() {
    const buffer = await consumeBody(this);
    return JSON.parse(buffer.toString());
  }
  async text() {
    const buffer = await consumeBody(this);
    return buffer.toString();
  }
  buffer() {
    return consumeBody(this);
  }
};
Object.defineProperties(Body.prototype, {
  body: {enumerable: true},
  bodyUsed: {enumerable: true},
  arrayBuffer: {enumerable: true},
  blob: {enumerable: true},
  json: {enumerable: true},
  text: {enumerable: true}
});
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let {body} = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof import_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const err = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(err);
        throw err;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error3) {
    if (error3 instanceof FetchBaseError) {
      throw error3;
    } else {
      throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error3.message}`, "system", error3);
    }
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error3) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error3.message}`, "system", error3);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
var clone = (instance, highWaterMark) => {
  let p1;
  let p2;
  let {body} = instance;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
    p1 = new import_stream.PassThrough({highWaterMark});
    p2 = new import_stream.PassThrough({highWaterMark});
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS$2].body = p1;
    body = p2;
  }
  return body;
};
var extractContentType = (body, request) => {
  if (body === null) {
    return null;
  }
  if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  }
  if (isURLSearchParameters(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  if (isBlob(body)) {
    return body.type || null;
  }
  if (Buffer.isBuffer(body) || import_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body && typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  }
  if (isFormData(body)) {
    return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
  }
  if (body instanceof import_stream.default) {
    return null;
  }
  return "text/plain;charset=UTF-8";
};
var getTotalBytes = (request) => {
  const {body} = request;
  if (body === null) {
    return 0;
  }
  if (isBlob(body)) {
    return body.size;
  }
  if (Buffer.isBuffer(body)) {
    return body.length;
  }
  if (body && typeof body.getLengthSync === "function") {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }
  if (isFormData(body)) {
    return getFormDataLength(request[INTERNALS$2].boundary);
  }
  return null;
};
var writeToStream = (dest, {body}) => {
  if (body === null) {
    dest.end();
  } else if (isBlob(body)) {
    body.stream().pipe(dest);
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
};
var validateHeaderName = typeof import_http.default.validateHeaderName === "function" ? import_http.default.validateHeaderName : (name2) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name2)) {
    const err = new TypeError(`Header name must be a valid HTTP token [${name2}]`);
    Object.defineProperty(err, "code", {value: "ERR_INVALID_HTTP_TOKEN"});
    throw err;
  }
};
var validateHeaderValue = typeof import_http.default.validateHeaderValue === "function" ? import_http.default.validateHeaderValue : (name2, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    const err = new TypeError(`Invalid character in header content ["${name2}"]`);
    Object.defineProperty(err, "code", {value: "ERR_INVALID_CHAR"});
    throw err;
  }
};
var Headers = class extends URLSearchParams {
  constructor(init2) {
    let result = [];
    if (init2 instanceof Headers) {
      const raw = init2.raw();
      for (const [name2, values] of Object.entries(raw)) {
        result.push(...values.map((value) => [name2, value]));
      }
    } else if (init2 == null)
      ;
    else if (typeof init2 === "object" && !import_util.types.isBoxedPrimitive(init2)) {
      const method = init2[Symbol.iterator];
      if (method == null) {
        result.push(...Object.entries(init2));
      } else {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        result = [...init2].map((pair2) => {
          if (typeof pair2 !== "object" || import_util.types.isBoxedPrimitive(pair2)) {
            throw new TypeError("Each header pair must be an iterable object");
          }
          return [...pair2];
        }).map((pair2) => {
          if (pair2.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          return [...pair2];
        });
      }
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result = result.length > 0 ? result.map(([name2, value]) => {
      validateHeaderName(name2);
      validateHeaderValue(name2, String(value));
      return [String(name2).toLowerCase(), String(value)];
    }) : void 0;
    super(result);
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name2, value) => {
              validateHeaderName(name2);
              validateHeaderValue(name2, String(value));
              return URLSearchParams.prototype[p].call(receiver, String(name2).toLowerCase(), String(value));
            };
          case "delete":
          case "has":
          case "getAll":
            return (name2) => {
              validateHeaderName(name2);
              return URLSearchParams.prototype[p].call(receiver, String(name2).toLowerCase());
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name2) {
    const values = this.getAll(name2);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(", ");
    if (/^content-encoding$/i.test(name2)) {
      value = value.toLowerCase();
    }
    return value;
  }
  forEach(callback) {
    for (const name2 of this.keys()) {
      callback(this.get(name2), name2);
    }
  }
  *values() {
    for (const name2 of this.keys()) {
      yield this.get(name2);
    }
  }
  *entries() {
    for (const name2 of this.keys()) {
      yield [name2, this.get(name2)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  raw() {
    return [...this.keys()].reduce((result, key) => {
      result[key] = this.getAll(key);
      return result;
    }, {});
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result, key) => {
      const values = this.getAll(key);
      if (key === "host") {
        result[key] = values[0];
      } else {
        result[key] = values.length > 1 ? values : values[0];
      }
      return result;
    }, {});
  }
};
Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
  result[property] = {enumerable: true};
  return result;
}, {}));
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index2, array) => {
    if (index2 % 2 === 0) {
      result.push(array.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name2, value]) => {
    try {
      validateHeaderName(name2);
      validateHeaderValue(name2, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
var redirectStatus = new Set([301, 302, 303, 307, 308]);
var isRedirect = (code) => {
  return redirectStatus.has(code);
};
var INTERNALS$1 = Symbol("Response internals");
var Response2 = class extends Body {
  constructor(body = null, options2 = {}) {
    super(body, options2);
    const status = options2.status || 200;
    const headers = new Headers(options2.headers);
    if (body !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS$1] = {
      url: options2.url,
      status,
      statusText: options2.statusText || "",
      headers,
      counter: options2.counter,
      highWaterMark: options2.highWaterMark
    };
  }
  get url() {
    return this[INTERNALS$1].url || "";
  }
  get status() {
    return this[INTERNALS$1].status;
  }
  get ok() {
    return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
  }
  get redirected() {
    return this[INTERNALS$1].counter > 0;
  }
  get statusText() {
    return this[INTERNALS$1].statusText;
  }
  get headers() {
    return this[INTERNALS$1].headers;
  }
  get highWaterMark() {
    return this[INTERNALS$1].highWaterMark;
  }
  clone() {
    return new Response2(clone(this, this.highWaterMark), {
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size
    });
  }
  static redirect(url, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new Response2(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response2.prototype, {
  url: {enumerable: true},
  status: {enumerable: true},
  ok: {enumerable: true},
  redirected: {enumerable: true},
  statusText: {enumerable: true},
  headers: {enumerable: true},
  clone: {enumerable: true}
});
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
};
var INTERNALS = Symbol("Request internals");
var isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS] === "object";
};
var Request = class extends Body {
  constructor(input, init2 = {}) {
    let parsedURL;
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    let method = init2.method || input.method || "GET";
    method = method.toUpperCase();
    if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
    super(inputBody, {
      size: init2.size || input.size || 0
    });
    const headers = new Headers(init2.headers || input.headers || {});
    if (inputBody !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init2) {
      signal = init2.signal;
    }
    if (signal !== null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal");
    }
    this[INTERNALS] = {
      method,
      redirect: init2.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal
    };
    this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
    this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
    this.counter = init2.counter || input.counter || 0;
    this.agent = init2.agent || input.agent;
    this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
  }
  get method() {
    return this[INTERNALS].method;
  }
  get url() {
    return (0, import_url.format)(this[INTERNALS].parsedURL);
  }
  get headers() {
    return this[INTERNALS].headers;
  }
  get redirect() {
    return this[INTERNALS].redirect;
  }
  get signal() {
    return this[INTERNALS].signal;
  }
  clone() {
    return new Request(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request.prototype, {
  method: {enumerable: true},
  url: {enumerable: true},
  headers: {enumerable: true},
  redirect: {enumerable: true},
  clone: {enumerable: true},
  signal: {enumerable: true}
});
var getNodeRequestOptions = (request) => {
  const {parsedURL} = request[INTERNALS];
  const headers = new Headers(request[INTERNALS].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate,br");
  }
  let {agent} = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  if (!headers.has("Connection") && !agent) {
    headers.set("Connection", "close");
  }
  const search = getSearch(parsedURL);
  const requestOptions = {
    path: parsedURL.pathname + search,
    pathname: parsedURL.pathname,
    hostname: parsedURL.hostname,
    protocol: parsedURL.protocol,
    port: parsedURL.port,
    hash: parsedURL.hash,
    search: parsedURL.search,
    query: parsedURL.query,
    href: parsedURL.href,
    method: request.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return requestOptions;
};
var AbortError = class extends FetchBaseError {
  constructor(message, type = "aborted") {
    super(message, type);
  }
};
var supportedSchemas = new Set(["data:", "http:", "https:"]);
async function fetch2(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data = src(request.url);
      const response2 = new Response2(data, {headers: {"Content-Type": data.typeFull}});
      resolve2(response2);
      return;
    }
    const send = (options2.protocol === "https:" ? import_https.default : import_http.default).request;
    const {signal} = request;
    let response = null;
    const abort = () => {
      const error3 = new AbortError("The operation was aborted.");
      reject(error3);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error3);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error3);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (err) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (error3) {
                reject(error3);
              }
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve2(fetch2(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
        }
      }
      response_.once("end", () => {
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      });
      let body = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error3) => {
        reject(error3);
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), (error3) => {
          reject(error3);
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error3) => {
          reject(error3);
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflate(), (error3) => {
              reject(error3);
            });
          } else {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflateRaw(), (error3) => {
              reject(error3);
            });
          }
          response = new Response2(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createBrotliDecompress(), (error3) => {
          reject(error3);
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
globalThis.fetch = fetch2;
globalThis.Response = Response2;
globalThis.Request = Request;
globalThis.Headers = Headers;

// node_modules/@sveltejs/kit/dist/ssr.js
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped$1 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name2, thing) {
      params_1.push(name2);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name2 + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name2 + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name2 + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name2 + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name2 = "";
  do {
    name2 = chars[num % chars.length] + name2;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name2) ? name2 + "_" : name2;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = [];
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (let i = 0; i < subscribers.length; i += 1) {
          const s2 = subscribers[i];
          s2[1]();
          subscriber_queue.push(s2, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.push(subscriber);
    if (subscribers.length === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      const index2 = subscribers.indexOf(subscriber);
      if (index2 !== -1) {
        subscribers.splice(index2, 1);
      }
      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }
  return {set, update, subscribe};
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
var s$1 = JSON.stringify;
async function render_response({
  options: options2,
  $session,
  page_config,
  status,
  error: error3,
  branch,
  page
}) {
  const css2 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error3) {
    error3.stack = options2.get_stack(error3);
  }
  if (branch) {
    branch.forEach(({node, loaded, fetched, uses_credentials}) => {
      if (node.css)
        node.css.forEach((url) => css2.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content2) => styles.add(content2));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session
      },
      page,
      components: branch.map(({node}) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = {head: "", html: "", css: {code: "", map: null}};
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"></script>`;
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error4) => {
      throw new Error(`Failed to serialize session data: ${error4.message}`);
    })},
				host: ${page && page.host ? s$1(page.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error3)},
					nodes: [
						${branch.map(({node}) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page.host ? s$1(page.host) : "location.host"}, // TODO this is redundant
						path: ${s$1(page.path)},
						query: new URLSearchParams(${s$1(page.query.toString())}),
						params: ${s$1(page.params)}
					}
				}` : "null"}
			});
		</script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({url, body: body2, json}) => {
    return body2 ? `<script type="svelte-data" url="${url}" body="${hash(body2)}">${json}</script>` : `<script type="svelte-data" url="${url}">${json}</script>`;
  }).join("\n\n			")}
		`.replace(/^\t{2}/gm, "");
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({head, body})
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(err);
    return null;
  }
}
function serialize_error(error3) {
  if (!error3)
    return null;
  let serialized = try_serialize(error3);
  if (!serialized) {
    const {name: name2, message, stack} = error3;
    serialized = try_serialize({name: name2, message, stack});
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  if (loaded.error) {
    const error3 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    const status = loaded.status;
    if (!(error3 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error3}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return {status: 500, error: error3};
    }
    return {status, error: error3};
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  return loaded;
}
function resolve(base2, path) {
  const baseparts = path[0] === "/" ? [] : base2.slice(1).split("/");
  const pathparts = path[0] === "/" ? path.slice(1).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  return `/${baseparts.join("/")}`;
}
var s = JSON.stringify;
async function load_node({
  request,
  options: options2,
  state,
  route,
  page,
  node,
  $session,
  context,
  is_leaf,
  is_error,
  status,
  error: error3
}) {
  const {module: module2} = node;
  let uses_credentials = false;
  const fetched = [];
  let loaded;
  if (module2.load) {
    const load_input = {
      page,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        if (options2.read && url.startsWith(options2.paths.assets)) {
          url = url.replace(options2.paths.assets, "");
        }
        if (url.startsWith("//")) {
          throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
        }
        let response;
        if (/^[a-zA-Z]+:/.test(url)) {
          response = await fetch(url, opts);
        } else {
          const [path, search] = url.split("?");
          const resolved = resolve(request.path, path);
          const filename = resolved.slice(1);
          const filename_html = `${filename}/index.html`;
          const asset = options2.manifest.assets.find((d) => d.file === filename || d.file === filename_html);
          if (asset) {
            if (options2.read) {
              response = new Response(options2.read(asset.file), {
                headers: {
                  "content-type": asset.type
                }
              });
            } else {
              response = await fetch(`http://${page.host}/${asset.file}`, opts);
            }
          }
          if (!response) {
            const headers = {...opts.headers};
            if (opts.credentials !== "omit") {
              uses_credentials = true;
              headers.cookie = request.headers.cookie;
              if (!headers.authorization) {
                headers.authorization = request.headers.authorization;
              }
            }
            if (opts.body && typeof opts.body !== "string") {
              throw new Error("Request body must be a string");
            }
            const rendered = await respond({
              host: request.host,
              method: opts.method || "GET",
              headers,
              path: resolved,
              rawBody: opts.body,
              query: new URLSearchParams(search)
            }, options2, {
              fetched: url,
              initiator: route
            });
            if (rendered) {
              if (state.prerender) {
                state.prerender.dependencies.set(resolved, rendered);
              }
              response = new Response(rendered.body, {
                status: rendered.status,
                headers: rendered.headers
              });
            }
          }
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 !== "etag" && key2 !== "set-cookie")
                    headers[key2] = value;
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":${escape(body)}}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      context: {...context}
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error3;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  return {
    node,
    loaded: normalize(loaded),
    context: loaded.context || context,
    fetched,
    uses_credentials
  };
}
var escaped = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escape(str) {
  let result = '"';
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += `\\u${code.toString(16).toUpperCase()}`;
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
async function respond_with_error({request, options: options2, state, $session, status, error: error3}) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page,
    node: default_layout,
    $session,
    context: {},
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page,
      node: default_error,
      $session,
      context: loaded.context,
      is_leaf: false,
      is_error: true,
      status,
      error: error3
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error3,
      branch,
      page
    });
  } catch (error4) {
    options2.handle_error(error4);
    return {
      status: 500,
      headers: {},
      body: error4.stack
    };
  }
}
async function respond$1({request, options: options2, state, $session, route}) {
  const match = route.pattern.exec(request.path);
  const params = route.params(match);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id && options2.load_component(id)));
  } catch (error4) {
    options2.handle_error(error4);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error4
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  const page_config = {
    ssr: "ssr" in leaf ? leaf.ssr : options2.ssr,
    router: "router" in leaf ? leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? leaf.hydrate : options2.hydrate
  };
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {},
      body: null
    };
  }
  let branch;
  let status = 200;
  let error3;
  ssr:
    if (page_config.ssr) {
      let context = {};
      branch = [];
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              request,
              options: options2,
              state,
              route,
              page,
              node,
              $session,
              context,
              is_leaf: i === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            if (loaded.loaded.redirect) {
              return {
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              };
            }
            if (loaded.loaded.error) {
              ({status, error: error3} = loaded.loaded);
            }
          } catch (e) {
            options2.handle_error(e);
            status = 500;
            error3 = e;
          }
          if (error3) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let error_loaded;
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  error_loaded = await load_node({
                    request,
                    options: options2,
                    state,
                    route,
                    page,
                    node: error_node,
                    $session,
                    context: node_loaded.context,
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error3
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (e) {
                  options2.handle_error(e);
                  continue;
                }
              }
            }
            return await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error3
            });
          }
        }
        branch.push(loaded);
        if (loaded && loaded.loaded.context) {
          context = {
            ...context,
            ...loaded.loaded.context
          };
        }
      }
    }
  try {
    return await render_response({
      options: options2,
      $session,
      page_config,
      status,
      error: error3,
      branch: branch && branch.filter(Boolean),
      page
    });
  } catch (error4) {
    options2.handle_error(error4);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error4
    });
  }
}
async function render_page(request, route, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const $session = await options2.hooks.getSession(request);
  if (route) {
    const response = await respond$1({
      request,
      options: options2,
      state,
      $session,
      route
    });
    if (response) {
      return response;
    }
    if (state.fetched) {
      return {
        status: 500,
        headers: {},
        body: `Bad request in load function: failed to fetch ${state.fetched}`
      };
    }
  } else {
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 404,
      error: new Error(`Not found: ${request.path}`)
    });
  }
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
async function render_route(request, route) {
  const mod = await route.load();
  const handler = mod[request.method.toLowerCase().replace("delete", "del")];
  if (handler) {
    const match = route.pattern.exec(request.path);
    const params = route.params(match);
    const response = await handler({...request, params});
    if (response) {
      if (typeof response !== "object") {
        return error(`Invalid response from route ${request.path}: expected an object, got ${typeof response}`);
      }
      let {status = 200, body, headers = {}} = response;
      headers = lowercase_keys(headers);
      const type = headers["content-type"];
      if (type === "application/octet-stream" && !(body instanceof Uint8Array)) {
        return error(`Invalid response from route ${request.path}: body must be an instance of Uint8Array if content type is application/octet-stream`);
      }
      if (body instanceof Uint8Array && type !== "application/octet-stream") {
        return error(`Invalid response from route ${request.path}: Uint8Array body must be accompanied by content-type: application/octet-stream header`);
      }
      let normalized_body;
      if (typeof body === "object" && (!type || type === "application/json")) {
        headers = {...headers, "content-type": "application/json"};
        normalized_body = JSON.stringify(body);
      } else {
        normalized_body = body;
      }
      return {status, body: normalized_body, headers};
    }
  }
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        map.get(key).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
var ReadOnlyFormData = class {
  #map;
  constructor(map) {
    this.#map = map;
  }
  get(key) {
    const value = this.#map.get(key);
    return value && value[0];
  }
  getAll(key) {
    return this.#map.get(key);
  }
  has(key) {
    return this.#map.has(key);
  }
  *[Symbol.iterator]() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *entries() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *keys() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield key;
      }
    }
  }
  *values() {
    for (const [, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield value;
      }
    }
  }
};
function parse_body(req) {
  const raw = req.rawBody;
  if (!raw)
    return raw;
  const [type, ...directives] = req.headers["content-type"].split(/;\s*/);
  if (typeof raw === "string") {
    switch (type) {
      case "text/plain":
        return raw;
      case "application/json":
        return JSON.parse(raw);
      case "application/x-www-form-urlencoded":
        return get_urlencoded(raw);
      case "multipart/form-data": {
        const boundary = directives.find((directive) => directive.startsWith("boundary="));
        if (!boundary)
          throw new Error("Missing boundary");
        return get_multipart(raw, boundary.slice("boundary=".length));
      }
      default:
        throw new Error(`Invalid Content-Type ${type}`);
    }
  }
  return raw;
}
function get_urlencoded(text) {
  const {data, append} = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  const nope = () => {
    throw new Error("Malformed form data");
  };
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    nope();
  }
  const {data, append} = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name2, value] = raw_header.split(": ");
      name2 = name2.toLowerCase();
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name3, value2] = raw_directive.split("=");
        directives[name3] = JSON.parse(value2);
      });
      if (name2 === "content-disposition") {
        if (value !== "form-data")
          nope();
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      nope();
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !incoming.path.split("/").pop().includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: encodeURI(path + (q ? `?${q}` : ""))
        }
      };
    }
  }
  try {
    return await options2.hooks.handle({
      request: {
        ...incoming,
        headers: lowercase_keys(incoming.headers),
        body: parse_body(incoming),
        params: null,
        locals: {}
      },
      render: async (request) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request),
            page_config: {ssr: false, router: true, hydrate: true},
            status: 200,
            error: null,
            branch: [],
            page: null
          });
        }
        for (const route of options2.manifest.routes) {
          if (!route.pattern.test(request.path))
            continue;
          const response = route.type === "endpoint" ? await render_route(request, route) : await render_page(request, route, options2, state);
          if (response) {
            if (response.status === 200) {
              if (!/(no-store|immutable)/.test(response.headers["cache-control"])) {
                const etag = `"${hash(response.body)}"`;
                if (request.headers["if-none-match"] === etag) {
                  return {
                    status: 304,
                    headers: {},
                    body: null
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        return await render_page(request, null, options2, state);
      }
    });
  } catch (e) {
    options2.handle_error(e);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}

// node_modules/svelte/internal/index.mjs
function noop2() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
var tasks = new Set();
function custom_event(type, detail) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, false, false, detail);
  return e;
}
var active_docs = new Set();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail);
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
    }
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
var resolved_promise = Promise.resolve();
var seen_callbacks = new Set();
var outroing = new Set();
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
var escaped2 = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escape2(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped2[match]);
}
function each(items, fn) {
  let str = "";
  for (let i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }
  return str;
}
var missing_component = {
  $$render: () => ""
};
function validate_component(component, name2) {
  if (!component || !component.$$render) {
    if (name2 === "svelte:component")
      name2 += " this={...}";
    throw new Error(`<${name2}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(parent_component ? parent_component.$$.context : context || []),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({$$});
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, {$$slots = {}, context = new Map()} = {}) => {
      on_destroy = [];
      const result = {title: "", head: "", css: new Set()};
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name2, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name2}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape2(value)) : `"${value}"`}`}`;
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({mode: "open"});
    }
    connectedCallback() {
      const {on_mount} = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr, _oldValue, newValue) {
      this[attr] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop2;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index2 = callbacks.indexOf(callback);
        if (index2 !== -1)
          callbacks.splice(index2, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}

// .svelte-kit/output/server/app.js
var import_dotenv = __toModule(require_main());
var import_mongodb = __toModule(require_mongodb());
var import_auto = __toModule(require_auto());

// node_modules/@codemirror/text/dist/index.js
var extend = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s2) => s2 ? parseInt(s2, 36) : 1);
for (let i = 1; i < extend.length; i++)
  extend[i] += extend[i - 1];
function isExtendingChar(code) {
  for (let i = 1; i < extend.length; i += 2)
    if (extend[i] > code)
      return extend[i - 1] <= code;
  return false;
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
var ZWJ = 8205;
function findClusterBreak(str, pos, forward = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos);
}
function nextClusterBreak(str, pos) {
  if (pos == str.length)
    return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
    pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i = pos - 2;
      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
        countBefore++;
        i -= 2;
      }
      if (countBefore % 2 == 0)
        break;
      else
        pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2);
    if (found < pos)
      return found;
    pos--;
  }
  return 0;
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code) {
  if (code <= 65535)
    return String.fromCharCode(code);
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}
function countColumn(string2, n, tabSize) {
  for (let i = 0; i < string2.length; ) {
    if (string2.charCodeAt(i) == 9) {
      n += tabSize - n % tabSize;
      i++;
    } else {
      n++;
      i = findClusterBreak(string2, i);
    }
  }
  return n;
}
function findColumn(string2, n, col, tabSize) {
  for (let i = 0; i < string2.length; ) {
    if (n >= col)
      return {offset: i, leftOver: 0};
    n += string2.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
    i = findClusterBreak(string2, i);
  }
  return {offset: string2.length, leftOver: col - n};
}
var Text = class {
  constructor() {
  }
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  line(n) {
    if (n < 1 || n > this.lines)
      throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
    return this.lineInner(n, true, 1, 0);
  }
  replace(from, to, text) {
    let parts = [];
    this.decompose(0, from, parts, 2);
    if (text.length)
      text.decompose(0, text.length, parts, 1 | 2);
    this.decompose(to, this.length, parts, 1);
    return TextNode.from(parts, this.length - (to - from) + text.length);
  }
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  slice(from, to = this.length) {
    let parts = [];
    this.decompose(from, to, parts, 0);
    return TextNode.from(parts, to - from);
  }
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let a = new RawTextCursor(this), b = new RawTextCursor(other);
    for (; ; ) {
      a.next();
      b.next();
      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
        return false;
      if (a.done)
        return true;
    }
  }
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  iterRange(from, to = this.length) {
    return new PartialTextCursor(this, from, to);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  static of(text) {
    if (text.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text.length == 1 && !text[0])
      return Text.empty;
    return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
  }
};
if (typeof Symbol != "undefined")
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
var TextLeaf = class extends Text {
  constructor(text, length = textLength(text)) {
    super();
    this.text = text;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let string2 = this.text[i], end = offset + string2.length;
      if ((isLine ? line : end) >= target)
        return new Line(offset, end, line, string2);
      offset = end + 1;
      line++;
    }
  }
  decompose(from, to, target, open) {
    let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target.pop();
      let joined = appendText(text.text, prev.text.slice(), 0, text.length);
      if (joined.length <= 32) {
        target.push(new TextLeaf(joined, prev.length + text.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text);
    }
  }
  replace(from, to, text) {
    if (!(text instanceof TextLeaf))
      return super.replace(from, to, text);
    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
    let newLen = this.length + text.length - (to - from);
    if (lines.length <= 32)
      return new TextLeaf(lines, newLen);
    return TextNode.from(TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    let result = "";
    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
      let line = this.text[i], end = pos + line.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += line.slice(Math.max(0, from - pos), to - pos);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let line of this.text)
      target.push(line);
  }
  static split(text, target) {
    let part = [], len = -1;
    for (let line of text) {
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target.push(new TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target.push(new TextLeaf(part, len));
    return target;
  }
};
var TextNode = class extends Text {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;
    for (let child of children)
      this.lines += child.lines;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target)
        return child.lineInner(target, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to, target, open) {
    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (from <= end && to >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
        if (pos >= from && end <= to && !childOpen)
          target.push(child);
        else
          child.decompose(from - pos, to - pos, target, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to, text) {
    if (text.lines < this.lines)
      for (let i = 0, pos = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from >= pos && to <= end) {
          let updated = child.replace(from - pos, to - pos, text);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy = this.children.slice();
            copy[i] = updated;
            return new TextNode(copy, this.length - (to - from) + text.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
    return super.replace(from, to, text);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    let result = "";
    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
      let child = this.children[i], end = pos + child.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += child.sliceString(from - pos, to - pos, lineSep);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let child of this.children)
      child.flatten(target);
  }
  static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
    let lines = 0;
    for (let ch of children)
      lines += ch.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch of children)
        ch.flatten(flat);
      return new TextLeaf(flat, length);
    }
    let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add2(child) {
      let last;
      if (child.lines > maxChunk && child instanceof TextNode) {
        for (let node of child.children)
          add2(node);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children)
      add2(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
  }
};
Text.empty = new TextLeaf([""], 0);
function textLength(text) {
  let length = -1;
  for (let line of text)
    length += line.length + 1;
  return length;
}
function appendText(text, target, from = 0, to = 1e9) {
  for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
    let line = text[i], end = pos + line.length;
    if (end >= from) {
      if (end > to)
        line = line.slice(0, to - pos);
      if (pos < from)
        line = line.slice(from - pos);
      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else
        target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text, from, to) {
  return appendText(text, [""], from, to);
}
var RawTextCursor = class {
  constructor(text, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text];
    this.offsets = [dir > 0 ? 0 : text instanceof TextLeaf ? text.text.length : text.children.length];
  }
  next(skip = 0) {
    for (; ; ) {
      let last = this.nodes.length - 1;
      if (last < 0) {
        this.done = true;
        this.value = "";
        this.lineBreak = false;
        return this;
      }
      let top2 = this.nodes[last], offset = this.offsets[last];
      let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset == (this.dir > 0 ? size : 0)) {
        this.nodes.pop();
        this.offsets.pop();
      } else if (!this.lineBreak && offset != (this.dir > 0 ? 0 : size)) {
        this.lineBreak = true;
        if (skip == 0) {
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset - (this.dir < 0 ? 1 : 0)];
        this.offsets[last] = offset += this.dir;
        this.lineBreak = false;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : this.dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top2.children[this.dir > 0 ? offset : offset - 1];
        this.offsets[last] = offset + this.dir;
        this.lineBreak = false;
        if (skip > next.length) {
          skip -= next.length;
        } else {
          this.nodes.push(next);
          this.offsets.push(this.dir > 0 ? 0 : next instanceof TextLeaf ? next.text.length : next.children.length);
        }
      }
    }
  }
};
var PartialTextCursor = class {
  constructor(text, start, end) {
    this.value = "";
    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
    if (start > end) {
      this.skip = text.length - start;
      this.limit = start - end;
    } else {
      this.skip = start;
      this.limit = end - start;
    }
  }
  next(skip = 0) {
    if (this.limit <= 0) {
      this.limit = -1;
    } else {
      let {value, lineBreak, done} = this.cursor.next(this.skip + skip);
      this.skip = 0;
      this.value = value;
      let len = lineBreak ? 1 : value.length;
      if (len > this.limit)
        this.value = this.cursor.dir > 0 ? value.slice(0, this.limit) : value.slice(len - this.limit);
      if (done || this.value.length == 0)
        this.limit = -1;
      else
        this.limit -= this.value.length;
    }
    return this;
  }
  get lineBreak() {
    return this.cursor.lineBreak;
  }
  get done() {
    return this.limit < 0;
  }
};
var Line = class {
  constructor(from, to, number2, text) {
    this.from = from;
    this.to = to;
    this.number = number2;
    this.text = text;
  }
  get length() {
    return this.to - this.from;
  }
};

// node_modules/@codemirror/state/dist/index.js
var DefaultSplit = /\r\n?|\n/;
var MapMode = /* @__PURE__ */ function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
var ChangeDesc = class {
  constructor(sections) {
    this.sections = sections;
  }
  get length() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2)
      result += this.sections[i];
    return result;
  }
  get newLength() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2) {
      let ins = this.sections[i + 1];
      result += ins < 0 ? this.sections[i] : ins;
    }
    return result;
  }
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  iterGaps(f) {
    for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  get invertedDesc() {
    let sections = [];
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new ChangeDesc(sections);
  }
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  touchesRange(from, to = from) {
    for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
      let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
      if (ins >= 0 && pos <= to && end >= from)
        return pos < from && end > to ? "cover" : true;
      pos = end;
    }
    return false;
  }
  toString() {
    let result = "";
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(json) {
    if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ChangeDesc(json);
  }
};
var ChangeSet = class extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
    return doc2;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i = 0, pos = 0; i < sections.length; i += 2) {
      let len = sections[i], ins = sections[i + 1];
      if (ins >= 0) {
        sections[i] = ins;
        sections[i + 1] = len;
        let index2 = i >> 1;
        while (inserted.length < index2)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new ChangeSet(sections, inserted);
  }
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  iterChanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  get desc() {
    return new ChangeDesc(this.sections);
  }
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done:
      for (let i = 0, pos = 0; ; ) {
        let next = i == ranges.length ? 1e9 : ranges[i++];
        while (pos < next || pos == next && iter.len == 0) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, next - pos);
          addSection(filteredSections, len, -1);
          let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
          addSection(resultSections, len, ins);
          if (ins > 0)
            addInsert(resultInserted, resultSections, iter.text);
          iter.forward(len);
          pos += len;
        }
        let end = ranges[i++];
        while (pos < end) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, end - pos);
          addSection(resultSections, len, -1);
          addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
          iter.forward(len);
          pos += len;
        }
      }
    return {
      changes: new ChangeSet(resultSections, resultInserted),
      filtered: new ChangeDesc(filteredSections)
    };
  }
  toJSON() {
    let parts = [];
    for (let i = 0; i < this.sections.length; i += 2) {
      let len = this.sections[i], ins = this.sections[i + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i >> 1].toJSON()));
    }
    return parts;
  }
  static of(changes, length, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length)
        addSection(sections, length - pos, -1);
      let set = new ChangeSet(sections, inserted);
      total = total ? total.compose(set.map(total)) : set;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec)
          process2(sub);
      } else if (spec instanceof ChangeSet) {
        if (spec.length != length)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let {from, to = from, insert: insert2} = spec;
        if (from > to || from < 0 || to > length)
          throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from == to && insLen == 0)
          return;
        if (from < pos)
          flush();
        if (from > pos)
          addSection(sections, from - pos, -1);
        addSection(sections, to - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  static empty(length) {
    return new ChangeSet(length ? [length, -1] : [], []);
  }
  static fromJSON(json) {
    if (!Array.isArray(json))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i = 0; i < json.length; i++) {
      let part = json[i];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i)
          inserted.push(Text.empty);
        inserted[i] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i].length);
      }
    }
    return new ChangeSet(sections, inserted);
  }
};
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last = sections.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections[last + 1])
    sections[last] += len;
  else if (len == 0 && sections[last] == 0)
    sections[last + 1] += ins;
  else if (forceJoin) {
    sections[last] += len;
    sections[last + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values, sections, value) {
  if (value.length == 0)
    return;
  let index2 = sections.length - 2 >> 1;
  if (index2 < values.length) {
    values[values.length - 1] = values[values.length - 1].append(value);
  } else {
    while (values.length < index2)
      values.push(Text.empty);
    values.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
    let len = desc.sections[i++], ins = desc.sections[i++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text = text.append(inserted[i - 2 >> 1]);
        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
          break;
        len = desc.sections[i++];
        ins = desc.sections[i++];
      }
      f(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let posA = 0, posB = 0; ; ) {
    if (a.ins == -1) {
      posA += a.len;
      a.next();
    } else if (b.ins == -1 && posB < posA) {
      let skip = Math.min(b.len, posA - posB);
      b.forward(skip);
      addSection(sections, skip, -1);
      posB += skip;
    } else if (b.ins >= 0 && (a.done || posB < posA || posB == posA && (b.len < a.len || b.len == a.len && !before))) {
      addSection(sections, b.ins, -1);
      while (posA > posB && !a.done && posA + a.len < posB + b.len) {
        posA += a.len;
        a.next();
      }
      posB += b.len;
      b.next();
    } else if (a.ins >= 0) {
      let len = 0, end = posA + a.len;
      for (; ; ) {
        if (b.ins >= 0 && posB > posA && posB + b.len < end) {
          len += b.ins;
          posB += b.len;
          b.next();
        } else if (b.ins == -1 && posB < end) {
          let skip = Math.min(b.len, end - posB);
          len += skip;
          b.forward(skip);
          posB += skip;
        } else {
          break;
        }
      }
      addSection(sections, len, a.ins);
      if (insert2)
        addInsert(insert2, sections, a.text);
      posA = end;
      a.next();
    } else if (a.done && b.done) {
      return insert2 ? new ChangeSet(sections, insert2) : new ChangeDesc(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a.done && b.done) {
      return insert2 ? new ChangeSet(sections, insert2) : new ChangeDesc(sections);
    } else if (a.ins == 0) {
      addSection(sections, a.len, 0, open);
      a.next();
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open);
      if (insert2)
        addInsert(insert2, sections, b.text);
      b.next();
    } else if (a.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a.len2, b.len), sectionLen = sections.length;
      if (a.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a.off ? 0 : a.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a.textBit(len));
      } else {
        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
        if (insert2 && !b.off)
          addInsert(insert2, sections, b.text);
      }
      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a.forward2(len);
      b.forward(len);
    }
  }
}
var SectionIter = class {
  constructor(set) {
    this.set = set;
    this.i = 0;
    this.next();
  }
  next() {
    let {sections} = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let {inserted} = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length ? Text.empty : inserted[index2];
  }
  textBit(len) {
    let {inserted} = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length && !len ? Text.empty : inserted[index2].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
};
var SelectionRange = class {
  constructor(from, to, flags) {
    this.from = from;
    this.to = to;
    this.flags = flags;
  }
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  get bidiLevel() {
    let level = this.flags & 3;
    return level == 3 ? null : level;
  }
  get goalColumn() {
    let value = this.flags >> 5;
    return value == 33554431 ? void 0 : value;
  }
  map(change, assoc = -1) {
    let from = change.mapPos(this.from, assoc), to = change.mapPos(this.to, assoc);
    return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
  }
  extend(from, to = from) {
    if (from <= this.anchor && to >= this.anchor)
      return EditorSelection.range(from, to);
    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
    return EditorSelection.range(this.anchor, head);
  }
  eq(other) {
    return this.anchor == other.anchor && this.head == other.head;
  }
  toJSON() {
    return {anchor: this.anchor, head: this.head};
  }
  static fromJSON(json) {
    if (!json || typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json.anchor, json.head);
  }
};
var EditorSelection = class {
  constructor(ranges, mainIndex = 0) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
  }
  eq(other) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(other.ranges[i]))
        return false;
    return true;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new EditorSelection([this.main]);
  }
  addRange(range, main = true) {
    return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return EditorSelection.create(ranges, this.mainIndex);
  }
  toJSON() {
    return {ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex};
  }
  static fromJSON(json) {
    if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
  }
  static single(anchor, head = anchor) {
    return new EditorSelection([EditorSelection.range(anchor, head)], 0);
  }
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i = 0; i < ranges.length; i++) {
      let range = ranges[i];
      if (range.empty ? range.from <= pos : range.from < pos)
        return normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }
    return new EditorSelection(ranges, mainIndex);
  }
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return new SelectionRange(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
  }
  static range(anchor, head, goalColumn) {
    let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5;
    return head < anchor ? new SelectionRange(head, anchor, 16 | goal) : new SelectionRange(anchor, head, goal);
  }
};
function normalized(ranges, mainIndex = 0) {
  let main = ranges[mainIndex];
  ranges.sort((a, b) => a.from - b.from);
  mainIndex = ranges.indexOf(main);
  for (let i = 1; i < ranges.length; i++) {
    let range = ranges[i], prev = ranges[i - 1];
    if (range.empty ? range.from <= prev.to : range.from < prev.to) {
      let from = prev.from, to = Math.max(range.to, prev.to);
      if (i <= mainIndex)
        mainIndex--;
      ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
    }
  }
  return new EditorSelection(ranges, mainIndex);
}
function checkSelection(selection, docLength) {
  for (let range of selection.ranges)
    if (range.to > docLength)
      throw new RangeError("Selection points outside of document");
}
var nextID = 0;
var Facet = class {
  constructor(combine, compareInput, compare2, isStatic, extensions) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.extensions = extensions;
    this.id = nextID++;
    this.default = combine([]);
  }
  static define(config2 = {}) {
    return new Facet(config2.combine || ((a) => a), config2.compareInput || ((a, b) => a === b), config2.compare || (!config2.combine ? sameArray : (a, b) => a === b), !!config2.static, config2.enables);
  }
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  compute(deps, get2) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get2);
  }
  computeN(deps, get2) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get2);
  }
  from(field, get2) {
    if (!get2)
      get2 = (x) => x;
    return this.compute([field], (state) => get2(state.field(field)));
  }
};
function sameArray(a, b) {
  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
var FacetProvider = class {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let idx = addresses[this.id] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return (state, tr) => {
      if (!tr || tr.reconfigured) {
        state.values[idx] = getter(state);
        return 1;
      } else {
        let depChanged = depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || depAddrs.some((addr) => (ensureAddr(state, addr) & 1) > 0);
        if (!depChanged)
          return 0;
        let newVal = getter(state), oldVal = tr.startState.values[idx];
        if (multi ? compareArray(newVal, oldVal, compare2) : compare2(newVal, oldVal))
          return 0;
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
};
function compareArray(a, b, compare2) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!compare2(a[i], b[i]))
      return false;
  return true;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id]);
  let providerTypes = providers.map((p) => p.type);
  let dynamic = providerAddrs.filter((p) => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  return (state, tr) => {
    let oldAddr = !tr ? null : tr.reconfigured ? tr.startState.config.address[facet.id] : idx << 1;
    let changed = oldAddr == null;
    for (let dynAddr of dynamic) {
      if (ensureAddr(state, dynAddr) & 1)
        changed = true;
    }
    if (!changed)
      return 0;
    let values = [];
    for (let i = 0; i < providerAddrs.length; i++) {
      let value = getAddr(state, providerAddrs[i]);
      if (providerTypes[i] == 2)
        for (let val of value)
          values.push(val);
      else
        values.push(value);
    }
    let newVal = facet.combine(values);
    if (oldAddr != null && facet.compare(newVal, getAddr(tr.startState, oldAddr)))
      return 0;
    state.values[idx] = newVal;
    return 1;
  };
}
function maybeIndex(state, id) {
  let found = state.config.address[id];
  return found == null ? null : found >> 1;
}
var initField = /* @__PURE__ */ Facet.define({static: true});
var StateField = class {
  constructor(id, createF, updateF, compareF, spec) {
    this.id = id;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  static define(config2) {
    let field = new StateField(nextID++, config2.create, config2.update, config2.compare || ((a, b) => a === b), config2);
    if (config2.provide)
      field.provides = config2.provide(field);
    return field;
  }
  create(state) {
    let init2 = state.facet(initField).find((i) => i.field == this);
    return ((init2 === null || init2 === void 0 ? void 0 : init2.create) || this.createF)(state);
  }
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return (state, tr) => {
      if (!tr || tr.reconfigured && maybeIndex(tr.startState, this.id) == null) {
        state.values[idx] = this.create(state);
        return 1;
      }
      let oldVal, changed = 0;
      if (tr.reconfigured) {
        oldVal = tr.startState.values[maybeIndex(tr.startState, this.id)];
        changed = 1;
      } else {
        oldVal = tr.startState.values[idx];
      }
      let value = this.updateF(oldVal, tr);
      if (!changed && !this.compareF(oldVal, value))
        changed = 1;
      if (changed)
        state.values[idx] = value;
      return changed;
    };
  }
  init(create) {
    return [this, initField.of({field: this, create})];
  }
  get extension() {
    return this;
  }
};
var Prec_ = {fallback: 3, default: 2, extend: 1, override: 0};
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
var Prec = {
  fallback: /* @__PURE__ */ prec(Prec_.fallback),
  default: /* @__PURE__ */ prec(Prec_.default),
  extend: /* @__PURE__ */ prec(Prec_.extend),
  override: /* @__PURE__ */ prec(Prec_.override)
};
var PrecExtension = class {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
};
var Compartment = class {
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  reconfigure(content2) {
    return Compartment.reconfigure.of({compartment: this, extension: content2});
  }
  get(state) {
    return state.config.compartments.get(this);
  }
};
var CompartmentInstance = class {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
};
var Configuration = class {
  constructor(base2, compartments, dynamicSlots, address, staticValues) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(0);
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = Object.create(null);
    let newCompartments = new Map();
    for (let ext of flatten(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a) => field.slot(a));
    }
    for (let id in facets) {
      let providers = facets[id], facet = providers[0].facet;
      if (providers.every((p) => p.type == 0)) {
        address[facet.id] = staticValues.length << 1 | 1;
        let value = facet.combine(providers.map((p) => p.value));
        let oldAddr = oldState ? oldState.config.address[facet.id] : null;
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (facet.compare(value, oldVal))
            value = oldVal;
        }
        staticValues.push(value);
      } else {
        for (let p of providers) {
          if (p.type == 0) {
            address[p.id] = staticValues.length << 1 | 1;
            staticValues.push(p.value);
          } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a) => p.dynamicSlot(a));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
      }
    }
    return new Configuration(base2, newCompartments, dynamicSlots.map((f) => f(address)), address, staticValues);
  }
};
function flatten(extension, compartments, newCompartments) {
  let result = [[], [], [], []];
  let seen = new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known >= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e of ext)
        inner(e, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, prec2);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.config.dynamicSlots[idx](state, state.applying);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
var languageData = /* @__PURE__ */ Facet.define();
var allowMultipleSelections = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((v) => v),
  static: true
});
var lineSeparator = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : void 0,
  static: true
});
var changeFilter = /* @__PURE__ */ Facet.define();
var transactionFilter = /* @__PURE__ */ Facet.define();
var transactionExtender = /* @__PURE__ */ Facet.define();
var Annotation = class {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  static define() {
    return new AnnotationType();
  }
};
var AnnotationType = class {
  of(value) {
    return new Annotation(this, value);
  }
};
var StateEffectType = class {
  constructor(map) {
    this.map = map;
  }
  of(value) {
    return new StateEffect(this, value);
  }
};
var StateEffect = class {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
  }
  is(type) {
    return this.type == type;
  }
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v));
  }
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
};
StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
var Transaction = class {
  constructor(startState, changes, selection, effects, annotations, scrollIntoView2) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView2;
    this._doc = null;
    this._state = null;
    if (selection)
      checkSelection(selection, changes.newLength);
    if (!annotations.some((a) => a.type == Transaction.time))
      this.annotations = annotations.concat(Transaction.time.of(Date.now()));
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  annotation(type) {
    for (let ann of this.annotations)
      if (ann.type == type)
        return ann.value;
    return void 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
};
Transaction.time = /* @__PURE__ */ Annotation.define();
Transaction.userEvent = /* @__PURE__ */ Annotation.define();
Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
Transaction.remote = /* @__PURE__ */ Annotation.define();
function joinRanges(a, b) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from, to;
    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
      from = a[iA++];
      to = a[iA++];
    } else if (iB < b.length) {
      from = b[iB++];
      to = b[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from)
      result.push(from, to);
    else if (result[result.length - 1] < to)
      result[result.length - 1] = to;
  }
}
function mergeTransaction(a, b, sequential) {
  var _a;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a.changes);
    mapForB = a.changes.mapDesc(b.changes, true);
    changes = a.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection;
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations: asArray(spec.annotations),
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter) {
  let s2 = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter = false;
  for (let i = 1; i < specs.length; i++) {
    if (specs[i].filter === false)
      filter = false;
    let seq = !!specs[i].sequential;
    s2 = mergeTransaction(s2, resolveTransactionInner(state, specs[i], seq ? s2.changes.newLength : state.doc.length), seq);
  }
  let tr = new Transaction(state, s2.changes, s2.selection, s2.effects, s2.annotations, s2.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result = true;
  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.invertedDesc;
    }
    tr = new Transaction(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i = filters.length - 1; i >= 0; i--) {
    let filtered = filters[i](tr);
    if (filtered instanceof Transaction)
      tr = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0];
    else
      tr = resolveTransaction(state, asArray(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
  for (let i = extenders.length - 1; i >= 0; i--) {
    let extension = extenders[i](tr);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(tr, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }
  return spec == tr ? tr : new Transaction(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
var none = [];
function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = /* @__PURE__ */ function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
var wordChar;
try {
  wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i = 0; i < str.length; i++) {
    let ch = str[i];
    if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i = 0; i < wordChars.length; i++)
      if (char.indexOf(wordChars[i]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
var EditorState = class {
  constructor(config2, doc2, selection, tr = null) {
    this.config = config2;
    this.doc = doc2;
    this.selection = selection;
    this.applying = null;
    this.status = config2.statusTemplate.slice();
    if (tr && tr.startState.config == config2) {
      this.values = tr.startState.values.slice();
    } else {
      this.values = config2.dynamicSlots.map((_) => null);
      if (tr)
        for (let id in config2.address) {
          let cur2 = config2.address[id], prev = tr.startState.config.address[id];
          if (prev != null && (cur2 & 1) == 0)
            this.values[cur2 >> 1] = getAddr(tr.startState, prev);
        }
    }
    this.applying = tr;
    if (tr)
      tr._state = this;
    for (let i = 0; i < this.config.dynamicSlots.length; i++)
      ensureAddr(this, i << 1);
    this.applying = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  applyTransaction(tr) {
    let conf = this.config, {base: base2, compartments} = conf;
    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray(base2).concat(effect.value);
      }
    }
    new EditorState(conf || Configuration.resolve(base2, compartments, this), tr.newDoc, tr.newSelection, tr);
  }
  replaceSelection(text) {
    if (typeof text == "string")
      text = this.toText(text);
    return this.changeByRange((range) => ({
      changes: {from: range.from, to: range.to, insert: text},
      range: EditorSelection.cursor(range.from + text.length)
    }));
  }
  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray(result1.effects);
    for (let i = 1; i < sel.ranges.length; i++) {
      let result = f(sel.ranges[i]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j = 0; j < i; j++)
        ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
  }
  toText(string2) {
    return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
  }
  sliceDoc(from = 0, to = this.doc.length) {
    return this.doc.sliceString(from, to, this.lineBreak);
  }
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result;
  }
  static fromJSON(json, config2 = {}, fields) {
    if (!json || typeof json.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        let field = fields[prop], value = json[prop];
        fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
      }
    return EditorState.create({
      doc: json.doc,
      selection: EditorSelection.fromJSON(json.selection),
      extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
    });
  }
  static create(config2 = {}) {
    let configuration = Configuration.resolve(config2.extensions || [], new Map());
    let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
    let selection = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
    checkSelection(selection, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection = selection.asSingle();
    return new EditorState(configuration, doc2, selection);
  }
  get tabSize() {
    return this.facet(EditorState.tabSize);
  }
  get lineBreak() {
    return this.facet(EditorState.lineSeparator) || "\n";
  }
  phrase(phrase) {
    for (let map of this.facet(EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map, phrase))
        return map[phrase];
    return phrase;
  }
  languageDataAt(name2, pos) {
    let values = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos)) {
        if (Object.prototype.hasOwnProperty.call(result, name2))
          values.push(result[name2]);
      }
    }
    return values;
  }
  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
  }
  wordAt(pos) {
    let {text, from, length} = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from, end = pos - from;
    while (start > 0) {
      let prev = findClusterBreak(text, start, false);
      if (cat(text.slice(prev, start)) != CharCategory.Word)
        break;
      start = prev;
    }
    while (end < length) {
      let next = findClusterBreak(text, end);
      if (cat(text.slice(end, next)) != CharCategory.Word)
        break;
      end = next;
    }
    return start == end ? EditorSelection.range(start + from, end + from) : null;
  }
};
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.phrases = /* @__PURE__ */ Facet.define();
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
function combineConfig(configs, defaults3, combine = {}) {
  let result = {};
  for (let config2 of configs)
    for (let key of Object.keys(config2)) {
      let value = config2[key], current = result[key];
      if (current === void 0)
        result[key] = value;
      else if (current === value || value === void 0)
        ;
      else if (Object.hasOwnProperty.call(combine, key))
        result[key] = combine[key](current, value);
      else
        throw new Error("Config merge conflict for field " + key);
    }
  for (let key in defaults3)
    if (result[key] === void 0)
      result[key] = defaults3[key];
  return result;
}

// node_modules/style-mod/src/style-mod.js
var C = "\u037C";
var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
var StyleModule = class {
  constructor(spec, options2) {
    this.rules = [];
    let {finish} = options2 || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render2(selectors, spec2, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null)
        return target.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render2(prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);
        } else if (value && typeof value == "object") {
          if (!isAt)
            throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render2(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec)
      render2(splitSelector(prop), spec[prop], this.rules);
  }
  getRules() {
    return this.rules.join("\n");
  }
  static newName() {
    let id = top[COUNT] || 1;
    top[COUNT] = id + 1;
    return C + id.toString(36);
  }
  static mount(root, modules) {
    (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
  }
};
var adoptedSet = null;
var StyleSet = class {
  constructor(root) {
    if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
      if (adoptedSet) {
        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
        return root[SET] = adoptedSet;
      }
      this.sheet = new CSSStyleSheet();
      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
      adoptedSet = this;
    } else {
      this.styleTag = (root.ownerDocument || root).createElement("style");
      let target = root.head || root;
      target.insertBefore(this.styleTag, target.firstChild);
    }
    this.modules = [];
    root[SET] = this;
  }
  mount(modules) {
    let sheet = this.sheet;
    let pos = 0, j = 0;
    for (let i = 0; i < modules.length; i++) {
      let mod = modules[i], index2 = this.modules.indexOf(mod);
      if (index2 < j && index2 > -1) {
        this.modules.splice(index2, 1);
        j--;
        index2 = -1;
      }
      if (index2 == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet)
          for (let k = 0; k < mod.rules.length; k++)
            sheet.insertRule(mod.rules[k], pos++);
      } else {
        while (j < index2)
          pos += this.modules[j++].rules.length;
        pos += mod.rules.length;
        j++;
      }
    }
    if (!sheet) {
      let text = "";
      for (let i = 0; i < this.modules.length; i++)
        text += this.modules[i].getRules() + "\n";
      this.styleTag.textContent = text;
    }
  }
};

// node_modules/@codemirror/rangeset/dist/index.js
var RangeValue = class {
  eq(other) {
    return this == other;
  }
  range(from, to = from) {
    return new Range(from, to, this);
  }
};
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
var Range = class {
  constructor(from, to, value) {
    this.from = from;
    this.to = to;
    this.value = value;
  }
};
function cmpRange(a, b) {
  return a.from - b.from || a.value.startSide - b.value.startSide;
}
var Chunk = class {
  constructor(from, to, value, maxPoint) {
    this.from = from;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(pos, end, side = end * 1e9, startAt = 0) {
    if (pos <= 0)
      return startAt;
    let arr = end < 0 ? this.to : this.from;
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi)
        return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side;
      if (mid == lo)
        return diff >= 0 ? lo : hi;
      if (diff >= 0)
        hi = mid;
      else
        lo = mid + 1;
    }
  }
  between(offset, from, to, f) {
    for (let i = this.findIndex(from, -1), e = this.findIndex(to, 1, void 0, i); i < e; i++)
      if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
        return false;
  }
  map(offset, changes) {
    let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
    for (let i = 0; i < this.value.length; i++) {
      let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to.push(newTo - newPos);
    }
    return {mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos};
  }
};
var RangeSet = class {
  constructor(chunkPos, chunk, nextLayer = RangeSet.empty, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  get size() {
    if (this == RangeSet.empty)
      return 0;
    let size = this.nextLayer.size;
    for (let chunk of this.chunk)
      size += chunk.value.length;
    return size;
  }
  chunkEnd(index2) {
    return this.chunkPos[index2] + this.chunk[index2].length;
  }
  update(updateSpec) {
    let {add: add2 = [], sort = false, filterFrom = 0, filterTo = this.length} = updateSpec;
    let filter = updateSpec.filter;
    if (add2.length == 0 && !filter)
      return this;
    if (sort)
      add2.slice().sort(cmpRange);
    if (this == RangeSet.empty)
      return add2.length ? RangeSet.of(add2) : this;
    let cur2 = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur2.value || i < add2.length) {
      if (i < add2.length && (cur2.from - add2[i].from || cur2.startSide - add2[i].value.startSide) >= 0) {
        let range = add2[i++];
        if (!builder.addInner(range.from, range.to, range.value))
          spill.push(range);
      } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i == add2.length || this.chunkEnd(cur2.chunkIndex) < add2[i].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
        cur2.nextChunk();
      } else {
        if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
          if (!builder.addInner(cur2.from, cur2.to, cur2.value))
            spill.push(new Range(cur2.from, cur2.to, cur2.value));
        }
        cur2.next();
      }
    }
    return builder.finishInner(this.nextLayer == RangeSet.empty && !spill.length ? RangeSet.empty : this.nextLayer.update({add: spill, filter, filterFrom, filterTo}));
  }
  map(changes) {
    if (changes.length == 0 || this == RangeSet.empty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      let touch = changes.touchesRange(start, start + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let {mapped, pos} = chunk.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);
  }
  between(from, to, f) {
    if (this == RangeSet.empty)
      return;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false)
        return;
    }
    this.nextLayer.between(from, to, f);
  }
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a = oldSets.filter((set) => set.maxPoint >= 500 || set != RangeSet.empty && newSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);
    let b = newSets.filter((set) => set.maxPoint >= 500 || set != RangeSet.empty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a, b);
    let sideA = new SpanCursor(a, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  static spans(sets, from, to, iterator, minPointSize = -1) {
    let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
    let open = cursor.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor.to, to);
      if (cursor.point) {
        iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);
        open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor.active, open);
        open = cursor.openEnd(curTo);
      }
      if (cursor.to > to)
        break;
      pos = cursor.to;
      cursor.next();
    }
    return open;
  }
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range of ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges)
      build.add(range.from, range.to, range.value);
    return build.finish();
  }
};
RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
RangeSet.empty.nextLayer = RangeSet.empty;
var RangeSetBuilder = class {
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  add(from, to, value) {
    if (!this.addInner(from, to, value))
      (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
  }
  addInner(from, to, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to - from);
    return true;
  }
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from;
    this.lastTo = chunk.to[last] + from;
    return true;
  }
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  finishInner(next) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next;
    let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result;
  }
};
function findSharedChunks(a, b) {
  let inA = new Map();
  for (let set of a)
    for (let i = 0; i < set.chunk.length; i++)
      if (set.chunk[i].maxPoint < 500)
        inA.set(set.chunk[i], set.chunkPos[i]);
  let shared = new Set();
  for (let set of b)
    for (let i = 0; i < set.chunk.length; i++)
      if (inA.get(set.chunk[i]) == set.chunkPos[i])
        shared.add(set.chunk[i]);
  return shared;
}
var LayerCursor = class {
  constructor(layer, skip, minPoint, rank = 0) {
    this.layer = layer;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0 : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side);
    if (!forward || this.rangeIndex < rangeIndex)
      this.rangeIndex = rangeIndex;
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        if (++this.rangeIndex == chunk.value.length) {
          this.chunkIndex++;
          if (this.skip) {
            while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
              this.chunkIndex++;
          }
          this.rangeIndex = 0;
        }
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;
  }
};
var HeapCursor = class {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i = 0; i < sets.length; i++) {
      for (let cur2 = sets[i]; cur2 != RangeSet.empty; cur2 = cur2.nextLayer) {
        if (cur2.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur2, skip, minPoint, i));
      }
    }
    return heap.length == 1 ? heap[0] : new HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur2 of this.heap)
      cur2.goto(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur2 of this.heap)
      cur2.forward(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value)
        top2.next();
      heapBubble(this.heap, 0);
    }
  }
};
function heapBubble(heap, index2) {
  for (let cur2 = heap[index2]; ; ) {
    let childIndex = (index2 << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur2.compare(child) < 0)
      break;
    heap[childIndex] = cur2;
    heap[index2] = child;
    index2 = childIndex;
  }
}
var SpanCursor = class {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index2) {
    remove(this.active, index2);
    remove(this.activeTo, index2);
    remove(this.activeRank, index2);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i = 0, {value, to, rank} = this.cursor;
    while (i < this.activeRank.length && this.activeRank[i] <= rank)
      i++;
    insert(this.active, i, value);
    insert(this.activeTo, i, to);
    insert(this.activeRank, i, rank);
    if (trackOpen)
      insert(trackOpen, i, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  next() {
    let from = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;
    for (; ; ) {
      let a = this.minActive;
      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a] > from) {
          this.to = this.activeTo[a];
          this.endSide = this.active[a].endSide;
          break;
        }
        this.removeActive(a);
        if (trackOpen)
          remove(trackOpen, a);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to && nextVal.endSide == this.endSide) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          if (this.cursor.from < from)
            trackExtra = 1;
          this.cursor.next();
          if (this.to > from)
            this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      let openStart = 0;
      while (openStart < trackOpen.length && trackOpen[openStart] < from)
        openStart++;
      this.openStart = openStart + trackExtra;
    }
  }
  activeForPoint(to) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i = 0; i < this.active.length; i++) {
      if (this.activeRank[i] > this.pointRank)
        break;
      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide > this.point.endSide)
        active.push(this.active[i]);
    }
    return active;
  }
  openEnd(to) {
    let open = 0;
    while (open < this.activeTo.length && this.activeTo[open] > to)
      open++;
    return open;
  }
};
function compare(a, startA, b, startB, length, comparator) {
  a.goto(startA);
  b.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let diff = a.to + dPos - b.to || a.endSide - b.endSide;
    let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
    if (a.point || b.point) {
      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point))))
        comparator.comparePoint(pos, clipEnd, a.point, b.point);
    } else {
      if (clipEnd > pos && !sameValues(a.active, b.active))
        comparator.compareRange(pos, clipEnd, a.active, b.active);
    }
    if (end > endB)
      break;
    pos = end;
    if (diff <= 0)
      a.next();
    if (diff >= 0)
      b.next();
  }
}
function sameValues(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (a[i] != b[i] && !a[i].eq(b[i]))
      return false;
  return true;
}
function remove(array, index2) {
  for (let i = index2, e = array.length - 1; i < e; i++)
    array[i] = array[i + 1];
  array.pop();
}
function insert(array, index2, value) {
  for (let i = array.length - 1; i >= index2; i--)
    array[i + 1] = array[i];
  array[index2] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i = 0; i < array.length; i++)
    if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
      found = i;
      foundPos = array[i];
    }
  return found;
}

// node_modules/w3c-keyname/index.es.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"',
  229: "Q"
};
var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac;
for (var i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
function keyName(event) {
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || (safari || ie) && event.shiftKey && event.key && event.key.length == 1;
  var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name2 == "Esc")
    name2 = "Escape";
  if (name2 == "Del")
    name2 = "Delete";
  if (name2 == "Left")
    name2 = "ArrowLeft";
  if (name2 == "Up")
    name2 = "ArrowUp";
  if (name2 == "Right")
    name2 = "ArrowRight";
  if (name2 == "Down")
    name2 = "ArrowDown";
  return name2;
}

// node_modules/@codemirror/view/dist/index.js
function getSelection(root) {
  return root.getSelection ? root.getSelection() : document.getSelection();
}
function contains(dom, node) {
  return node ? dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function deepActiveElement() {
  let elt = document.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function hasSelection(dom, selection) {
  if (!selection.anchorNode)
    return false;
  try {
    return contains(dom, selection.anchorNode);
  } catch (_) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}
function domIndex(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling;
    if (!node)
      return index2;
  }
}
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == "DIV")
        return false;
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      off = dir < 0 ? maxOffset(node) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
var Rect0 = {left: 0, right: 0, top: 0, bottom: 0};
function flattenRect(rect, left) {
  let x = left ? rect.left : rect.right;
  return {left: x, right: x, top: rect.top, bottom: rect.bottom};
}
function windowRect(win) {
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
var ScrollSpace = 5;
function scrollRectIntoView(dom, rect) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView;
  for (let cur2 = dom.parentNode; cur2; ) {
    if (cur2.nodeType == 1) {
      let bounding, top2 = cur2 == document.body;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
          cur2 = cur2.parentNode;
          continue;
        }
        let rect2 = cur2.getBoundingClientRect();
        bounding = {
          left: rect2.left,
          right: rect2.left + cur2.clientWidth,
          top: rect2.top,
          bottom: rect2.top + cur2.clientHeight
        };
      }
      let moveX = 0, moveY = 0;
      if (rect.top < bounding.top)
        moveY = -(bounding.top - rect.top + ScrollSpace);
      else if (rect.bottom > bounding.bottom)
        moveY = rect.bottom - bounding.bottom + ScrollSpace;
      if (rect.left < bounding.left)
        moveX = -(bounding.left - rect.left + ScrollSpace);
      else if (rect.right > bounding.right)
        moveX = rect.right - bounding.right + ScrollSpace;
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          if (moveY) {
            let start = cur2.scrollTop;
            cur2.scrollTop += moveY;
            moveY = cur2.scrollTop - start;
          }
          if (moveX) {
            let start = cur2.scrollLeft;
            cur2.scrollLeft += moveX;
            moveX = cur2.scrollLeft - start;
          }
          rect = {
            left: rect.left - moveX,
            top: rect.top - moveY,
            right: rect.right - moveX,
            bottom: rect.bottom - moveY
          };
        }
      }
      if (top2)
        break;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
}
var DOMSelection = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  set(domSel) {
    this.anchorNode = domSel.anchorNode;
    this.anchorOffset = domSel.anchorOffset;
    this.focusNode = domSel.focusNode;
    this.focusOffset = domSel.focusOffset;
  }
};
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
    stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
    if (cur2 == cur2.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = {preventScroll: true};
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i = 0; i < stack.length; ) {
      let elt = stack[i++], top2 = stack[i++], left = stack[i++];
      if (elt.scrollTop != top2)
        elt.scrollTop = top2;
      if (elt.scrollLeft != left)
        elt.scrollLeft = left;
    }
  }
}
var scratchRange;
function textRange(node, from, to = from) {
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node, to);
  range.setStart(node, from);
  return range;
}
function dispatchKey(elt, name2, code) {
  let options2 = {key: name2, code: name2, keyCode: code, which: code, cancelable: true};
  let down = new KeyboardEvent("keydown", options2);
  down.synthetic = true;
  elt.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options2);
  up.synthetic = true;
  elt.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
var DOMPos = class {
  constructor(node, offset, precise = true) {
    this.node = node;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
};
var none$3 = [];
var ContentView = class {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.dirty = 2;
  }
  get editorView() {
    if (!this.parent)
      throw new Error("Accessing view in orphan content view");
    return this.parent.editorView;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(view) {
    let pos = this.posAtStart;
    for (let child of this.children) {
      if (child == view)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(view) {
    return this.posBefore(view) + view.length;
  }
  coordsAt(_pos, _side) {
    return null;
  }
  sync(track) {
    var _a;
    if (this.dirty & 2) {
      let parent = this.dom, pos = null;
      for (let child of this.children) {
        if (child.dirty) {
          let next2 = pos ? pos.nextSibling : parent.firstChild;
          if (!child.dom && next2 && !((_a = ContentView.get(next2)) === null || _a === void 0 ? void 0 : _a.parent))
            child.reuseDOM(next2);
          child.sync(track);
          child.dirty = 0;
        }
        if (track && track.node == parent && pos != child.dom)
          track.written = true;
        syncNodeInto(parent, pos, child.dom);
        pos = child.dom;
      }
      let next = pos ? pos.nextSibling : parent.firstChild;
      if (next && track && track.node == parent)
        track.written = true;
      while (next)
        next = rm(next);
    } else if (this.dirty & 1) {
      for (let child of this.children)
        if (child.dirty) {
          child.sync(track);
          child.dirty = 0;
        }
    }
  }
  reuseDOM(_dom) {
    return false;
  }
  localPosFromDOM(node, offset) {
    let after;
    if (node == this.dom) {
      after = this.dom.childNodes[offset];
    } else {
      let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
      for (; ; ) {
        let parent = node.parentNode;
        if (parent == this.dom)
          break;
        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node == parent.firstChild)
            bias = -1;
          else
            bias = 1;
        }
        node = parent;
      }
      if (bias < 0)
        after = node;
      else
        after = node.nextSibling;
    }
    if (after == this.dom.firstChild)
      return 0;
    while (after && !ContentView.get(after))
      after = after.nextSibling;
    if (!after)
      return this.length;
    for (let i = 0, pos = 0; ; i++) {
      let child = this.children[i];
      if (child.dom == after)
        return pos;
      pos += child.length + child.breakAfter;
    }
  }
  domBoundsAround(from, to, offset = 0) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (pos < from && end > to)
        return child.domBoundsAround(from, to, pos);
      if (end >= from && fromI == -1) {
        fromI = i;
        fromStart = pos;
      }
      if (pos > to && child.dom.parentNode == this.dom) {
        toI = i;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd, startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild, endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null};
  }
  markDirty(andParent = false) {
    if (this.dirty & 2)
      return;
    this.dirty |= 2;
    this.markParentsDirty(andParent);
  }
  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList)
        parent.dirty |= 2;
      if (parent.dirty & 1)
        return;
      parent.dirty |= 1;
      childList = false;
    }
  }
  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent;
      if (this.dirty)
        this.markParentsDirty(true);
    }
  }
  setDOM(dom) {
    this.dom = dom;
    dom.cmView = this;
  }
  get rootView() {
    for (let v = this; ; ) {
      let parent = v.parent;
      if (!parent)
        return v;
      v = parent;
    }
  }
  replaceChildren(from, to, children = none$3) {
    this.markDirty();
    for (let i = from; i < to; i++) {
      let child = this.children[i];
      if (child.parent == this)
        child.parent = null;
    }
    this.children.splice(from, to - from, ...children);
    for (let i = 0; i < children.length; i++)
      children[i].setParent(this);
  }
  ignoreMutation(_rec) {
    return false;
  }
  ignoreEvent(_event) {
    return false;
  }
  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length);
  }
  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias);
  }
  toString() {
    let name2 = this.constructor.name.replace("View", "");
    return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(node) {
    return node.cmView;
  }
};
ContentView.prototype.breakAfter = 0;
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
function syncNodeInto(parent, after, dom) {
  let next = after ? after.nextSibling : parent.firstChild;
  if (dom.parentNode == parent)
    while (next != dom)
      next = rm(next);
  else
    parent.insertBefore(dom, next);
}
var ChildCursor = class {
  constructor(children, pos, i) {
    this.children = children;
    this.pos = pos;
    this.i = i;
    this.off = 0;
  }
  findPos(pos, bias = 1) {
    for (; ; ) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }
      let next = this.children[--this.i];
      this.pos -= next.length + next.breakAfter;
    }
  }
};
var [nav, doc] = typeof navigator != "undefined" ? [navigator, document] : [{userAgent: "", vendor: "", platform: ""}, {documentElement: {style: {}}}];
var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
var gecko2 = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
var chrome2 = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
var webkit = "webkitFontSmoothing" in doc.documentElement.style;
var safari2 = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
var browser = {
  mac: /* @__PURE__ */ /Mac/.test(nav.platform),
  ie: ie2,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko: gecko2,
  gecko_version: gecko2 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome2,
  chrome_version: chrome2 ? +chrome2[1] : 0,
  ios: safari2 && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2),
  android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
  webkit,
  safari: safari2,
  webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
var none$2 = [];
var InlineView = class extends ContentView {
  become(_other) {
    return false;
  }
  getSide() {
    return 0;
  }
};
InlineView.prototype.children = none$2;
var MaxJoinLen = 256;
var TextView = class extends InlineView {
  constructor(text) {
    super();
    this.text = text;
  }
  get length() {
    return this.text.length;
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }
  sync(track) {
    if (!this.dom)
      this.createDOM();
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom)
        track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType != 3)
      return false;
    this.createDOM(dom);
    return true;
  }
  merge(from, to, source) {
    if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))
      return false;
    this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
    this.markDirty();
    return true;
  }
  slice(from) {
    return new TextView(this.text.slice(from));
  }
  localPosFromDOM(node, offset) {
    return node == this.dom ? offset : offset ? this.text.length : 0;
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }
  domBoundsAround(_from, _to, offset) {
    return {from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling};
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }
};
var MarkView = class extends InlineView {
  constructor(mark, children = [], length = 0) {
    super();
    this.mark = mark;
    this.children = children;
    this.length = length;
    for (let ch of children)
      ch.setParent(this);
  }
  createDOM() {
    let dom = document.createElement(this.mark.tagName);
    if (this.mark.class)
      dom.className = this.mark.class;
    if (this.mark.attrs)
      for (let name2 in this.mark.attrs)
        dom.setAttribute(name2, this.mark.attrs[name2]);
    this.setDOM(dom);
  }
  sync(track) {
    if (!this.dom)
      this.createDOM();
    super.sync(track);
  }
  merge(from, to, source, openStart, openEnd) {
    if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    mergeInlineChildren(this, from, to, source ? source.children : none$2, openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }
  slice(from) {
    return new MarkView(this.mark, sliceInlineChildren(this.children, from), this.length - from);
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this.dom, this.children, pos);
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
};
function textCoords(text, pos, side) {
  let length = text.nodeValue.length;
  if (pos > length)
    pos = length;
  let from = pos, to = pos, flatten2 = 0;
  if (pos == 0 && side < 0 || pos == length && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from--;
        flatten2 = 1;
      } else {
        to++;
        flatten2 = -1;
      }
    }
  } else {
    if (side < 0)
      from--;
    else
      to++;
  }
  let rects = textRange(text, from, to).getClientRects();
  if (!rects.length)
    return Rect0;
  let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten2 && rect.width == 0)
    rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
  return flatten2 ? flattenRect(rect, flatten2 < 0) : rect;
}
var WidgetView = class extends InlineView {
  constructor(widget, length, side) {
    super();
    this.widget = widget;
    this.length = length;
    this.side = side;
  }
  static create(widget, length, side) {
    return new (widget.customView || WidgetView)(widget, length, side);
  }
  slice(from) {
    return WidgetView.create(this.widget, this.length - from, this.side);
  }
  sync() {
    if (!this.dom || !this.widget.updateDOM(this.dom)) {
      this.setDOM(this.widget.toDOM(this.editorView));
      this.dom.contentEditable = "false";
    }
  }
  getSide() {
    return this.side;
  }
  merge(from, to, source, openStart, openEnd) {
    if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  become(other) {
    if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
      if (this.widget.constructor == other.widget.constructor) {
        if (!this.widget.eq(other.widget))
          this.markDirty(true);
        this.widget = other.widget;
        return true;
      }
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Text.empty;
    let top2 = this;
    while (top2.parent)
      top2 = top2.parent;
    let view = top2.editorView, text = view && view.state.doc, start = this.posAtStart;
    return text ? text.slice(start, start + this.length) : Text.empty;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos, side) {
    let rects = this.dom.getClientRects(), rect = null;
    if (!rects.length)
      return Rect0;
    for (let i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {
      rect = rects[i];
      if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
        break;
    }
    return pos == 0 && side > 0 || pos == this.length && side <= 0 ? rect : flattenRect(rect, pos == 0);
  }
};
var CompositionView = class extends WidgetView {
  domAtPos(pos) {
    return new DOMPos(this.widget.text, pos);
  }
  sync() {
    if (!this.dom)
      this.setDOM(this.widget.toDOM());
  }
  localPosFromDOM(node, offset) {
    return !offset ? 0 : node.nodeType == 3 ? Math.min(offset, this.length) : this.length;
  }
  ignoreMutation() {
    return false;
  }
  get overrideDOMText() {
    return null;
  }
  coordsAt(pos, side) {
    return textCoords(this.widget.text, pos, side);
  }
};
function mergeInlineChildren(parent, from, to, elts, openStart, openEnd) {
  let cur2 = parent.childCursor();
  let {i: toI, off: toOff} = cur2.findPos(to, 1);
  let {i: fromI, off: fromOff} = cur2.findPos(from, -1);
  let dLen = from - to;
  for (let view of elts)
    dLen += view.length;
  parent.length += dLen;
  let {children} = parent;
  if (fromI == toI && fromOff) {
    let start = children[fromI];
    if (elts.length == 1 && start.merge(fromOff, toOff, elts[0], openStart, openEnd))
      return;
    if (elts.length == 0) {
      start.merge(fromOff, toOff, null, openStart, openEnd);
      return;
    }
    let after = start.slice(toOff);
    if (after.merge(0, 0, elts[elts.length - 1], 0, openEnd))
      elts[elts.length - 1] = after;
    else
      elts.push(after);
    toI++;
    openEnd = toOff = 0;
  }
  if (toOff) {
    let end = children[toI];
    if (elts.length && end.merge(0, toOff, elts[elts.length - 1], 0, openEnd)) {
      elts.pop();
      openEnd = elts.length ? 0 : openStart;
    } else {
      end.merge(0, toOff, null, 0, 0);
    }
  } else if (toI < children.length && elts.length && children[toI].merge(0, 0, elts[elts.length - 1], 0, openEnd)) {
    elts.pop();
    openEnd = elts.length ? 0 : openStart;
  }
  if (fromOff) {
    let start = children[fromI];
    if (elts.length && start.merge(fromOff, start.length, elts[0], openStart, 0)) {
      elts.shift();
      openStart = elts.length ? 0 : openEnd;
    } else {
      start.merge(fromOff, start.length, null, 0, 0);
    }
    fromI++;
  } else if (fromI && elts.length) {
    let end = children[fromI - 1];
    if (end.merge(end.length, end.length, elts[0], openStart, 0)) {
      elts.shift();
      openStart = elts.length ? 0 : openEnd;
    }
  }
  while (fromI < toI && elts.length && children[toI - 1].become(elts[elts.length - 1])) {
    elts.pop();
    toI--;
    openEnd = elts.length ? 0 : openStart;
  }
  while (fromI < toI && elts.length && children[fromI].become(elts[0])) {
    elts.shift();
    fromI++;
    openStart = elts.length ? 0 : openEnd;
  }
  if (!elts.length && fromI && toI < children.length && openStart && openEnd && children[toI].merge(0, 0, children[fromI - 1], openStart, openEnd))
    fromI--;
  if (elts.length || fromI != toI)
    parent.replaceChildren(fromI, toI, elts);
}
function sliceInlineChildren(children, from) {
  let result = [], off = 0;
  for (let elt of children) {
    let end = off + elt.length;
    if (end > from)
      result.push(off < from ? elt.slice(from - off) : elt);
    off = end;
  }
  return result;
}
function inlineDOMAtPos(dom, children, pos) {
  let i = 0;
  for (let off = 0; i < children.length; i++) {
    let child = children[i], end = off + child.length;
    if (end == off && child.getSide() <= 0)
      continue;
    if (pos > off && pos < end && child.dom.parentNode == dom)
      return child.domAtPos(pos - off);
    if (pos <= off)
      break;
    off = end;
  }
  for (; i > 0; i--) {
    let before = children[i - 1].dom;
    if (before.parentNode == dom)
      return DOMPos.after(before);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
  let last, {children} = parent;
  if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
    joinInlineInto(last, view.children[0], open - 1);
  } else {
    children.push(view);
    view.setParent(parent);
  }
  parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
  for (let off = 0, i = 0; i < view.children.length; i++) {
    let child = view.children[i], end = off + child.length;
    if (end == off && child.getSide() <= 0)
      continue;
    if (side <= 0 || end == view.length ? end >= pos : end > pos)
      return child.coordsAt(pos - off, side);
    off = end;
  }
  let last = view.dom.lastChild;
  if (!last)
    return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last);
  return rects[rects.length - 1];
}
function combineAttrs(source, target) {
  for (let name2 in source) {
    if (name2 == "class" && target.class)
      target.class += " " + source.class;
    else if (name2 == "style" && target.style)
      target.style += ";" + source.style;
    else
      target[name2] = source[name2];
  }
  return target;
}
function attrsEq(a, b) {
  if (a == b)
    return true;
  if (!a || !b)
    return false;
  let keysA = Object.keys(a), keysB = Object.keys(b);
  if (keysA.length != keysB.length)
    return false;
  for (let key of keysA) {
    if (keysB.indexOf(key) == -1 || a[key] !== b[key])
      return false;
  }
  return true;
}
function updateAttrs(dom, prev, attrs) {
  if (prev) {
    for (let name2 in prev)
      if (!(attrs && name2 in attrs))
        dom.removeAttribute(name2);
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev && prev[name2] == attrs[name2]))
        dom.setAttribute(name2, attrs[name2]);
  }
}
var WidgetType = class {
  eq(_widget) {
    return false;
  }
  updateDOM(_dom) {
    return false;
  }
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent(_event) {
    return true;
  }
  get customView() {
    return null;
  }
};
var BlockType = /* @__PURE__ */ function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
}(BlockType || (BlockType = {}));
var Decoration = class extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  get heightRelevant() {
    return false;
  }
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  static widget(spec) {
    let side = spec.side || 0;
    if (spec.block)
      side += (2e8 + 1) * (side > 0 ? 1 : -1);
    return new PointDecoration(spec, side, side, !!spec.block, spec.widget || null, false);
  }
  static replace(spec) {
    let block = !!spec.block;
    let {start, end} = getInclusive(spec);
    let startSide = block ? -2e8 * (start ? 2 : 1) : 1e8 * (start ? -1 : 1);
    let endSide = block ? 2e8 * (end ? 2 : 1) : 1e8 * (end ? 1 : -1);
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  static line(spec) {
    return new LineDecoration(spec);
  }
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
};
Decoration.none = RangeSet.empty;
var MarkDecoration = class extends Decoration {
  constructor(spec) {
    let {start, end} = getInclusive(spec);
    super(1e8 * (start ? -1 : 1), 1e8 * (end ? 1 : -1), null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }
  eq(other) {
    return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
  }
  range(from, to = from) {
    if (from >= to)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to);
  }
};
MarkDecoration.prototype.point = false;
var LineDecoration = class extends Decoration {
  constructor(spec) {
    super(-1e8, -1e8, null, spec);
  }
  eq(other) {
    return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from, to = from) {
    if (to != from)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to);
  }
};
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
var PointDecoration = class extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? MapMode.TrackDel : startSide < 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  get type() {
    return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide < 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
  }
  eq(other) {
    return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from, to = from) {
    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide < 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to != from)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to);
  }
};
PointDecoration.prototype.point = true;
function getInclusive(spec) {
  let {inclusiveStart: start, inclusiveEnd: end} = spec;
  if (start == null)
    start = spec.inclusive;
  if (end == null)
    end = spec.inclusive;
  return {start: start || false, end: end || false};
}
function widgetsEq(a, b) {
  return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
  let last = ranges.length - 1;
  if (last >= 0 && ranges[last] + margin > from)
    ranges[last] = Math.max(ranges[last], to);
  else
    ranges.push(from, to);
}
var LineView = class extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = void 0;
    this.attrs = null;
    this.breakAfter = 0;
  }
  merge(from, to, source, takeDeco, openStart, openEnd) {
    if (source) {
      if (!(source instanceof LineView))
        return false;
      if (!this.dom)
        source.transferDOM(this);
    }
    if (takeDeco)
      this.setDeco(source ? source.attrs : null);
    mergeInlineChildren(this, from, to, source ? source.children : none$1, openStart, openEnd);
    return true;
  }
  split(at) {
    let end = new LineView();
    end.breakAfter = this.breakAfter;
    if (this.length == 0)
      return end;
    let {i, off} = this.childPos(at);
    if (off) {
      end.append(this.children[i].slice(off), 0);
      this.children[i].merge(off, this.children[i].length, null, 0, 0);
      i++;
    }
    for (let j = i; j < this.children.length; j++)
      end.append(this.children[j], 0);
    while (i > 0 && this.children[i - 1].length == 0) {
      this.children[i - 1].parent = null;
      i--;
    }
    this.children.length = i;
    this.markDirty();
    this.length = at;
    return end;
  }
  transferDOM(other) {
    if (!this.dom)
      return;
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
    this.prevAttrs = void 0;
    this.dom = null;
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }
      this.attrs = attrs;
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  }
  addLineDeco(deco) {
    let attrs = deco.spec.attributes;
    if (attrs)
      this.attrs = combineAttrs(attrs, this.attrs || {});
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this.dom, this.children, pos);
  }
  sync(track) {
    if (!this.dom) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    }
    if (this.prevAttrs !== void 0) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = void 0;
    }
    super.sync(track);
    let last = this.dom.lastChild;
    if (!last || last.nodeName != "BR" && ContentView.get(last) instanceof WidgetView && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let totalWidth = 0;
    for (let child of this.children) {
      if (!(child instanceof TextView))
        return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1)
        return null;
      totalWidth += rects[0].width;
    }
    return {lineHeight: this.dom.getBoundingClientRect().height, charWidth: totalWidth / this.length};
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
  match(_other) {
    return false;
  }
  get type() {
    return BlockType.Text;
  }
  static find(docView, pos) {
    for (let i = 0, off = 0; ; i++) {
      let block = docView.children[i], end = off + block.length;
      if (end >= pos) {
        if (block instanceof LineView)
          return block;
        if (block.length)
          return null;
      }
      off = end + block.breakAfter;
    }
  }
};
var none$1 = [];
var BlockWidgetView = class extends ContentView {
  constructor(widget, length, type) {
    super();
    this.widget = widget;
    this.length = length;
    this.type = type;
    this.breakAfter = 0;
  }
  merge(from, to, source, _takeDeco, openStart, openEnd) {
    if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  split(at) {
    let len = this.length - at;
    this.length = at;
    return new BlockWidgetView(this.widget, len, this.type);
  }
  get children() {
    return none$1;
  }
  sync() {
    if (!this.dom || !this.widget.updateDOM(this.dom)) {
      this.setDOM(this.widget.toDOM(this.editorView));
      this.dom.contentEditable = "false";
    }
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
  }
  domBoundsAround() {
    return null;
  }
  match(other) {
    if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.eq(this.widget))
        this.markDirty(true);
      this.widget = other.widget;
      this.length = other.length;
      this.breakAfter = other.breakAfter;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
};
var ContentBuilder = class {
  constructor(doc2, pos, end) {
    this.doc = doc2;
    this.pos = pos;
    this.end = end;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
    this.skip = pos;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last = this.content[this.content.length - 1];
    return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
  }
  getLine() {
    if (!this.curLine)
      this.content.push(this.curLine = new LineView());
    return this.curLine;
  }
  addWidget(view) {
    this.curLine = null;
    this.content.push(view);
  }
  finish() {
    if (!this.posCovered())
      this.getLine();
  }
  wrapMarks(view, active) {
    for (let i = active.length - 1; i >= 0; i--)
      view = new MarkView(active[i], [view], view.length);
    return view;
  }
  buildText(length, active, openStart) {
    while (length > 0) {
      if (this.textOff == this.text.length) {
        let {value, lineBreak, done} = this.cursor.next(this.skip);
        this.skip = 0;
        if (done)
          throw new Error("Ran out of text content when drawing inline views");
        if (lineBreak) {
          if (!this.posCovered())
            this.getLine();
          if (this.content.length)
            this.content[this.content.length - 1].breakAfter = 1;
          else
            this.breakAtStart = 1;
          this.curLine = null;
          length--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }
      let take = Math.min(this.text.length - this.textOff, length, 512);
      this.getLine().append(this.wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
      this.textOff += take;
      length -= take;
      openStart = 0;
    }
  }
  span(from, to, active, openStart) {
    this.buildText(to - from, active, openStart);
    this.pos = to;
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  point(from, to, deco, active, openStart) {
    let len = to - from;
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        let {type} = deco;
        if (type == BlockType.WidgetAfter && !this.posCovered())
          this.getLine();
        this.addWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
      } else {
        let widget = this.wrapMarks(WidgetView.create(deco.widget || new NullWidget("span"), len, deco.startSide), active);
        this.getLine().append(widget, openStart);
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco);
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }
      this.pos = to;
    }
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  static build(text, from, to, decorations2) {
    let builder = new ContentBuilder(text, from, to);
    builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
    if (builder.openStart < 0)
      builder.openStart = builder.openEnd;
    builder.finish();
    return builder;
  }
};
var NullWidget = class extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt) {
    return elt.nodeName.toLowerCase() == this.tag;
  }
};
var none2 = [];
var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
var exceptionSink = /* @__PURE__ */ Facet.define();
var updateListener = /* @__PURE__ */ Facet.define();
var inputHandler = /* @__PURE__ */ Facet.define();
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror)
    window.onerror(String(exception), context, void 0, void 0, exception);
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
var editable = /* @__PURE__ */ Facet.define({combine: (values) => values.length ? values[0] : true});
var PluginFieldProvider = class {
  constructor(field, get2) {
    this.field = field;
    this.get = get2;
  }
};
var PluginField = class {
  from(get2) {
    return new PluginFieldProvider(this, get2);
  }
  static define() {
    return new PluginField();
  }
};
PluginField.decorations = /* @__PURE__ */ PluginField.define();
PluginField.scrollMargins = /* @__PURE__ */ PluginField.define();
var nextPluginID = 0;
var viewPlugin = /* @__PURE__ */ Facet.define();
var ViewPlugin = class {
  constructor(id, create, fields) {
    this.id = id;
    this.create = create;
    this.fields = fields;
    this.extension = viewPlugin.of(this);
  }
  static define(create, spec) {
    let {eventHandlers, provide, decorations: decorations2} = spec || {};
    let fields = [];
    if (provide)
      for (let provider of Array.isArray(provide) ? provide : [provide])
        fields.push(provider);
    if (eventHandlers)
      fields.push(domEventHandlers.from((value) => ({plugin: value, handlers: eventHandlers})));
    if (decorations2)
      fields.push(PluginField.decorations.from(decorations2));
    return new ViewPlugin(nextPluginID++, create, fields);
  }
  static fromClass(cls, spec) {
    return ViewPlugin.define((view) => new cls(view), spec);
  }
};
var domEventHandlers = /* @__PURE__ */ PluginField.define();
var PluginInstance = class {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  takeField(type, target) {
    for (let {field, get: get2} of this.spec.fields)
      if (field == type)
        target.push(get2(this.value));
  }
  update(view) {
    if (!this.value) {
      try {
        this.value = this.spec.create(view);
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
        return PluginInstance.dummy;
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (!this.value.update)
        return this;
      try {
        this.value.update(update);
      } catch (e) {
        logException(update.state, e, "CodeMirror plugin crashed");
        if (this.value.destroy)
          try {
            this.value.destroy();
          } catch (_) {
          }
        return PluginInstance.dummy;
      }
    }
    return this;
  }
  destroy(view) {
    var _a;
    if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
      try {
        this.value.destroy();
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
      }
    }
  }
};
PluginInstance.dummy = /* @__PURE__ */ new PluginInstance(/* @__PURE__ */ ViewPlugin.define(() => ({})));
var editorAttributes = /* @__PURE__ */ Facet.define({
  combine: (values) => values.reduce((a, b) => combineAttrs(b, a), {})
});
var contentAttributes = /* @__PURE__ */ Facet.define({
  combine: (values) => values.reduce((a, b) => combineAttrs(b, a), {})
});
var decorations = /* @__PURE__ */ Facet.define();
var styleModule = /* @__PURE__ */ Facet.define();
var ChangedRange = class {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set) {
    let i = set.length, me = this;
    for (; i > 0; i--) {
      let range = set[i - 1];
      if (range.fromA > me.toA)
        continue;
      if (range.toA < me.fromA)
        break;
      me = me.join(range);
      set.splice(i - 1, 1);
    }
    set.splice(i, 0, me);
    return set;
  }
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0)
      return diff;
    let result = [];
    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
      let next = dI == diff.length ? null : diff[dI], off = posA - posB;
      let end = next ? next.fromB : 1e9;
      while (rI < ranges.length && ranges[rI] < end) {
        let from = ranges[rI], to = ranges[rI + 1];
        let fromB = Math.max(posB, from), toB = Math.min(end, to);
        if (fromB <= toB)
          new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
        if (to > end)
          break;
        else
          rI += 2;
      }
      if (!next)
        return result;
      new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
      posA = next.toA;
      posB = next.toB;
    }
  }
};
var ViewUpdate = class {
  constructor(view, state, transactions = none2) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr of transactions)
      this.changes = this.changes.compose(tr.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      view.inputState.notifiedFocused = focus;
      this.flags |= 1;
    }
    if (this.docChanged)
      this.flags |= 2;
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & (16 | 2)) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return this.transactions.some((tr) => tr.docChanged);
  }
  get selectionSet() {
    return this.transactions.some((tr) => tr.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
};
var DocView = class extends ContentView {
  constructor(view) {
    super();
    this.view = view;
    this.compositionDeco = Decoration.none;
    this.decorations = [];
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], this.updateDeco(), 0);
  }
  get root() {
    return this.view.root;
  }
  get editorView() {
    return this.view;
  }
  get length() {
    return this.view.state.doc.length;
  }
  update(update) {
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({fromA, toA}) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    if (this.view.inputState.composing < 0)
      this.compositionDeco = Decoration.none;
    else if (update.transactions.length)
      this.compositionDeco = computeCompositionDeco(this.view, update.changes);
    let forceSelection = (browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines;
    let prevDeco = this.decorations, deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    let pointerSel = update.transactions.some((tr) => tr.annotation(Transaction.userEvent) == "pointerselection");
    if (this.dirty == 0 && changedRanges.length == 0 && !(update.flags & (4 | 8)) && update.state.selection.main.from >= this.view.viewport.from && update.state.selection.main.to <= this.view.viewport.to) {
      this.updateSelection(forceSelection, pointerSel);
      return false;
    } else {
      this.updateInner(changedRanges, deco, update.startState.doc.length, forceSelection, pointerSel);
      return true;
    }
  }
  updateInner(changes, deco, oldLength, forceSelection = false, pointerSel = false) {
    this.updateChildren(changes, deco, oldLength);
    let {observer} = this.view;
    observer.ignore(() => {
      this.dom.style.height = this.view.viewState.domHeight + "px";
      this.dom.style.minWidth = this.minWidth ? this.minWidth + "px" : "";
      let track = browser.chrome || browser.ios ? {node: observer.selectionRange.focusNode, written: false} : void 0;
      this.sync(track);
      this.dirty = 0;
      if (track && (track.written || observer.selectionRange.focusNode != track.node))
        forceSelection = true;
      this.updateSelection(forceSelection, pointerSel);
      this.dom.style.height = "";
    });
  }
  updateChildren(changes, deco, oldLength) {
    let cursor = this.childCursor(oldLength);
    for (let i = changes.length - 1; ; i--) {
      let next = i >= 0 ? changes[i] : null;
      if (!next)
        break;
      let {fromA, toA, fromB, toB} = next;
      let {content: content2, breakAtStart, openStart, openEnd} = ContentBuilder.build(this.view.state.doc, fromB, toB, deco);
      let {i: toI, off: toOff} = cursor.findPos(toA, 1);
      let {i: fromI, off: fromOff} = cursor.findPos(fromA, -1);
      this.replaceRange(fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
    }
  }
  replaceRange(fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd) {
    let before = this.children[fromI], last = content2.length ? content2[content2.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    if (fromI == toI && !breakAtStart && !breakAtEnd && content2.length < 2 && before.merge(fromOff, toOff, content2.length ? last : null, fromOff == 0, openStart, openEnd))
      return;
    let after = this.children[toI];
    if (toOff < after.length || after.children.length && after.children[after.children.length - 1].length == 0) {
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
        content2[content2.length - 1] = after;
      } else {
        if (toOff || after.children.length && after.children[0].length == 0)
          after.merge(0, toOff, null, false, 0, openEnd);
        content2.push(after);
      }
    } else if (after.breakAfter) {
      if (last)
        last.breakAfter = 1;
      else
        breakAtStart = 1;
    }
    toI++;
    before.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && content2.length && before.merge(fromOff, before.length, content2[0], false, openStart, 0)) {
        before.breakAfter = content2.shift().breakAfter;
      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
        before.merge(fromOff, before.length, null, false, openStart, 0);
      }
      fromI++;
    }
    while (fromI < toI && content2.length) {
      if (this.children[toI - 1].match(content2[content2.length - 1]))
        toI--, content2.pop();
      else if (this.children[fromI].match(content2[0]))
        fromI++, content2.shift();
      else
        break;
    }
    if (fromI < toI || content2.length)
      this.replaceChildren(fromI, toI, content2);
  }
  updateSelection(force = false, fromPointer = false) {
    if (!(fromPointer || this.mayControlSelection()))
      return;
    let main = this.view.state.selection.main;
    let anchor = this.domAtPos(main.anchor);
    let head = main.empty ? anchor : this.domAtPos(main.head);
    if (browser.gecko && main.empty && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || browser.gecko && main.empty && nextToUneditable(domSel.focusNode, domSel.focusOffset) || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
      this.view.observer.ignore(() => {
        let rawSel = getSelection(this.root);
        if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
              if (text)
                anchor = new DOMPos(text, nextTo == 1 ? 0 : text.nodeValue.length);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
            domSel.cursorBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          rawSel.extend(head.node, head.offset);
        } else {
          let range = document.createRange();
          if (main.anchor > main.head)
            [anchor, head] = [head, anchor];
          range.setEnd(head.node, head.offset);
          range.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range);
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  enforceCursorAssoc() {
    let cursor = this.view.state.selection.main;
    let sel = getSelection(this.root);
    if (!cursor.empty || !cursor.assoc || !sel.modify)
      return;
    let line = LineView.find(this, cursor.head);
    if (!line)
      return;
    let lineStart = line.posAtStart;
    if (cursor.head == lineStart || cursor.head == lineStart + line.length)
      return;
    let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
    if (!before || !after || before.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor.head + cursor.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
  }
  mayControlSelection() {
    return this.view.state.facet(editable) ? this.root.activeElement == this.dom : hasSelection(this.dom, this.view.observer.selectionRange);
  }
  nearest(dom) {
    for (let cur2 = dom; cur2; ) {
      let domView = ContentView.get(cur2);
      if (domView && domView.rootView == this)
        return domView;
      cur2 = cur2.parentNode;
    }
    return null;
  }
  posFromDOM(node, offset) {
    let view = this.nearest(node);
    if (!view)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node, offset) + view.posAtStart;
  }
  domAtPos(pos) {
    let {i, off} = this.childCursor().findPos(pos, -1);
    for (; i < this.children.length - 1; ) {
      let child = this.children[i];
      if (off < child.length || child instanceof LineView)
        break;
      i++;
      off = 0;
    }
    return this.children[i].domAtPos(off);
  }
  coordsAt(pos, side) {
    for (let off = this.length, i = this.children.length - 1; ; i--) {
      let child = this.children[i], start = off - child.breakAfter - child.length;
      if (pos > start || pos == start && (child.type == BlockType.Text || !i || this.children[i - 1].breakAfter))
        return child.coordsAt(pos - start, side);
      off = start;
    }
  }
  measureVisibleLineHeights() {
    let result = [], {from, to} = this.view.viewState.viewport;
    let minWidth = Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    for (let pos = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (end > to)
        break;
      if (pos >= from) {
        result.push(child.dom.getBoundingClientRect().height);
        let width = child.dom.scrollWidth;
        if (width > minWidth) {
          this.minWidth = minWidth = width;
          this.minWidthFrom = pos;
          this.minWidthTo = end;
        }
      }
      pos = end + child.breakAfter;
    }
    return result;
  }
  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure)
          return measure;
      }
    }
    let dummy = document.createElement("div"), lineHeight, charWidth;
    dummy.className = "cm-line";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect ? rect.width / 27 : 7;
      dummy.remove();
    });
    return {lineHeight, charWidth};
  }
  childCursor(pos = this.length) {
    let i = this.children.length;
    if (i)
      pos -= this.children[--i].length;
    return new ChildCursor(this.children, pos, i);
  }
  computeBlockGapDeco() {
    let deco = [], vs = this.view.viewState;
    for (let pos = 0, i = 0; ; i++) {
      let next = i == vs.viewports.length ? null : vs.viewports[i];
      let end = next ? next.from - 1 : this.length;
      if (end > pos) {
        let height = vs.lineAt(end, 0).bottom - vs.lineAt(pos, 0).top;
        deco.push(Decoration.replace({widget: new BlockGapWidget(height), block: true, inclusive: true}).range(pos, end));
      }
      if (!next)
        break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    return this.decorations = [
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco,
      this.compositionDeco,
      ...this.view.state.facet(decorations),
      ...this.view.pluginField(PluginField.decorations)
    ];
  }
  scrollPosIntoView(pos, side) {
    let rect = this.coordsAt(pos, side);
    if (!rect)
      return;
    let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
    for (let margins of this.view.pluginField(PluginField.scrollMargins))
      if (margins) {
        let {left, right, top: top2, bottom} = margins;
        if (left != null)
          mLeft = Math.max(mLeft, left);
        if (right != null)
          mRight = Math.max(mRight, right);
        if (top2 != null)
          mTop = Math.max(mTop, top2);
        if (bottom != null)
          mBottom = Math.max(mBottom, bottom);
      }
    scrollRectIntoView(this.dom, {
      left: rect.left - mLeft,
      top: rect.top - mTop,
      right: rect.right + mRight,
      bottom: rect.bottom + mBottom
    });
  }
};
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset < pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
var BlockGapWidget = class extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt = document.createElement("div");
    this.updateDOM(elt);
    return elt;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt) {
    elt.style.height = this.height + "px";
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
};
function computeCompositionDeco(view, changes) {
  let sel = view.observer.selectionRange;
  let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
  if (!textNode)
    return Decoration.none;
  let cView = view.docView.nearest(textNode);
  let from, to, topNode = textNode;
  if (cView instanceof InlineView) {
    while (cView.parent instanceof InlineView)
      cView = cView.parent;
    from = cView.posAtStart;
    to = from + cView.length;
    topNode = cView.dom;
  } else if (cView instanceof LineView) {
    while (topNode.parentNode != cView.dom)
      topNode = topNode.parentNode;
    let prev = topNode.previousSibling;
    while (prev && !ContentView.get(prev))
      prev = prev.previousSibling;
    from = to = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
  } else {
    return Decoration.none;
  }
  let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
  let text = textNode.nodeValue, {state} = view;
  if (newTo - newFrom < text.length) {
    if (state.sliceDoc(newFrom, Math.min(state.doc.length, newFrom + text.length)) == text)
      newTo = newFrom + text.length;
    else if (state.sliceDoc(Math.max(0, newTo - text.length), newTo) == text)
      newFrom = newTo - text.length;
    else
      return Decoration.none;
  } else if (state.sliceDoc(newFrom, newTo) != text) {
    return Decoration.none;
  }
  return Decoration.set(Decoration.replace({widget: new CompositionWidget(topNode, textNode)}).range(newFrom, newTo));
}
var CompositionWidget = class extends WidgetType {
  constructor(top2, text) {
    super();
    this.top = top2;
    this.text = text;
  }
  eq(other) {
    return this.top == other.top && this.text == other.text;
  }
  toDOM() {
    return this.top;
  }
  ignoreEvent() {
    return false;
  }
  get customView() {
    return CompositionView;
  }
};
function nearbyTextNode(node, offset, side) {
  for (; ; ) {
    if (node.nodeType == 3)
      return node;
    if (node.nodeType == 1 && offset > 0 && side <= 0) {
      node = node.childNodes[offset - 1];
      offset = maxOffset(node);
    } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
      node = node.childNodes[offset];
      offset = 0;
    } else {
      return null;
    }
  }
}
function nextToUneditable(node, offset) {
  if (node.nodeType != 1)
    return 0;
  return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
var DecorationComparator$1 = class {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to) {
    addRange(from, to, this.changes);
  }
  comparePoint(from, to) {
    addRange(from, to, this.changes);
  }
};
function findChangedDeco(a, b, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a, b, diff, comp);
  return comp.changes;
}
var Direction = /* @__PURE__ */ function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
}(Direction || (Direction = {}));
var LTR = Direction.LTR;
var RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i = 0; i < str.length; i++)
    result.push(1 << +str[i]);
  return result;
}
var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
var Brackets = /* @__PURE__ */ Object.create(null);
var BracketStack = [];
for (let p of ["()", "[]", "{}"]) {
  let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
  Brackets[l] = r;
  Brackets[r] = -l;
}
function charType(ch) {
  return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8203 ? 256 : ch == 8204 ? 256 : 1;
}
var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
var BidiSpan = class {
  constructor(from, to, level) {
    this.from = from;
    this.to = to;
    this.level = level;
  }
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  static find(order, index2, level, assoc) {
    let maybe = -1;
    for (let i = 0; i < order.length; i++) {
      let span = order[i];
      if (span.from <= index2 && span.to >= index2) {
        if (span.level == level)
          return i;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index2 : span.to > index2 : order[maybe].level > span.level))
          maybe = i;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
};
var types2 = [];
function computeOrder(line, direction) {
  let len = line.length, outerType = direction == LTR ? 1 : 2, oppositeType = direction == LTR ? 2 : 1;
  if (!line || outerType == 1 && !BidiRE.test(line))
    return trivialOrder(len);
  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
    let type = charType(line.charCodeAt(i));
    if (type == 512)
      type = prev;
    else if (type == 8 && prevStrong == 4)
      type = 16;
    types2[i] = type == 4 ? 2 : type;
    if (type & 7)
      prevStrong = type;
    prev = type;
  }
  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
    let type = types2[i];
    if (type == 128) {
      if (i < len - 1 && prev == types2[i + 1] && prev & 24)
        type = types2[i] = prev;
      else
        types2[i] = 256;
    } else if (type == 64) {
      let end = i + 1;
      while (end < len && types2[end] == 64)
        end++;
      let replace = i && prev == 8 || end < len && types2[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
      for (let j = i; j < end; j++)
        types2[j] = replace;
      i = end - 1;
    } else if (type == 8 && prevStrong == 1) {
      types2[i] = 1;
    }
    prev = type;
    if (type & 7)
      prevStrong = type;
  }
  for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {
    if (br = Brackets[ch = line.charCodeAt(i)]) {
      if (br < 0) {
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          if (BracketStack[sJ + 1] == -br) {
            let flags = BracketStack[sJ + 2];
            let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
            if (type2)
              types2[i] = types2[BracketStack[sJ]] = type2;
            sI = sJ;
            break;
          }
        }
      } else if (BracketStack.length == 189) {
        break;
      } else {
        BracketStack[sI++] = i;
        BracketStack[sI++] = ch;
        BracketStack[sI++] = context;
      }
    } else if ((type = types2[i]) == 2 || type == 1) {
      let embed = type == outerType;
      context = embed ? 0 : 1;
      for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
        let cur2 = BracketStack[sJ + 2];
        if (cur2 & 2)
          break;
        if (embed) {
          BracketStack[sJ + 2] |= 2;
        } else {
          if (cur2 & 4)
            break;
          BracketStack[sJ + 2] |= 4;
        }
      }
    }
  }
  for (let i = 0; i < len; i++) {
    if (types2[i] == 256) {
      let end = i + 1;
      while (end < len && types2[end] == 256)
        end++;
      let beforeL = (i ? types2[i - 1] : outerType) == 1;
      let afterL = (end < len ? types2[end] : outerType) == 1;
      let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
      for (let j = i; j < end; j++)
        types2[j] = replace;
      i = end - 1;
    }
  }
  let order = [];
  if (outerType == 1) {
    for (let i = 0; i < len; ) {
      let start = i, rtl = types2[i++] != 1;
      while (i < len && rtl == (types2[i] != 1))
        i++;
      if (rtl) {
        for (let j = i; j > start; ) {
          let end = j, l = types2[--j] != 2;
          while (j > start && l == (types2[j - 1] != 2))
            j--;
          order.push(new BidiSpan(j, end, l ? 2 : 1));
        }
      } else {
        order.push(new BidiSpan(start, i, 0));
      }
    }
  } else {
    for (let i = 0; i < len; ) {
      let start = i, rtl = types2[i++] == 2;
      while (i < len && rtl == (types2[i] == 2))
        i++;
      order.push(new BidiSpan(start, i, rtl ? 1 : 2));
    }
  }
  return order;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
var movedOver = "";
function moveVisually(line, order, dir, start, forward) {
  var _a;
  let startIndex = start.head - line.from, spanI = -1;
  if (startIndex == 0) {
    if (!forward || !line.length)
      return null;
    if (order[0].level != dir) {
      startIndex = order[0].side(false, dir);
      spanI = 0;
    }
  } else if (startIndex == line.length) {
    if (forward)
      return null;
    let last = order[order.length - 1];
    if (last.level != dir) {
      startIndex = last.side(true, dir);
      spanI = order.length - 1;
    }
  }
  if (spanI < 0)
    spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
  let span = order[spanI];
  if (startIndex == span.side(forward, dir)) {
    span = order[spanI += forward ? 1 : -1];
    startIndex = span.side(!forward, dir);
  }
  let indexForward = forward == (span.dir == dir);
  let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  if (nextIndex != span.side(forward, dir))
    return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (!nextSpan && span.level != dir)
    return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
  if (nextSpan && nextSpan.level < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line.length)
    bias = -1;
  let from = linePos, to = linePos;
  if (bias < 0)
    from = findClusterBreak(line.text, linePos, false);
  else
    to = findClusterBreak(line.text, linePos);
  let cat = categorize(line.text.slice(from, to));
  while (from > 0) {
    let prev = findClusterBreak(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat)
      break;
    from = prev;
  }
  while (to < line.length) {
    let next = findClusterBreak(line.text, to);
    if (categorize(line.text.slice(to, next)) != cat)
      break;
    to = next;
  }
  return EditorSelection.range(from + line.from, to + line.from);
}
function getdx(x, rect) {
  return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
  return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top2) {
  return top2 < rect.top ? {top: top2, left: rect.left, right: rect.right, bottom: rect.bottom} : rect;
}
function upBot(rect, bottom) {
  return bottom > rect.bottom ? {top: rect.top, left: rect.left, right: rect.right, bottom} : rect;
}
function domPosAtCoords(parent, x, y) {
  let closest, closestRect, closestX, closestY;
  let above, below, aboveRect, belowRect;
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (closestRect && yOverlap(closestRect, rect))
        rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
      let dx = getdx(x, rect), dy = getdy(y, rect);
      if (dx == 0 && dy == 0)
        return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
      if (!closest || closestY > dy || closestY == dy && closestX > dx) {
        closest = child;
        closestRect = rect;
        closestX = dx;
        closestY = dy;
      }
      if (dx == 0) {
        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child;
          aboveRect = rect;
        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child;
          belowRect = rect;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom);
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest)
    return {node: parent, offset: 0};
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
  if (closest.nodeType == 3)
    return domPosInText(closest, clipX, y);
  if (!closestX && closest.contentEditable == "true")
    return domPosAtCoords(closest, clipX, y);
  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return {node: parent, offset};
}
function domPosInText(node, x, y) {
  let len = node.nodeValue.length;
  let closestOffset = -1, closestDY = 1e9, generalSide = 0;
  for (let i = 0; i < len; i++) {
    let rects = textRange(node, i, i + 1).getClientRects();
    for (let j = 0; j < rects.length; j++) {
      let rect = rects[j];
      if (rect.top == rect.bottom)
        continue;
      if (!generalSide)
        generalSide = x - rect.left;
      let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
      if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
        let right = x >= (rect.left + rect.right) / 2, after = right;
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node, i).getBoundingClientRect();
          if (rectBefore.left == rect.right)
            after = !right;
        }
        if (dy <= 0)
          return {node, offset: i + (after ? 1 : 0)};
        closestOffset = i + (after ? 1 : 0);
        closestDY = dy;
      }
    }
  }
  return {node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0};
}
function posAtCoords(view, {x, y}, bias = -1) {
  let content2 = view.contentDOM.getBoundingClientRect(), block;
  let halfLine = view.defaultLineHeight / 2;
  for (let bounced = false; ; ) {
    block = view.blockAtHeight(y, content2.top);
    if (block.top > y || block.bottom < y) {
      bias = block.top > y ? -1 : 1;
      y = Math.min(block.bottom - halfLine, Math.max(block.top + halfLine, y));
      if (bounced)
        return -1;
      else
        bounced = true;
    }
    if (block.type == BlockType.Text)
      break;
    y = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
  }
  let lineStart = block.from;
  if (lineStart < view.viewport.from)
    return view.viewport.from == 0 ? 0 : null;
  if (lineStart > view.viewport.to)
    return view.viewport.to == view.state.doc.length ? view.state.doc.length : null;
  x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
  let root = view.root, element = root.elementFromPoint(x, y);
  let node, offset = -1;
  if (element && view.contentDOM.contains(element) && !(view.docView.nearest(element) instanceof WidgetView)) {
    if (root.caretPositionFromPoint) {
      let pos = root.caretPositionFromPoint(x, y);
      if (pos)
        ({offsetNode: node, offset} = pos);
    } else if (root.caretRangeFromPoint) {
      let range = root.caretRangeFromPoint(x, y);
      if (range) {
        ({startContainer: node, startOffset: offset} = range);
        if (browser.safari && isSuspiciousCaretResult(node, offset, x))
          node = void 0;
      }
    }
  }
  if (!node || !view.docView.dom.contains(node)) {
    let line = LineView.find(view.docView, lineStart);
    ({node, offset} = domPosAtCoords(line.dom, x, y));
  }
  return view.docView.posFromDOM(node, offset);
}
function isSuspiciousCaretResult(node, offset, x) {
  let len;
  if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
    return false;
  for (let next = node.nextSibling; next; next = node.nextSibling)
    if (next.nodeType != 1 || next.nodeName != "BR")
      return false;
  return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = view.state.doc.lineAt(start.head);
  let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let pos = view.posAtCoords({
      x: forward == (view.textDirection == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  let lineView = LineView.find(view.docView, start.head);
  let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
  return EditorSelection.cursor(end, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
  for (let cur2 = start, check = null; ; ) {
    let next = moveVisually(line, spans, view.textDirection, cur2, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1))
        return cur2;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = EditorSelection.cursor(forward ? line.from : line.to);
    }
    if (!check) {
      if (!by)
        return next;
      check = by(char);
    } else if (!check(char)) {
      return cur2;
    }
    cur2 = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  var _a;
  let startPos = start.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos);
  let startCoords = view.coordsAtPos(startPos);
  if (startCoords) {
    let rect = view.dom.getBoundingClientRect();
    let goal2 = (_a = start.goalColumn) !== null && _a !== void 0 ? _a : startCoords.left - rect.left;
    let resolvedGoal = rect.left + goal2;
    let dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;
    for (let startY = dir < 0 ? startCoords.top : startCoords.bottom, extra = 0; extra < 50; extra += 10) {
      let pos = posAtCoords(view, {x: resolvedGoal, y: startY + (dist + extra) * dir}, dir);
      if (pos == null)
        break;
      if (pos != startPos)
        return EditorSelection.cursor(pos, void 0, void 0, goal2);
    }
  }
  let {doc: doc2} = view.state, line = doc2.lineAt(startPos), tabSize = view.state.tabSize;
  let goal = start.goalColumn, goalCol = 0;
  if (goal == null) {
    for (const iter = doc2.iterRange(line.from, startPos); !iter.next().done; )
      goalCol = countColumn(iter.value, goalCol, tabSize);
    goal = goalCol * view.defaultCharacterWidth;
  } else {
    goalCol = Math.round(goal / view.defaultCharacterWidth);
  }
  if (dir < 0 && line.from == 0)
    return EditorSelection.cursor(0);
  else if (dir > 0 && line.to == doc2.length)
    return EditorSelection.cursor(line.to);
  let otherLine = doc2.line(line.number + dir);
  let result = otherLine.from;
  let seen = 0;
  for (const iter = doc2.iterRange(otherLine.from, otherLine.to); seen >= goalCol && !iter.next().done; ) {
    const {offset, leftOver} = findColumn(iter.value, seen, goalCol, tabSize);
    seen = goalCol - leftOver;
    result += offset;
  }
  return EditorSelection.cursor(result, void 0, void 0, goal);
}
var InputState = class {
  constructor(view) {
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.pendingIOSKey = null;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastEscPress = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.registeredEvents = [];
    this.customHandlers = [];
    this.composing = -1;
    this.compositionEndedAt = 0;
    this.mouseSelection = null;
    for (let type in handlers) {
      let handler = handlers[type];
      view.contentDOM.addEventListener(type, (event) => {
        if (type == "keydown" && this.keydown(view, event))
          return;
        if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event))
          return;
        if (this.mustFlushObserver(event))
          view.observer.forceFlush();
        if (this.runCustomHandlers(type, view, event))
          event.preventDefault();
        else
          handler(view, event);
      });
      this.registeredEvents.push(type);
    }
    this.notifiedFocused = view.hasFocus;
    this.ensureHandlers(view);
    if (browser.safari)
      view.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  ensureHandlers(view) {
    let handlers2 = this.customHandlers = view.pluginField(domEventHandlers);
    for (let set of handlers2) {
      for (let type in set.handlers)
        if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
          this.registeredEvents.push(type);
          view.contentDOM.addEventListener(type, (event) => {
            if (!eventBelongsToEditor(view, event))
              return;
            if (this.runCustomHandlers(type, view, event))
              event.preventDefault();
          });
        }
    }
  }
  runCustomHandlers(type, view, event) {
    for (let set of this.customHandlers) {
      let handler = set.handlers[type], handled = false;
      if (handler) {
        try {
          handled = handler.call(set.plugin, event, view);
        } catch (e) {
          logException(view.state, e);
        }
        if (handled || event.defaultPrevented) {
          if (browser.android && type == "keydown" && event.keyCode == 13)
            view.observer.flushSoon();
          return true;
        }
      }
    }
    return false;
  }
  runScrollHandlers(view, event) {
    for (let set of this.customHandlers) {
      let handler = set.handlers.scroll;
      if (handler) {
        try {
          handler.call(set.plugin, event, view);
        } catch (e) {
          logException(view.state, e);
        }
      }
    }
  }
  keydown(view, event) {
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (this.screenKeyEvent(view, event))
      return true;
    if (browser.ios && (event.keyCode == 13 || event.keyCode == 8) && !(event.ctrlKey || event.altKey || event.metaKey) && !event.synthetic) {
      this.pendingIOSKey = event.keyCode == 13 ? "enter" : "backspace";
      setTimeout(() => this.flushIOSKey(view), 250);
      return true;
    }
    return false;
  }
  flushIOSKey(view) {
    if (!this.pendingIOSKey)
      return false;
    let dom = view.contentDOM, key = this.pendingIOSKey;
    this.pendingIOSKey = null;
    return key == "enter" ? dispatchKey(dom, "Enter", 13) : dispatchKey(dom, "Backspace", 8);
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type))
      return false;
    if (this.composing > 0)
      return true;
    if (browser.safari && Date.now() - this.compositionEndedAt < 500) {
      this.compositionEndedAt = 0;
      return true;
    }
    return false;
  }
  screenKeyEvent(view, event) {
    let protectedTab = event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3;
    if (event.keyCode == 27)
      this.lastEscPress = Date.now();
    else if (modifierCodes.indexOf(event.keyCode) < 0)
      this.lastEscPress = 0;
    return protectedTab;
  }
  mustFlushObserver(event) {
    return event.type == "keydown" && event.keyCode != 229 || event.type == "compositionend" && !browser.ios;
  }
  startMouseSelection(view, event, style) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = new MouseSelection(this, view, event, style);
  }
  update(update) {
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
};
var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
var MouseSelection = class {
  constructor(inputState, view, startEvent, style) {
    this.inputState = inputState;
    this.view = view;
    this.startEvent = startEvent;
    this.style = style;
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragMove = dragMovesSelection(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) ? null : false;
    if (this.dragging === false) {
      startEvent.preventDefault();
      this.select(startEvent);
    }
  }
  move(event) {
    if (event.buttons == 0)
      return this.destroy();
    if (this.dragging !== false)
      return;
    this.select(event);
  }
  up(event) {
    if (this.dragging == null)
      this.select(this.startEvent);
    if (!this.dragging)
      event.preventDefault();
    this.destroy();
  }
  destroy() {
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.inputState.mouseSelection = null;
  }
  select(event) {
    let selection = this.style.get(event, this.extend, this.multiple);
    if (!selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)
      this.view.dispatch({
        selection,
        annotations: Transaction.userEvent.of("pointerselection"),
        scrollIntoView: true
      });
  }
  update(update) {
    if (update.docChanged && this.dragging)
      this.dragging = this.dragging.map(update.changes);
    this.style.update(update);
  }
};
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let {main} = view.state.selection;
  if (main.empty)
    return false;
  let sel = getSelection(view.root);
  if (sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i = 0; i < rects.length; i++) {
    let rect = rects[i];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
    if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
      return false;
  return true;
}
var handlers = /* @__PURE__ */ Object.create(null);
var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function doPaste(view, input) {
  let {state} = view, changes, i = 1, text = state.toText(input);
  let byLine = text.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range) => {
      let line = state.doc.lineAt(range.from);
      if (line.from == lastLine)
        return {range};
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
      return {
        changes: {from: line.from, insert: insert2},
        range: EditorSelection.cursor(range.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range) => {
      let line = text.line(i++);
      return {
        changes: {from: range.from, to: range.to, insert: line.text},
        range: EditorSelection.cursor(range.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text);
  }
  view.dispatch(changes, {
    annotations: Transaction.userEvent.of("paste"),
    scrollIntoView: true
  });
}
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("keyboardselection");
};
var lastTouch = 0;
handlers.touchstart = (view, e) => {
  lastTouch = Date.now();
  view.inputState.setSelectionOrigin("pointerselection");
};
handlers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("pointerselection");
};
handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (lastTouch > Date.now() - 2e3)
    return;
  let style = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event);
    if (style)
      break;
  }
  if (!style && event.button == 0)
    style = basicMouseSelection(view, event);
  if (style) {
    if (view.root.activeElement != view.contentDOM)
      view.observer.ignore(() => focusPreventScroll(view.contentDOM));
    view.inputState.startMouseSelection(view, event, style);
  }
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
    if (to < view.state.doc.length && to == line.to)
      to++;
    return EditorSelection.range(from, to);
  }
}
var insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
var inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
function findPositionSide(view, pos, x, y) {
  let line = LineView.find(view.docView, pos);
  if (!line)
    return 1;
  let off = pos - line.posAtStart;
  if (off == 0)
    return 1;
  if (off == line.length)
    return -1;
  let before = line.coordsAt(off, -1);
  if (before && inside(x, y, before))
    return -1;
  let after = line.coordsAt(off, 1);
  if (after && inside(x, y, after))
    return 1;
  return before && insideY(y, before) ? -1 : 1;
}
function queryPos(view, event) {
  let pos = view.posAtCoords({x: event.clientX, y: event.clientY});
  if (pos == null)
    return null;
  return {pos, bias: findPositionSide(view, pos, event.clientX, event.clientY)};
}
var BadMouseDetail = browser.ie && browser.ie_version <= 11;
var lastMouseDown = null;
var lastMouseDownCount = 0;
var lastMouseDownTime = 0;
function getClickType(event) {
  if (!BadMouseDetail)
    return event.detail;
  let last = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start = queryPos(view, event), type = getClickType(event);
  let startSel = view.state.selection;
  let last = start, lastEvent = event;
  return {
    update(update) {
      if (update.changes) {
        if (start)
          start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, extend2, multiple) {
      let cur2;
      if (event2.clientX == lastEvent.clientX && event2.clientY == lastEvent.clientY)
        cur2 = last;
      else {
        cur2 = last = queryPos(view, event2);
        lastEvent = event2;
      }
      if (!cur2 || !start)
        return startSel;
      let range = rangeForClick(view, cur2.pos, cur2.bias, type);
      if (start.pos != cur2.pos && !extend2) {
        let startRange = rangeForClick(view, start.pos, start.bias, type);
        let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
        range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
      }
      if (extend2)
        return startSel.replaceRange(startSel.main.extend(range.from, range.to));
      else if (multiple)
        return startSel.addRange(range);
      else
        return EditorSelection.create([range]);
    }
  };
}
handlers.dragstart = (view, event) => {
  let {selection: {main}} = view.state;
  let {mouseSelection} = view.inputState;
  if (mouseSelection)
    mouseSelection.dragging = main;
  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
    event.dataTransfer.effectAllowed = "copyMove";
  }
};
function dropText(view, event, text, direct) {
  let dropPos = view.posAtCoords({x: event.clientX, y: event.clientY});
  if (dropPos == null || !text)
    return;
  event.preventDefault();
  let {mouseSelection} = view.inputState;
  let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? {from: mouseSelection.dragging.from, to: mouseSelection.dragging.to} : null;
  let ins = {from: dropPos, insert: text};
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: {anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1)},
    annotations: Transaction.userEvent.of("drop")
  });
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer || !view.state.facet(editable))
    return;
  let files = event.dataTransfer.files;
  if (files && files.length) {
    event.preventDefault();
    let text = Array(files.length), read2 = 0;
    let finishFile = () => {
      if (++read2 == files.length)
        dropText(view, event, text.filter((s2) => s2 != null).join(view.state.lineBreak), false);
    };
    for (let i = 0; i < files.length; i++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text[i] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i]);
    }
  } else {
    dropText(view, event, event.dataTransfer.getData("Text"), true);
  }
};
handlers.paste = (view, event) => {
  if (!view.state.facet(editable))
    return;
  view.observer.flush();
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let text = data && data.getData("text/plain");
  if (text) {
    doPaste(view, text);
    event.preventDefault();
  } else {
    capturePaste(view);
  }
};
function captureCopy(view, text) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text;
  target.focus();
  target.selectionEnd = text.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range of state.selection.ranges)
    if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
  if (!content2.length) {
    let upto = -1;
    for (let {from} of state.selection.ranges) {
      let line = state.doc.lineAt(from);
      if (line.number > upto) {
        content2.push(line.text);
        ranges.push({from: line.from, to: Math.min(state.doc.length, line.to + 1)});
      }
      upto = line.number;
    }
    linewise = true;
  }
  return {text: content2.join(state.lineBreak), ranges, linewise};
}
var lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
  let {text, ranges, linewise} = copiedRange(view.state);
  if (!text)
    return;
  lastLinewiseCopy = linewise ? text : null;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/plain", text);
  } else {
    captureCopy(view, text);
  }
  if (event.type == "cut" && view.state.facet(editable))
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      annotations: Transaction.userEvent.of("cut")
    });
};
handlers.focus = handlers.blur = (view) => {
  setTimeout(() => {
    if (view.hasFocus != view.inputState.notifiedFocused)
      view.update([]);
  }, 10);
};
handlers.beforeprint = (view) => {
  view.viewState.printing = true;
  view.requestMeasure();
  setTimeout(() => {
    view.viewState.printing = false;
    view.requestMeasure();
  }, 2e3);
};
function forceClearComposition(view) {
  if (view.docView.compositionDeco.size)
    view.update([]);
}
handlers.compositionstart = handlers.compositionupdate = (view) => {
  if (view.inputState.composing < 0) {
    if (view.docView.compositionDeco.size) {
      view.observer.flush();
      forceClearComposition(view);
    }
    view.inputState.composing = 0;
  }
};
handlers.compositionend = (view) => {
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  setTimeout(() => {
    if (view.inputState.composing < 0)
      forceClearComposition(view);
  }, 50);
};
handlers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line"];
var HeightOracle = class {
  constructor() {
    this.doc = Text.empty;
    this.lineWrapping = false;
    this.direction = Direction.LTR;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.lineLength = 30;
    this.heightChanged = false;
  }
  heightForGap(from, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping)
      lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);
    return this.lineHeight * lines;
  }
  heightForLine(length) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefresh(lineHeights, whiteSpace, direction) {
    let newHeight = false;
    for (let i = 0; i < lineHeights.length; i++) {
      let h = lineHeights[i];
      if (h < 0) {
        i++;
      } else if (!this.heightSamples[Math.floor(h * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return newHeight || wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping || this.direction != direction;
  }
  refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping || this.direction != direction;
    this.lineWrapping = lineWrapping;
    this.direction = direction;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i = 0; i < knownHeights.length; i++) {
        let h = knownHeights[i];
        if (h < 0)
          i++;
        else
          this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return changed;
  }
};
var MeasuredHeights = class {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
};
var BlockInfo = class {
  constructor(from, length, top2, height, type) {
    this.from = from;
    this.length = length;
    this.top = top2;
    this.height = height;
    this.type = type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  join(other) {
    let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
    return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
  }
};
var QueryType = /* @__PURE__ */ function(QueryType2) {
  QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
  QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
  QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType2;
}(QueryType || (QueryType = {}));
var Epsilon = 1e-4;
var HeightMap = class {
  constructor(length, height, flags = 2) {
    this.length = length;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(oracle, height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon)
        oracle.heightChanged = true;
      this.height = height;
    }
  }
  replace(_from, _to, nodes) {
    return HeightMap.of(nodes);
  }
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this;
    for (let i = changes.length - 1; i >= 0; i--) {
      let {fromA, toA, fromB, toB} = changes[i];
      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i > 0 && start.from <= changes[i - 1].toA) {
        fromA = changes[i - 1].fromA;
        fromB = changes[i - 1].fromB;
        i--;
        if (fromA < start.from)
          start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
      }
      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle, decorations2, fromB, toB);
      me = me.replace(fromA, toA, nodes);
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i = 0, j = nodes.length, before = 0, after = 0;
    for (; ; ) {
      if (i == j) {
        if (before > after * 2) {
          let split = nodes[i - 1];
          if (split.break)
            nodes.splice(--i, 1, split.left, null, split.right);
          else
            nodes.splice(--i, 1, split.left, split.right);
          j += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j];
          if (split.break)
            nodes.splice(j, 1, split.left, null, split.right);
          else
            nodes.splice(j, 1, split.left, split.right);
          j += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next = nodes[i++];
        if (next)
          before += next.size;
      } else {
        let next = nodes[--j];
        if (next)
          after += next.size;
      }
    }
    let brk = 0;
    if (nodes[i - 1] == null) {
      brk = 1;
      i--;
    } else if (nodes[i] == null) {
      brk = 1;
      j++;
    }
    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
  }
};
HeightMap.prototype.size = 1;
var HeightMapBlock = class extends HeightMap {
  constructor(length, height, type) {
    super(length, height);
    this.type = type;
  }
  blockAt(_height, _doc, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.type);
  }
  lineAt(_value, _type, doc2, top2, offset) {
    return this.blockAt(0, doc2, top2, offset);
  }
  forEachLine(_from, _to, doc2, top2, offset, f) {
    f(this.blockAt(0, doc2, top2, offset));
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
};
var HeightMapText = class extends HeightMapBlock {
  constructor(length, height) {
    super(length, height, BlockType.Text);
    this.collapsed = 0;
    this.widgetHeight = 0;
  }
  replace(_from, _to, nodes) {
    let node = nodes[0];
    if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
      if (node instanceof HeightMapGap)
        node = new HeightMapText(node.length, this.height);
      else
        node.height = this.height;
      if (!this.outdated)
        node.outdated = false;
      return node;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    else if (force || this.outdated)
      this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
};
var HeightMapGap = class extends HeightMap {
  constructor(length) {
    super(length, 0);
  }
  lines(doc2, offset) {
    let firstLine = doc2.lineAt(offset).number, lastLine = doc2.lineAt(offset + this.length).number;
    return {firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1)};
  }
  blockAt(height, doc2, top2, offset) {
    let {firstLine, lastLine, lineHeight} = this.lines(doc2, offset);
    let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / lineHeight)));
    let {from, length} = doc2.line(firstLine + line);
    return new BlockInfo(from, length, top2 + lineHeight * line, lineHeight, BlockType.Text);
  }
  lineAt(value, type, doc2, top2, offset) {
    if (type == QueryType.ByHeight)
      return this.blockAt(value, doc2, top2, offset);
    if (type == QueryType.ByPosNoHeight) {
      let {from: from2, to} = doc2.lineAt(value);
      return new BlockInfo(from2, to - from2, 0, 0, BlockType.Text);
    }
    let {firstLine, lineHeight} = this.lines(doc2, offset);
    let {from, length, number: number2} = doc2.lineAt(value);
    return new BlockInfo(from, length, top2 + lineHeight * (number2 - firstLine), lineHeight, BlockType.Text);
  }
  forEachLine(from, to, doc2, top2, offset, f) {
    let {firstLine, lineHeight} = this.lines(doc2, offset);
    for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end; ) {
      let line = doc2.lineAt(pos);
      if (pos == from)
        top2 += lineHeight * (line.number - firstLine);
      f(new BlockInfo(line.from, line.length, top2, lineHeight, BlockType.Text));
      top2 += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from, to, nodes) {
    let after = this.length - to;
    if (after > 0) {
      let last = nodes[nodes.length - 1];
      if (last instanceof HeightMapGap)
        nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
      else
        nodes.push(null, new HeightMapGap(after - 1));
    }
    if (from > 0) {
      let first = nodes[0];
      if (first instanceof HeightMapGap)
        nodes[0] = new HeightMapGap(from + first.length);
      else
        nodes.unshift(new HeightMapGap(from - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to, result) {
    result.push(new HeightMapGap(to - 1), null);
  }
  decomposeRight(from, result) {
    result.push(null, new HeightMapGap(this.length - from - 1));
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset, measured.from);
      if (measured.from > offset)
        nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let line = new HeightMapText(len, measured.heights[measured.index++]);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end)
        nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
      oracle.heightChanged = true;
      return HeightMap.of(nodes);
    } else if (force || this.outdated) {
      this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
};
var HeightMapBranch = class extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, doc2, top2, offset) {
    let mid = top2 + this.left.height;
    return height < mid || this.right.height == 0 ? this.left.blockAt(height, doc2, top2, offset) : this.right.blockAt(height, doc2, mid, offset + this.left.length + this.break);
  }
  lineAt(value, type, doc2, top2, offset) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    let left = type == QueryType.ByHeight ? value < rightTop || this.right.height == 0 : value < rightOffset;
    let base2 = left ? this.left.lineAt(value, type, doc2, top2, offset) : this.right.lineAt(value, type, doc2, rightTop, rightOffset);
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left)
      return base2.join(this.right.lineAt(rightOffset, subQuery, doc2, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, doc2, top2, offset).join(base2);
  }
  forEachLine(from, to, doc2, top2, offset, f) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from < rightOffset)
        this.left.forEachLine(from, to, doc2, top2, offset, f);
      if (to >= rightOffset)
        this.right.forEachLine(from, to, doc2, rightTop, rightOffset, f);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, doc2, top2, offset);
      if (from < mid.from)
        this.left.forEachLine(from, mid.from - 1, doc2, top2, offset, f);
      if (mid.to >= from && mid.from <= to)
        f(mid);
      if (to > mid.to)
        this.right.forEachLine(mid.to + 1, to, doc2, rightTop, rightOffset, f);
    }
  }
  replace(from, to, nodes) {
    let rightStart = this.left.length + this.break;
    if (to < rightStart)
      return this.balanced(this.left.replace(from, to, nodes), this.right);
    if (from > this.left.length)
      return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
    let result = [];
    if (from > 0)
      this.decomposeLeft(from, result);
    let left = result.length;
    for (let node of nodes)
      result.push(node);
    if (from > 0)
      mergeGaps(result, left - 1);
    if (to < this.length) {
      let right = result.length;
      this.decomposeRight(to, result);
      mergeGaps(result, right);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to, result) {
    let left = this.left.length;
    if (to <= left)
      return this.left.decomposeLeft(to, result);
    result.push(this.left);
    if (this.break) {
      left++;
      if (to >= left)
        result.push(null);
    }
    if (to > left)
      this.right.decomposeLeft(to - left, result);
  }
  decomposeRight(from, result) {
    let left = this.left.length, right = left + this.break;
    if (from >= right)
      return this.right.decomposeRight(from - right, result);
    if (from < left)
      this.left.decomposeRight(from, result);
    if (this.break && from < right)
      result.push(null);
    result.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size)
      return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = left;
    this.right = right;
    this.height = left.height + right.height;
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let {left, right} = this, rightStart = offset + left.length + this.break, rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more)
      rebalance = left = left.updateHeight(oracle, offset, force, measured);
    else
      left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more)
      rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
    else
      right.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
var relevantWidgetHeight = 5;
var NodeBuilder = class {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to) {
    if (this.lineStart > -1) {
      let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
      if (last instanceof HeightMapText)
        last.length += end - this.pos;
      else if (end > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end - this.pos, -1));
      this.writtenTo = end;
      if (to > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to;
  }
  point(from, to, deco) {
    if (from < to || deco.heightRelevant) {
      let height = deco.widget ? Math.max(0, deco.widget.estimatedHeight) : 0;
      let len = to - from;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco.type));
      } else if (len || height >= relevantWidgetHeight) {
        this.addLineDeco(height, len);
      }
    } else if (to > from) {
      this.span(from, to);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let {from, to} = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to;
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }
    if (this.pos > from)
      this.nodes.push(new HeightMapText(this.pos - from, -1));
    this.writtenTo = this.pos;
  }
  blankContent(from, to) {
    let gap = new HeightMapGap(to - from);
    if (this.oracle.doc.lineAt(from).to == to)
      gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last instanceof HeightMapText)
      return last;
    let line = new HeightMapText(0, -1);
    this.nodes.push(line);
    return line;
  }
  addBlock(block) {
    this.enterLine();
    if (block.type == BlockType.WidgetAfter && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (block.type != BlockType.WidgetBefore)
      this.covering = block;
  }
  addLineDeco(height, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    this.writtenTo = this.pos = this.pos + length;
  }
  finish(from) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1));
    else if (this.writtenTo < this.pos || last == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;
    for (let node of this.nodes) {
      if (node instanceof HeightMapText)
        node.updateHeight(this.oracle, pos);
      pos += node ? node.length : 1;
    }
    return this.nodes;
  }
  static build(oracle, decorations2, from, to) {
    let builder = new NodeBuilder(from, oracle);
    RangeSet.spans(decorations2, from, to, builder, 0);
    return builder.finish(from);
  }
};
function heightRelevantDecoChanges(a, b, diff) {
  let comp = new DecorationComparator();
  RangeSet.compare(a, b, diff, comp, 0);
  return comp.changes;
}
var DecorationComparator = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from, to, a, b) {
    if (from < to || a && a.heightRelevant || b && b.heightRelevant)
      addRange(from, to, this.changes, 5);
  }
};
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);
  let top2 = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent; ) {
    if (parent.nodeType == 1) {
      let style = window.getComputedStyle(parent);
      if ((parent.scrollHeight > parent.clientHeight || parent.scrollWidth > parent.clientWidth) && style.overflow != "visible") {
        let parentRect = parent.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom = Math.min(bottom, parentRect.bottom);
      }
      parent = style.position == "absolute" || style.position == "fixed" ? parent.offsetParent : parent.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: right - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: bottom - (rect.top + paddingTop)
  };
}
var LineGap = class {
  constructor(from, to, size) {
    this.from = from;
    this.to = to;
    this.size = size;
  }
  static same(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      let gA = a[i], gB = b[i];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
        return false;
    }
    return true;
  }
  draw(wrapping) {
    return Decoration.replace({widget: new LineGapWidget(this.size, wrapping)}).range(this.from, this.to);
  }
};
var LineGapWidget = class extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt = document.createElement("div");
    if (this.vertical) {
      elt.style.height = this.size + "px";
    } else {
      elt.style.width = this.size + "px";
      elt.style.height = "2px";
      elt.style.display = "inline-block";
    }
    return elt;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
};
var ViewState = class {
  constructor(state) {
    this.state = state;
    this.pixelViewport = {left: 0, right: window.innerWidth, top: 0, bottom: 0};
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentWidth = 0;
    this.heightOracle = new HeightOracle();
    this.scaler = IdScaler;
    this.scrollTo = null;
    this.printing = false;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    this.heightMap = HeightMap.empty().applyChanges(state.facet(decorations), Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    this.viewport = this.getViewport(0, null);
    this.updateForViewport();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], {main} = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let pos = i ? main.head : main.anchor;
      if (!viewports.some(({from, to}) => pos >= from && pos <= to)) {
        let {from, to} = this.lineAt(pos, 0);
        viewports.push(new Viewport(from, to));
      }
    }
    this.viewports = viewports.sort((a, b) => a.from - b.from);
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
  }
  update(update, scrollTo2 = null) {
    let prev = this.state;
    this.state = update.state;
    let newDeco = this.state.facet(decorations);
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(update.startState.facet(decorations), newDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight)
      update.flags |= 2;
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTo2 && (scrollTo2.head < viewport.from || scrollTo2.head > viewport.to) || !this.viewportIsAppropriate(viewport))
      viewport = this.getViewport(0, scrollTo2);
    if (!viewport.eq(this.viewport)) {
      this.viewport = viewport;
      update.flags |= 4;
    }
    this.updateForViewport();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15e3)
      update.flags |= this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    this.computeVisibleRanges();
    if (scrollTo2)
      this.scrollTo = scrollTo2;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc)
      this.mustEnforceCursorAssoc = true;
  }
  measure(docView, repeated) {
    let dom = docView.dom, whiteSpace = "", direction = Direction.LTR;
    if (!repeated) {
      let style = window.getComputedStyle(dom);
      whiteSpace = style.whiteSpace, direction = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      this.paddingTop = parseInt(style.paddingTop) || 0;
      this.paddingBottom = parseInt(style.paddingBottom) || 0;
    }
    let pixelViewport = this.printing ? {top: -1e8, bottom: 1e8, left: -1e8, right: 1e8} : visiblePixelRange(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    this.inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (!this.inView)
      return 0;
    let lineHeights = docView.measureVisibleLineHeights();
    let refresh = false, bias = 0, result = 0, oracle = this.heightOracle;
    if (!repeated) {
      let contentWidth = docView.dom.clientWidth;
      if (oracle.mustRefresh(lineHeights, whiteSpace, direction) || oracle.lineWrapping && Math.abs(contentWidth - this.contentWidth) > oracle.charWidth) {
        let {lineHeight, charWidth} = docView.measureTextSize();
        refresh = oracle.refresh(whiteSpace, direction, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
        if (refresh) {
          docView.minWidth = 0;
          result |= 16;
        }
      }
      if (this.contentWidth != contentWidth) {
        this.contentWidth = contentWidth;
        result |= 16;
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
    }
    oracle.heightChanged = false;
    this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));
    if (oracle.heightChanged)
      result |= 2;
    if (!this.viewportIsAppropriate(this.viewport, bias) || this.scrollTo && (this.scrollTo.head < this.viewport.from || this.scrollTo.head > this.viewport.to)) {
      let newVP = this.getViewport(bias, this.scrollTo);
      if (newVP.from != this.viewport.from || newVP.to != this.viewport.to) {
        this.viewport = newVP;
        result |= 4;
      }
    }
    this.updateForViewport();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15e3)
      result |= this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));
    this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top, 0);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom, 0);
  }
  getViewport(bias, scrollTo2) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map = this.heightMap, doc2 = this.state.doc, {visibleTop, visibleBottom} = this;
    let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, doc2, 0, 0).to);
    if (scrollTo2) {
      if (scrollTo2.head < viewport.from) {
        let {top: newTop} = map.lineAt(scrollTo2.head, QueryType.ByPos, doc2, 0, 0);
        viewport = new Viewport(map.lineAt(newTop - 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(newTop + (visibleBottom - visibleTop) + 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).to);
      } else if (scrollTo2.head > viewport.to) {
        let {bottom: newBottom} = map.lineAt(scrollTo2.head, QueryType.ByPos, doc2, 0, 0);
        viewport = new Viewport(map.lineAt(newBottom - (visibleBottom - visibleTop) - 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(newBottom + 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);
  }
  viewportIsAppropriate({from, to}, bias = 0) {
    let {top: top2} = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);
    let {bottom} = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);
    let {visibleTop, visibleBottom} = this;
    return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
    return mapped;
  }
  ensureLineGaps(current) {
    let gaps = [];
    if (this.heightOracle.direction != Direction.LTR)
      return gaps;
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (line) => {
      if (line.length < 1e4)
        return;
      let structure = lineStructure(line.from, line.to, this.state);
      if (structure.total < 1e4)
        return;
      let viewFrom, viewTo;
      if (this.heightOracle.lineWrapping) {
        if (line.from != this.viewport.from)
          viewFrom = line.from;
        else
          viewFrom = findPosition(structure, (this.visibleTop - line.top) / line.height);
        if (line.to != this.viewport.to)
          viewTo = line.to;
        else
          viewTo = findPosition(structure, (this.visibleBottom - line.top) / line.height);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        viewFrom = findPosition(structure, this.pixelViewport.left / totalWidth);
        viewTo = findPosition(structure, this.pixelViewport.right / totalWidth);
      }
      let sel = this.state.selection.main;
      if (sel.from <= viewFrom && sel.to >= line.from)
        viewFrom = sel.from;
      if (sel.from <= line.to && sel.to >= viewTo)
        viewTo = sel.to;
      let gapTo = viewFrom - 1e4, gapFrom = viewTo + 1e4;
      if (gapTo > line.from + 5e3)
        gaps.push(find(current, (gap) => gap.from == line.from && gap.to > gapTo - 5e3 && gap.to < gapTo + 5e3) || new LineGap(line.from, gapTo, this.gapSize(line, gapTo, true, structure)));
      if (gapFrom < line.to - 5e3)
        gaps.push(find(current, (gap) => gap.to == line.to && gap.from > gapFrom - 5e3 && gap.from < gapFrom + 5e3) || new LineGap(gapFrom, line.to, this.gapSize(line, gapFrom, false, structure)));
    });
    return gaps;
  }
  gapSize(line, pos, start, structure) {
    if (this.heightOracle.lineWrapping) {
      let height = line.height * findFraction(structure, pos);
      return start ? height : line.height - height;
    } else {
      let ratio = findFraction(structure, pos);
      return structure.total * this.heightOracle.charWidth * (start ? ratio : 1 - ratio);
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this.heightOracle.lineWrapping)));
      return 8;
    }
    return 0;
  }
  computeVisibleRanges() {
    let deco = this.state.facet(decorations);
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to) {
        ranges.push({from, to});
      },
      point() {
      }
    }, 20);
    this.visibleRanges = ranges;
  }
  lineAt(pos, editorTop) {
    editorTop += this.paddingTop;
    return scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, editorTop, 0), this.scaler, editorTop);
  }
  lineAtHeight(height, editorTop) {
    editorTop += this.paddingTop;
    return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height, editorTop), QueryType.ByHeight, this.state.doc, editorTop, 0), this.scaler, editorTop);
  }
  blockAtHeight(height, editorTop) {
    editorTop += this.paddingTop;
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height, editorTop), this.state.doc, editorTop, 0), this.scaler, editorTop);
  }
  forEachLine(from, to, f, editorTop) {
    editorTop += this.paddingTop;
    return this.heightMap.forEachLine(from, to, this.state.doc, editorTop, 0, this.scaler.scale == 1 ? f : (b) => f(scaleBlock(b, this.scaler, editorTop)));
  }
  get contentHeight() {
    return this.domHeight + this.paddingTop + this.paddingBottom;
  }
  get domHeight() {
    return this.scaler.toDOM(this.heightMap.height, this.paddingTop);
  }
};
var Viewport = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
  eq(b) {
    return this.from == b.from && this.to == b.to;
  }
};
function lineStructure(from, to, state) {
  let ranges = [], pos = from, total = 0;
  RangeSet.spans(state.facet(decorations), from, to, {
    span() {
    },
    point(from2, to2) {
      if (from2 > pos) {
        ranges.push({from: pos, to: from2});
        total += from2 - pos;
      }
      pos = to2;
    }
  }, 20);
  if (pos < to) {
    ranges.push({from: pos, to});
    total += to - pos;
  }
  return {total, ranges};
}
function findPosition({total, ranges}, ratio) {
  if (ratio <= 0)
    return ranges[0].from;
  if (ratio >= 1)
    return ranges[ranges.length - 1].to;
  let dist = Math.floor(total * ratio);
  for (let i = 0; ; i++) {
    let {from, to} = ranges[i], size = to - from;
    if (dist <= size)
      return from + dist;
    dist -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let {from, to} of structure.ranges) {
    if (pos <= to) {
      counted += pos - from;
      break;
    }
    counted += to - from;
  }
  return counted / structure.total;
}
function find(array, f) {
  for (let val of array)
    if (f(val))
      return val;
  return void 0;
}
var IdScaler = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1
};
var BigScaler = class {
  constructor(doc2, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({from, to}) => {
      let top2 = heightMap.lineAt(from, QueryType.ByPos, doc2, 0, 0).top;
      let bottom = heightMap.lineAt(to, QueryType.ByPos, doc2, 0, 0).bottom;
      vpHeight += bottom - top2;
      return {from, to, top: top2, bottom, domTop: 0, domBottom: 0};
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n, top2) {
    n -= top2;
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.top)
        return domBase + (n - base2) * this.scale + top2;
      if (n <= vp.bottom)
        return vp.domTop + (n - vp.top) + top2;
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  fromDOM(n, top2) {
    n -= top2;
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.domTop)
        return base2 + (n - domBase) / this.scale + top2;
      if (n <= vp.domBottom)
        return vp.top + (n - vp.domTop) + top2;
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
};
function scaleBlock(block, scaler, top2) {
  if (scaler.scale == 1)
    return block;
  let bTop = scaler.toDOM(block.top, top2), bBottom = scaler.toDOM(block.bottom, top2);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b) => scaleBlock(b, scaler, top2)) : block.type);
}
var theme = /* @__PURE__ */ Facet.define({combine: (strs) => strs.join(" ")});
var darkTheme = /* @__PURE__ */ Facet.define({combine: (values) => values.indexOf(true) > -1});
var baseThemeID = /* @__PURE__ */ StyleModule.newName();
var baseLightID = /* @__PURE__ */ StyleModule.newName();
var baseDarkID = /* @__PURE__ */ StyleModule.newName();
var lightDarkIDs = {"&light": "." + baseLightID, "&dark": "." + baseDarkID};
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
        if (m == "&")
          return main;
        if (!scopes || !scopes[m])
          throw new RangeError(`Unsupported selector: ${m}`);
        return scopes[m];
      }) : main + " " + sel;
    }
  });
}
var baseTheme = /* @__PURE__ */ buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    minHeight: "100%",
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none"
  },
  ".cm-lineWrapping": {
    whiteSpace: "pre-wrap",
    overflowWrap: "anywhere"
  },
  "&light .cm-content": {caretColor: "black"},
  "&dark .cm-content": {caretColor: "white"},
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 4px"
  },
  ".cm-selectionLayer": {
    zIndex: -1,
    contain: "size style"
  },
  ".cm-selectionBackground": {
    position: "absolute"
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    zIndex: 100,
    contain: "size style",
    pointerEvents: "none"
  },
  "&.cm-focused .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  "@keyframes cm-blink": {"0%": {}, "50%": {visibility: "hidden"}, "100%": {}},
  "@keyframes cm-blink2": {"0%": {}, "50%": {visibility: "hidden"}, "100%": {}},
  ".cm-cursor": {
    position: "absolute",
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none",
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  "&.cm-focused .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": {backgroundColor: "#f3f9ff"},
  "&dark .cm-activeLine": {backgroundColor: "#223039"},
  "&light .cm-specialChar": {color: "red"},
  "&dark .cm-specialChar": {color: "#f78"},
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "3px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
var observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  characterDataOldValue: true
};
var useCharData = browser.ie && browser.ie_version <= 11;
var DOMObserver = class {
  constructor(view, onChange, onScrollChanged) {
    this.view = view;
    this.onChange = onChange;
    this.onScrollChanged = onScrollChanged;
    this.active = false;
    this.ignoreSelection = new DOMSelection();
    this.delayedFlush = -1;
    this.queue = [];
    this.lastFlush = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.intersecting = false;
    this._selectionRange = null;
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      this._selectionRange = null;
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData)
      this.onCharData = (event) => {
        this.queue.push({
          target: event.target,
          type: "characterData",
          oldValue: event.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.start();
    this.onScroll = this.onScroll.bind(this);
    window.addEventListener("scroll", this.onScroll);
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, {});
      this.intersection.observe(this.dom);
    }
    this.listenForScroll();
  }
  onScroll(e) {
    if (this.intersecting)
      this.flush();
    this.onScrollChanged(e);
  }
  onSelectionChange(event) {
    if (this.lastFlush < Date.now() - 50)
      this._selectionRange = null;
    let {view} = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event))
      return;
    if (browser.ie && browser.ie_version <= 11 && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush();
  }
  get selectionRange() {
    if (!this._selectionRange) {
      let {root} = this.view, sel = getSelection(root);
      if (browser.safari && root.nodeType == 11 && deepActiveElement() == this.view.contentDOM)
        sel = safariSelectionRangeHack(this.view) || sel;
      this._selectionRange = sel;
    }
    return this._selectionRange;
  }
  setSelectionRange(anchor, head) {
    var _a;
    if (!((_a = this._selectionRange) === null || _a === void 0 ? void 0 : _a.type))
      this._selectionRange = {
        anchorNode: anchor.node,
        anchorOffset: anchor.offset,
        focusNode: head.node,
        focusOffset: head.offset
      };
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
          i++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f) {
    if (!this.active)
      return f();
    try {
      this.stop();
      return f();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    this.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    this.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  clearSelection() {
    this.ignoreSelection.set(this.selectionRange);
  }
  clear() {
    this.observer.takeRecords();
    this.queue.length = 0;
    this.clearSelection();
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = window.setTimeout(() => {
        this.delayedFlush = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      window.clearTimeout(this.delayedFlush);
      this.delayedFlush = -1;
      this.flush();
    }
  }
  flush() {
    if (this.delayedFlush >= 0)
      return;
    this.lastFlush = Date.now();
    let records = this.queue;
    for (let mut of this.observer.takeRecords())
      records.push(mut);
    if (records.length)
      this.queue = [];
    let selection = this.selectionRange;
    let newSel = !this.ignoreSelection.eq(selection) && hasSelection(this.dom, selection);
    if (records.length == 0 && !newSel)
      return;
    let from = -1, to = -1, typeOver = false;
    for (let record of records) {
      let range = this.readMutation(record);
      if (!range)
        continue;
      if (range.typeOver)
        typeOver = true;
      if (from == -1) {
        ({from, to} = range);
      } else {
        from = Math.min(range.from, from);
        to = Math.max(range.to, to);
      }
    }
    let startState = this.view.state;
    if (from > -1 || newSel)
      this.onChange(from, to, typeOver);
    if (this.view.state == startState) {
      if (this.view.docView.dirty) {
        this.ignore(() => this.view.docView.sync());
        this.view.docView.dirty = 0;
      }
      this.view.docView.updateSelection();
    }
    this.clearSelection();
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec))
      return null;
    cView.markDirty();
    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else {
      return {from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue};
    }
  }
  destroy() {
    this.stop();
    if (this.intersection)
      this.intersection.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    window.removeEventListener("scroll", this.onScroll);
    clearTimeout(this.parentCheck);
  }
};
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView)
      return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function safariSelectionRangeHack(view) {
  let found = null;
  function read2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read2, true);
  document.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read2, true);
  if (!found)
    return null;
  let anchorNode = found.startContainer, anchorOffset = found.startOffset;
  let focusNode = found.endContainer, focusOffset = found.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return {anchorNode, anchorOffset, focusNode, focusOffset};
}
function applyDOMChange(view, start, end, typeOver) {
  let change, newSel;
  let sel = view.state.selection.main, bounds;
  if (start > -1 && (bounds = view.docView.domBoundsAround(start, end, 0))) {
    let {from, to} = bounds;
    let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view);
    let reader = new DOMReader(selPoints, view);
    reader.readRange(bounds.startDOM, bounds.endDOM);
    newSel = selectionFromPoints(selPoints, from);
    let preferredPos = sel.from, preferredSide = null;
    if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && reader.text.length < to - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.sliceDoc(from, to), reader.text, preferredPos - from, preferredSide);
    if (diff)
      change = {
        from: from + diff.from,
        to: from + diff.toA,
        insert: view.state.toText(reader.text.slice(diff.from, diff.toB))
      };
  } else if (view.hasFocus || !view.state.facet(editable)) {
    let domSel = view.observer.selectionRange;
    let {impreciseHead: iHead, impreciseAnchor: iAnchor} = view.docView;
    let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
    let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (head != sel.head || anchor != sel.anchor)
      newSel = EditorSelection.single(anchor, head);
  }
  if (!change && !newSel)
    return;
  if (!change && typeOver && !sel.empty && newSel && newSel.main.empty)
    change = {from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to)};
  else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4)
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  if (change) {
    let startState = view.state;
    if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)) || browser.ios && view.inputState.flushIOSKey(view))
      return;
    let text = change.insert.toString();
    if (view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text)))
      return;
    if (view.inputState.composing >= 0)
      view.inputState.composing++;
    let tr;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length)) {
      let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
      let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
      tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
    } else {
      let changes = startState.changes(change);
      tr = {
        changes,
        selection: newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? startState.selection.replaceRange(newSel.main) : void 0
      };
    }
    view.dispatch(tr, {scrollIntoView: true, annotations: Transaction.userEvent.of("input")});
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView2 = false, annotations;
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "keyboardselection")
        scrollIntoView2 = true;
      else
        annotations = Transaction.userEvent.of(view.inputState.lastSelectionOrigin);
    }
    view.dispatch({selection: newSel, scrollIntoView: scrollIntoView2, annotations});
  }
}
function findDiff(a, b, preferredPos, preferredSide) {
  let minLen = Math.min(a.length, b.length);
  let from = 0;
  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
    from++;
  if (from == minLen && a.length == b.length)
    return null;
  let toA = a.length, toB = b.length;
  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }
  if (toA < from && a.length < b.length) {
    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move;
    toA = from + (toA - toB);
    toB = from;
  }
  return {from, toA, toB};
}
var DOMReader = class {
  constructor(points, view) {
    this.points = points;
    this.view = view;
    this.text = "";
    this.lineBreak = view.state.lineBreak;
  }
  readRange(start, end) {
    if (!start)
      return;
    let parent = start.parentNode;
    for (let cur2 = start; ; ) {
      this.findPointBefore(parent, cur2);
      this.readNode(cur2);
      let next = cur2.nextSibling;
      if (next == end)
        break;
      let view = ContentView.get(cur2), nextView = ContentView.get(next);
      if ((view ? view.breakAfter : isBlockElement(cur2)) || (nextView ? nextView.breakAfter : isBlockElement(next)) && !(cur2.nodeName == "BR" && !cur2.cmIgnore))
        this.text += this.lineBreak;
      cur2 = next;
    }
    this.findPointBefore(parent, end);
  }
  readNode(node) {
    if (node.cmIgnore)
      return;
    let view = ContentView.get(node);
    let fromView = view && view.overrideDOMText;
    let text;
    if (fromView != null)
      text = fromView.sliceString(0, void 0, this.lineBreak);
    else if (node.nodeType == 3)
      text = node.nodeValue;
    else if (node.nodeName == "BR")
      text = node.nextSibling ? this.lineBreak : "";
    else if (node.nodeType == 1)
      this.readRange(node.firstChild, null);
    if (text != null) {
      this.findPointIn(node, text.length);
      this.text += text;
      if (browser.chrome && this.view.inputState.lastKeyCode == 13 && !node.nextSibling && /\n\n$/.test(this.text))
        this.text = this.text.slice(0, -1);
    }
  }
  findPointBefore(node, next) {
    for (let point of this.points)
      if (point.node == node && node.childNodes[point.offset] == next)
        point.pos = this.text.length;
  }
  findPointIn(node, maxLen) {
    for (let point of this.points)
      if (point.node == node)
        point.pos = this.text.length + Math.min(point.offset, maxLen);
  }
};
function isBlockElement(node) {
  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
var DOMPoint = class {
  constructor(node, offset) {
    this.node = node;
    this.offset = offset;
    this.pos = -1;
  }
};
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let {anchorNode, anchorOffset, focusNode, focusOffset} = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
}
var EditorView = class {
  constructor(config2 = {}) {
    this.plugins = [];
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.style.cssText = "position: absolute; top: -10000px";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    this._dispatch = config2.dispatch || ((tr) => this.update([tr]));
    this.dispatch = this.dispatch.bind(this);
    this.root = config2.root || document;
    this.viewState = new ViewState(config2.state || EditorState.create());
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec).update(this));
    this.observer = new DOMObserver(this, (from, to, typeOver) => {
      applyDOMChange(this, from, to, typeOver);
    }, (event) => {
      this.inputState.runScrollHandlers(this, event);
      if (this.observer.intersecting)
        this.measure();
    });
    this.inputState = new InputState(this);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    ensureGlobalHandler();
    this.requestMeasure();
    if (config2.parent)
      config2.parent.appendChild(this.dom);
  }
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  dispatch(...input) {
    this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0] : this.state.update(...input));
  }
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, update;
    let state = this.state;
    for (let tr of transactions) {
      if (tr.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr.state;
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = new ViewUpdate(this, state, transactions);
    try {
      this.updateState = 2;
      let scrollTo2 = transactions.some((tr) => tr.scrollIntoView) ? state.selection.main : null;
      this.viewState.update(update, scrollTo2);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty)
        this.updatePlugins(update);
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      this.updateAttrs();
      this.showAnnouncements(transactions);
    } finally {
      this.updateState = 0;
    }
    if (redrawn || scrollTo || this.viewState.mustEnforceCursorAssoc)
      this.requestMeasure();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener))
        listener(update);
  }
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    this.updateState = 2;
    try {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec).update(this));
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin = this.plugins[found];
          plugin.mustUpdate = update;
          newPlugins.push(plugin);
        }
      }
      for (let plugin of this.plugins)
        if (plugin.mustUpdate != update)
          plugin.destroy(this);
      this.plugins = newPlugins;
      this.inputState.ensureHandlers(this);
    } else {
      for (let p of this.plugins)
        p.mustUpdate = update;
    }
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i] = this.plugins[i].update(this);
  }
  measure() {
    if (this.measureScheduled > -1)
      cancelAnimationFrame(this.measureScheduled);
    this.measureScheduled = -1;
    let updated = null;
    try {
      for (let i = 0; ; i++) {
        this.updateState = 1;
        let changed = this.viewState.measure(this.docView, i > 0);
        let measuring = this.measureRequests;
        if (!changed && !measuring.length && this.viewState.scrollTo == null)
          break;
        this.measureRequests = [];
        if (i > 5) {
          console.warn("Viewport failed to stabilize");
          break;
        }
        let measured = measuring.map((m) => {
          try {
            return m.read(this);
          } catch (e) {
            logException(this.state, e);
            return BadMeasure;
          }
        });
        let update = new ViewUpdate(this, this.state);
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty)
          this.updatePlugins(update);
        this.updateAttrs();
        if (changed)
          this.docView.update(update);
        for (let i2 = 0; i2 < measuring.length; i2++)
          if (measured[i2] != BadMeasure) {
            try {
              measuring[i2].write(measured[i2], this);
            } catch (e) {
              logException(this.state, e);
            }
          }
        if (this.viewState.scrollTo) {
          this.docView.scrollPosIntoView(this.viewState.scrollTo.head, this.viewState.scrollTo.assoc);
          this.viewState.scrollTo = null;
        }
        if (!(changed & 4) && this.measureRequests.length == 0)
          break;
      }
    } finally {
      this.updateState = 0;
    }
    this.measureScheduled = -1;
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = combineAttrs(this.state.facet(editorAttributes), {
      class: "cm-editor cm-wrap" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    updateAttrs(this.dom, this.editorAttrs, editorAttrs);
    this.editorAttrs = editorAttrs;
    let contentAttrs = combineAttrs(this.state.facet(contentAttributes), {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      contenteditable: String(this.state.facet(editable)),
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    });
    updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
    this.contentAttrs = contentAttrs;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr of trs)
      for (let effect of tr.effects)
        if (effect.is(EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure();
  }
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = requestAnimationFrame(() => this.measure());
    if (request) {
      if (request.key != null)
        for (let i = 0; i < this.measureRequests.length; i++) {
          if (this.measureRequests[i].key === request.key) {
            this.measureRequests[i] = request;
            return;
          }
        }
      this.measureRequests.push(request);
    }
  }
  pluginField(field) {
    let result = [];
    for (let plugin of this.plugins)
      plugin.update(this).takeField(field, result);
    return result;
  }
  plugin(plugin) {
    for (let inst of this.plugins)
      if (inst.spec == plugin)
        return inst.update(this).value;
    return null;
  }
  blockAtHeight(height, docTop) {
    this.readMeasured();
    return this.viewState.blockAtHeight(height, ensureTop(docTop, this.contentDOM));
  }
  visualLineAtHeight(height, docTop) {
    this.readMeasured();
    return this.viewState.lineAtHeight(height, ensureTop(docTop, this.contentDOM));
  }
  viewportLines(f, docTop) {
    let {from, to} = this.viewport;
    this.viewState.forEachLine(from, to, f, ensureTop(docTop, this.contentDOM));
  }
  visualLineAt(pos, docTop = 0) {
    return this.viewState.lineAt(pos, docTop);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(start, forward, by) {
    return moveByChar(this, start, forward, by);
  }
  moveByGroup(start, forward) {
    return moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial));
  }
  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  moveVertically(start, forward, distance) {
    return moveVertically(this, start, forward, distance);
  }
  scrollPosIntoView(pos) {
    this.viewState.scrollTo = EditorSelection.cursor(pos);
    this.requestMeasure();
  }
  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  posAtDOM(node, offset = 0) {
    return this.docView.posFromDOM(node, offset);
  }
  posAtCoords(coords) {
    this.readMeasured();
    return posAtCoords(this, coords);
  }
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right)
      return rect;
    let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.heightOracle.direction;
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(line) {
    if (line.length > MaxBidiLine)
      return trivialOrder(line.length);
    let dir = this.textDirection;
    for (let entry of this.bidiCache)
      if (entry.from == line.from && entry.dir == dir)
        return entry.order;
    let order = computeOrder(line.text, this.textDirection);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
    return order;
  }
  get hasFocus() {
    var _a;
    return (document.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  destroy() {
    for (let plugin of this.plugins)
      plugin.destroy(this);
    this.inputState.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      cancelAnimationFrame(this.measureScheduled);
  }
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), {eventHandlers: handlers2});
  }
  static theme(spec, options2) {
    let prefix = StyleModule.newName();
    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options2 && options2.dark)
      result.push(darkTheme.of(true));
    return result;
  }
  static baseTheme(spec) {
    return Prec.fallback(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
};
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({"class": "cm-lineWrapping"});
EditorView.announce = /* @__PURE__ */ StateEffect.define();
var MaxBidiLine = 4096;
function ensureTop(given, dom) {
  return given == null ? dom.getBoundingClientRect().top : given;
}
var resizeDebounce = -1;
function ensureGlobalHandler() {
  window.addEventListener("resize", () => {
    if (resizeDebounce == -1)
      resizeDebounce = setTimeout(handleResize, 50);
  });
}
function handleResize() {
  resizeDebounce = -1;
  let found = document.querySelectorAll(".cm-content");
  for (let i = 0; i < found.length; i++) {
    let docView = ContentView.get(found[i]);
    if (docView)
      docView.editorView.requestMeasure();
  }
}
var BadMeasure = {};
var CachedOrder = class {
  constructor(from, to, dir, order) {
    this.from = from;
    this.to = to;
    this.dir = dir;
    this.order = order;
  }
  static update(cache, changes) {
    if (changes.empty)
      return cache;
    let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
    for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
      let entry = cache[i];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
    }
    return result;
  }
};
var currentPlatform = typeof navigator == "undefined" ? "key" : /* @__PURE__ */ /Mac/.test(navigator.platform) ? "mac" : /* @__PURE__ */ /Win/.test(navigator.platform) ? "win" : /* @__PURE__ */ /Linux|X11/.test(navigator.platform) ? "linux" : "key";
function normalizeKeyName(name2, platform) {
  const parts = name2.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta2;
  for (let i = 0; i < parts.length - 1; ++i) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta2 = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (platform == "mac")
        meta2 = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta2)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function modifiers(name2, event, shift2) {
  if (event.altKey)
    name2 = "Alt-" + name2;
  if (event.ctrlKey)
    name2 = "Ctrl-" + name2;
  if (event.metaKey)
    name2 = "Meta-" + name2;
  if (shift2 !== false && event.shiftKey)
    name2 = "Shift-" + name2;
  return name2;
}
var handleKeyEvents = /* @__PURE__ */ EditorView.domEventHandlers({
  keydown(event, view) {
    return runHandlers(getKeymap(view.state), event, view, "editor");
  }
});
var keymap = /* @__PURE__ */ Facet.define({enables: handleKeyEvents});
var Keymaps = /* @__PURE__ */ new WeakMap();
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map = Keymaps.get(bindings);
  if (!map)
    Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
  return map;
}
function runScopeHandlers(view, event, scope) {
  return runHandlers(getKeymap(view.state), event, view, scope);
}
var storedPrefix = null;
var PrefixTimeout = 4e3;
function buildKeymap(bindings, platform = currentPlatform) {
  let bound = Object.create(null);
  let isPrefix = Object.create(null);
  let checkPrefix = (name2, is) => {
    let current = isPrefix[name2];
    if (current == null)
      isPrefix[name2] = is;
    else if (current != is)
      throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add2 = (scope, key, command2, preventDefault) => {
    let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
    let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
    for (let i = 1; i < parts.length; i++) {
      let prefix = parts.slice(0, i).join(" ");
      checkPrefix(prefix, true);
      if (!scopeObj[prefix])
        scopeObj[prefix] = {
          preventDefault: true,
          commands: [(view) => {
            let ourObj = storedPrefix = {view, prefix, scope};
            setTimeout(() => {
              if (storedPrefix == ourObj)
                storedPrefix = null;
            }, PrefixTimeout);
            return true;
          }]
        };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = {preventDefault: false, commands: []});
    binding.commands.push(command2);
    if (preventDefault)
      binding.preventDefault = true;
  };
  for (let b of bindings) {
    let name2 = b[platform] || b.key;
    if (!name2)
      continue;
    for (let scope of b.scope ? b.scope.split(" ") : ["editor"]) {
      add2(scope, name2, b.run, b.preventDefault);
      if (b.shift)
        add2(scope, "Shift-" + name2, b.shift, b.preventDefault);
    }
  }
  return bound;
}
function runHandlers(map, event, view, scope) {
  let name2 = keyName(event), isChar = name2.length == 1 && name2 != " ";
  let prefix = "", fallthrough = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix = storedPrefix.prefix + " ";
    if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)
      storedPrefix = null;
  }
  let runFor = (binding) => {
    if (binding) {
      for (let cmd2 of binding.commands)
        if (cmd2(view))
          return true;
      if (binding.preventDefault)
        fallthrough = true;
    }
    return false;
  };
  let scopeObj = map[scope], baseName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)]))
      return true;
    if (isChar && (event.shiftKey || event.altKey || event.metaKey) && (baseName = base[event.keyCode]) && baseName != name2) {
      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))
        return true;
    } else if (isChar && event.shiftKey) {
      if (runFor(scopeObj[prefix + modifiers(name2, event, true)]))
        return true;
    }
  }
  return fallthrough;
}
var CanHidePrimary = !browser.ios;
var selectionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (a, b) => Math.min(a, b),
      drawRangeCursor: (a, b) => a || b
    });
  }
});
function drawSelection(config2 = {}) {
  return [
    selectionConfig.of(config2),
    drawSelectionPlugin,
    hideNativeSelection
  ];
}
var Piece = class {
  constructor(left, top2, width, height, className) {
    this.left = left;
    this.top = top2;
    this.width = width;
    this.height = height;
    this.className = className;
  }
  draw() {
    let elt = document.createElement("div");
    elt.className = this.className;
    this.adjust(elt);
    return elt;
  }
  adjust(elt) {
    elt.style.left = this.left + "px";
    elt.style.top = this.top + "px";
    if (this.width >= 0)
      elt.style.width = this.width + "px";
    elt.style.height = this.height + "px";
  }
  eq(p) {
    return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
  }
};
var drawSelectionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.rangePieces = [];
    this.cursors = [];
    this.measureReq = {read: this.readPos.bind(this), write: this.drawSel.bind(this)};
    this.selectionLayer = view.scrollDOM.appendChild(document.createElement("div"));
    this.selectionLayer.className = "cm-selectionLayer";
    this.selectionLayer.setAttribute("aria-hidden", "true");
    this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
    this.cursorLayer.className = "cm-cursorLayer";
    this.cursorLayer.setAttribute("aria-hidden", "true");
    view.requestMeasure(this.measureReq);
    this.setBlinkRate();
  }
  setBlinkRate() {
    this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + "ms";
  }
  update(update) {
    let confChanged = update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
    if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged)
      this.view.requestMeasure(this.measureReq);
    if (update.transactions.some((tr) => tr.scrollIntoView))
      this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    if (confChanged)
      this.setBlinkRate();
  }
  readPos() {
    let {state} = this.view, conf = state.facet(selectionConfig);
    let rangePieces = state.selection.ranges.map((r) => r.empty ? [] : measureRange(this.view, r)).reduce((a, b) => a.concat(b));
    let cursors = [];
    for (let r of state.selection.ranges) {
      let prim = r == state.selection.main;
      if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
        let piece = measureCursor(this.view, r, prim);
        if (piece)
          cursors.push(piece);
      }
    }
    return {rangePieces, cursors};
  }
  drawSel({rangePieces, cursors}) {
    if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i) => !p.eq(this.rangePieces[i]))) {
      this.selectionLayer.textContent = "";
      for (let p of rangePieces)
        this.selectionLayer.appendChild(p.draw());
      this.rangePieces = rangePieces;
    }
    if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {
      let oldCursors = this.cursorLayer.children;
      if (oldCursors.length !== cursors.length) {
        this.cursorLayer.textContent = "";
        for (const c of cursors)
          this.cursorLayer.appendChild(c.draw());
      } else {
        cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));
      }
      this.cursors = cursors;
    }
  }
  destroy() {
    this.selectionLayer.remove();
    this.cursorLayer.remove();
  }
});
var themeSpec = {
  ".cm-line": {
    "& ::selection": {backgroundColor: "transparent !important"},
    "&::selection": {backgroundColor: "transparent !important"}
  }
};
if (CanHidePrimary)
  themeSpec[".cm-line"].caretColor = "transparent !important";
var hideNativeSelection = /* @__PURE__ */ Prec.override(/* @__PURE__ */ EditorView.theme(themeSpec));
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
  return {left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop};
}
function wrappedLine(view, pos, inside2) {
  let range = EditorSelection.cursor(pos);
  return {
    from: Math.max(inside2.from, view.moveToLineBoundary(range, false, true).from),
    to: Math.min(inside2.to, view.moveToLineBoundary(range, true, true).from)
  };
}
function measureRange(view, range) {
  if (range.to <= view.viewport.from || range.from >= view.viewport.to)
    return [];
  let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
  let lineStyle = window.getComputedStyle(content2.firstChild);
  let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft);
  let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
  let visualStart = view.visualLineAt(from);
  let visualEnd = view.visualLineAt(to);
  if (view.lineWrapping) {
    visualStart = wrappedLine(view, from, visualStart);
    visualEnd = wrappedLine(view, to, visualEnd);
  }
  if (visualStart.from == visualEnd.from) {
    return pieces(drawForLine(range.from, range.to, visualStart));
  } else {
    let top2 = drawForLine(range.from, null, visualStart);
    let bottom = drawForLine(null, range.to, visualEnd);
    let between = [];
    if (visualStart.to < visualEnd.from - 1)
      between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
    else if (top2.bottom < bottom.top && bottom.top - top2.bottom < 4)
      top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
    return pieces(top2).concat(between).concat(pieces(bottom));
  }
  function piece(left, top2, right, bottom) {
    return new Piece(left - base2.left, top2 - base2.top, right - left, bottom - top2, "cm-selectionBackground");
  }
  function pieces({top: top2, bottom, horizontal}) {
    let pieces2 = [];
    for (let i = 0; i < horizontal.length; i += 2)
      pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom));
    return pieces2;
  }
  function drawForLine(from2, to2, line) {
    let top2 = 1e9, bottom = -1e9, horizontal = [];
    function addSpan(from3, fromOpen, to3, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -1 : 1);
      let toCoords = view.coordsAtPos(to3, to3 == line.from ? 1 : -1);
      top2 = Math.min(fromCoords.top, toCoords.top, top2);
      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
      if (dir == Direction.LTR)
        horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
      else
        horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }
    let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
    for (let r of view.visibleRanges)
      if (r.to > start && r.from < end) {
        for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
          let docLine = view.state.doc.lineAt(pos);
          for (let span of view.bidiSpans(docLine)) {
            let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
            if (spanFrom >= endPos)
              break;
            if (spanTo > pos)
              addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
          }
          pos = docLine.to + 1;
          if (pos >= endPos)
            break;
        }
      }
    if (horizontal.length == 0)
      addSpan(start, from2 == null, end, to2 == null, view.textDirection);
    return {top: top2, bottom, horizontal};
  }
}
function measureCursor(view, cursor, primary) {
  let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);
  if (!pos)
    return null;
  let base2 = getBase(view);
  return new Piece(pos.left - base2.left, pos.top - base2.top, -1, pos.bottom - pos.top, primary ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary");
}
function iterMatches(doc2, re, from, to, f) {
  re.lastIndex = 0;
  for (let cursor = doc2.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
    if (!cursor.lineBreak)
      while (m = re.exec(cursor.value))
        f(pos + m.index, pos + m.index + m[0].length, m);
  }
}
var MatchDecorator = class {
  constructor(config2) {
    let {regexp, decoration, boundary} = config2;
    if (!regexp.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = regexp;
    this.getDeco = typeof decoration == "function" ? decoration : () => decoration;
    this.boundary = boundary;
  }
  createDeco(view) {
    let build = new RangeSetBuilder();
    for (let {from, to} of view.visibleRanges)
      iterMatches(view.state.doc, this.regexp, from, to, (a, b, m) => build.add(a, b, this.getDeco(m, view, a)));
    return build.finish();
  }
  updateDeco(update, deco) {
    let changeFrom = 1e9, changeTo = -1;
    if (update.docChanged)
      update.changes.iterChanges((_f, _t, from, to) => {
        if (to > update.view.viewport.from && from < update.view.viewport.to) {
          changeFrom = Math.min(from, changeFrom);
          changeTo = Math.max(to, changeTo);
        }
      });
    if (update.viewportChanged || changeTo - changeFrom > 1e3)
      return this.createDeco(update.view);
    if (changeTo > -1)
      return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
    return deco;
  }
  updateRange(view, deco, updateFrom, updateTo) {
    for (let r of view.visibleRanges) {
      let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
      if (to > from) {
        let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
        let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
        if (this.boundary) {
          for (; from > fromLine.from; from--)
            if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
              start = from;
              break;
            }
          for (; to < toLine.to; to++)
            if (this.boundary.test(toLine.text[to - toLine.from])) {
              end = to;
              break;
            }
        }
        let ranges = [], m;
        if (fromLine == toLine) {
          this.regexp.lastIndex = start - fromLine.from;
          while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) {
            let pos = m.index + fromLine.from;
            ranges.push(this.getDeco(m, view, pos).range(pos, pos + m[0].length));
          }
        } else {
          iterMatches(view.state.doc, this.regexp, start, end, (from2, to2, m2) => ranges.push(this.getDeco(m2, view, from2).range(from2, to2)));
        }
        deco = deco.update({filterFrom: start, filterTo: end, filter: () => false, add: ranges});
      }
    }
    return deco;
  }
};
var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
var Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
var Names = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
var _supportsTabSize = null;
function supportsTabSize() {
  var _a;
  if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
    let styles = document.body.style;
    _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
  }
  return _supportsTabSize || false;
}
var specialCharConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let config2 = combineConfig(configs, {
      render: null,
      specialChars: Specials,
      addSpecialChars: null
    });
    if (config2.replaceTabs = !supportsTabSize())
      config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
    if (config2.addSpecialChars)
      config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
    return config2;
  }
});
function highlightSpecialChars(config2 = {}) {
  return [specialCharConfig.of(config2), specialCharPlugin()];
}
var _plugin = null;
function specialCharPlugin() {
  return _plugin || (_plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = Decoration.none;
      this.decorationCache = Object.create(null);
      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
      this.decorations = this.decorator.createDeco(view);
    }
    makeDecorator(conf) {
      return new MatchDecorator({
        regexp: conf.specialChars,
        decoration: (m, view, pos) => {
          let {doc: doc2} = view.state;
          let code = codePointAt(m[0], 0);
          if (code == 9) {
            let line = doc2.lineAt(pos);
            let size = view.state.tabSize, col = countColumn(doc2.sliceString(line.from, pos), 0, size);
            return Decoration.replace({widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth)});
          }
          return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({widget: new SpecialCharWidget(conf, code)}));
        },
        boundary: conf.replaceTabs ? void 0 : /[^]/
      });
    }
    update(update) {
      let conf = update.state.facet(specialCharConfig);
      if (update.startState.facet(specialCharConfig) != conf) {
        this.decorator = this.makeDecorator(conf);
        this.decorations = this.decorator.createDeco(update.view);
      } else {
        this.decorations = this.decorator.updateDeco(update, this.decorations);
      }
    }
  }, {
    decorations: (v) => v.decorations
  }));
}
var DefaultPlaceholder = "\u2022";
function placeholder$1(code) {
  if (code >= 32)
    return DefaultPlaceholder;
  if (code == 10)
    return "\u2424";
  return String.fromCharCode(9216 + code);
}
var SpecialCharWidget = class extends WidgetType {
  constructor(options2, code) {
    super();
    this.options = options2;
    this.code = code;
  }
  eq(other) {
    return other.code == this.code;
  }
  toDOM(view) {
    let ph = placeholder$1(this.code);
    let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
    let custom = this.options.render && this.options.render(this.code, desc, ph);
    if (custom)
      return custom;
    let span = document.createElement("span");
    span.textContent = ph;
    span.title = desc;
    span.setAttribute("aria-label", desc);
    span.className = "cm-specialChar";
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
var TabWidget = class extends WidgetType {
  constructor(width) {
    super();
    this.width = width;
  }
  eq(other) {
    return other.width == this.width;
  }
  toDOM() {
    let span = document.createElement("span");
    span.textContent = "	";
    span.className = "cm-tab";
    span.style.width = this.width + "px";
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
function highlightActiveLine() {
  return activeLineHighlighter;
}
var lineDeco = /* @__PURE__ */ Decoration.line({attributes: {class: "cm-activeLine"}});
var activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.docChanged || update.selectionSet)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let lastLineStart = -1, deco = [];
    for (let r of view.state.selection.ranges) {
      if (!r.empty)
        return Decoration.none;
      let line = view.visualLineAt(r.head);
      if (line.from > lastLineStart) {
        deco.push(lineDeco.range(line.from));
        lastLineStart = line.from;
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});

// node_modules/lezer-tree/dist/tree.es.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var CachedNode = new WeakMap();
var NodeProp = class {
  constructor({deserialize: deserialize2} = {}) {
    this.id = nextPropID++;
    this.deserialize = deserialize2 || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  static string() {
    return new NodeProp({deserialize: (str) => str});
  }
  static number() {
    return new NodeProp({deserialize: Number});
  }
  static flag() {
    return new NodeProp({deserialize: () => true});
  }
  set(propObj, value) {
    propObj[this.id] = value;
    return propObj;
  }
  add(match) {
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({deserialize: (str) => str.split(" ")});
NodeProp.openedBy = new NodeProp({deserialize: (str) => str.split(" ")});
NodeProp.group = new NodeProp({deserialize: (str) => str.split(" ")});
var noProps = Object.create(null);
var NodeType = class {
  constructor(name2, props, id, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id;
    this.flags = flags;
  }
  static define(spec) {
    let props = spec.props && spec.props.length ? Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src2 of spec.props) {
        if (!Array.isArray(src2))
          src2 = src2(type);
        if (src2)
          src2[0].set(props, src2[1]);
      }
    return type;
  }
  prop(prop) {
    return this.props[prop.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  static match(map) {
    let direct = Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType("", Object.create(null), 0, 8);
var NodeSet = class {
  constructor(types3) {
    this.types = types3;
    for (let i = 0; i < types3.length; i++)
      if (types3[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add2 = source(type);
        if (add2) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          add2[0].set(newProps, add2[1]);
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new NodeSet(newTypes);
  }
};
var Tree = class {
  constructor(type, children, positions, length) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
  }
  toString() {
    let children = this.children.map((c) => c.toString()).join();
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  cursor(pos, side = 0) {
    let scope = pos != null && CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    if (pos != null) {
      cursor.moveTo(pos, side);
      CachedNode.set(this, cursor._tree);
    }
    return cursor;
  }
  fullCursor() {
    return new TreeCursor(this.topNode, true);
  }
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  resolve(pos, side = 0) {
    return this.cursor(pos, side).node;
  }
  iterate(spec) {
    let {enter, leave, from = 0, to = this.length} = spec;
    for (let c = this.cursor(); ; ) {
      let mustLeave = false;
      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {
        if (c.firstChild())
          continue;
        if (!c.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(c.type, c.from, c.to);
        mustLeave = c.type.isAnonymous;
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        mustLeave = true;
      }
    }
  }
  balance(maxBufferLength = DefaultBufferLength) {
    return this.children.length <= BalanceBranchFactor ? this : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length, 0);
  }
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
function withHash(tree, hash2) {
  if (hash2)
    tree.contextHash = hash2;
  return tree;
}
var TreeBuffer = class {
  constructor(buffer, length, set, type = NodeType.none) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
    this.type = type;
  }
  toString() {
    let result = [];
    for (let index2 = 0; index2 < this.buffer.length; ) {
      result.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result.join(",");
  }
  childString(index2) {
    let id = this.buffer[index2], endIndex = this.buffer[index2 + 3];
    let type = this.set.types[id], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index2 += 4;
    if (endIndex == index2)
      return result;
    let children = [];
    while (index2 < endIndex) {
      children.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  findChild(startIndex, endIndex, dir, after) {
    let {buffer} = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (after != -1e8) {
        let start = buffer[i + 1], end = buffer[i + 2];
        if (dir > 0) {
          if (end > after)
            pick = i;
          if (end > after)
            break;
        } else {
          if (start < after)
            pick = i;
          if (end >= after)
            break;
        }
      } else {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
};
var TreeNode = class {
  constructor(node, from, index2, _parent) {
    this.node = node;
    this.from = from;
    this.index = index2;
    this._parent = _parent;
  }
  get type() {
    return this.node.type;
  }
  get name() {
    return this.node.type.name;
  }
  get to() {
    return this.from + this.node.length;
  }
  nextChild(i, dir, after, full = false) {
    for (let parent = this; ; ) {
      for (let {children, positions} = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i], start = positions[i] + parent.from;
        if (after != -1e8 && (dir < 0 ? start >= after : start + next.length <= after))
          continue;
        if (next instanceof TreeBuffer) {
          let index2 = next.findChild(0, next.buffer.length, dir, after == -1e8 ? -1e8 : after - start);
          if (index2 > -1)
            return new BufferNode(new BufferContext(parent, next, i, start), null, index2);
        } else if (full || (!next.type.isAnonymous || hasChild(next))) {
          let inner = new TreeNode(next, start, i, parent);
          return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);
        }
      }
      if (full || !parent.type.isAnonymous)
        return null;
      i = parent.index + dir;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, -1e8);
  }
  get lastChild() {
    return this.nextChild(this.node.children.length - 1, -1, -1e8);
  }
  childAfter(pos) {
    return this.nextChild(0, 1, pos);
  }
  childBefore(pos) {
    return this.nextChild(this.node.children.length - 1, -1, pos);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;
  }
  get prevSibling() {
    return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;
  }
  get cursor() {
    return new TreeCursor(this);
  }
  resolve(pos, side = 0) {
    return this.cursor.moveTo(pos, side).node;
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  toString() {
    return this.node.toString();
  }
};
function getChildren(node, type, before, after) {
  let cur2 = node.cursor, result = [];
  if (!cur2.firstChild())
    return result;
  if (before != null) {
    while (!cur2.type.is(before))
      if (!cur2.nextSibling())
        return result;
  }
  for (; ; ) {
    if (after != null && cur2.type.is(after))
      return result;
    if (cur2.type.is(type))
      result.push(cur2.node);
    if (!cur2.nextSibling())
      return after == null ? result : [];
  }
}
var BufferContext = class {
  constructor(parent, buffer, index2, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index2;
    this.start = start;
  }
};
var BufferNode = class {
  constructor(context, _parent, index2) {
    this.context = context;
    this._parent = _parent;
    this.index = index2;
    this.type = context.buffer.set.types[context.buffer.buffer[index2]];
  }
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  child(dir, after) {
    let {buffer} = this.context;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -1e8 ? -1e8 : after - this.context.start);
    return index2 < 0 ? null : new BufferNode(this.context, this, index2);
  }
  get firstChild() {
    return this.child(1, -1e8);
  }
  get lastChild() {
    return this.child(-1, -1e8);
  }
  childAfter(pos) {
    return this.child(1, pos);
  }
  childBefore(pos) {
    return this.child(-1, pos);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);
  }
  get nextSibling() {
    let {buffer} = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let {buffer} = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -1e8));
  }
  get cursor() {
    return new TreeCursor(this);
  }
  resolve(pos, side = 0) {
    return this.cursor.moveTo(pos, side).node;
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
};
var TreeCursor = class {
  constructor(node, full = false) {
    this.full = full;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  get name() {
    return this.type.name;
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index2, type) {
    this.index = index2;
    let {start, buffer} = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index2]];
    this.from = start + buffer.buffer[index2 + 1];
    this.to = start + buffer.buffer[index2 + 2];
    return true;
  }
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enter(dir, after) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));
    let {buffer} = this.buffer;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -1e8 ? -1e8 : after - this.buffer.start);
    if (index2 < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index2);
  }
  firstChild() {
    return this.enter(1, -1e8);
  }
  lastChild() {
    return this.enter(-1, -1e8);
  }
  childAfter(pos) {
    return this.enter(1, pos);
  }
  childBefore(pos) {
    return this.enter(-1, pos);
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -1e8, this.full));
    let {buffer} = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -1e8));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -1e8, this.full)) : false;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index2, parent, {buffer} = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({index: index2, parent} = buffer);
    } else {
      ({index: index2, _parent: parent} = this._tree);
    }
    for (; parent; {index: index2, _parent: parent} = parent) {
      for (let i = index2 + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
        let child = parent.node.children[i];
        if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child))
          return false;
      }
    }
    return true;
  }
  move(dir) {
    if (this.enter(dir, -1e8))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  next() {
    return this.move(1);
  }
  prev() {
    return this.move(-1);
  }
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    for (; ; ) {
      if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos))
        break;
      if (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) {
        this.parent();
        break;
      }
    }
    return this;
  }
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache = this.bufferNode, result = null, depth2 = 0;
    if (cache && cache.context == this.buffer) {
      scan:
        for (let index2 = this.index, d = this.stack.length; d >= 0; ) {
          for (let c = cache; c; c = c._parent)
            if (c.index == index2) {
              if (index2 == this.index)
                return c;
              result = c;
              depth2 = d + 1;
              break scan;
            }
          index2 = this.stack[--d];
        }
    }
    for (let i = depth2; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree.node;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch));
}
var FlatBufferCursor = class {
  constructor(buffer, index2) {
    this.buffer = buffer;
    this.index = index2;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }
};
var BalanceBranchFactor = 8;
function buildTree(data) {
  var _a;
  let {buffer, nodeSet, topID = 0, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length} = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types3 = nodeSet.types;
  let contextHash = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
    let {id, start, end, size} = cursor;
    let startPos = start - parentStart;
    if (size < 0) {
      if (size == -1) {
        children2.push(reused[id]);
        positions2.push(startPos);
      } else {
        contextHash = id;
      }
      cursor.next();
      return;
    }
    let type = types3[id], node, buffer2;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor.pos - buffer2.size, index2 = data2.length;
      while (cursor.pos > endPos)
        index2 = copyToBuffer(buffer2.start, data2, index2, inRepeat);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet, inRepeat < 0 ? NodeType.none : types3[inRepeat]);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id >= minRepeatType ? id : -1;
      while (cursor.pos > endPos) {
        if (cursor.id == localInRepeat)
          cursor.next();
        else
          takeNode(start, endPos, localChildren, localPositions, localInRepeat);
      }
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)
        node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start, contextHash);
      else
        node = withHash(new Tree(type, localChildren, localPositions, end - start), contextHash);
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = {size: 0, start: 0, skip: 0};
    scan:
      for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        if (fork.id == inRepeat) {
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        let nodeSize = fork.size, startPos = fork.pos - nodeSize;
        if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart2 = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0)
            break scan;
          if (fork.id >= minRepeatType)
            localSkipped += 4;
          fork.next();
        }
        start = nodeStart2;
        size += nodeSize;
        skip += localSkipped;
      }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index2, inRepeat) {
    let {id, start, end, size} = cursor;
    cursor.next();
    if (id == inRepeat)
      return index2;
    let startIndex = index2;
    if (size > 4) {
      let endPos = cursor.pos - (size - 4);
      while (cursor.pos > endPos)
        index2 = copyToBuffer(bufferStart, buffer2, index2, inRepeat);
    }
    if (id < minRepeatType) {
      buffer2[--index2] = startIndex;
      buffer2[--index2] = end - bufferStart;
      buffer2[--index2] = start - bufferStart;
      buffer2[--index2] = id;
    }
    return index2;
  }
  let children = [], positions = [];
  while (cursor.pos > 0)
    takeNode(data.start || 0, 0, children, positions, -1);
  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types3[topID], children.reverse(), positions.reverse(), length);
}
function balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length, contextHash) {
  let localChildren = [], localPositions = [];
  if (length <= maxBufferLength) {
    for (let i = from; i < to; i++) {
      localChildren.push(children[i]);
      localPositions.push(positions[i] - start);
    }
  } else {
    let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));
    for (let i = from; i < to; ) {
      let groupFrom = i, groupStart = positions[i];
      i++;
      for (; i < to; i++) {
        let nextEnd = positions[i] + children[i].length;
        if (nextEnd - groupStart > maxChild)
          break;
      }
      if (i == groupFrom + 1) {
        let only = children[groupFrom];
        if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) {
          for (let j = 0; j < only.children.length; j++) {
            localChildren.push(only.children[j]);
            localPositions.push(only.positions[j] + groupStart - start);
          }
          continue;
        }
        localChildren.push(only);
      } else if (i == groupFrom + 1) {
        localChildren.push(children[groupFrom]);
      } else {
        let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart, contextHash);
        if (innerType != NodeType.none && !containsType(inner.children, innerType))
          inner = withHash(new Tree(NodeType.none, inner.children, inner.positions, inner.length), contextHash);
        localChildren.push(inner);
      }
      localPositions.push(groupStart - start);
    }
  }
  return withHash(new Tree(outerType, localChildren, localPositions, length), contextHash);
}
function containsType(nodes, type) {
  for (let elt of nodes)
    if (elt.type == type)
      return true;
  return false;
}
var TreeFragment = class {
  constructor(from, to, tree, offset, open) {
    this.from = from;
    this.to = to;
    this.tree = tree;
    this.offset = offset;
    this.open = open;
  }
  get openStart() {
    return (this.open & 1) > 0;
  }
  get openEnd() {
    return (this.open & 2) > 0;
  }
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length)
      return fragments;
    let result = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    let cI = 0, pos = 0, off = 0;
    for (; ; ) {
      let nextC = cI < changes.length ? changes[cI++] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off) {
            let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
            cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1 : 0) | (nextC ? 2 : 0));
          }
          if (cut)
            result.push(cut);
          if (nextF.to > nextPos)
            break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
      if (!nextC)
        break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }
    return result;
  }
  static addTree(tree, fragments = [], partial = false) {
    let result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2 : 0)];
    for (let f of fragments)
      if (f.to > tree.length)
        result.push(f);
    return result;
  }
};
function stringInput(input) {
  return new StringInput(input);
}
var StringInput = class {
  constructor(string2, length = string2.length) {
    this.string = string2;
    this.length = length;
  }
  get(pos) {
    return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);
  }
  lineAfter(pos) {
    if (pos < 0)
      return "";
    let end = this.string.indexOf("\n", pos);
    return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));
  }
  read(from, to) {
    return this.string.slice(from, Math.min(this.length, to));
  }
  clip(at) {
    return new StringInput(this.string, at);
  }
};

// node_modules/lezer/dist/index.es.js
var Stack = class {
  constructor(p, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, parent) {
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score2;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.parent = parent;
  }
  toString() {
    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(p, state, pos = 0) {
    let cx = p.parser.context;
    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  reduce(action) {
    let depth2 = action >> 19, type = action & 65535;
    let {parser: parser2} = this.p;
    let dPrec = parser2.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth2 == 0) {
      if (type < parser2.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, 4, true);
      this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
      this.reduceContext(type);
      return;
    }
    let base2 = this.stack.length - (depth2 - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = this.stack[base2 - 2];
    let bufferBase = this.stack[base2 - 1], count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base2];
    } else {
      let baseStateID = this.stack[base2 - 3];
      this.state = parser2.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base2)
      this.stack.pop();
    this.reduceContext(type);
  }
  storeNode(term, start, end, size = 4, isReduce = false) {
    if (term == 0) {
      let cur2 = this, top2 = this.buffer.length;
      if (top2 == 0 && cur2.parent) {
        top2 = cur2.bufferBase - cur2.parent.bufferBase;
        cur2 = cur2.parent;
      }
      if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
        if (start == end)
          return;
        if (cur2.buffer[top2 - 2] >= start) {
          cur2.buffer[top2 - 2] = end;
          return;
        }
      }
    }
    if (!isReduce || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index2 = this.buffer.length;
      if (index2 > 0 && this.buffer[index2 - 4] != 0)
        while (index2 > 0 && this.buffer[index2 - 2] > end) {
          this.buffer[index2] = this.buffer[index2 - 4];
          this.buffer[index2 + 1] = this.buffer[index2 - 3];
          this.buffer[index2 + 2] = this.buffer[index2 - 2];
          this.buffer[index2 + 3] = this.buffer[index2 - 1];
          index2 -= 4;
          if (size > 4)
            size -= 4;
        }
      this.buffer[index2] = term;
      this.buffer[index2 + 1] = start;
      this.buffer[index2 + 2] = end;
      this.buffer[index2 + 3] = size;
    }
  }
  shift(action, next, nextEnd) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let start = this.pos, nextState = action, {parser: parser2} = this.p;
      if (nextEnd > this.pos || next <= parser2.maxNode) {
        this.pos = nextEnd;
        if (!parser2.stateFlag(nextState, 1))
          this.reducePos = nextEnd;
      }
      this.pushState(nextState, start);
      if (next <= parser2.maxNode)
        this.buffer.push(next, start, nextEnd, 4);
      this.shiftContext(next);
    } else {
      if (next <= this.p.parser.maxNode)
        this.buffer.push(next, this.pos, nextEnd, 4);
      this.pos = nextEnd;
    }
  }
  apply(action, next, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next, nextEnd);
  }
  useNode(value, next) {
    let index2 = this.p.reused.length - 1;
    if (index2 < 0 || this.p.reused[index2] != value) {
      this.p.reused.push(value);
      index2++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(index2, start, this.reducePos, -1);
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this.p.input, this));
  }
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
    while (parent && base2 == parent.bufferBase)
      parent = parent.parent;
    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, parent);
  }
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 200;
  }
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(sim.top, 4) || this.p.parser.hasAction(sim.top, term);
      if ((action & 65536) == 0)
        return true;
      if (action == 0)
        return false;
      sim.reduce(action);
    }
  }
  get ruleStart() {
    for (let state = this.state, base2 = this.stack.length; ; ) {
      let force = this.p.parser.stateSlot(state, 5);
      if (!(force & 65536))
        return 0;
      base2 -= 3 * (force >> 19);
      if ((force & 65535) < this.p.parser.minRepeatTerm)
        return this.stack[base2 + 1];
      state = this.stack[base2];
    }
  }
  startOf(types3, before) {
    let state = this.state, frame = this.stack.length, {parser: parser2} = this.p;
    for (; ; ) {
      let force = parser2.stateSlot(state, 5);
      let depth2 = force >> 19, term = force & 65535;
      if (types3.indexOf(term) > -1) {
        let base2 = frame - 3 * (force >> 19), pos = this.stack[base2 + 1];
        if (before == null || before > pos)
          return pos;
      }
      if (frame == 0)
        return null;
      if (depth2 == 0) {
        frame -= 3;
        state = this.stack[frame];
      } else {
        frame -= 3 * (depth2 - 1);
        state = parser2.getGoto(this.stack[frame - 3], term, true);
      }
    }
  }
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i = 0, s2; i < nextStates.length; i += 2) {
        if ((s2 = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s2, next))
          best.push(nextStates[i], s2);
      }
      if (this.stack.length < 120)
        for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
          let s2 = nextStates[i + 1];
          if (!best.some((v, i2) => i2 & 1 && v == s2))
            best.push(nextStates[i], s2);
        }
      nextStates = best;
    }
    let result = [];
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s2 = nextStates[i + 1];
      if (s2 == this.state)
        continue;
      let stack = this.split();
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.pushState(s2, this.pos);
      stack.shiftContext(nextStates[i]);
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  forceReduce() {
    let reduce = this.p.parser.stateSlot(this.state, 5);
    if ((reduce & 65536) == 0)
      return false;
    if (!this.p.parser.validAction(this.state, reduce)) {
      this.storeNode(0, this.reducePos, this.reducePos, 4, true);
      this.score -= 100;
    }
    this.reduce(reduce);
    return true;
  }
  forceAll() {
    while (!this.p.parser.stateFlag(this.state, 2) && this.forceReduce()) {
    }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let {parser: parser2} = this.p;
    return parser2.data[parser2.stateSlot(this.state, 1)] == 65535 && !parser2.stateSlot(this.state, 4);
  }
  restart() {
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i = 0; i < this.stack.length; i += 3)
      if (this.stack[i] != other.stack[i])
        return false;
    return true;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this.p.input, this));
  }
  reduceContext(term) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this.p.input, this));
  }
  emitContext() {
    let cx = this.curContext;
    if (!cx.tracker.strict)
      return;
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -2)
      this.buffer.push(cx.hash, this.reducePos, this.reducePos, -2);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
};
var StackContext = class {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.hash(context);
  }
};
var Recover;
(function(Recover2) {
  Recover2[Recover2["Token"] = 200] = "Token";
  Recover2[Recover2["Reduce"] = 100] = "Reduce";
  Recover2[Recover2["MaxNext"] = 4] = "MaxNext";
  Recover2[Recover2["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
  Recover2[Recover2["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
var SimulatedStack = class {
  constructor(stack) {
    this.stack = stack;
    this.top = stack.state;
    this.rest = stack.stack;
    this.offset = this.rest.length;
  }
  reduce(action) {
    let term = action & 65535, depth2 = action >> 19;
    if (depth2 == 0) {
      if (this.rest == this.stack.stack)
        this.rest = this.rest.slice();
      this.rest.push(this.top, 0, 0);
      this.offset += 3;
    } else {
      this.offset -= (depth2 - 1) * 3;
    }
    let goto = this.stack.p.parser.getGoto(this.rest[this.offset - 3], term, true);
    this.top = goto;
  }
};
var StackBufferCursor = class {
  constructor(stack, pos, index2) {
    this.stack = stack;
    this.pos = pos;
    this.index = index2;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack) {
    return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index);
  }
};
var Token = class {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
  }
  accept(value, end) {
    this.value = value;
    this.end = end;
  }
};
var TokenGroup = class {
  constructor(data, id) {
    this.data = data;
    this.id = id;
  }
  token(input, token, stack) {
    readToken(this.data, input, token, stack, this.id);
  }
};
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var ExternalTokenizer = class {
  constructor(token, options2 = {}) {
    this.token = token;
    this.contextual = !!options2.contextual;
    this.fallback = !!options2.fallback;
    this.extend = !!options2.extend;
  }
};
function readToken(data, input, token, stack, group) {
  let state = 0, groupMask = 1 << group, dialect = stack.p.parser.dialect;
  scan:
    for (let pos = token.start; ; ) {
      if ((groupMask & data[state]) == 0)
        break;
      let accEnd = data[state + 1];
      for (let i = state + 3; i < accEnd; i += 2)
        if ((data[i + 1] & groupMask) > 0) {
          let term = data[i];
          if (dialect.allows(term) && (token.value == -1 || token.value == term || stack.p.parser.overrides(term, token.value))) {
            token.accept(term, pos);
            break;
          }
        }
      let next = input.get(pos++);
      for (let low = 0, high = data[state + 2]; low < high; ) {
        let mid = low + high >> 1;
        let index2 = accEnd + mid + (mid << 1);
        let from = data[index2], to = data[index2 + 1];
        if (next < from)
          high = mid;
        else if (next >= to)
          low = mid + 1;
        else {
          state = data[index2 + 2];
          continue scan;
        }
      }
      break;
    }
}
function decodeArray(input, Type = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type(value);
  }
  return array;
}
var verbose = typeof process != "undefined" && /\bparse\b/.test(process.env.LOG);
var stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor = tree.cursor(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
          return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 5)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 5));
        if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
          break;
        if (!cursor.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
var FragmentCursor = class {
  constructor(fragments) {
    this.fragments = fragments;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top2 = this.trees[last], index2 = this.index[last];
      if (index2 == top2.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top2.children[index2];
      let start = this.start[last] + top2.positions[index2];
      if (start > pos) {
        this.nextStart = start;
        return null;
      } else if (start == pos && start + next.length <= this.safeTo) {
        return start == pos && start >= this.safeFrom ? next : null;
      }
      if (next instanceof TreeBuffer) {
        this.index[last]++;
        this.nextStart = start + next.length;
      } else {
        this.index[last]++;
        if (start + next.length >= pos) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      }
    }
  }
};
var CachedToken = class extends Token {
  constructor() {
    super(...arguments);
    this.extended = -1;
    this.mask = 0;
    this.context = 0;
  }
  clear(start) {
    this.start = start;
    this.value = this.extended = -1;
  }
};
var dummyToken = new Token();
var TokenCache = class {
  constructor(parser2) {
    this.tokens = [];
    this.mainToken = dummyToken;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_) => new CachedToken());
  }
  getActions(stack, input) {
    let actionIndex = 0;
    let main = null;
    let {parser: parser2} = stack.p, {tokenizers} = parser2;
    let mask = parser2.stateSlot(stack.state, 3);
    let context = stack.curContext ? stack.curContext.hash : 0;
    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0)
        continue;
      let tokenizer = tokenizers[i], token = this.tokens[i];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack, input);
        token.mask = mask;
        token.context = context;
      }
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (!main) {
      main = dummyToken;
      main.start = stack.pos;
      if (stack.pos == input.length)
        main.accept(stack.p.parser.eofTerm, stack.pos);
      else
        main.accept(0, stack.pos + 1);
    }
    this.mainToken = main;
    return this.actions;
  }
  updateCachedToken(token, tokenizer, stack, input) {
    token.clear(stack.pos);
    tokenizer.token(input, token, stack);
    if (token.value > -1) {
      let {parser: parser2} = stack.p;
      for (let i = 0; i < parser2.specialized.length; i++)
        if (parser2.specialized[i] == token.value) {
          let result = parser2.specializers[i](input.read(token.start, token.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token.value = result >> 1;
            else
              token.extended = result >> 1;
            break;
          }
        }
    } else if (stack.pos == input.length) {
      token.accept(stack.p.parser.eofTerm, stack.pos);
    } else {
      token.accept(0, stack.pos + 1);
    }
  }
  putAction(action, token, end, index2) {
    for (let i = 0; i < index2; i += 3)
      if (this.actions[i] == action)
        return index2;
    this.actions[index2++] = action;
    this.actions[index2++] = token;
    this.actions[index2++] = end;
    return index2;
  }
  addActions(stack, token, end, index2) {
    let {state} = stack, {parser: parser2} = stack.p, {data} = parser2;
    for (let set = 0; set < 2; set++) {
      for (let i = parser2.stateSlot(state, set ? 2 : 1); ; i += 3) {
        if (data[i] == 65535) {
          if (data[i + 1] == 1) {
            i = pair(data, i + 2);
          } else {
            if (index2 == 0 && data[i + 1] == 2)
              index2 = this.putAction(pair(data, i + 1), token, end, index2);
            break;
          }
        }
        if (data[i] == token)
          index2 = this.putAction(pair(data, i + 1), token, end, index2);
      }
    }
    return index2;
  }
};
var Rec;
(function(Rec2) {
  Rec2[Rec2["Distance"] = 5] = "Distance";
  Rec2[Rec2["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
  Rec2[Rec2["MinBufferLengthPrune"] = 200] = "MinBufferLengthPrune";
  Rec2[Rec2["ForceReduceLimit"] = 10] = "ForceReduceLimit";
})(Rec || (Rec = {}));
var Parse = class {
  constructor(parser2, input, startPos, context) {
    this.parser = parser2;
    this.input = input;
    this.startPos = startPos;
    this.context = context;
    this.pos = 0;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.nested = null;
    this.nestEnd = 0;
    this.nestWrap = null;
    this.reused = [];
    this.tokens = new TokenCache(parser2);
    this.topTerm = parser2.top[1];
    this.stacks = [Stack.start(this, parser2.top[0], this.startPos)];
    let fragments = context === null || context === void 0 ? void 0 : context.fragments;
    this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null;
  }
  advance() {
    if (this.nested) {
      let result = this.nested.advance();
      this.pos = this.nested.pos;
      if (result) {
        this.finishNested(this.stacks[0], result);
        this.nested = null;
      }
      return null;
    }
    let stacks = this.stacks, pos = this.pos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    let maybeNest;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i], nest;
      for (; ; ) {
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (nest = this.checkNest(stack)) {
          if (!maybeNest || maybeNest.stack.score < stack.score)
            maybeNest = nest;
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.mainToken;
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (maybeNest) {
      this.startNested(maybeNest);
      return null;
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished)
        return this.stackToTree(finished);
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + this.parser.getName(this.tokens.mainToken.value));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished)
        return this.stackToTree(finished.forceAll());
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s2) => s2.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer:
        for (let i = 0; i < newStacks.length - 1; i++) {
          let stack = newStacks[i];
          for (let j = i + 1; j < newStacks.length; j++) {
            let other = newStacks[j];
            if (stack.sameState(other) || stack.buffer.length > 200 && other.buffer.length > 200) {
              if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                newStacks.splice(j--, 1);
              } else {
                newStacks.splice(i--, 1);
                continue outer;
              }
            }
          }
        }
    }
    this.pos = newStacks[0].pos;
    for (let i = 1; i < newStacks.length; i++)
      if (newStacks[i].pos < this.pos)
        this.pos = newStacks[i].pos;
    return null;
  }
  advanceStack(stack, stacks, split) {
    let start = stack.pos, {input, parser: parser2} = this;
    let base2 = verbose ? this.stackID(stack) + " -> " : "";
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached2 = this.fragments.nodeAt(start); cached2; ) {
        let match = this.parser.nodeSet.types[cached2.type.id] == cached2.type ? parser2.getGoto(stack.state, cached2.type.id) : -1;
        if (match > -1 && cached2.length && (!strictCx || (cached2.contextHash || 0) == cxHash)) {
          stack.useNode(cached2, match);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached2.type.id)})`);
          return true;
        }
        if (!(cached2 instanceof Tree) || cached2.children.length == 0 || cached2.positions[0] > 0)
          break;
        let inner = cached2.children[0];
        if (inner instanceof Tree)
          cached2 = inner;
        else
          break;
      }
    }
    let defaultReduce = parser2.stateSlot(stack.state, 4);
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser2.getName(defaultReduce & 65535)})`);
      return true;
    }
    let actions = this.tokens.getActions(stack, input);
    for (let i = 0; i < actions.length; ) {
      let action = actions[i++], term = actions[i++], end = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack : stack.split();
      localStack.apply(action, term, end);
      if (verbose)
        console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(action & 65535)}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      let nest = this.checkNest(stack);
      if (nest)
        return nest;
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    let maybeNest;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base2 + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done) {
          if (done !== true)
            maybeNest = done;
          continue;
        }
      }
      let force = stack.split(), forceBase = base2;
      for (let j = 0; force.forceReduce() && j < 10; j++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done) {
          if (done !== true)
            maybeNest = done;
          break;
        }
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert2 of stack.recoverByInsert(token)) {
        if (verbose)
          console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
        this.advanceFully(insert2, newStacks);
      }
      if (this.input.length > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    if (finished)
      return finished;
    if (maybeNest) {
      for (let s2 of this.stacks)
        if (s2.score > maybeNest.stack.score) {
          maybeNest = void 0;
          break;
        }
    }
    if (maybeNest)
      this.startNested(maybeNest);
    return null;
  }
  forceFinish() {
    let stack = this.stacks[0].split();
    if (this.nested)
      this.finishNested(stack, this.nested.forceFinish());
    return this.stackToTree(stack.forceAll());
  }
  stackToTree(stack, pos = stack.pos) {
    if (this.parser.context)
      stack.emitContext();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.startPos,
      length: pos - this.startPos,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  checkNest(stack) {
    let info = this.parser.findNested(stack.state);
    if (!info)
      return null;
    let spec = info.value;
    if (typeof spec == "function")
      spec = spec(this.input, stack);
    return spec ? {stack, info, spec} : null;
  }
  startNested(nest) {
    let {stack, info, spec} = nest;
    this.stacks = [stack];
    this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd);
    this.nestWrap = typeof spec.wrapType == "number" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null;
    if (spec.startParse) {
      this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context);
    } else {
      this.finishNested(stack);
    }
  }
  scanForNestEnd(stack, endToken, filter) {
    for (let pos = stack.pos; pos < this.input.length; pos++) {
      dummyToken.start = pos;
      dummyToken.value = -1;
      endToken.token(this.input, dummyToken, stack);
      if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end))))
        return pos;
    }
    return this.input.length;
  }
  finishNested(stack, tree) {
    if (this.nestWrap)
      tree = new Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos);
    else if (!tree)
      tree = new Tree(NodeType.none, [], [], this.nestEnd - stack.pos);
    let info = this.parser.findNested(stack.state);
    stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true));
    if (verbose)
      console.log(this.stackID(stack) + ` (via unnest)`);
  }
  stackID(stack) {
    let id = (stackIDs || (stackIDs = new WeakMap())).get(stack);
    if (!id)
      stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
    return id + stack;
  }
};
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score)
        newStacks[i] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
var Dialect = class {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
};
var Parser = class {
  constructor(spec) {
    this.bufferLength = DefaultBufferLength;
    this.strict = false;
    this.cachedDialect = null;
    if (spec.version != 13)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13})`);
    let tokenArray = decodeArray(spec.tokenData);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    this.context = spec.context;
    for (let i = 0; i < spec.repeatNodeCount; i++)
      nodeNames.push("");
    let nodeProps = [];
    for (let i = 0; i < nodeNames.length; i++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        for (let i = 1; i < propSpec.length; ) {
          let next = propSpec[i++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i++]);
          } else {
            let value = propSpec[i + -next];
            for (let j = -next; j > 0; j--)
              setProp(propSpec[i++], prop, value);
            i++;
          }
        }
      }
    this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
    this.specializers = [];
    if (spec.specialized)
      for (let i = 0; i < spec.specialized.length; i++) {
        this.specialized[i] = spec.specialized[i].term;
        this.specializers[i] = spec.specialized[i].get;
      }
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
    this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
      name: i >= this.minRepeatTerm ? void 0 : name2,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.nested = (spec.nested || []).map(([name2, value, endToken, placeholder]) => {
      return {name: name2, value, end: new TokenGroup(decodeArray(endToken), 0), placeholder};
    });
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  parse(input, startPos = 0, context = {}) {
    if (typeof input == "string")
      input = stringInput(input);
    let cx = new Parse(this, input, startPos, context);
    for (; ; ) {
      let done = cx.advance();
      if (done)
        return done;
    }
  }
  startParse(input, startPos = 0, context = {}) {
    if (typeof input == "string")
      input = stringInput(input);
    return new Parse(this, input, startPos, context);
  }
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last = groupTag & 1;
      let target = table[pos++];
      if (last && loose)
        return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table[pos] == state)
          return target;
      if (last)
        return -1;
    }
  }
  hasAction(state, terminal) {
    let data = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i = this.stateSlot(state, set ? 2 : 1), next; ; i += 3) {
        if ((next = data[i]) == 65535) {
          if (data[i + 1] == 1)
            next = data[i = pair(data, i + 2)];
          else if (data[i + 1] == 2)
            return pair(data, i + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data, i + 1);
      }
    }
    return 0;
  }
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  stateFlag(state, flag) {
    return (this.stateSlot(state, 0) & flag) > 0;
  }
  findNested(state) {
    let flags = this.stateSlot(state, 0);
    return flags & 4 ? this.nested[flags >> 10] : null;
  }
  validAction(state, action) {
    if (action == this.stateSlot(state, 4))
      return true;
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          return false;
      }
      if (action == pair(this.data, i + 1))
        return true;
    }
  }
  nextStates(state) {
    let result = [];
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      if ((this.data[i + 2] & 65536 >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i2) => i2 & 1 && v == value))
          result.push(this.data[i], value);
      }
    }
    return result;
  }
  overrides(token, prev) {
    let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
  }
  configure(config2) {
    let copy = Object.assign(Object.create(Parser.prototype), this);
    if (config2.props)
      copy.nodeSet = this.nodeSet.extend(...config2.props);
    if (config2.top) {
      let info = this.topRules[config2.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config2.top}`);
      copy.top = info;
    }
    if (config2.tokenizers)
      copy.tokenizers = this.tokenizers.map((t2) => {
        let found = config2.tokenizers.find((r) => r.from == t2);
        return found ? found.to : t2;
      });
    if (config2.dialect)
      copy.dialect = this.parseDialect(config2.dialect);
    if (config2.nested)
      copy.nested = this.nested.map((obj) => {
        if (!Object.prototype.hasOwnProperty.call(config2.nested, obj.name))
          return obj;
        return {name: obj.name, value: config2.nested[obj.name], end: obj.end, placeholder: obj.placeholder};
      });
    if (config2.strict != null)
      copy.strict = config2.strict;
    if (config2.bufferLength != null)
      copy.bufferLength = config2.bufferLength;
    return copy;
  }
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get hasNested() {
    return this.nested.length > 0;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(term) {
    let prec2 = this.dynamicPrecedences;
    return prec2 == null ? 0 : prec2[term] || 0;
  }
  parseDialect(dialect) {
    if (this.cachedDialect && this.cachedDialect.source == dialect)
      return this.cachedDialect;
    let values = Object.keys(this.dialects), flags = values.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id = values.indexOf(part);
        if (id >= 0)
          flags[id] = true;
      }
    let disabled = null;
    for (let i = 0; i < values.length; i++)
      if (!flags[i]) {
        for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
      }
    return this.cachedDialect = new Dialect(dialect, flags, disabled);
  }
  static deserialize(spec) {
    return new Parser(spec);
  }
};
function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}
function findOffset(data, start, term) {
  for (let i = start, next; (next = data[i]) != 65535; i++)
    if (next == term)
      return i - start;
  return -1;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    if (stack.pos == stack.p.input.length && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}

// node_modules/lezer-javascript/dist/index.es.js
var noSemi = 269;
var incdec = 1;
var incdecPrefix = 2;
var templateContent = 270;
var templateDollarBrace = 271;
var templateEnd = 272;
var insertSemi = 273;
var TSExtends = 3;
var Dialect_ts = 1;
var newline = [10, 13, 8232, 8233];
var space = [9, 11, 12, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288];
var braceR = 125;
var braceL = 123;
var semicolon = 59;
var slash = 47;
var star = 42;
var plus = 43;
var minus = 45;
var dollar = 36;
var backtick = 96;
var backslash = 92;
function newlineBefore(input, pos) {
  for (let i = pos - 1; i >= 0; i--) {
    let prev = input.get(i);
    if (newline.indexOf(prev) > -1)
      return true;
    if (space.indexOf(prev) < 0)
      break;
  }
  return false;
}
var insertSemicolon = new ExternalTokenizer((input, token, stack) => {
  let pos = token.start, next = input.get(pos);
  if ((next == braceR || next == -1 || newlineBefore(input, pos)) && stack.canShift(insertSemi))
    token.accept(insertSemi, token.start);
}, {contextual: true, fallback: true});
var noSemicolon = new ExternalTokenizer((input, token, stack) => {
  let pos = token.start, next = input.get(pos++);
  if (space.indexOf(next) > -1 || newline.indexOf(next) > -1)
    return;
  if (next == slash) {
    let after = input.get(pos++);
    if (after == slash || after == star)
      return;
  }
  if (next != braceR && next != semicolon && next != -1 && !newlineBefore(input, token.start) && stack.canShift(noSemi))
    token.accept(noSemi, token.start);
}, {contextual: true});
var incdecToken = new ExternalTokenizer((input, token, stack) => {
  let pos = token.start, next = input.get(pos);
  if ((next == plus || next == minus) && next == input.get(pos + 1)) {
    let mayPostfix = !newlineBefore(input, token.start) && stack.canShift(incdec);
    token.accept(mayPostfix ? incdec : incdecPrefix, pos + 2);
  }
}, {contextual: true});
var template = new ExternalTokenizer((input, token) => {
  let pos = token.start, afterDollar = false;
  for (; ; ) {
    let next = input.get(pos++);
    if (next < 0) {
      if (pos - 1 > token.start)
        token.accept(templateContent, pos - 1);
      break;
    } else if (next == backtick) {
      if (pos == token.start + 1)
        token.accept(templateEnd, pos);
      else
        token.accept(templateContent, pos - 1);
      break;
    } else if (next == braceL && afterDollar) {
      if (pos == token.start + 2)
        token.accept(templateDollarBrace, pos);
      else
        token.accept(templateContent, pos - 2);
      break;
    } else if (next == 10 && pos > token.start + 1) {
      token.accept(templateContent, pos);
      break;
    } else if (next == backslash && pos != input.length) {
      pos++;
    }
    afterDollar = next == dollar;
  }
});
function tsExtends(value, stack) {
  return value == "extends" && stack.dialectEnabled(Dialect_ts) ? TSExtends : -1;
}
var spec_identifier = {__proto__: null, export: 16, as: 21, from: 25, default: 30, async: 35, function: 36, this: 46, true: 54, false: 54, void: 58, typeof: 62, null: 76, super: 78, new: 112, await: 129, yield: 131, delete: 132, class: 142, extends: 144, public: 181, private: 181, protected: 181, readonly: 183, in: 202, instanceof: 204, const: 206, import: 238, keyof: 289, unique: 293, infer: 299, is: 333, abstract: 353, implements: 355, type: 357, let: 360, var: 362, interface: 369, enum: 373, namespace: 379, module: 381, declare: 385, global: 389, for: 410, of: 419, while: 422, with: 426, do: 430, if: 434, else: 436, switch: 440, case: 446, try: 452, catch: 454, finally: 456, return: 460, throw: 464, break: 468, continue: 472, debugger: 476};
var spec_word = {__proto__: null, async: 99, get: 101, set: 103, public: 151, private: 151, protected: 151, static: 153, abstract: 155, readonly: 159, new: 337};
var spec_LessThan = {__proto__: null, "<": 119};
var parser = Parser.deserialize({
  version: 13,
  states: "$,lO]QYOOO&zQ!LdO'#CgO'ROSO'#DRO)ZQYO'#DWO)kQYO'#DcO)rQYO'#DmO-iQYO'#DsOOQO'#ET'#ETO-|QWO'#ESO.RQWO'#ESO0QQ!LdO'#IgO2hQ!LdO'#IhO3UQWO'#EqO3ZQpO'#FWOOQ!LS'#Ey'#EyO3cO!bO'#EyO3qQWO'#F_O4{QWO'#F^OOQ!LS'#Ih'#IhOOQ!LQ'#Ig'#IgOOQQ'#JR'#JRO5QQWO'#HeO5VQ!LYO'#HfOOQQ'#I['#I[OOQQ'#Hg'#HgQ]QYOOO)rQYO'#DeO5_QWO'#GRO5dQ#tO'#ClO5rQWO'#ERO5}Q#tO'#ExO6iQWO'#GRO6nQWO'#GVO6yQWO'#GVO7XQWO'#GYO7XQWO'#GZO7XQWO'#G]O5_QWO'#G`O7xQWO'#GcO9WQWO'#CcO9hQWO'#GpO9pQWO'#GvO9pQWO'#GxO]QYO'#GzO9pQWO'#G|O9pQWO'#HPO9uQWO'#HVO9zQ!LZO'#HZO)rQYO'#H]O:VQ!LZO'#H_O:bQ!LZO'#HaO5VQ!LYO'#HcO)rQYO'#IjOOOS'#Hh'#HhO:mOSO,59mOOQ!LS,59m,59mO=OQbO'#CgO=YQYO'#HiO=gQWO'#IlO?fQbO'#IlO'^QYO'#IlO?mQWO,59rO@TQ&jO'#D]O@|QWO'#ETOAZQWO'#IvOAfQWO'#IuOAnQWO,5:qOAsQWO'#ItOAzQWO'#DtO5dQ#tO'#EROBYQWO'#EROBeQ`O'#ExOOQ!LS,59},59}OBmQYO,59}ODkQ!LdO,5:XOEXQWO,5:_OErQ!LYO'#IsO6nQWO'#IrOEyQWO'#IrOFRQWO,5:pOFWQWO'#IrOFfQYO,5:nOHcQWO'#EPOIjQWO,5:nOJvQWO'#DgOJ}QYO'#DlOKXQ&jO,5:wO)rQYO,5:wOOQQ'#Ei'#EiOOQQ'#Ek'#EkO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xOOQQ'#Eo'#EoOK^QYO,5;YOOQ!LS,5;_,5;_OOQ!LS,5;`,5;`OMZQWO,5;`OOQ!LS,5;a,5;aO)rQYO'#HsOM`Q!LYO,5;zOMzQWO,5:xO)rQYO,5;]ONdQpO'#IzONRQpO'#IzONkQpO'#IzON|QpO,5;hOOQO,5;r,5;rO! [QYO'#FYOOOO'#Hr'#HrO3cO!bO,5;eO! cQpO'#F[OOQ!LS,5;e,5;eO!!PQ,UO'#CqOOQ!LS'#Ct'#CtO!!dQWO'#CtO!!zQ#tO,5;wO!#RQWO,5;yO!$[QWO'#FiO!$iQWO'#FjO!$nQWO'#FnO!%pQ&jO'#FrO!&cQ,UO'#IeOOQ!LS'#Ie'#IeO!&mQWO'#IdO!&{QWO'#IcOOQ!LS'#Cr'#CrOOQ!LS'#Cx'#CxO!'TQWO'#CzOIoQWO'#FaOIoQWO'#FcO!'YQWO'#FeOIeQWO'#FfO!'_QWO'#FlOIoQWO'#FqO!'dQWO'#EUO!'{QWO,5;xO]QYO,5>POOQQ'#I_'#I_OOQQ,5>Q,5>QOOQQ-E;e-E;eO!)wQ!LdO,5:POOQ!LQ'#Co'#CoO!*hQ#tO,5<mOOQO'#Ce'#CeO!*yQWO'#CpO!+RQ!LYO'#I`O4{QWO'#I`O9uQWO,59WO!+aQpO,59WO!+iQ#tO,59WO5dQ#tO,59WO!+tQWO,5:nO!+|QWO'#GoO!,UQWO'#JVO)rQYO,5;bOKXQ&jO,5;dO!,^QWO,5=YO!,cQWO,5=YO!,hQWO,5=YO5VQ!LYO,5=YO5_QWO,5<mO!,vQWO'#EVO!-XQ&jO'#EWOOQ!LQ'#It'#ItO!-jQ!LYO'#JSO5VQ!LYO,5<qO7XQWO,5<wOOQO'#Cq'#CqO!-uQpO,5<tO!-}Q#tO,5<uO!.YQWO,5<wO!._Q`O,5<zO9uQWO'#GeO5_QWO'#GgO!.gQWO'#GgO5dQ#tO'#GjO!.lQWO'#GjOOQQ,5<},5<}O!.qQWO'#GkO!.yQWO'#ClO!/OQWO,58}O!/YQWO,58}O!1XQYO,58}OOQQ,58},58}O!1fQ!LYO,58}O)rQYO,58}O!1qQYO'#GrOOQQ'#Gs'#GsOOQQ'#Gt'#GtO]QYO,5=[O!2RQWO,5=[O)rQYO'#DsO]QYO,5=bO]QYO,5=dO!2WQWO,5=fO]QYO,5=hO!2]QWO,5=kO!2bQYO,5=qOOQQ,5=u,5=uO)rQYO,5=uO5VQ!LYO,5=wOOQQ,5=y,5=yO!6`QWO,5=yOOQQ,5={,5={O!6`QWO,5={OOQQ,5=},5=}O!6eQ`O,5?UOOOS-E;f-E;fOOQ!LS1G/X1G/XO!6jQbO,5>TO)rQYO,5>TOOQO-E;g-E;gO!6tQWO,5?WO!6|QbO,5?WO!7TQWO,5?aOOQ!LS1G/^1G/^O!7]QpO'#DPOOQO'#In'#InO)rQYO'#InO!7zQpO'#InO!8iQpO'#D^O!8zQ&jO'#D^O!;SQYO'#D^O!;ZQWO'#ImO!;cQWO,59wO!;hQWO'#EXO!;vQWO'#IwO!<OQWO,5:rO!<fQ&jO'#D^O)rQYO,5?bO!<pQWO'#HnO!7TQWO,5?aOOQ!LQ1G0]1G0]O!=vQ&jO'#DwOOQ!LS,5:`,5:`O)rQYO,5:`OHcQWO,5:`O!=}QWO,5:`O9uQWO,5:mO!+aQpO,5:mO!+iQ#tO,5:mO5dQ#tO,5:mOOQ!LS1G/i1G/iOOQ!LS1G/y1G/yOOQ!LQ'#EO'#EOO)rQYO,5?_O!>YQ!LYO,5?_O!>kQ!LYO,5?_O!>rQWO,5?^O!>zQWO'#HpO!>rQWO,5?^OOQ!LQ1G0[1G0[O6nQWO,5?^OOQ!LS1G0Y1G0YO!?fQ!LdO1G0YO!@VQ!LbO,5:kOOQ!LS'#Fh'#FhO!@sQ!LdO'#IeOFfQYO1G0YO!BrQ#tO'#IoO!B|QWO,5:RO!CRQbO'#IpO)rQYO'#IpO!C]QWO,5:WOOQ!LS'#DP'#DPOOQ!LS1G0c1G0cO!CbQWO1G0cO!EsQ!LdO1G0dO!EzQ!LdO1G0dO!H_Q!LdO1G0dO!HfQ!LdO1G0dO!JmQ!LdO1G0dO!KQQ!LdO1G0dO!MqQ!LdO1G0dO!MxQ!LdO1G0dO#!]Q!LdO1G0dO#!dQ!LdO1G0dO#$XQ!LdO1G0dO#'RQ7^O'#CgO#(|Q7^O1G0tO#*wQ7^O'#IhOOQ!LS1G0z1G0zO#+[Q!LdO,5>_OOQ!LQ-E;q-E;qO#+{Q!LdO1G0dOOQ!LS1G0d1G0dO#-}Q!LdO1G0wO#.nQpO,5;jO#.sQpO,5;kO#.xQpO'#FRO#/^QWO'#FQOOQO'#I{'#I{OOQO'#Hq'#HqO#/cQpO1G1SOOQ!LS1G1S1G1SOOQO1G1]1G1]O#/qQ7^O'#IgO#/{QWO,5;tOK^QYO,5;tOOOO-E;p-E;pOOQ!LS1G1P1G1POOQ!LS,5;v,5;vO#0QQpO,5;vOOQ!LS,59`,59`O)rQYO1G1cOKXQ&jO'#HuO#0VQWO,5<[OOQ!LS,5<X,5<XOOQO'#F|'#F|OIoQWO,5<gOOQO'#GO'#GOOIoQWO,5<iOIoQWO,5<kOOQO1G1e1G1eO#0bQ`O'#CoO#0uQ`O,5<TO#0|QWO'#JOO5_QWO'#JOO#1[QWO,5<VOIoQWO,5<UO#1aQ`O'#FhO#1nQ`O'#JPO#1xQWO'#JPOHcQWO'#JPO#1}QWO,5<YOOQ!LQ'#Db'#DbO#2SQWO'#FkO#2_QpO'#FsO!%kQ&jO'#FsO!%kQ&jO'#FuO#2pQWO'#FvO!'_QWO'#FyOOQO'#Hw'#HwO#2uQ&jO,5<^OOQ!LS,5<^,5<^O#2|Q&jO'#FsO#3[Q&jO'#FtO#3dQ&jO'#FtOOQ!LS,5<l,5<lOIoQWO,5?OOIoQWO,5?OO#3iQWO'#HxO#3tQWO,5>}OOQ!LS'#Cg'#CgO#4hQ#tO,59fOOQ!LS,59f,59fO#5ZQ#tO,5;{O#5|Q#tO,5;}O#6WQWO,5<POOQ!LS,5<Q,5<QO#6]QWO,5<WO#6bQ#tO,5<]OFfQYO1G1dO#6rQWO1G1dOOQQ1G3k1G3kOOQ!LS1G/k1G/kOMZQWO1G/kOOQQ1G2X1G2XOHcQWO1G2XO)rQYO1G2XOHcQWO1G2XO#6wQWO1G2XO#7VQWO,59[O#8]QWO'#EPOOQ!LQ,5>z,5>zO#8gQ!LYO,5>zOOQQ1G.r1G.rO9uQWO1G.rO!+aQpO1G.rO!+iQ#tO1G.rO#8uQWO1G0YO#8zQWO'#CgO#9VQWO'#JWO#9_QWO,5=ZO#9dQWO'#JWO#9iQWO'#IQO#9wQWO,5?qO#:PQbO1G0|OOQ!LS1G1O1G1OO5_QWO1G2tO#:WQWO1G2tO#:]QWO1G2tO#:bQWO1G2tOOQQ1G2t1G2tO#:gQ#tO1G2XO6nQWO'#IuO6nQWO'#EXO6nQWO'#HzO#:xQ!LYO,5?nOOQQ1G2]1G2]O!.YQWO1G2cOHcQWO1G2`O#;TQWO1G2`OOQQ1G2a1G2aOHcQWO1G2aO#;YQWO1G2aO#;bQ&jO'#G_OOQQ1G2c1G2cO!%kQ&jO'#H|O!._Q`O1G2fOOQQ1G2f1G2fOOQQ,5=P,5=PO#;jQ#tO,5=RO5_QWO,5=RO#2pQWO,5=UO4{QWO,5=UO!+aQpO,5=UO!+iQ#tO,5=UO5dQ#tO,5=UO#;{QWO'#JUO#<WQWO,5=VOOQQ1G.i1G.iO#<]Q!LYO1G.iO#<hQWO1G.iO!'TQWO1G.iO5VQ!LYO1G.iO#<mQbO,5?sO#<wQWO,5?sO#=SQYO,5=^O#=ZQWO,5=^O6nQWO,5?sOOQQ1G2v1G2vO]QYO1G2vOOQQ1G2|1G2|OOQQ1G3O1G3OO9pQWO1G3QO#=`QYO1G3SO#AWQYO'#HROOQQ1G3V1G3VO9uQWO1G3]O#AeQWO1G3]O5VQ!LYO1G3aOOQQ1G3c1G3cOOQ!LQ'#Fo'#FoO5VQ!LYO1G3eO5VQ!LYO1G3gOOOS1G4p1G4pO#AmQ`O,5;zO#AuQbO1G3oO#BPQWO1G4rO#BXQWO1G4{O#BaQWO,5?YOK^QYO,5:sO6nQWO,5:sO9uQWO,59xOK^QYO,59xO!+aQpO,59xO#BfQ7^O,59xOOQO,5:s,5:sO#BpQ&jO'#HjO#CWQWO,5?XOOQ!LS1G/c1G/cO#C`Q&jO'#HoO#CtQWO,5?cOOQ!LQ1G0^1G0^O!8zQ&jO,59xO#C|QbO1G4|OOQO,5>Y,5>YO6nQWO,5>YOOQO-E;l-E;lO#DWQ!LrO'#D|O!%kQ&jO'#DxOOQO'#Hm'#HmO#DrQ&jO,5:cOOQ!LS,5:c,5:cO#DyQ&jO'#DxO#EXQ&jO'#D|O#EmQ&jO'#D|O!%kQ&jO'#D|O#EwQWO1G/zO#E|Q`O1G/zOOQ!LS1G/z1G/zO)rQYO1G/zOHcQWO1G/zOOQ!LS1G0X1G0XO9uQWO1G0XO!+aQpO1G0XO!+iQ#tO1G0XO#FTQ!LdO1G4yO)rQYO1G4yO#FeQ!LYO1G4yO#FvQWO1G4xO6nQWO,5>[OOQO,5>[,5>[O#GOQWO,5>[OOQO-E;n-E;nO#FvQWO1G4xO#G^Q!LdO,59fO#I]Q!LdO,5;{O#K_Q!LdO,5;}O#MaQ!LdO,5<]OOQ!LS7+%t7+%tO$ iQ!LdO7+%tO$!YQWO'#HkO$!dQWO,5?ZOOQ!LS1G/m1G/mO$!lQYO'#HlO$!yQWO,5?[O$#RQbO,5?[OOQ!LS1G/r1G/rOOQ!LS7+%}7+%}O$#]Q7^O,5:XO)rQYO7+&`O$#gQ7^O,5:POOQO1G1U1G1UOOQO1G1V1G1VO$#tQMhO,5;mOK^QYO,5;lOOQO-E;o-E;oOOQ!LS7+&n7+&nOOQO7+&w7+&wOOOO1G1`1G1`O$$PQWO1G1`OOQ!LS1G1b1G1bO$$UQ!LdO7+&}OOQ!LS,5>a,5>aO$$uQWO,5>aOOQ!LS1G1v1G1vP$$zQWO'#HuPOQ!LS-E;s-E;sO$%kQ#tO1G2RO$&^Q#tO1G2TO$&hQ#tO1G2VOOQ!LS1G1o1G1oO$&oQWO'#HtO$&}QWO,5?jO$&}QWO,5?jO$'VQWO,5?jO$'bQWO,5?jOOQO1G1q1G1qO$'pQ#tO1G1pO$(QQWO'#HvO$(bQWO,5?kOHcQWO,5?kO$(jQ`O,5?kOOQ!LS1G1t1G1tO5VQ!LYO,5<_O5VQ!LYO,5<`O$(tQWO,5<`O#2kQWO,5<`O!+aQpO,5<_O$(yQWO,5<aO5VQ!LYO,5<bO$(tQWO,5<eOOQO-E;u-E;uOOQ!LS1G1x1G1xO!%kQ&jO,5<_O$)RQWO,5<`O!%kQ&jO,5<aO!%kQ&jO,5<`O$)^Q#tO1G4jO$)hQ#tO1G4jOOQO,5>d,5>dOOQO-E;v-E;vOKXQ&jO,59hO)rQYO,59hO$)uQWO1G1kOIoQWO1G1rO$)zQ!LdO7+'OOOQ!LS7+'O7+'OOFfQYO7+'OOOQ!LS7+%V7+%VO$*kQ`O'#JQO#EwQWO7+'sO$*uQWO7+'sO$*}Q`O7+'sOOQQ7+'s7+'sOHcQWO7+'sO)rQYO7+'sOHcQWO7+'sOOQO1G.v1G.vO$+XQ!LbO'#CgO$+iQ!LbO,5<cO$,WQWO,5<cOOQ!LQ1G4f1G4fOOQQ7+$^7+$^O9uQWO7+$^O!+aQpO7+$^OFfQYO7+%tO$,]QWO'#IPO$,hQWO,5?rOOQO1G2u1G2uO5_QWO,5?rOOQO,5>l,5>lOOQO-E<O-E<OOOQ!LS7+&h7+&hO$,pQWO7+(`O5VQ!LYO7+(`O5_QWO7+(`O$,uQWO7+(`O$,zQWO7+'sOOQ!LQ,5>f,5>fOOQ!LQ-E;x-E;xOOQQ7+'}7+'}O$-YQ!LbO7+'zOHcQWO7+'zO$-dQ`O7+'{OOQQ7+'{7+'{OHcQWO7+'{O$-kQWO'#JTO$-vQWO,5<yOOQO,5>h,5>hOOQO-E;z-E;zOOQQ7+(Q7+(QO$.mQ&jO'#GhOOQQ1G2m1G2mOHcQWO1G2mO)rQYO1G2mOHcQWO1G2mO$.tQWO1G2mO$/SQ#tO1G2mO5VQ!LYO1G2pO#2pQWO1G2pO4{QWO1G2pO!+aQpO1G2pO!+iQ#tO1G2pO$/eQWO'#IOO$/pQWO,5?pO$/xQ&jO,5?pOOQ!LQ1G2q1G2qOOQQ7+$T7+$TO$/}QWO7+$TO5VQ!LYO7+$TO$0SQWO7+$TO)rQYO1G5_O)rQYO1G5`O$0XQYO1G2xO$0`QWO1G2xO$0eQYO1G2xO$0lQ!LYO1G5_OOQQ7+(b7+(bO5VQ!LYO7+(lO]QYO7+(nOOQQ'#JZ'#JZOOQQ'#IR'#IRO$0vQYO,5=mOOQQ,5=m,5=mO)rQYO'#HSO$1TQWO'#HUOOQQ7+(w7+(wO$1YQYO7+(wO6nQWO7+(wOOQQ7+({7+({OOQQ7+)P7+)POOQQ7+)R7+)ROOQO1G4t1G4tO$5TQ7^O1G0_O$5_QWO1G0_OOQO1G/d1G/dO$5jQ7^O1G/dO9uQWO1G/dOK^QYO'#D^OOQO,5>U,5>UOOQO-E;h-E;hOOQO,5>Z,5>ZOOQO-E;m-E;mO!+aQpO1G/dOOQO1G3t1G3tO9uQWO,5:dOOQO,5:h,5:hO)rQYO,5:hO$5tQ!LYO,5:hO$6PQ!LYO,5:hO!+aQpO,5:dOOQO-E;k-E;kOOQ!LS1G/}1G/}O!%kQ&jO,5:dO$6_Q!LrO,5:hO$6yQ&jO,5:dO!%kQ&jO,5:hO$7XQ&jO,5:hO$7mQ!LYO,5:hOOQ!LS7+%f7+%fO#EwQWO7+%fO#E|Q`O7+%fOOQ!LS7+%s7+%sO9uQWO7+%sO!+aQpO7+%sO$8RQ!LdO7+*eO)rQYO7+*eOOQO1G3v1G3vO6nQWO1G3vO$8cQWO7+*dO$8kQ!LdO1G2RO$:mQ!LdO1G2TO$<oQ!LdO1G1pO$>wQ#tO,5>VOOQO-E;i-E;iO$?RQbO,5>WO)rQYO,5>WOOQO-E;j-E;jO$?]QWO1G4vO$?eQ7^O1G0YO$AlQ7^O1G0dO$AsQ7^O1G0dO$CtQ7^O1G0dO$C{Q7^O1G0dO$EpQ7^O1G0dO$FTQ7^O1G0dO$HbQ7^O1G0dO$HiQ7^O1G0dO$JjQ7^O1G0dO$JqQ7^O1G0dO$LfQ7^O1G0dO$LyQ!LdO<<IzO$MjQ7^O1G0dO% YQ7^O'#IeO%#VQ7^O1G0wOK^QYO'#FTOOQO'#I|'#I|OOQO1G1X1G1XO%#dQWO1G1WO%#iQ7^O,5>_OOOO7+&z7+&zOOQ!LS1G3{1G3{OIoQWO7+'qO%#sQWO,5>`O5_QWO,5>`OOQO-E;r-E;rO%$RQWO1G5UO%$RQWO1G5UO%$ZQWO1G5UO%$fQ`O,5>bO%$pQWO,5>bOHcQWO,5>bOOQO-E;t-E;tO%$uQ`O1G5VO%%PQWO1G5VOOQO1G1y1G1yOOQO1G1z1G1zO5VQ!LYO1G1zO$(tQWO1G1zO5VQ!LYO1G1yO%%XQWO1G1{OHcQWO1G1{OOQO1G1|1G1|O5VQ!LYO1G2PO!+aQpO1G1yO#2kQWO1G1zO%%^QWO1G1{O%%fQWO1G1zOIoQWO7+*UOOQ!LS1G/S1G/SO%%qQWO1G/SOOQ!LS7+'V7+'VO%%vQ#tO7+'^O%&WQ!LdO<<JjOOQ!LS<<Jj<<JjOHcQWO'#HyO%&wQWO,5?lOOQQ<<K_<<K_OHcQWO<<K_O#EwQWO<<K_O%'PQWO<<K_O%'XQ`O<<K_OHcQWO1G1}OOQQ<<Gx<<GxO9uQWO<<GxO%'cQ!LdO<<I`OOQ!LS<<I`<<I`OOQO,5>k,5>kO%(SQWO,5>kOOQO-E;}-E;}O%(XQWO1G5^O%(aQWO<<KzOOQQ<<Kz<<KzO%(fQWO<<KzO5VQ!LYO<<KzO)rQYO<<K_OHcQWO<<K_OOQQ<<Kf<<KfO$-YQ!LbO<<KfOOQQ<<Kg<<KgO$-dQ`O<<KgO%(kQ&jO'#H{O%(vQWO,5?oOK^QYO,5?oOOQQ1G2e1G2eO#DWQ!LrO'#D|O!%kQ&jO'#GiOOQO'#H}'#H}O%)OQ&jO,5=SOOQQ,5=S,5=SO#3[Q&jO'#D|O%)VQ&jO'#D|O%)kQ&jO'#D|O%)uQ&jO'#GiO%*TQWO7+(XO%*YQWO7+(XO%*bQ`O7+(XOOQQ7+(X7+(XOHcQWO7+(XO)rQYO7+(XOHcQWO7+(XO%*lQWO7+(XOOQQ7+([7+([O5VQ!LYO7+([O#2pQWO7+([O4{QWO7+([O!+aQpO7+([O%*zQWO,5>jOOQO-E;|-E;|OOQO'#Gl'#GlO%+VQWO1G5[O5VQ!LYO<<GoOOQQ<<Go<<GoO%+_QWO<<GoO%+dQWO7+*yO%+iQWO7+*zOOQQ7+(d7+(dO%+nQWO7+(dO%+sQYO7+(dO%+zQWO7+(dO)rQYO7+*yO)rQYO7+*zOOQQ<<LW<<LWOOQQ<<LY<<LYOOQQ-E<P-E<POOQQ1G3X1G3XO%,PQWO,5=nOOQQ,5=p,5=pO9uQWO<<LcO%,UQWO<<LcOK^QYO7+%yOOQO7+%O7+%OO%,ZQ7^O1G4|O9uQWO7+%OOOQO1G0O1G0OO%,eQ!LdO1G0SOOQO1G0S1G0SO)rQYO1G0SO%,oQ!LYO1G0SO9uQWO1G0OO!+aQpO1G0OO%,zQ!LYO1G0SO!%kQ&jO1G0OO%-YQ!LYO1G0SO%-nQ!LrO1G0SO%-xQ&jO1G0OO!%kQ&jO1G0SOOQ!LS<<IQ<<IQOOQ!LS<<I_<<I_O9uQWO<<I_O%.WQ!LdO<<NPOOQO7+)b7+)bO%.hQ!LdO7+'^O%0pQbO1G3rO%0zQ7^O7+%tO%1XQ7^O,59fO%3UQ7^O,5;{O%5RQ7^O,5;}O%7OQ7^O,5<]O%8nQ7^O7+&}O%8{Q7^O7+'OO%9YQWO,5;oOOQO7+&r7+&rO%9_Q#tO<<K]OOQO1G3z1G3zO%9oQWO1G3zO%9zQWO1G3zO%:YQWO7+*pO%:YQWO7+*pOHcQWO1G3|O%:bQ`O1G3|O%:lQWO7+*qOOQO7+'f7+'fO5VQ!LYO7+'fOOQO7+'e7+'eO$(tQWO7+'gO%:tQ`O7+'gOOQO7+'k7+'kO5VQ!LYO7+'eO$(tQWO7+'fO%:{QWO7+'gOHcQWO7+'gO#2kQWO7+'fO%;QQ#tO<<MpOOQ!LS7+$n7+$nO%;[Q`O,5>eOOQO-E;w-E;wO#EwQWOAN@yOOQQAN@yAN@yOHcQWOAN@yO%;fQ!LbO7+'iOOQQAN=dAN=dO5_QWO1G4VO%;sQWO7+*xO5VQ!LYOANAfO%;{QWOANAfOOQQANAfANAfO%<QQWOAN@yO%<YQ`OAN@yOOQQANAQANAQOOQQANARANARO%<dQWO,5>gOOQO-E;y-E;yO%<oQ7^O1G5ZO#2pQWO,5=TO4{QWO,5=TO!+aQpO,5=TOOQO-E;{-E;{OOQQ1G2n1G2nO$6_Q!LrO,5:hO!%kQ&jO,5=TO%<yQ&jO,5=TO%=XQ&jO,5:hOOQQ<<Ks<<KsOHcQWO<<KsO%*TQWO<<KsO%=mQWO<<KsO%=uQ`O<<KsO)rQYO<<KsOHcQWO<<KsOOQQ<<Kv<<KvO5VQ!LYO<<KvO#2pQWO<<KvO4{QWO<<KvO%>PQ&jO1G4UO%>UQWO7+*vOOQQAN=ZAN=ZO5VQ!LYOAN=ZOOQQ<<Ne<<NeOOQQ<<Nf<<NfOOQQ<<LO<<LOO%>^QWO<<LOO%>cQYO<<LOO%>jQWO<<NeO%>oQWO<<NfOOQQ1G3Y1G3YOOQQANA}ANA}O9uQWOANA}O%>tQ7^O<<IeOOQO<<Hj<<HjOOQO7+%n7+%nO%,eQ!LdO7+%nO)rQYO7+%nOOQO7+%j7+%jO9uQWO7+%jO%?OQ!LYO7+%nO!+aQpO7+%jO%?ZQ!LYO7+%nO!%kQ&jO7+%jO%?iQ!LYO7+%nOOQ!LSAN>yAN>yO%?}Q!LdO<<K]O%BVQ7^O<<IzO%BdQ7^O1G1pO%DSQ7^O1G2RO%FPQ7^O1G2TO%G|Q7^O<<JjO%HZQ7^O<<I`OOQO1G1Z1G1ZOOQO7+)f7+)fO%HhQWO7+)fO%HsQWO<<N[O%H{Q`O7+)hOOQO<<KQ<<KQO5VQ!LYO<<KRO$(tQWO<<KROOQO<<KP<<KPO5VQ!LYO<<KQO%IVQ`O<<KRO$(tQWO<<KQOOQQG26eG26eO#EwQWOG26eOOQO7+)q7+)qOOQQG27QG27QO5VQ!LYOG27QOHcQWOG26eOK^QYO1G4RO%I^QWO7+*uO5VQ!LYO1G2oO#2pQWO1G2oO4{QWO1G2oO!+aQpO1G2oO!%kQ&jO1G2oO%-nQ!LrO1G0SO%IfQ&jO1G2oO%*TQWOANA_OOQQANA_ANA_OHcQWOANA_O%ItQWOANA_O%I|Q`OANA_OOQQANAbANAbO5VQ!LYOANAbO#2pQWOANAbOOQO'#Gm'#GmOOQO7+)p7+)pOOQQG22uG22uOOQQANAjANAjO%JWQWOANAjOOQQANDPANDPOOQQANDQANDQO%J]QYOG27iOOQO<<IY<<IYO%,eQ!LdO<<IYOOQO<<IU<<IUO)rQYO<<IYO9uQWO<<IUO%NWQ!LYO<<IYO!+aQpO<<IUO%NcQ!LYO<<IYO%NqQ7^O7+'^OOQO<<MQ<<MQOOQOAN@mAN@mO5VQ!LYOAN@mOOQOAN@lAN@lO$(tQWOAN@mO5VQ!LYOAN@lOOQQLD,PLD,POOQQLD,lLD,lO#EwQWOLD,PO&!aQ7^O7+)mOOQO7+(Z7+(ZO5VQ!LYO7+(ZO#2pQWO7+(ZO4{QWO7+(ZO!+aQpO7+(ZO!%kQ&jO7+(ZOOQQG26yG26yO%*TQWOG26yOHcQWOG26yOOQQG26|G26|O5VQ!LYOG26|OOQQG27UG27UO9uQWOLD-TOOQOAN>tAN>tO%,eQ!LdOAN>tOOQOAN>pAN>pO)rQYOAN>tO9uQWOAN>pO&!kQ!LYOAN>tO&!vQ7^O<<K]OOQOG26XG26XO5VQ!LYOG26XOOQOG26WG26WOOQQ!$( k!$( kOOQO<<Ku<<KuO5VQ!LYO<<KuO#2pQWO<<KuO4{QWO<<KuO!+aQpO<<KuOOQQLD,eLD,eO%*TQWOLD,eOOQQLD,hLD,hOOQQ!$(!o!$(!oOOQOG24`G24`O%,eQ!LdOG24`OOQOG24[G24[O)rQYOG24`OOQOLD+sLD+sOOQOANAaANAaO5VQ!LYOANAaO#2pQWOANAaO4{QWOANAaOOQQ!$(!P!$(!POOQOLD)zLD)zO%,eQ!LdOLD)zOOQOG26{G26{O5VQ!LYOG26{O#2pQWOG26{OOQO!$'Mf!$'MfOOQOLD,gLD,gO5VQ!LYOLD,gOOQO!$(!R!$(!ROK^QYO'#DmO&$fQbO'#IgOK^QYO'#DeO&$mQ!LdO'#CgO&%WQbO'#CgO&%hQYO,5:nOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO'#HsO&'eQWO,5;zO&(tQWO,5:xOK^QYO,5;]O!'TQWO'#CzO!'TQWO'#CzOHcQWO'#FaO&'mQWO'#FaOHcQWO'#FcO&'mQWO'#FcOHcQWO'#FqO&'mQWO'#FqOK^QYO,5?bO&%hQYO1G0YO&({Q7^O'#CgOK^QYO1G1cOHcQWO,5<gO&'mQWO,5<gOHcQWO,5<iO&'mQWO,5<iOHcQWO,5<UO&'mQWO,5<UO&%hQYO1G1dOK^QYO7+&`OHcQWO1G1rO&'mQWO1G1rO&%hQYO7+'OO&%hQYO7+%tOHcQWO7+'qO&'mQWO7+'qO&)VQWO'#ESO&)[QWO'#ESO&)dQWO'#EqO&)iQWO'#IvO&)tQWO'#ItO&*PQWO,5:nO&*UQ#tO,5;wO&*]QWO'#FjO&*bQWO'#FjO&*gQWO,5;xO&*oQWO,5:nO&*wQ7^O1G0tO&+OQWO,5<WO&+TQWO,5<WO&+YQWO1G1dO&+_QWO1G0YO&+dQ#tO1G2VO&+kQ#tO1G2VO3qQWO'#F_O4{QWO'#F^OBYQWO'#EROK^QYO,5;YO!'_QWO'#FlO!'_QWO'#FlOIoQWO,5<kOIoQWO,5<k",
  stateData: "&,e~O&}OSSOSTOS~OPTOQTOWwO]bO^gOamOblOgbOiTOjbOkbOmTOoTOtROvbOwbOxbO!OSO!YjO!_UO!bTO!cTO!dTO!eTO!fTO!ikO#ZqO#knO#o]O$voO$xrO$zpO${pO%OsO%QtO%TuO%UuO%WvO%exO%kyO%mzO%o{O%q|O%t}O%z!OO&O!PO&Q!QO&S!RO&U!SO&W!TO'PPO']QO'q`O~OPZXYZX^ZXiZXqZXrZXtZX|ZX![ZX!]ZX!_ZX!eZX!tZX#OcX#RZX#SZX#TZX#UZX#VZX#WZX#XZX#YZX#[ZX#^ZX#`ZX#aZX#fZX&{ZX']ZX'eZX'lZX'mZX~O!W$cX~P$tO&x!VO&y!UO&z!XO~OPTOQTO]bOa!hOb!gOgbOiTOjbOkbOmTOoTOtROvbOwbOxbO!O!`O!YjO!_UO!bTO!cTO!dTO!eTO!fTO!i!fO#k!iO#o]O'P!YO']QO'q`O~O{!^O|!ZOy'`Py'iP~P'^O}!jO~P]OPTOQTO]bOa!hOb!gOgbOiTOjbOkbOmTOoTOtROvbOwbOxbO!O!`O!YjO!_UO!bTO!cTO!dTO!eTO!fTO!i!fO#k!iO#o]O'P8cO']QO'q`O~OPTOQTO]bOa!hOb!gOgbOiTOjbOkbOmTOoTOtROvbOwbOxbO!O!`O!YjO!_UO!bTO!cTO!dTO!eTO!fTO!i!fO#k!iO#o]O']QO'q`O~O{!oO!|!rO!}!oO'P8dO!^'fP~P+oO#O!sO~O!W!tO#O!sO~OP#ZOY#aOi#OOq!xOr!xOt!yO|#_O![#QO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO#W#QO#X#QO#Y#QO#[#RO#^#TO#`#VO#a#WO']QO'e#XO'l!zO'm!{O~O^'ZX&{'ZX!^'ZXy'ZX!O'ZX$w'ZX!W'ZX~P.ZO!t#bO#f#bOP'[XY'[X^'[Xi'[Xq'[Xr'[Xt'[X|'[X!['[X!]'[X!_'[X!e'[X#R'[X#S'[X#T'[X#U'[X#V'[X#W'[X#Y'[X#['[X#^'[X#`'[X#a'[X']'[X'e'[X'l'[X'm'[X~O#X'[X&{'[Xy'[X!^'[X'_'[X!O'[X$w'[X!W'[X~P0kO!t#bO~O#q#cO#x#gO~O!O#hO#o]O#{#iO#}#kO~O]#nOg#zOi#oOj#nOk#nOm#{Oo#|Ot#tO!O#uO!Y$RO!_#rO!}$SO#k$PO$U#}O$W$OO$Z$QO'P#mO'T'VP~O!_$TO~O!W$VO~O^$WO&{$WO~O'P$[O~O!_$TO'P$[O'Q$^O'U$_O~Ob$eO!_$TO'P$[O~O]$nOq$jO!O$gO!_$iO$x$mO'P$[O'Q$^O['yP~O!i$oO~Ot$pO!O$qO'P$[O~Ot$pO!O$qO%Q$uO'P$[O~O'P$vO~O#ZqO$xrO$zpO${pO%OsO%QtO%TuO%UuO~Oa%POb%OO!i$|O$v$}O%Y${O~P7^Oa%SOblO!O%RO!ikO#ZqO$voO$zpO${pO%OsO%QtO%TuO%UuO%WvO~O_%VO!t%YO$x%TO'Q$^O~P8]O!_%ZO!b%_O~O!_%`O~O!OSO~O^$WO&w%hO&{$WO~O^$WO&w%kO&{$WO~O^$WO&w%mO&{$WO~O&x!VO&y!UO&z%qO~OPZXYZXiZXqZXrZXtZX|ZX|cX![ZX!]ZX!_ZX!eZX!tZX!tcX#OcX#RZX#SZX#TZX#UZX#VZX#WZX#XZX#YZX#[ZX#^ZX#`ZX#aZX#fZX']ZX'eZX'lZX'mZX~OyZXycX~P:xO{%sOy&]X|&]X~P)rO|!ZOy'`X~OP#ZOY#aOi#OOq!xOr!xOt!yO|!ZO![#QO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO#W#QO#X#QO#Y#QO#[#RO#^#TO#`#VO#a#WO']QO'e#XO'l!zO'm!{O~Oy'`X~P=oOy%xO~Ot%{O!R&VO!S&OO!T&OO'Q$^O~O]%|Oj%|O{&PO'Y%yO}'aP}'kP~P?rOy'hX|'hX!W'hX!^'hX'e'hX~O!t'hX#O!wX}'hX~P@kO!t&WOy'jX|'jX~O|&XOy'iX~Oy&ZO~O!t#bO~P@kOR&_O!O&[O!j&^O'P$[O~Ob&dO!_$TO'P$[O~Oq$jO!_$iO~O}&eO~P]Oq!xOr!xOt!yO!]!vO!_!wO']QOP!aaY!aai!aa|!aa![!aa!e!aa#R!aa#S!aa#T!aa#U!aa#V!aa#W!aa#X!aa#Y!aa#[!aa#^!aa#`!aa#a!aa'e!aa'l!aa'm!aa~O^!aa&{!aay!aa!^!aa'_!aa!O!aa$w!aa!W!aa~PBtO!^&fO~O!W!tO!t&hO'e&gO|'gX^'gX&{'gX~O!^'gX~PE^O|&lO!^'fX~O!^&nO~Ot$pO!O$qO!}&oO'P$[O~OPTOQTO]bOa!hOb!gOgbOiTOjbOkbOmTOoTOtROvbOwbOxbO!OSO!YjO!_UO!bTO!cTO!dTO!eTO!fTO!i!fO#k!iO#o]O'P8cO']QO'q`O~O]#nOg#zOi#oOj#nOk#nOm#{Oo8uOt#tO!O#uO!Y9wO!_#rO!}8{O#k$PO$U8wO$W8yO$Z$QO'P&sO~O#O&uO~O]#nOg#zOi#oOj#nOk#nOm#{Oo#|Ot#tO!O#uO!Y$RO!_#rO!}$SO#k$PO$U#}O$W$OO$Z$QO'P&sO~O'T'cP~PIoO{&yO!^'dP~P)rO'Y&{O~OP8`OQ8`O]bOa9uOb!gOgbOi8`OjbOkbOm8`Oo8`OtROvbOwbOxbO!O!`O!Y8bO!_UO!b8`O!c8`O!d8`O!e8`O!f8`O!i!fO#k!iO#o]O'P'ZO']QO'q9sO~O!_!wO~O|#_O^$Sa&{$Sa!^$Say$Sa!O$Sa$w$Sa!W$Sa~O#Z'bO~PHcO!W'dO!O'nX#n'nX#q'nX#x'nX~Oq'eO~PNROq'eO!O'nX#n'nX#q'nX#x'nX~O!O'gO#n'kO#q'fO#x'lO~O{'oO~PK^O#q#cO#x'rO~Oq$[Xt$[X!]$[X'e$[X'l$[X'm$[X~OReX|eX!teX'TeX'T$[X~P! kOj'tO~Oq'vOt'wO'e#XO'l'yO'm'{O~O'T'uO~P!!iO'T(OO~O]#nOg#zOi#oOj#nOk#nOm#{Oo8uOt#tO!O#uO!Y9wO!_#rO!}8{O#k$PO$U8wO$W8yO$Z$QO~O{(SO'P(PO!^'rP~P!#WO#O(UO~O{(YO'P(VOy'sP~P!#WO^(cOi(hOt(`O!R(fO!S(_O!T(_O!_(]O!q(gO$n(bO'Q$^O'Y([O~O}(eO~P!${O!]!vOq'XXt'XX'e'XX'l'XX'm'XX|'XX!t'XX~O'T'XX#d'XX~P!%wOR(kO!t(jO|'WX'T'WX~O|(lO'T'VX~O'P(nO~O!_(sO~O!_(]O~Ot$pO{!oO!O$qO!|!rO!}!oO'P$[O!^'fP~O!W!tO#O(wO~OP#ZOY#aOi#OOq!xOr!xOt!yO![#QO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO#W#QO#X#QO#Y#QO#[#RO#^#TO#`#VO#a#WO']QO'e#XO'l!zO'm!{O~O^!Xa|!Xa&{!Xay!Xa!^!Xa'_!Xa!O!Xa$w!Xa!W!Xa~P!(TOR)PO!O&[O!j)OO$w(}O'U$_O~O'P$vO'T'VP~O!W)SO!O'SX^'SX&{'SX~O!_$TO'U$_O~O!_$TO'P$[O'U$_O~O!W!tO#O&uO~O'P)[O}'zP~O|)`O['yX~OY)dO~O[)eO~O!O$gO'P$[O'Q$^O['yP~Ot$pO{)jO!O$qO'P$[Oy'iP~O]&SOj&SO{)kO'Y&{O}'kP~O|)lO^'vX&{'vX~O!t)pO'U$_O~OR)sO!O#uO'U$_O~O!O)uO~Oq)wO!OSO~O!i)|O~Ob*RO~O'P(nO}'xP~Ob$eO~O$xrO'P$vO~P8]OY*XO[*WO~OPTOQTO]bOamOblOgbOiTOjbOkbOmTOoTOtROvbOwbOxbO!YjO!_UO!bTO!cTO!dTO!eTO!fTO!ikO#o]O$voO']QO'q`O~O!O!`O#k!iO'P8cO~P!/bO[*WO^$WO&{$WO~O^*]O#Z*_O$z*_O${*_O~P)rO!_%ZO~O%k*dO~O!O*fO~O%{*iO%|*hOP%yaQ%yaW%ya]%ya^%yaa%yab%yag%yai%yaj%yak%yam%yao%yat%yav%yaw%yax%ya!O%ya!Y%ya!_%ya!b%ya!c%ya!d%ya!e%ya!f%ya!i%ya#Z%ya#k%ya#o%ya$v%ya$x%ya$z%ya${%ya%O%ya%Q%ya%T%ya%U%ya%W%ya%e%ya%k%ya%m%ya%o%ya%q%ya%t%ya%z%ya&O%ya&Q%ya&S%ya&U%ya&W%ya&v%ya'P%ya']%ya'q%ya}%ya%r%ya_%ya%w%ya~O'P*lO~O'_*oO~Oy&]a|&]a~P!(TO|!ZOy'`a~Oy'`a~P=oO|&XOy'ia~O|sX|!UX}sX}!UX!WsX!W!UX!_!UX!tsX'U!UX~O!W*vO!t*uO|!{X|'bX}!{X}'bX!W'bX!_'bX'U'bX~O!W*xO!_$TO'U$_O|!QX}!QX~O]%zOj%zOt%{O'Y([O~OP8`OQ8`O]bOa9uOb!gOgbOi8`OjbOkbOm8`Oo8`OtROvbOwbOxbO!O!`O!Y8bO!_UO!b8`O!c8`O!d8`O!e8`O!f8`O!i!fO#k!iO#o]O']QO'q9sO~O'P9PO~P!9YO|*|O}'aX~O}+OO~O!W*vO!t*uO|!{X}!{X~O|+PO}'kX~O}+RO~O]%zOj%zOt%{O'Q$^O'Y([O~O!S+SO!T+SO~P!<TOt$pO{+VO!O$qO'P$[Oy&bX|&bX~O^+ZO!R+^O!S+YO!T+YO!m+`O!n+_O!o+_O!q+aO'Q$^O'Y([O~O}+]O~P!=UOR+fO!O&[O!j+eO~O!t+lO|'ga!^'ga^'ga&{'ga~O!W!tO~P!>YO|&lO!^'fa~Ot$pO{+oO!O$qO!|+qO!}+oO'P$[O|&dX!^&dX~O^!vi|!vi&{!viy!vi!^!vi'_!vi!O!vi$w!vi!W!vi~P!(TO#O!sa|!sa!^!sa!t!sa!O!sa^!sa&{!say!sa~P!!iO#O'XXP'XXY'XX^'XXi'XXr'XX!['XX!_'XX!e'XX#R'XX#S'XX#T'XX#U'XX#V'XX#W'XX#X'XX#Y'XX#['XX#^'XX#`'XX#a'XX&{'XX']'XX!^'XXy'XX!O'XX$w'XX'_'XX!W'XX~P!%wO|+zO'T'cX~P!!iO'T+|O~O|+}O!^'dX~P!(TO!^,QO~Oy,RO~OP#ZOq!xOr!xOt!yO!]!vO!_!wO!e#ZO']QOY#Qi^#Qii#Qi|#Qi![#Qi#S#Qi#T#Qi#U#Qi#V#Qi#W#Qi#X#Qi#Y#Qi#[#Qi#^#Qi#`#Qi#a#Qi&{#Qi'e#Qi'l#Qi'm#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~O#R#Qi~P!CgO#R!|O~P!CgOP#ZOq!xOr!xOt!yO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O']QOY#Qi^#Qi|#Qi![#Qi#V#Qi#W#Qi#X#Qi#Y#Qi#[#Qi#^#Qi#`#Qi#a#Qi&{#Qi'e#Qi'l#Qi'm#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~Oi#Qi~P!FROi#OO~P!FROP#ZOi#OOq!xOr!xOt!yO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO']QO^#Qi|#Qi#[#Qi#^#Qi#`#Qi#a#Qi&{#Qi'e#Qi'l#Qi'm#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~OY#Qi![#Qi#W#Qi#X#Qi#Y#Qi~P!HmOY#aO![#QO#W#QO#X#QO#Y#QO~P!HmOP#ZOY#aOi#OOq!xOr!xOt!yO![#QO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO#W#QO#X#QO#Y#QO#[#RO']QO^#Qi|#Qi#^#Qi#`#Qi#a#Qi&{#Qi'e#Qi'm#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~O'l#Qi~P!KeO'l!zO~P!KeOP#ZOY#aOi#OOq!xOr!xOt!yO![#QO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO#W#QO#X#QO#Y#QO#[#RO#^#TO']QO'l!zO^#Qi|#Qi#`#Qi#a#Qi&{#Qi'e#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~O'm#Qi~P!NPO'm!{O~P!NPOP#ZOY#aOi#OOq!xOr!xOt!yO![#QO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO#W#QO#X#QO#Y#QO#[#RO#^#TO#`#VO']QO'l!zO'm!{O~O^#Qi|#Qi#a#Qi&{#Qi'e#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~P#!kOPZXYZXiZXqZXrZXtZX![ZX!]ZX!_ZX!eZX!tZX#OcX#RZX#SZX#TZX#UZX#VZX#WZX#XZX#YZX#[ZX#^ZX#`ZX#aZX#fZX']ZX'eZX'lZX'mZX|ZX}ZX~O#dZX~P#%OOP#ZOY8sOi8hOq!xOr!xOt!yO![8jO!]!vO!_!wO!e#ZO#R8fO#S8gO#T8gO#U8gO#V8iO#W8jO#X8jO#Y8jO#[8kO#^8mO#`8oO#a8pO']QO'e#XO'l!zO'm!{O~O#d,TO~P#'YOP'[XY'[Xi'[Xq'[Xr'[Xt'[X!['[X!]'[X!_'[X!e'[X#R'[X#S'[X#T'[X#U'[X#V'[X#W'[X#Y'[X#['[X#^'[X#`'[X#a'[X']'[X'e'[X'l'[X'm'[X|'[X~O!t8tO#f8tO#X'[X#d'[X}'[X~P#)TO^&ga|&ga&{&ga!^&ga'_&gay&ga!O&ga$w&ga!W&ga~P!(TOP#QiY#Qi^#Qii#Qir#Qi|#Qi![#Qi!]#Qi!_#Qi!e#Qi#R#Qi#S#Qi#T#Qi#U#Qi#V#Qi#W#Qi#X#Qi#Y#Qi#[#Qi#^#Qi#`#Qi#a#Qi&{#Qi']#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~P!!iO^#ei|#ei&{#eiy#ei!^#ei'_#ei!O#ei$w#ei!W#ei~P!(TO#q,VO~O#q,WO~O!W'dO!t,XO!O#uX#n#uX#q#uX#x#uX~O{,YO~O!O'gO#n,[O#q'fO#x,]O~O|8qO}'ZX~P#'YO},^O~O#x,`O~O],cOj,cOy,dO~O|cX!WcX!^cX!^$[X'ecX~P! kO!^,jO~P!!iO|,kO!W!tO'e&gO!^'rX~O!^,pO~Oy$[X|$[X!W$cX~P! kO|,rOy'sX~P!!iO!W,tO~Oy,vO~O{(SO'P$[O!^'rP~Oi,zO!W!tO!_$TO'U$_O'e&gO~O!W)SO~O}-QO~P!${O!S-RO!T-RO'Q$^O'Y([O~Ot-TO'Y([O~O!q-UO~O'P$vO|&lX'T&lX~O|(lO'T'Va~Oq-ZOr-ZOt-[O'ena'lna'mna|na!tna~O'Tna#dna~P#3|Oq'vOt'wO'e$Ta'l$Ta'm$Ta|$Ta!t$Ta~O'T$Ta#d$Ta~P#4rOq'vOt'wO'e$Va'l$Va'm$Va|$Va!t$Va~O'T$Va#d$Va~P#5eO]-]O~O#O-^O~O'T$ea|$ea#d$ea!t$ea~P!!iO#O-aO~OR-jO!O&[O!j-iO$w-hO~O'T-kO~O]#nOi#oOj#nOk#nOm#{Oo8uOt#tO!O#uO!Y9wO!_#rO!}8{O#k$PO$U8wO$W8yO$Z$QO~Og-mO'P-lO~P#7[O!W)SO!O'Sa^'Sa&{'Sa~O#O-sO~OYZX|cX}cX~O|-tO}'zX~O}-vO~OY-wO~O!O$gO'P$[O[&tX|&tX~O|)`O['ya~O!^-zO~P!(TO]-|O~OY-}O~O[.OO~OR-jO!O&[O!j-iO$w-hO'U$_O~O|)lO^'va&{'va~O!t.UO~OR.XO!O#uO~O'Y&{O}'wP~OR.cO!O._O!j.bO$w.aO'U$_O~OY.mO|.kO}'xX~O}.nO~O[.pO^$WO&{$WO~O].qO~O#X.sO%i.tO~P0kO!t#bO#X.sO%i.tO~O^.uO~P)rO^.wO~O%r.{OP%piQ%piW%pi]%pi^%pia%pib%pig%pii%pij%pik%pim%pio%pit%piv%piw%pix%pi!O%pi!Y%pi!_%pi!b%pi!c%pi!d%pi!e%pi!f%pi!i%pi#Z%pi#k%pi#o%pi$v%pi$x%pi$z%pi${%pi%O%pi%Q%pi%T%pi%U%pi%W%pi%e%pi%k%pi%m%pi%o%pi%q%pi%t%pi%z%pi&O%pi&Q%pi&S%pi&U%pi&W%pi&v%pi'P%pi']%pi'q%pi}%pi_%pi%w%pi~O_/RO}/PO%w/QO~P]O!OSO!_/UO~O|#_O'_$Sa~Oy&]i|&]i~P!(TO|!ZOy'`i~O|&XOy'ii~Oy/YO~O|!Qa}!Qa~P#'YO]%zOj%zO{/`O'Y([O|&^X}&^X~P?rO|*|O}'aa~O]&SOj&SO{)kO'Y&{O|&cX}&cX~O|+PO}'ka~Oy'ji|'ji~P!(TO^$WO!W!tO!_$TO!e/kO!t/iO&{$WO'U$_O'e&gO~O}/nO~P!=UO!S/oO!T/oO'Q$^O'Y([O~O!R/qO!S/oO!T/oO!q/rO'Q$^O'Y([O~O!n/sO!o/sO~P#EXO!O&[O~O!O&[O~P!!iO|'gi!^'gi^'gi&{'gi~P!(TO!t/|O|'gi!^'gi^'gi&{'gi~O|&lO!^'fi~Ot$pO!O$qO!}0OO'P$[O~O#OnaPnaYna^naina![na!]na!_na!ena#Rna#Sna#Tna#Una#Vna#Wna#Xna#Yna#[na#^na#`na#ana&{na']na!^nayna!Ona$wna'_na!Wna~P#3|O#O$TaP$TaY$Ta^$Tai$Tar$Ta![$Ta!]$Ta!_$Ta!e$Ta#R$Ta#S$Ta#T$Ta#U$Ta#V$Ta#W$Ta#X$Ta#Y$Ta#[$Ta#^$Ta#`$Ta#a$Ta&{$Ta']$Ta!^$Tay$Ta!O$Ta$w$Ta'_$Ta!W$Ta~P#4rO#O$VaP$VaY$Va^$Vai$Var$Va![$Va!]$Va!_$Va!e$Va#R$Va#S$Va#T$Va#U$Va#V$Va#W$Va#X$Va#Y$Va#[$Va#^$Va#`$Va#a$Va&{$Va']$Va!^$Vay$Va!O$Va$w$Va'_$Va!W$Va~P#5eO#O$eaP$eaY$ea^$eai$ear$ea|$ea![$ea!]$ea!_$ea!e$ea#R$ea#S$ea#T$ea#U$ea#V$ea#W$ea#X$ea#Y$ea#[$ea#^$ea#`$ea#a$ea&{$ea']$ea!^$eay$ea!O$ea!t$ea$w$ea'_$ea!W$ea~P!!iO^!vq|!vq&{!vqy!vq!^!vq'_!vq!O!vq$w!vq!W!vq~P!(TO|&_X'T&_X~PIoO|+zO'T'ca~O{0WO|&`X!^&`X~P)rO|+}O!^'da~O|+}O!^'da~P!(TO#d!aa}!aa~PBtO#d!Xa|!Xa}!Xa~P#'YO!O0kO#o]O#v0lO~O}0pO~O^$Pq|$Pq&{$Pqy$Pq!^$Pq'_$Pq!O$Pq$w$Pq!W$Pq~P!(TOy0qO~O],cOj,cO~Oq'vOt'wO'm'{O'e$oi'l$oi|$oi!t$oi~O'T$oi#d$oi~P$%SOq'vOt'wO'e$qi'l$qi'm$qi|$qi!t$qi~O'T$qi#d$qi~P$%uO#d0rO~P!!iO{0tO'P$[O|&hX!^&hX~O|,kO!^'ra~O|,kO!W!tO!^'ra~O|,kO!W!tO'e&gO!^'ra~O'T$^i|$^i#d$^i!t$^i~P!!iO{0{O'P(VOy&jX|&jX~P!#WO|,rOy'sa~O|,rOy'sa~P!!iO!W!tO~O!W!tO#X1VO~Oi1ZO!W!tO'e&gO~O|'Wi'T'Wi~P!!iO!t1^O|'Wi'T'Wi~P!!iO!^1aO~O^$Qq|$Qq&{$Qqy$Qq!^$Qq'_$Qq!O$Qq$w$Qq!W$Qq~P!(TO|1eO!O'tX~P!!iO!O&[O$w1hO~O!O&[O$w1hO~P!!iO!O$[X$lZX^$[X&{$[X~P! kO$l1lOqfXtfX!OfX'efX'lfX'mfX^fX&{fX~O$l1lO~O'P)[O|&sX}&sX~O|-tO}'za~O[1uO~O]1xO~OR1zO!O&[O!j1yO$w1hO~O^$WO&{$WO~P!!iO!O#uO~P!!iO|2PO!t2RO}'wX~O}2SO~Ot(`O!R2]O!S2UO!T2UO!m2[O!n2ZO!o2ZO!q2YO'Q$^O'Y([O~O}2XO~P$-{OR2dO!O._O!j2cO$w2bO~OR2dO!O._O!j2cO$w2bO'U$_O~O'P(nO|&rX}&rX~O|.kO}'xa~O'Y2mO~O]2oO~O[2qO~O!^2tO~P)rO^2vO~O^2vO~P)rO#X2xO%i2yO~PE^O_/RO}2}O%w/QO~P]O!W3PO~O%|3QOP%yqQ%yqW%yq]%yq^%yqa%yqb%yqg%yqi%yqj%yqk%yqm%yqo%yqt%yqv%yqw%yqx%yq!O%yq!Y%yq!_%yq!b%yq!c%yq!d%yq!e%yq!f%yq!i%yq#Z%yq#k%yq#o%yq$v%yq$x%yq$z%yq${%yq%O%yq%Q%yq%T%yq%U%yq%W%yq%e%yq%k%yq%m%yq%o%yq%q%yq%t%yq%z%yq&O%yq&Q%yq&S%yq&U%yq&W%yq&v%yq'P%yq']%yq'q%yq}%yq%r%yq_%yq%w%yq~O|!{i}!{i~P#'YO!t3SO|!{i}!{i~O|!Qi}!Qi~P#'YO^$WO!t3ZO&{$WO~O^$WO!W!tO!t3ZO&{$WO~O^$WO!W!tO!_$TO!e3_O!t3ZO&{$WO'U$_O'e&gO~O!S3`O!T3`O'Q$^O'Y([O~O!R3cO!S3`O!T3`O!q3dO'Q$^O'Y([O~O^$WO!W!tO!e3_O!t3ZO&{$WO'e&gO~O|'gq!^'gq^'gq&{'gq~P!(TO|&lO!^'fq~O#O$oiP$oiY$oi^$oii$oir$oi![$oi!]$oi!_$oi!e$oi#R$oi#S$oi#T$oi#U$oi#V$oi#W$oi#X$oi#Y$oi#[$oi#^$oi#`$oi#a$oi&{$oi']$oi!^$oiy$oi!O$oi$w$oi'_$oi!W$oi~P$%SO#O$qiP$qiY$qi^$qii$qir$qi![$qi!]$qi!_$qi!e$qi#R$qi#S$qi#T$qi#U$qi#V$qi#W$qi#X$qi#Y$qi#[$qi#^$qi#`$qi#a$qi&{$qi']$qi!^$qiy$qi!O$qi$w$qi'_$qi!W$qi~P$%uO#O$^iP$^iY$^i^$^ii$^ir$^i|$^i![$^i!]$^i!_$^i!e$^i#R$^i#S$^i#T$^i#U$^i#V$^i#W$^i#X$^i#Y$^i#[$^i#^$^i#`$^i#a$^i&{$^i']$^i!^$^iy$^i!O$^i!t$^i$w$^i'_$^i!W$^i~P!!iO|&_a'T&_a~P!!iO|&`a!^&`a~P!(TO|+}O!^'di~O#d!vi|!vi}!vi~P#'YOP#ZOq!xOr!xOt!yO!]!vO!_!wO!e#ZO']QOY#Qii#Qi![#Qi#S#Qi#T#Qi#U#Qi#V#Qi#W#Qi#X#Qi#Y#Qi#[#Qi#^#Qi#`#Qi#a#Qi#d#Qi'e#Qi'l#Qi'm#Qi|#Qi}#Qi~O#R#Qi~P$?rO#R8fO~P$?rOP#ZOq!xOr!xOt!yO!]!vO!_!wO!e#ZO#R8fO#S8gO#T8gO#U8gO']QOY#Qi![#Qi#V#Qi#W#Qi#X#Qi#Y#Qi#[#Qi#^#Qi#`#Qi#a#Qi#d#Qi'e#Qi'l#Qi'm#Qi|#Qi}#Qi~Oi#Qi~P$AzOi8hO~P$AzOP#ZOi8hOq!xOr!xOt!yO!]!vO!_!wO!e#ZO#R8fO#S8gO#T8gO#U8gO#V8iO']QO#[#Qi#^#Qi#`#Qi#a#Qi#d#Qi'e#Qi'l#Qi'm#Qi|#Qi}#Qi~OY#Qi![#Qi#W#Qi#X#Qi#Y#Qi~P$DSOY8sO![8jO#W8jO#X8jO#Y8jO~P$DSOP#ZOY8sOi8hOq!xOr!xOt!yO![8jO!]!vO!_!wO!e#ZO#R8fO#S8gO#T8gO#U8gO#V8iO#W8jO#X8jO#Y8jO#[8kO']QO#^#Qi#`#Qi#a#Qi#d#Qi'e#Qi'm#Qi|#Qi}#Qi~O'l#Qi~P$FhO'l!zO~P$FhOP#ZOY8sOi8hOq!xOr!xOt!yO![8jO!]!vO!_!wO!e#ZO#R8fO#S8gO#T8gO#U8gO#V8iO#W8jO#X8jO#Y8jO#[8kO#^8mO']QO'l!zO#`#Qi#a#Qi#d#Qi'e#Qi|#Qi}#Qi~O'm#Qi~P$HpO'm!{O~P$HpOP#ZOY8sOi8hOq!xOr!xOt!yO![8jO!]!vO!_!wO!e#ZO#R8fO#S8gO#T8gO#U8gO#V8iO#W8jO#X8jO#Y8jO#[8kO#^8mO#`8oO']QO'l!zO'm!{O~O#a#Qi#d#Qi'e#Qi|#Qi}#Qi~P$JxO^#by|#by&{#byy#by!^#by'_#by!O#by$w#by!W#by~P!(TOP#QiY#Qii#Qir#Qi![#Qi!]#Qi!_#Qi!e#Qi#R#Qi#S#Qi#T#Qi#U#Qi#V#Qi#W#Qi#X#Qi#Y#Qi#[#Qi#^#Qi#`#Qi#a#Qi#d#Qi']#Qi|#Qi}#Qi~P!!iO!]!vOP'XXY'XXi'XXq'XXr'XXt'XX!['XX!_'XX!e'XX#R'XX#S'XX#T'XX#U'XX#V'XX#W'XX#X'XX#Y'XX#['XX#^'XX#`'XX#a'XX#d'XX']'XX'e'XX'l'XX'm'XX|'XX}'XX~O#d#ei|#ei}#ei~P#'YO}3tO~O|&ga}&ga~P#'YO!W!tO'e&gO|&ha!^&ha~O|,kO!^'ri~O|,kO!W!tO!^'ri~Oy&ja|&ja~P!!iO!W3{O~O|,rOy'si~P!!iO|,rOy'si~Oy4RO~O!W!tO#X4XO~Oi4YO!W!tO'e&gO~Oy4[O~O'T$`q|$`q#d$`q!t$`q~P!!iO^$Qy|$Qy&{$Qyy$Qy!^$Qy'_$Qy!O$Qy$w$Qy!W$Qy~P!(TO|1eO!O'ta~O!O&[O$w4aO~O!O&[O$w4aO~P!!iO^!vy|!vy&{!vyy!vy!^!vy'_!vy!O!vy$w!vy!W!vy~P!(TOY4dO~O|-tO}'zi~O]4fO~O[4gO~O'Y&{O|&oX}&oX~O|2PO}'wa~O}4tO~P$-{O!R4wO!S4vO!T4vO!q/rO'Q$^O'Y([O~O!n4xO!o4xO~P%)VO!S4vO!T4vO'Q$^O'Y([O~O!O._O~O!O._O$w4zO~O!O._O$w4zO~P!!iOR5PO!O._O!j5OO$w4zO~OY5UO|&ra}&ra~O|.kO}'xi~O]5XO~O!^5YO~O!^5ZO~O!^5[O~O!^5[O~P)rO^5^O~O!W5aO~O!^5cO~O|'ji}'ji~P#'YO^$WO&{$WO~P!(TO^$WO!t5hO&{$WO~O^$WO!W!tO!t5hO&{$WO~O^$WO!W!tO!e5mO!t5hO&{$WO'e&gO~O!_$TO'U$_O~P%-YO!S5nO!T5nO'Q$^O'Y([O~O|'gy!^'gy^'gy&{'gy~P!(TO#O$`qP$`qY$`q^$`qi$`qr$`q|$`q![$`q!]$`q!_$`q!e$`q#R$`q#S$`q#T$`q#U$`q#V$`q#W$`q#X$`q#Y$`q#[$`q#^$`q#`$`q#a$`q&{$`q']$`q!^$`qy$`q!O$`q!t$`q$w$`q'_$`q!W$`q~P!!iO|&`i!^&`i~P!(TO#d!vq|!vq}!vq~P#'YOq-ZOr-ZOt-[OPnaYnaina![na!]na!_na!ena#Rna#Sna#Tna#Una#Vna#Wna#Xna#Yna#[na#^na#`na#ana#dna']na'ena'lna'mna|na}na~Oq'vOt'wOP$TaY$Tai$Tar$Ta![$Ta!]$Ta!_$Ta!e$Ta#R$Ta#S$Ta#T$Ta#U$Ta#V$Ta#W$Ta#X$Ta#Y$Ta#[$Ta#^$Ta#`$Ta#a$Ta#d$Ta']$Ta'e$Ta'l$Ta'm$Ta|$Ta}$Ta~Oq'vOt'wOP$VaY$Vai$Var$Va![$Va!]$Va!_$Va!e$Va#R$Va#S$Va#T$Va#U$Va#V$Va#W$Va#X$Va#Y$Va#[$Va#^$Va#`$Va#a$Va#d$Va']$Va'e$Va'l$Va'm$Va|$Va}$Va~OP$eaY$eai$ear$ea![$ea!]$ea!_$ea!e$ea#R$ea#S$ea#T$ea#U$ea#V$ea#W$ea#X$ea#Y$ea#[$ea#^$ea#`$ea#a$ea#d$ea']$ea|$ea}$ea~P!!iO#d$Pq|$Pq}$Pq~P#'YO#d$Qq|$Qq}$Qq~P#'YO}5xO~O'T$sy|$sy#d$sy!t$sy~P!!iO!W!tO|&hi!^&hi~O!W!tO'e&gO|&hi!^&hi~O|,kO!^'rq~Oy&ji|&ji~P!!iO|,rOy'sq~Oy6PO~P!!iOy6PO~O|'Wy'T'Wy~P!!iO|&ma!O&ma~P!!iO!O$kq^$kq&{$kq~P!!iO|-tO}'zq~O]6YO~O!O&[O$w6ZO~O!O&[O$w6ZO~P!!iO!t6[O|&oa}&oa~O|2PO}'wi~P#'YO!S6bO!T6bO'Q$^O'Y([O~O!R6dO!S6bO!T6bO!q3dO'Q$^O'Y([O~O!O._O$w6gO~O!O._O$w6gO~P!!iO'Y6mO~O|.kO}'xq~O!^6pO~O!^6pO~P)rO!^6rO~O!^6sO~O|!{y}!{y~P#'YO^$WO!t6xO&{$WO~O^$WO!W!tO!t6xO&{$WO~O^$WO!W!tO!e6|O!t6xO&{$WO'e&gO~O#O$syP$syY$sy^$syi$syr$sy|$sy![$sy!]$sy!_$sy!e$sy#R$sy#S$sy#T$sy#U$sy#V$sy#W$sy#X$sy#Y$sy#[$sy#^$sy#`$sy#a$sy&{$sy']$sy!^$syy$sy!O$sy!t$sy$w$sy'_$sy!W$sy~P!!iO#d#by|#by}#by~P#'YOP$^iY$^ii$^ir$^i![$^i!]$^i!_$^i!e$^i#R$^i#S$^i#T$^i#U$^i#V$^i#W$^i#X$^i#Y$^i#[$^i#^$^i#`$^i#a$^i#d$^i']$^i|$^i}$^i~P!!iOq'vOt'wO'm'{OP$oiY$oii$oir$oi![$oi!]$oi!_$oi!e$oi#R$oi#S$oi#T$oi#U$oi#V$oi#W$oi#X$oi#Y$oi#[$oi#^$oi#`$oi#a$oi#d$oi']$oi'e$oi'l$oi|$oi}$oi~Oq'vOt'wOP$qiY$qii$qir$qi![$qi!]$qi!_$qi!e$qi#R$qi#S$qi#T$qi#U$qi#V$qi#W$qi#X$qi#Y$qi#[$qi#^$qi#`$qi#a$qi#d$qi']$qi'e$qi'l$qi'm$qi|$qi}$qi~O#d$Qy|$Qy}$Qy~P#'YO#d!vy|!vy}!vy~P#'YO!W!tO|&hq!^&hq~O|,kO!^'ry~Oy&jq|&jq~P!!iOy7SO~P!!iO|2PO}'wq~O!S7_O!T7_O'Q$^O'Y([O~O!O._O$w7bO~O!O._O$w7bO~P!!iO!^7eO~O%|7fOP%y!ZQ%y!ZW%y!Z]%y!Z^%y!Za%y!Zb%y!Zg%y!Zi%y!Zj%y!Zk%y!Zm%y!Zo%y!Zt%y!Zv%y!Zw%y!Zx%y!Z!O%y!Z!Y%y!Z!_%y!Z!b%y!Z!c%y!Z!d%y!Z!e%y!Z!f%y!Z!i%y!Z#Z%y!Z#k%y!Z#o%y!Z$v%y!Z$x%y!Z$z%y!Z${%y!Z%O%y!Z%Q%y!Z%T%y!Z%U%y!Z%W%y!Z%e%y!Z%k%y!Z%m%y!Z%o%y!Z%q%y!Z%t%y!Z%z%y!Z&O%y!Z&Q%y!Z&S%y!Z&U%y!Z&W%y!Z&v%y!Z'P%y!Z']%y!Z'q%y!Z}%y!Z%r%y!Z_%y!Z%w%y!Z~O^$WO!t7jO&{$WO~O^$WO!W!tO!t7jO&{$WO~OP$`qY$`qi$`qr$`q![$`q!]$`q!_$`q!e$`q#R$`q#S$`q#T$`q#U$`q#V$`q#W$`q#X$`q#Y$`q#[$`q#^$`q#`$`q#a$`q#d$`q']$`q|$`q}$`q~P!!iO|&oq}&oq~P#'YO^$WO!t8OO&{$WO~OP$syY$syi$syr$sy![$sy!]$sy!_$sy!e$sy#R$sy#S$sy#T$sy#U$sy#V$sy#W$sy#X$sy#Y$sy#[$sy#^$sy#`$sy#a$sy#d$sy']$sy|$sy}$sy~P!!iO'_'ZX~P.ZO'_ZXyZX!^ZX%iZX!OZX$wZX!WZX~P$tO!WcX!^ZX!^cX'ecX~P:xOP8`OQ8`O]bOa9uOb!gOgbOi8`OjbOkbOm8`Oo8`OtROvbOwbOxbO!OSO!Y8bO!_UO!b8`O!c8`O!d8`O!e8`O!f8`O!i!fO#k!iO#o]O'P'ZO']QO'q9sO~O|8qO}$Sa~O]#nOg#zOi#oOj#nOk#nOm#{Oo8vOt#tO!O#uO!Y9xO!_#rO!}8|O#k$PO$U8xO$W8zO$Z$QO'P&sO~O#Z'bO~P&'mO}ZX}cX~P:xO#O8eO~O!W!tO#O8eO~O!t8tO~O!t8}O|'jX}'jX~O!t8tO|'hX}'hX~O#O9OO~O'T9QO~P!!iO#O9VO~O#O9WO~O!W!tO#O9XO~O!W!tO#O9OO~O#d9YO~P#'YO#O9ZO~O#O9[O~O#O9]O~O#O9^O~O#d9_O~P!!iO#d9`O~P!!iO#o~!]!m!o!|!}'q$U$W$Z$l$v$w$x%O%Q%T%U%W%Y~TS#o'q#q'Y'P&}#Sx~",
  goto: "#<v(OPPPPPPP(PP(aP)|PPPP-]PP-r2v4i4|P4|PPP4|P4|P6iPP6nP7VPPPP;fPPPP;f>UPPP>[@_P;fPBrPPPPDj;fPPPPPFc;fPPIbJ_PPPJcPJkKlP;f;fNs!#l!([!([!+iPPP!+p;fPPPPPPPPPP!.dP!/uPP;f!1SP;fP;f;f;f;fP;f!3fPP!6]P!9O!9W!9[!9[P!6YP!9`!9`P!<RP!<V;f;f!<]!>}4|P4|P4|4|P!@Q4|4|!At4|4|4|!Cu4|4|!Dc!F[!F[!F`!F[!FhP!F[P4|!Gd4|!Hm4|4|-]PPP!IyPP!Jc!JcP!JcP!Jx!JcPP!KOP!JuP!Ju!KbJg!Ju!LP!LV!LY(P!L](PP!Ld!Ld!LdP(PP(PP(PP(PPP(PP!Lj!LmP!Lm(PPPP(PP(PP(PP(PP(PP(P(P!Lq!L{!MR!Ma!Mg!Mm!Mw!M}!NX!N_!Nm!Ns!Ny# X# n##P##_##e##k##q##w#$R#$X#$_#$i#$s#$yPPPPPPPP#%PPP#%s#)qPP#+U#+]#+eP#/n#2RP#7{P#8P#8S#8V#8b#8eP#8h#8l#9Z#:O#:S#:fPP#:j#:p#:tP#:w#:{#;O#;n#<U#<Z#<^#<a#<g#<j#<n#<rmgOSi{!k$V%^%a%b%d*a*f.{/OQ$dlQ$knQ%UwS&O!`*|Q&c!gS(_#u(dQ)Y$eQ)f$mQ*Q%OQ+S&VS+Y&[+[Q+j&dQ-R(fQ.j*RU/o+^+_+`S2U._2WS3`/q/sU4v2Z2[2]Q5n3cS6b4w4xR7_6d$lZORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$V$i%V%Y%^%`%a%b%d%h%s%{&W&^&h&u&y'u(w)O*]*a*f+e+l+},T-[-a-i-s.b.s.t.u.w.{/O/Q/i/|0W1y2c2v2x2y3Z5O5^5h6x7j8O!j']#Y#h&P'o*u*x,Y/`0k2R3S6[8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vQ(o#|Q)_$gQ*S%RQ*Z%ZQ+t8uQ-n)SQ.r*XQ1r-tQ2k.kR3m8vpdOSiw{!k$V%T%^%a%b%d*a*f.{/OR*U%V&WVOSTijm{!Q!U!Z!h!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$V$i%V%Y%Z%^%`%a%b%d%h%s%{&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9u9vW!aRU!^&PQ$]kQ$clS$hn$mv$rpq!o!r$T$p&X&l&o)j)k)l*_*v+V+o+q/U0OQ$zuQ&`!fQ&b!gS(R#r(]S)X$d$eQ)]$gQ)i$oQ){$|Q*P%OS+i&c&dQ,o(SQ-r)YQ-x)`Q-{)dQ.e)|S.i*Q*RQ/z+jQ0s,kQ1q-tQ1t-wQ1w-}Q2j.jQ3x0tR6W4d!W$al!g$c$d$e%}&b&c&d(^)X)Y*y+X+i+j,{-r/e/l/p/z1Y3^3b5l6{Q)Q$]Q)q$wQ)t$xQ*O%OQ.P)iQ.d){U.h*P*Q*RQ2e.eS2i.i.jQ4q2TQ5T2jS6`4r4uS7]6a6cQ7u7^R8T7vW#x`$_(l9sS$wr%TQ$xsQ$ytR)o$u$T#w`!t!v#a#r#t#}$O$S&_'z'|'}(U(Y(j(k(})P)S)p)s+f+z,r,t-^-h-j.U.X.a.c0r0{1V1^1e1h1l1z2b2d3{4X4a4z5P6Z6g7b8s8w8x8y8z8{8|9R9S9T9U9V9W9Z9[9_9`9s9y9zV(p#|8u8vU&S!`$q+PQ&|!xQ)c$jQ,b'vQ.Y)uQ1_-ZR4m2P&YbORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$V$i%V%Y%Z%^%`%a%b%d%h%s%{&P&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9v$]#^Y!]!l$Z%r%v&q&x'O'P'Q'R'S'T'U'V'W'X'Y'['_'c'm)b*q*z+T+k+y,P,S,U,a-_/Z/^/{0V0Z0[0]0^0_0`0a0b0c0d0e0f0g0j0o1c1o3U3X3h3k3l3q3r4o5d5g5r5v5w6v7X7h7|8W8a9l&ZbORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$V$i%V%Y%Z%^%`%a%b%d%h%s%{&P&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vQ&Q!`R/a*|Y%z!`&O&V*|+SS(^#u(dS+X&[+[S,{(_(fQ,|(`Q-S(gQ.[)wS/l+Y+^S/p+_+`S/t+a2YQ1Y-RQ1[-TQ1]-US2T._2WS3^/o/qQ3a/rQ3b/sS4r2U2]S4u2Z2[S5l3`3cQ5o3dS6a4v4wQ6c4xQ6{5nS7^6b6dR7v7_lgOSi{!k$V%^%a%b%d*a*f.{/OQ%f!OS&p!s8eQ)V$bQ)y$zQ)z${Q+g&aS+x&u9OS-`(w9XQ-p)WQ.^)xQ/S*hQ/T*iQ/]*wQ/x+hS1d-a9]Q1m-qS1p-s9^Q3T/_Q3W/gQ3f/yQ4c1nQ5b3QQ5e3VQ5i3]Q5p3gQ6t5cQ6w5jQ7i6yQ7z7fR7}7k$W#]Y!]!l%r%v&q&x'O'P'Q'R'S'T'U'V'W'X'Y'['_'c'm)b*q*z+T+k+y,P,S,a-_/Z/^/{0V0Z0[0]0^0_0`0a0b0c0d0e0f0g0j0o1c1o3U3X3h3k3l3q3r4o5d5g5r5v5w6v7X7h7|8W8a9lU(i#v&t0iT({$Z,U$W#[Y!]!l%r%v&q&x'O'P'Q'R'S'T'U'V'W'X'Y'['_'c'm)b*q*z+T+k+y,P,S,a-_/Z/^/{0V0Z0[0]0^0_0`0a0b0c0d0e0f0g0j0o1c1o3U3X3h3k3l3q3r4o5d5g5r5v5w6v7X7h7|8W8a9lQ'^#]S(z$Z,UR-b({&YbORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$V$i%V%Y%Z%^%`%a%b%d%h%s%{&P&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vQ%ayQ%bzQ%d|Q%e}R.z*dQ&]!fQ(|$]Q+d&`S-g)Q)iS/u+b+cW1g-d-e-f.PS3e/v/wU4`1i1j1kU6U4_4i4jQ7U6VR7q7WT+Z&[+[S+Z&[+[T2V._2WS&j!n.xQ,n(RQ,y(^S/k+X2TQ0x,oS1S,z-SU3_/p/t4uQ3w0sS4V1Z1]U5m3a3b6cQ5z3xQ6T4YR6|5oQ!uXS&i!n.xQ(x$UQ)T$`Q)Z$fQ+m&jQ,m(RQ,x(^Q,}(aQ-o)UQ.f)}S/j+X2TS0w,n,oS1R,y-SQ1U,|Q1X-OQ2g.gW3[/k/p/t4uQ3v0sQ3z0xS4P1S1]Q4W1[Q5R2hW5k3_3a3b6cS5y3w3xQ6O4RQ6R4VQ6^4pQ6k5SS6z5m5oQ7O5zQ7Q6PQ7T6TQ7Z6_Q7d6lQ7l6|Q7o7SQ7s7[Q8R7tQ8Y8SQ8^8ZQ9f9bQ9o9jR9p9k$nWORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$V$i%V%Y%Z%^%`%a%b%d%h%s%{&W&^&h&u&y'u(w)O*]*a*f+e+l+},T-[-a-i-s.b.s.t.u.w.{/O/Q/i/|0W1y2c2v2x2y3Z5O5^5h6x7j8OS!um!h!j9a#Y#h&P'o*u*x,Y/`0k2R3S6[8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vR9f9u$nXORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$V$i%V%Y%Z%^%`%a%b%d%h%s%{&W&^&h&u&y'u(w)O*]*a*f+e+l+},T-[-a-i-s.b.s.t.u.w.{/O/Q/i/|0W1y2c2v2x2y3Z5O5^5h6x7j8OQ$Ua!W$`l!g$c$d$e%}&b&c&d(^)X)Y*y+X+i+j,{-r/e/l/p/z1Y3^3b5l6{S$fm!hQ)U$aQ)}%OW.g*O*P*Q*RU2h.h.i.jQ4p2TS5S2i2jU6_4q4r4uQ6l5TU7[6`6a6cS7t7]7^S8S7u7vQ8Z8T!j9b#Y#h&P'o*u*x,Y/`0k2R3S6[8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vQ9j9tR9k9u$f[OSTij{!Q!U!Z!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$V$i%V%Y%^%`%a%b%d%h%s%{&W&^&h&u&y'u(w)O*]*a*f+e+l+},T-[-a-i-s.b.s.t.u.w.{/O/Q/i/|0W1y2c2v2x2y3Z5O5^5h6x7j8OU!eRU!^v$rpq!o!r$T$p&X&l&o)j)k)l*_*v+V+o+q/U0OQ*[%Z!h9c#Y#h'o*u*x,Y/`0k2R3S6[8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vR9e&PS&T!`$qR/c+P$lZORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$V$i%V%Y%^%`%a%b%d%h%s%{&W&^&h&u&y'u(w)O*]*a*f+e+l+},T-[-a-i-s.b.s.t.u.w.{/O/Q/i/|0W1y2c2v2x2y3Z5O5^5h6x7j8O!j']#Y#h&P'o*u*x,Y/`0k2R3S6[8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vR*Z%Z!h#SY!]$Z%r%v&q&x'V'W'X'Y'_'c)b*q+T+k+y,P,a-_/{0V0g1c1o3X3h3k5g6v7h7|8W8a!R8l'['m*z,U/Z/^0Z0c0d0e0f0j0o3U3l3q3r4o5d5r5v5w7X9l!d#UY!]$Z%r%v&q&x'X'Y'_'c)b*q+T+k+y,P,a-_/{0V0g1c1o3X3h3k5g6v7h7|8W8a}8n'['m*z,U/Z/^0Z0e0f0j0o3U3l3q3r4o5d5r5v5w7X9l!`#YY!]$Z%r%v&q&x'_'c)b*q+T+k+y,P,a-_/{0V0g1c1o3X3h3k5g6v7h7|8W8al'}#p&v(v,i,q-V-W0T1b3u4Z9g9q9rx9v'['m*z,U/Z/^0Z0j0o3U3l3q3r4o5d5r5v5w7X9l!^9y&r'a(Q(W+c+w,u-c-f.T.V/w0S0y0}1k1|2O2`3j3|4S4]4b4j4}5q5|6S6iZ9z0h3p5s6}7m&YbORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$V$i%V%Y%Z%^%`%a%b%d%h%s%{&P&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vS#i_#jR0l,X&a^ORSTU_ij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h#j$V$i%V%Y%Z%^%`%a%b%d%h%s%{&P&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,X,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vS#d]#kT'f#f'jT#e]#kT'h#f'j&a_ORSTU_ij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h#j$V$i%V%Y%Z%^%`%a%b%d%h%s%{&P&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,X,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vT#i_#jQ#l_R'q#j$naORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$V$i%V%Y%Z%^%`%a%b%d%h%s%{&W&^&h&u&y'u(w)O*]*a*f+e+l+},T-[-a-i-s.b.s.t.u.w.{/O/Q/i/|0W1y2c2v2x2y3Z5O5^5h6x7j8O!k9t#Y#h&P'o*u*x,Y/`0k2R3S6[8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9v#RcOSUi{!Q!U!k!y#h$V%V%Y%Z%^%`%a%b%d%h%{&^'o)O*]*a*f+e,Y-[-i.b.s.t.u.w.{/O/Q0k1y2c2v2x2y5O5^t#v`!v#}$O$S'z'|'}(U(j(k+z-^0r1^9s9y9z!z&t!t#a#r#t&_(Y(})P)S)p)s+f,r,t-h-j.U.X.a.c0{1V1e1h1l1z2b2d3{4X4a4z5P6Z6g7b8w8y8{9R9T9V9Z9_Q(t$Qc0i8s8x8z8|9S9U9W9[9`t#s`!v#}$O$S'z'|'}(U(j(k+z-^0r1^9s9y9zS(a#u(dQ(u$RQ-O(b!z9h!t#a#r#t&_(Y(})P)S)p)s+f,r,t-h-j.U.X.a.c0{1V1e1h1l1z2b2d3{4X4a4z5P6Z6g7b8w8y8{9R9T9V9Z9_b9i8s8x8z8|9S9U9W9[9`Q9m9wR9n9xleOSi{!k$V%^%a%b%d*a*f.{/OQ(X#tQ*m%kQ*n%mR0z,r$S#w`!t!v#a#r#t#}$O$S&_'z'|'}(U(Y(j(k(})P)S)p)s+f+z,r,t-^-h-j.U.X.a.c0r0{1V1^1e1h1l1z2b2d3{4X4a4z5P6Z6g7b8s8w8x8y8z8{8|9R9S9T9U9V9W9Z9[9_9`9s9y9zQ)r$xQ.W)tQ1}.VR4l2OT(c#u(dS(c#u(dT2V._2WQ)T$`Q,}(aQ-o)UQ.f)}Q2g.gQ5R2hQ6^4pQ6k5SQ7Z6_Q7d6lQ7s7[Q8R7tQ8Y8SR8^8Zl'z#p&v(v,i,q-V-W0T1b3u4Z9g9q9r!^9R&r'a(Q(W+c+w,u-c-f.T.V/w0S0y0}1k1|2O2`3j3|4S4]4b4j4}5q5|6S6iZ9S0h3p5s6}7mn'|#p&v(v,g,i,q-V-W0T1b3u4Z9g9q9r!`9T&r'a(Q(W+c+w,u-c-f.T.V/w0Q0S0y0}1k1|2O2`3j3|4S4]4b4j4}5q5|6S6i]9U0h3p5s5t6}7mpdOSiw{!k$V%T%^%a%b%d*a*f.{/OQ%QvR*]%ZpdOSiw{!k$V%T%^%a%b%d*a*f.{/OR%QvQ)v$yR.S)oqdOSiw{!k$V%T%^%a%b%d*a*f.{/OQ.`){S2a.d.eW4y2^2_2`2eU6f4{4|4}U7`6e6h6iQ7w7aR8U7xQ%XwR*V%TR2n.mR6n5US$hn$mR-x)`Q%^xR*a%_R*g%eT.|*f/OQiOQ!kST$Yi!kQ!WQR%p!WQ![RU%t![%u*rQ%u!]R*r%vQ*}&QR/b*}Q+{&vR0U+{Q,O&xS0X,O0YR0Y,PQ+[&[R/m+[Q&Y!cQ*s%wT+W&Y*sQ+Q&TR/d+QQ&m!pQ+n&kU+r&m+n0PR0P+sQ'j#fR,Z'jQ#j_R'p#jQ#`YU'`#`*p8rQ*p8aR8r'mQ,l(RW0u,l0v3y5{U0v,m,n,oS3y0w0xR5{3z#o'x#p&r&v'a(Q(W(q(r(v+c+u+v+w,g,h,i,q,u-V-W-c-f.T.V/w0Q0R0S0T0h0y0}1b1k1|2O2`3j3n3o3p3u3|4S4Z4]4b4j4}5q5s5t5u5|6S6i6}7m9g9q9rQ,s(WU0|,s1O3}Q1O,uR3}0}Q(d#uR-P(dQ(m#yR-Y(mQ1f-cR4^1fQ)m$sR.R)mQ2Q.YS4n2Q6]R6]4oQ)x$zR.])xQ2W._R4s2WQ.l*SS2l.l5VR5V2nQ-u)]S1s-u4eR4e1tQ)a$hR-y)aQ/O*fR2|/OWhOSi!kQ%c{Q(y$VQ*`%^Q*b%aQ*c%bQ*e%dQ.y*aS.|*f/OR2{.{Q$XfQ%g!PQ%j!RQ%l!SQ%n!TQ)h$nQ)n$tQ*U%XQ*k%iS.o*V*YQ/V*jQ/W*mQ/X*nS/h+X2TQ1P,wQ1Q,xQ1W,}Q1v-|Q1{.TQ2f.fQ2p.qQ2z.zY3Y/j/k/p/t4uQ4O1RQ4Q1TQ4T1XQ4h1xQ4k1|Q5Q2gQ5W2o[5f3X3[3_3a3b6cQ5}4PQ6Q4UQ6X4fQ6j5RQ6o5XW6u5g5k5m5oQ7P6OQ7R6RQ7V6YQ7Y6^Q7c6kU7g6v6z6|Q7n7QQ7p7TQ7r7ZQ7y7dS7{7h7lQ8P7oQ8Q7sQ8V7|Q8X8RQ8[8WQ8]8YR8_8^Q$blQ&a!gU)W$c$d$eQ*w%}U+h&b&c&dQ,w(^S-q)X)YQ/_*yQ/g+XS/y+i+jQ1T,{Q1n-rQ3V/eS3]/l/pQ3g/zQ4U1YS5j3^3bQ6y5lR7k6{S#q`9sR)R$_U#y`$_9sR-X(lQ#p`S&r!t)SQ&v!vQ'a#aQ(Q#rQ(W#tQ(q#}Q(r$OQ(v$SQ+c&_Q+u8wQ+v8yQ+w8{Q,g'zQ,h'|Q,i'}Q,q(UQ,u(YQ-V(jQ-W(kd-c(}-h.a1h2b4a4z6Z6g7bQ-f)PQ.T)pQ.V)sQ/w+fQ0Q9RQ0R9TQ0S9VQ0T+zQ0h8sQ0y,rQ0},tQ1b-^Q1k-jQ1|.UQ2O.XQ2`.cQ3j9ZQ3n8xQ3o8zQ3p8|Q3u0rQ3|0{Q4S1VQ4Z1^Q4]1eQ4b1lQ4j1zQ4}2dQ5q9_Q5s9WQ5t9SQ5u9UQ5|3{Q6S4XQ6i5PQ6}9[Q7m9`Q9g9sQ9q9yR9r9zlfOSi{!k$V%^%a%b%d*a*f.{/OS!mU%`Q%i!QQ%o!UQ&}!yQ'n#hS*Y%V%YQ*^%ZQ*j%hQ*t%{Q+b&^Q,_'oQ-e)OQ.v*]Q/v+eQ0n,YQ1`-[Q1j-iQ2_.bQ2r.sQ2s.tQ2u.uQ2w.wQ3O/QQ3s0kQ4i1yQ4|2cQ5]2vQ5_2xQ5`2yQ6h5OR6q5^!vYOSUi{!Q!k!y$V%V%Y%Z%^%`%a%b%d%h%{&^)O*]*a*f+e-[-i.b.s.t.u.w.{/O/Q1y2c2v2x2y5O5^Q!]RQ!lTQ$ZjQ%r!ZQ%v!^Q&q!sQ&x!wQ'O!|Q'P!}Q'Q#OQ'R#PQ'S#QQ'T#RQ'U#SQ'V#TQ'W#UQ'X#VQ'Y#WQ'[#YQ'_#_Q'c#bW'm#h'o,Y0kQ)b$iQ*q%sS*z&P/`Q+T&WQ+k&hQ+y&uQ,P&yQ,S8`Q,U8bQ,a'uQ-_(wQ/Z*uQ/^*xQ/{+lQ0V+}Q0Z8eQ0[8fQ0]8gQ0^8hQ0_8iQ0`8jQ0a8kQ0b8lQ0c8mQ0d8nQ0e8oQ0f8pQ0g,TQ0j8tQ0o8qQ1c-aQ1o-sQ3U8}Q3X/iQ3h/|Q3k0WQ3l9OQ3q9QQ3r9XQ4o2RQ5d3SQ5g3ZQ5r9YQ5v9]Q5w9^Q6v5hQ7X6[Q7h6xQ7|7jQ8W8OQ8a!UR9l9vT!VQ!WR!_RR&R!`S%}!`*|S*y&O&VR/e+SR&w!vR&z!wT!qU$TS!pU$TU$spq*_S&k!o!rQ+p&lQ+s&oQ.Q)lS/}+o+qR3i0O[!bR!^$p&X)j+Vh!nUpq!o!r$T&l&o)l+o+q0OQ.x*_Q/[*vQ3R/UT9d&P)kT!dR$pS!cR$pS%w!^)jS*{&P)kQ+U&XR/f+VT&U!`$qQ#f]R's#kT'i#f'jR0m,XT(T#r(]R(Z#tQ-d(}Q1i-hQ2^.aQ4_1hQ4{2bQ6V4aQ6e4zQ7W6ZQ7a6gR7x7blgOSi{!k$V%^%a%b%d*a*f.{/OQ%WwR*U%TV$tpq*_R.Z)uR*T%RQ$lnR)g$mR)^$gT%[x%_T%]x%_T.}*f/O",
  nodeNames: "\u26A0 ArithOp ArithOp extends LineComment BlockComment Script ExportDeclaration export Star as VariableName from String ; default FunctionDeclaration async function VariableDefinition TypeParamList TypeDefinition ThisType this LiteralType ArithOp Number BooleanLiteral VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString null super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyNameDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression await yield delete LogicOp BitOp ParenthesizedExpression ClassExpression class extends ClassBody MethodDeclaration Privacy static abstract PropertyDeclaration readonly Optional TypeAnnotation Equals FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp in instanceof const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplatExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try catch finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement",
  maxTerm: 321,
  nodeProps: [
    [NodeProp.group, -26, 7, 14, 16, 53, 175, 179, 182, 183, 185, 188, 191, 202, 204, 210, 212, 214, 216, 219, 225, 229, 231, 233, 235, 237, 239, 240, "Statement", -30, 11, 13, 23, 26, 27, 37, 38, 39, 40, 42, 47, 55, 63, 69, 70, 83, 84, 93, 94, 110, 113, 115, 116, 117, 118, 120, 121, 139, 140, 142, "Expression", -21, 22, 24, 28, 30, 143, 145, 147, 148, 150, 151, 152, 154, 155, 156, 158, 159, 160, 169, 171, 173, 174, "Type", -2, 74, 78, "ClassItem"],
    [NodeProp.closedBy, 36, "]", 46, "}", 61, ")", 123, "JSXSelfCloseEndTag JSXEndTag", 137, "JSXEndTag"],
    [NodeProp.openedBy, 41, "[", 45, "{", 60, "(", 122, "JSXStartTag", 132, "JSXStartTag JSXStartCloseTag"]
  ],
  skippedNodes: [0, 4, 5],
  repeatNodeCount: 27,
  tokenData: "!?v~R!ZOX$tX^%S^p$tpq%Sqr&rrs'zst$ttu/wuv2Xvw2|wx3zxy:byz:rz{;S{|<S|}<g}!O<S!O!P<w!P!QAT!Q!R!-s!R![!/Y![!]!4x!]!^!5[!^!_!5l!_!`!6i!`!a!7a!a!b!9W!b!c$t!c!}/w!}#O!:i#O#P$t#P#Q!:y#Q#R!;Z#R#S/w#S#T!;n#T#o/w#o#p!<O#p#q!<T#q#r!<k#r#s!<}#s#y$t#y#z%S#z$f$t$f$g%S$g#BY/w#BY#BZ!=_#BZ$IS/w$IS$I_!=_$I_$I|/w$I|$JO!=_$JO$JT/w$JT$JU!=_$JU$KV/w$KV$KW!=_$KW&FU/w&FU&FV!=_&FV~/wW$yR#{WO!^$t!_#o$t#p~$t,T%Zg#{W&}+{OX$tX^%S^p$tpq%Sq!^$t!_#o$t#p#y$t#y#z%S#z$f$t$f$g%S$g#BY$t#BY#BZ%S#BZ$IS$t$IS$I_%S$I_$I|$t$I|$JO%S$JO$JT$t$JT$JU%S$JU$KV$t$KV$KW%S$KW&FU$t&FU&FV%S&FV~$t$T&yS#{W!e#{O!^$t!_!`'V!`#o$t#p~$t$O'^S#[#v#{WO!^$t!_!`'j!`#o$t#p~$t$O'qR#[#v#{WO!^$t!_#o$t#p~$t'u(RZ#{W]!ROY'zYZ(tZr'zrs*Rs!^'z!^!_*e!_#O'z#O#P,q#P#o'z#o#p*e#p~'z&r(yV#{WOr(trs)`s!^(t!^!_)p!_#o(t#o#p)p#p~(t&r)gR#v&j#{WO!^$t!_#o$t#p~$t&j)sROr)prs)|s~)p&j*RO#v&j'u*[R#v&j#{W]!RO!^$t!_#o$t#p~$t'm*jV]!ROY*eYZ)pZr*ers+Ps#O*e#O#P+W#P~*e'm+WO#v&j]!R'm+ZROr*ers+ds~*e'm+kU#v&j]!ROY+}Zr+}rs,fs#O+}#O#P,k#P~+}!R,SU]!ROY+}Zr+}rs,fs#O+}#O#P,k#P~+}!R,kO]!R!R,nPO~+}'u,vV#{WOr'zrs-]s!^'z!^!_*e!_#o'z#o#p*e#p~'z'u-fZ#v&j#{W]!ROY.XYZ$tZr.Xrs/Rs!^.X!^!_+}!_#O.X#O#P/c#P#o.X#o#p+}#p~.X!Z.`Z#{W]!ROY.XYZ$tZr.Xrs/Rs!^.X!^!_+}!_#O.X#O#P/c#P#o.X#o#p+}#p~.X!Z/YR#{W]!RO!^$t!_#o$t#p~$t!Z/hT#{WO!^.X!^!_+}!_#o.X#o#p+}#p~.X&i0S_#{W#qS'Yp'P%kOt$ttu/wu}$t}!O1R!O!Q$t!Q![/w![!^$t!_!c$t!c!}/w!}#R$t#R#S/w#S#T$t#T#o/w#p$g$t$g~/w[1Y_#{W#qSOt$ttu1Ru}$t}!O1R!O!Q$t!Q![1R![!^$t!_!c$t!c!}1R!}#R$t#R#S1R#S#T$t#T#o1R#p$g$t$g~1R$O2`S#T#v#{WO!^$t!_!`2l!`#o$t#p~$t$O2sR#{W#f#vO!^$t!_#o$t#p~$t%r3TU'm%j#{WOv$tvw3gw!^$t!_!`2l!`#o$t#p~$t$O3nS#{W#`#vO!^$t!_!`2l!`#o$t#p~$t'u4RZ#{W]!ROY3zYZ4tZw3zwx*Rx!^3z!^!_5l!_#O3z#O#P7l#P#o3z#o#p5l#p~3z&r4yV#{WOw4twx)`x!^4t!^!_5`!_#o4t#o#p5`#p~4t&j5cROw5`wx)|x~5`'m5qV]!ROY5lYZ5`Zw5lwx+Px#O5l#O#P6W#P~5l'm6ZROw5lwx6dx~5l'm6kU#v&j]!ROY6}Zw6}wx,fx#O6}#O#P7f#P~6}!R7SU]!ROY6}Zw6}wx,fx#O6}#O#P7f#P~6}!R7iPO~6}'u7qV#{WOw3zwx8Wx!^3z!^!_5l!_#o3z#o#p5l#p~3z'u8aZ#v&j#{W]!ROY9SYZ$tZw9Swx/Rx!^9S!^!_6}!_#O9S#O#P9|#P#o9S#o#p6}#p~9S!Z9ZZ#{W]!ROY9SYZ$tZw9Swx/Rx!^9S!^!_6}!_#O9S#O#P9|#P#o9S#o#p6}#p~9S!Z:RT#{WO!^9S!^!_6}!_#o9S#o#p6}#p~9S%V:iR!_$}#{WO!^$t!_#o$t#p~$tZ:yR!^R#{WO!^$t!_#o$t#p~$t%R;]U'Q!R#U#v#{WOz$tz{;o{!^$t!_!`2l!`#o$t#p~$t$O;vS#R#v#{WO!^$t!_!`2l!`#o$t#p~$t$u<ZSi$m#{WO!^$t!_!`2l!`#o$t#p~$t&i<nR|&a#{WO!^$t!_#o$t#p~$t&i=OVq%n#{WO!O$t!O!P=e!P!Q$t!Q![>Z![!^$t!_#o$t#p~$ty=jT#{WO!O$t!O!P=y!P!^$t!_#o$t#p~$ty>QR{q#{WO!^$t!_#o$t#p~$ty>bZ#{WjqO!Q$t!Q![>Z![!^$t!_!g$t!g!h?T!h#R$t#R#S>Z#S#X$t#X#Y?T#Y#o$t#p~$ty?YZ#{WO{$t{|?{|}$t}!O?{!O!Q$t!Q![@g![!^$t!_#R$t#R#S@g#S#o$t#p~$ty@QV#{WO!Q$t!Q![@g![!^$t!_#R$t#R#S@g#S#o$t#p~$ty@nV#{WjqO!Q$t!Q![@g![!^$t!_#R$t#R#S@g#S#o$t#p~$t,TA[`#{W#S#vOYB^YZ$tZzB^z{HT{!PB^!P!Q!*|!Q!^B^!^!_Da!_!`!+u!`!a!,t!a!}B^!}#OFY#O#PGi#P#oB^#o#pDa#p~B^XBe[#{WxPOYB^YZ$tZ!PB^!P!QCZ!Q!^B^!^!_Da!_!}B^!}#OFY#O#PGi#P#oB^#o#pDa#p~B^XCb_#{WxPO!^$t!_#Z$t#Z#[CZ#[#]$t#]#^CZ#^#a$t#a#bCZ#b#g$t#g#hCZ#h#i$t#i#jCZ#j#m$t#m#nCZ#n#o$t#p~$tPDfVxPOYDaZ!PDa!P!QD{!Q!}Da!}#OEd#O#PFP#P~DaPEQUxP#Z#[D{#]#^D{#a#bD{#g#hD{#i#jD{#m#nD{PEgTOYEdZ#OEd#O#PEv#P#QDa#Q~EdPEyQOYEdZ~EdPFSQOYDaZ~DaXF_Y#{WOYFYYZ$tZ!^FY!^!_Ed!_#OFY#O#PF}#P#QB^#Q#oFY#o#pEd#p~FYXGSV#{WOYFYYZ$tZ!^FY!^!_Ed!_#oFY#o#pEd#p~FYXGnV#{WOYB^YZ$tZ!^B^!^!_Da!_#oB^#o#pDa#p~B^,TH[^#{WxPOYHTYZIWZzHTz{Ki{!PHT!P!Q!)j!Q!^HT!^!_Mt!_!}HT!}#O!%e#O#P!(x#P#oHT#o#pMt#p~HT,TI]V#{WOzIWz{Ir{!^IW!^!_Jt!_#oIW#o#pJt#p~IW,TIwX#{WOzIWz{Ir{!PIW!P!QJd!Q!^IW!^!_Jt!_#oIW#o#pJt#p~IW,TJkR#{WT+{O!^$t!_#o$t#p~$t+{JwROzJtz{KQ{~Jt+{KTTOzJtz{KQ{!PJt!P!QKd!Q~Jt+{KiOT+{,TKp^#{WxPOYHTYZIWZzHTz{Ki{!PHT!P!QLl!Q!^HT!^!_Mt!_!}HT!}#O!%e#O#P!(x#P#oHT#o#pMt#p~HT,TLu_#{WT+{xPO!^$t!_#Z$t#Z#[CZ#[#]$t#]#^CZ#^#a$t#a#bCZ#b#g$t#g#hCZ#h#i$t#i#jCZ#j#m$t#m#nCZ#n#o$t#p~$t+{MyYxPOYMtYZJtZzMtz{Ni{!PMt!P!Q!$a!Q!}Mt!}#O! w#O#P!#}#P~Mt+{NnYxPOYMtYZJtZzMtz{Ni{!PMt!P!Q! ^!Q!}Mt!}#O! w#O#P!#}#P~Mt+{! eUT+{xP#Z#[D{#]#^D{#a#bD{#g#hD{#i#jD{#m#nD{+{! zWOY! wYZJtZz! wz{!!d{#O! w#O#P!#k#P#QMt#Q~! w+{!!gYOY! wYZJtZz! wz{!!d{!P! w!P!Q!#V!Q#O! w#O#P!#k#P#QMt#Q~! w+{!#[TT+{OYEdZ#OEd#O#PEv#P#QDa#Q~Ed+{!#nTOY! wYZJtZz! wz{!!d{~! w+{!$QTOYMtYZJtZzMtz{Ni{~Mt+{!$f_xPOzJtz{KQ{#ZJt#Z#[!$a#[#]Jt#]#^!$a#^#aJt#a#b!$a#b#gJt#g#h!$a#h#iJt#i#j!$a#j#mJt#m#n!$a#n~Jt,T!%j[#{WOY!%eYZIWZz!%ez{!&`{!^!%e!^!_! w!_#O!%e#O#P!(W#P#QHT#Q#o!%e#o#p! w#p~!%e,T!&e^#{WOY!%eYZIWZz!%ez{!&`{!P!%e!P!Q!'a!Q!^!%e!^!_! w!_#O!%e#O#P!(W#P#QHT#Q#o!%e#o#p! w#p~!%e,T!'hY#{WT+{OYFYYZ$tZ!^FY!^!_Ed!_#OFY#O#PF}#P#QB^#Q#oFY#o#pEd#p~FY,T!(]X#{WOY!%eYZIWZz!%ez{!&`{!^!%e!^!_! w!_#o!%e#o#p! w#p~!%e,T!(}X#{WOYHTYZIWZzHTz{Ki{!^HT!^!_Mt!_#oHT#o#pMt#p~HT,T!)qc#{WxPOzIWz{Ir{!^IW!^!_Jt!_#ZIW#Z#[!)j#[#]IW#]#^!)j#^#aIW#a#b!)j#b#gIW#g#h!)j#h#iIW#i#j!)j#j#mIW#m#n!)j#n#oIW#o#pJt#p~IW,T!+TV#{WS+{OY!*|YZ$tZ!^!*|!^!_!+j!_#o!*|#o#p!+j#p~!*|+{!+oQS+{OY!+jZ~!+j$P!,O[#{W#f#vxPOYB^YZ$tZ!PB^!P!QCZ!Q!^B^!^!_Da!_!}B^!}#OFY#O#PGi#P#oB^#o#pDa#p~B^]!,}[#nS#{WxPOYB^YZ$tZ!PB^!P!QCZ!Q!^B^!^!_Da!_!}B^!}#OFY#O#PGi#P#oB^#o#pDa#p~B^y!-zd#{WjqO!O$t!O!P>Z!P!Q$t!Q![!/Y![!^$t!_!g$t!g!h?T!h#R$t#R#S!/Y#S#U$t#U#V!0p#V#X$t#X#Y?T#Y#b$t#b#c!0`#c#d!2O#d#l$t#l#m!3W#m#o$t#p~$ty!/a_#{WjqO!O$t!O!P>Z!P!Q$t!Q![!/Y![!^$t!_!g$t!g!h?T!h#R$t#R#S!/Y#S#X$t#X#Y?T#Y#b$t#b#c!0`#c#o$t#p~$ty!0gR#{WjqO!^$t!_#o$t#p~$ty!0uW#{WO!Q$t!Q!R!1_!R!S!1_!S!^$t!_#R$t#R#S!1_#S#o$t#p~$ty!1fW#{WjqO!Q$t!Q!R!1_!R!S!1_!S!^$t!_#R$t#R#S!1_#S#o$t#p~$ty!2TV#{WO!Q$t!Q!Y!2j!Y!^$t!_#R$t#R#S!2j#S#o$t#p~$ty!2qV#{WjqO!Q$t!Q!Y!2j!Y!^$t!_#R$t#R#S!2j#S#o$t#p~$ty!3]Z#{WO!Q$t!Q![!4O![!^$t!_!c$t!c!i!4O!i#R$t#R#S!4O#S#T$t#T#Z!4O#Z#o$t#p~$ty!4VZ#{WjqO!Q$t!Q![!4O![!^$t!_!c$t!c!i!4O!i#R$t#R#S!4O#S#T$t#T#Z!4O#Z#o$t#p~$t%w!5RR!WV#{W#d%hO!^$t!_#o$t#p~$t!P!5cR^w#{WO!^$t!_#o$t#p~$t+c!5wR'Ud![%Y#o&s'qP!P!Q!6Q!^!_!6V!_!`!6dW!6VO#}W#v!6[P#V#v!_!`!6_#v!6dO#f#v#v!6iO#W#v%w!6pT!t%o#{WO!^$t!_!`'V!`!a!7P!a#o$t#p~$t$P!7WR#O#w#{WO!^$t!_#o$t#p~$t%w!7lT'T!s#W#v#xS#{WO!^$t!_!`!7{!`!a!8]!a#o$t#p~$t$O!8SR#W#v#{WO!^$t!_#o$t#p~$t$O!8dT#V#v#{WO!^$t!_!`2l!`!a!8s!a#o$t#p~$t$O!8zS#V#v#{WO!^$t!_!`2l!`#o$t#p~$t%w!9_V'e%o#{WO!O$t!O!P!9t!P!^$t!_!a$t!a!b!:U!b#o$t#p~$t$`!9{Rr$W#{WO!^$t!_#o$t#p~$t$O!:]S#{W#a#vO!^$t!_!`2l!`#o$t#p~$t&e!:pRt&]#{WO!^$t!_#o$t#p~$tZ!;QRyR#{WO!^$t!_#o$t#p~$t$O!;bS#^#v#{WO!^$t!_!`2l!`#o$t#p~$t$P!;uR#{W']#wO!^$t!_#o$t#p~$t~!<TO!O~%r!<[T'l%j#{WO!^$t!_!`2l!`#o$t#p#q!:U#q~$t$u!<tR}$k#{W'_QO!^$t!_#o$t#p~$tX!=UR!fP#{WO!^$t!_#o$t#p~$t,T!=lr#{W#qS'Yp'P%k&}+{OX$tX^%S^p$tpq%Sqt$ttu/wu}$t}!O1R!O!Q$t!Q![/w![!^$t!_!c$t!c!}/w!}#R$t#R#S/w#S#T$t#T#o/w#p#y$t#y#z%S#z$f$t$f$g%S$g#BY/w#BY#BZ!=_#BZ$IS/w$IS$I_!=_$I_$I|/w$I|$JO!=_$JO$JT/w$JT$JU!=_$JU$KV/w$KV$KW!=_$KW&FU/w&FU&FV!=_&FV~/w",
  tokenizers: [noSemicolon, incdecToken, template, 0, 1, 2, 3, 4, 5, 6, 7, 8, insertSemicolon],
  topRules: {"Script": [0, 6]},
  dialects: {jsx: 11074, ts: 11076},
  dynamicPrecedences: {"140": 1, "167": 1},
  specialized: [{term: 277, get: (value, stack) => tsExtends(value, stack) << 1 | 1}, {term: 277, get: (value) => spec_identifier[value] || -1}, {term: 286, get: (value) => spec_word[value] || -1}, {term: 58, get: (value) => spec_LessThan[value] || -1}],
  tokenPrec: 11096
});

// node_modules/@codemirror/language/dist/index.js
var languageDataProp = new NodeProp();
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values) => values.concat(baseData) : void 0
  });
}
var Language = class {
  constructor(data, parser2, topNode, extraExtensions = []) {
    this.data = data;
    this.topNode = topNode;
    if (!EditorState.prototype.hasOwnProperty("tree"))
      Object.defineProperty(EditorState.prototype, "tree", {get() {
        return syntaxTree(this);
      }});
    this.parser = parser2;
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos) => state.facet(languageDataFacetAt(state, pos)))
    ].concat(extraExtensions);
  }
  isActiveAt(state, pos) {
    return languageDataFacetAt(state, pos) == this.data;
  }
  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
      return [{from: 0, to: state.doc.length}];
    if (!lang || !lang.allowsNesting)
      return [];
    let result = [];
    syntaxTree(state).iterate({
      enter: (type, from, to) => {
        if (type.isTop && type.prop(languageDataProp) == this.data) {
          result.push({from, to});
          return false;
        }
        return void 0;
      }
    });
    return result;
  }
  get allowsNesting() {
    return true;
  }
  parseString(code) {
    let doc2 = Text.of(code.split("\n"));
    let parse = this.parser.startParse(new DocInput(doc2), 0, new EditorParseContext(this.parser, EditorState.create({doc: doc2}), [], Tree.empty, {from: 0, to: code.length}, [], null));
    let tree;
    while (!(tree = parse.advance())) {
    }
    return tree;
  }
};
Language.setState = StateEffect.define();
function languageDataFacetAt(state, pos) {
  let topLang = state.facet(language);
  if (!topLang)
    return null;
  if (!topLang.allowsNesting)
    return topLang.data;
  let tree = syntaxTree(state);
  let target = tree.resolve(pos, -1);
  while (target) {
    let facet = target.type.prop(languageDataProp);
    if (facet)
      return facet;
    target = target.parent;
  }
  return topLang.data;
}
var LezerLanguage = class extends Language {
  constructor(data, parser2) {
    super(data, parser2, parser2.topNode);
    this.parser = parser2;
  }
  static define(spec) {
    let data = defineLanguageFacet(spec.languageData);
    return new LezerLanguage(data, spec.parser.configure({
      props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
    }));
  }
  configure(options2) {
    return new LezerLanguage(this.data, this.parser.configure(options2));
  }
  get allowsNesting() {
    return this.parser.hasNested;
  }
};
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
var DocInput = class {
  constructor(doc2, length = doc2.length) {
    this.doc = doc2;
    this.length = length;
    this.cursorPos = 0;
    this.string = "";
    this.prevString = "";
    this.cursor = doc2.iter();
  }
  syncTo(pos) {
    if (pos < this.cursorPos) {
      this.cursor = this.doc.iter();
      this.cursorPos = 0;
    }
    this.prevString = pos == this.cursorPos ? this.string : "";
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  get(pos) {
    if (pos >= this.length)
      return -1;
    let stringStart = this.cursorPos - this.string.length;
    if (pos < stringStart || pos >= this.cursorPos) {
      if (pos < stringStart && pos >= stringStart - this.prevString.length)
        return this.prevString.charCodeAt(pos - (stringStart - this.prevString.length));
      stringStart = this.syncTo(pos);
    }
    return this.string.charCodeAt(pos - stringStart);
  }
  lineAfter(pos) {
    if (pos >= this.length || pos < 0)
      return "";
    let stringStart = this.cursorPos - this.string.length;
    if (pos < stringStart || pos >= this.cursorPos)
      stringStart = this.syncTo(pos);
    return this.cursor.lineBreak ? "" : this.string.slice(pos - stringStart, Math.min(this.length - stringStart, this.string.length));
  }
  read(from, to) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to >= this.cursorPos)
      return this.doc.sliceString(from, to);
    else
      return this.string.slice(from - stringStart, to - stringStart);
  }
  clip(at) {
    return new DocInput(this.doc, at);
  }
};
var EditorParseContext = class {
  constructor(parser2, state, fragments = [], tree, viewport, skipped, scheduleOn) {
    this.parser = parser2;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  work(time, upto) {
    if (this.tree != Tree.empty && (upto == null ? this.tree.length == this.state.doc.length : this.tree.length >= upto)) {
      this.takeTree();
      return true;
    }
    if (!this.parse)
      this.parse = this.parser.startParse(new DocInput(this.state.doc), 0, this);
    let endTime = Date.now() + time;
    for (; ; ) {
      let done = this.parse.advance();
      if (done) {
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done));
        this.parse = null;
        this.tree = done;
        return true;
      } else if (upto != null && this.parse.pos >= upto) {
        this.takeTree();
        return true;
      }
      if (Date.now() > endTime)
        return false;
    }
  }
  takeTree() {
    if (this.parse && this.parse.pos > this.tree.length) {
      this.tree = this.parse.forceFinish();
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
    }
  }
  withoutTempSkipped(fragments) {
    for (let r; r = this.tempSkipped.pop(); )
      fragments = cutFragments(fragments, r.from, r.to);
    return fragments;
  }
  changes(changes, newState) {
    let {fragments, tree, viewport, skipped} = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({fromA, toA, fromB, toB}));
      fragments = TreeFragment.applyChanges(fragments, ranges);
      tree = Tree.empty;
      viewport = {from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1)};
      if (this.skipped.length) {
        skipped = [];
        for (let r of this.skipped) {
          let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
          if (from < to)
            skipped.push({from, to});
        }
      }
    }
    return new EditorParseContext(this.parser, newState, fragments, tree, viewport, skipped, this.scheduleOn);
  }
  updateViewport(viewport) {
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let {from, to} = this.skipped[i];
      if (from < viewport.to && to > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to);
        this.skipped.splice(i--, 1);
      }
    }
    return this.skipped.length < startLen;
  }
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  skipUntilInView(from, to) {
    this.skipped.push({from, to});
  }
  static getSkippingParser(until) {
    return {
      startParse(input, startPos, context) {
        return {
          pos: startPos,
          advance() {
            let ecx = context;
            ecx.tempSkipped.push({from: startPos, to: input.length});
            if (until)
              ecx.scheduleOn = ecx.scheduleOn ? Promise.all([ecx.scheduleOn, until]) : until;
            this.pos = input.length;
            return new Tree(NodeType.none, [], [], input.length - startPos);
          },
          forceFinish() {
            return this.advance();
          }
        };
      }
    };
  }
  movedPast(pos) {
    return this.tree.length < pos && this.parse && this.parse.pos >= pos;
  }
};
EditorParseContext.skippingParser = EditorParseContext.getSkippingParser();
function cutFragments(fragments, from, to) {
  return TreeFragment.applyChanges(fragments, [{fromA: from, toA: to, fromB: from, toB: to}]);
}
var LanguageState = class {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr) {
    if (!tr.docChanged)
      return this;
    let newCx = this.context.changes(tr.changes, tr.state);
    let upto = this.context.tree.length == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.tree.length), newCx.viewport.to);
    if (!newCx.work(25, upto))
      newCx.takeTree();
    return new LanguageState(newCx);
  }
  static init(state) {
    let parseState = new EditorParseContext(state.facet(language).parser, state, [], Tree.empty, {from: 0, to: state.doc.length}, [], null);
    if (!parseState.work(25))
      parseState.takeTree();
    return new LanguageState(parseState);
  }
};
Language.state = StateField.define({
  create: LanguageState.init,
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(Language.setState))
        return e.value;
    if (tr.startState.facet(language) != tr.state.facet(language))
      return LanguageState.init(tr.state);
    return value.apply(tr);
  }
});
var requestIdle = typeof window != "undefined" && window.requestIdleCallback || ((callback, {timeout}) => setTimeout(callback, timeout));
var cancelIdle = typeof window != "undefined" && window.cancelIdleCallback || clearTimeout;
var parseWorker = ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = -1;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx = this.view.state.field(Language.state).context;
    if (update.viewportChanged) {
      if (cx.updateViewport(update.view.viewport))
        cx.reset();
      if (this.view.viewport.to > cx.tree.length)
        this.scheduleWork();
    }
    if (update.docChanged) {
      if (this.view.hasFocus)
        this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx);
  }
  scheduleWork(force = false) {
    if (this.working > -1)
      return;
    let {state} = this.view, field = state.field(Language.state);
    if (!force && field.tree.length >= state.doc.length)
      return;
    this.working = requestIdle(this.work, {timeout: 500});
  }
  work(deadline) {
    this.working = -1;
    let now = Date.now();
    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0)
      return;
    let {state, viewport: {to: vpTo}} = this.view, field = state.field(Language.state);
    if (field.tree.length >= vpTo + 1e6)
      return;
    let time = Math.min(this.chunkBudget, deadline ? Math.max(25, deadline.timeRemaining()) : 100);
    let done = field.context.work(time, vpTo + 1e6);
    this.chunkBudget -= Date.now() - now;
    if (done || this.chunkBudget <= 0 || field.context.movedPast(vpTo)) {
      field.context.takeTree();
      this.view.dispatch({effects: Language.setState.of(new LanguageState(field.context))});
    }
    if (!done && this.chunkBudget > 0)
      this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      cx.scheduleOn.then(() => this.scheduleWork(true));
      cx.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working >= 0)
      cancelIdle(this.working);
  }
}, {
  eventHandlers: {focus() {
    this.scheduleWork();
  }}
});
var language = Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: [Language.state, parseWorker]
});
var LanguageSupport = class {
  constructor(language2, support = []) {
    this.language = language2;
    this.support = support;
    this.extension = [language2, support];
  }
};
var indentService = Facet.define();
var indentUnit = Facet.define({
  combine: (values) => {
    if (!values.length)
      return "  ";
    if (!/^(?: +|\t+)$/.test(values[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
    return values[0];
  }
});
function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
  let result = "", ts = state.tabSize;
  if (state.facet(indentUnit).charCodeAt(0) == 9)
    while (cols >= ts) {
      result += "	";
      cols -= ts;
    }
  for (let i = 0; i < cols; i++)
    result += " ";
  return result;
}
function getIndentation(context, pos) {
  if (context instanceof EditorState)
    context = new IndentContext(context);
  for (let service of context.state.facet(indentService)) {
    let result = service(context, pos);
    if (result != null)
      return result;
  }
  let tree = syntaxTree(context.state);
  return tree ? syntaxIndentation(context, tree, pos) : null;
}
var IndentContext = class {
  constructor(state, options2 = {}) {
    this.state = state;
    this.options = options2;
    this.unit = getIndentUnit(state);
  }
  textAfterPos(pos) {
    var _a, _b;
    let sim = (_a = this.options) === null || _a === void 0 ? void 0 : _a.simulateBreak;
    if (pos == sim && ((_b = this.options) === null || _b === void 0 ? void 0 : _b.simulateDoubleBreak))
      return "";
    return this.state.sliceDoc(pos, Math.min(pos + 100, sim != null && sim > pos ? sim : 1e9, this.state.doc.lineAt(pos).to));
  }
  column(pos) {
    var _a;
    let line = this.state.doc.lineAt(pos), text = line.text.slice(0, pos - line.from);
    let result = this.countColumn(text, pos - line.from);
    let override = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.overrideIndentation) ? this.options.overrideIndentation(line.from) : -1;
    if (override > -1)
      result += override - this.countColumn(text, text.search(/\S/));
    return result;
  }
  countColumn(line, pos) {
    return countColumn(pos < 0 ? line : line.slice(0, pos), 0, this.state.tabSize);
  }
  lineIndent(line) {
    var _a;
    let override = (_a = this.options) === null || _a === void 0 ? void 0 : _a.overrideIndentation;
    if (override) {
      let overriden = override(line.from);
      if (overriden > -1)
        return overriden;
    }
    return this.countColumn(line.text, line.text.search(/\S/));
  }
};
var indentNodeProp = new NodeProp();
function syntaxIndentation(cx, ast, pos) {
  let tree = ast.resolve(pos);
  for (let scan = tree, scanPos = pos; ; ) {
    let last = scan.childBefore(scanPos);
    if (!last)
      break;
    if (last.type.isError && last.from == last.to) {
      tree = scan;
      scanPos = last.from;
    } else {
      scan = last;
      scanPos = scan.to + 1;
    }
  }
  return indentFrom(tree, pos, cx);
}
function ignoreClosed(cx) {
  var _a, _b;
  return cx.pos == ((_a = cx.options) === null || _a === void 0 ? void 0 : _a.simulateBreak) && ((_b = cx.options) === null || _b === void 0 ? void 0 : _b.simulateDoubleBreak);
}
function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp);
  if (strategy)
    return strategy;
  let first = tree.firstChild, close;
  if (first && (close = first.type.prop(NodeProp.closedBy))) {
    let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
    return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
  }
  return tree.parent == null ? topIndent : null;
}
function indentFrom(node, pos, base2) {
  for (; node; node = node.parent) {
    let strategy = indentStrategy(node);
    if (strategy)
      return strategy(new TreeIndentContext(base2, pos, node));
  }
  return null;
}
function topIndent() {
  return 0;
}
var TreeIndentContext = class extends IndentContext {
  constructor(base2, pos, node) {
    super(base2.state, base2.options);
    this.base = base2;
    this.pos = pos;
    this.node = node;
  }
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  get baseIndent() {
    let line = this.state.doc.lineAt(this.node.from);
    for (; ; ) {
      let atBreak = this.node.resolve(line.from);
      while (atBreak.parent && atBreak.parent.from == atBreak.from)
        atBreak = atBreak.parent;
      if (isParent(atBreak, this.node))
        break;
      line = this.state.doc.lineAt(atBreak.from);
    }
    return this.lineIndent(line);
  }
  continue() {
    let parent = this.node.parent;
    return parent ? indentFrom(parent, this.pos, this.base) : 0;
  }
};
function isParent(parent, of) {
  for (let cur2 = of; cur2; cur2 = cur2.parent)
    if (parent == cur2)
      return true;
  return false;
}
function bracketedAligned(context) {
  var _a;
  let tree = context.node;
  let openToken = tree.childAfter(tree.from), last = tree.lastChild;
  if (!openToken)
    return null;
  let sim = (_a = context.options) === null || _a === void 0 ? void 0 : _a.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
  for (let pos = openToken.to; ; ) {
    let next = tree.childAfter(pos);
    if (!next || next == last)
      return null;
    if (!next.type.isSkipped)
      return next.from < lineEnd ? openToken : null;
    pos = next.to;
  }
}
function delimitedIndent({closing: closing2, align = true, units = 1}) {
  return (context) => delimitedStrategy(context, align, units, closing2);
}
function delimitedStrategy(context, align, units, closing2, closedAt) {
  let after = context.textAfter, space2 = after.match(/^\s*/)[0].length;
  let closed = closing2 && after.slice(space2, space2 + closing2.length) == closing2 || closedAt == context.pos + space2;
  let aligned = align ? bracketedAligned(context) : null;
  if (aligned)
    return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
var flatIndent = (context) => context.baseIndent;
function continuedIndent({except, units = 1} = {}) {
  return (context) => {
    let matchExcept = except && except.test(context.textAfter);
    return context.baseIndent + (matchExcept ? 0 : units * context.unit);
  };
}
var DontIndentBeyond = 200;
function indentOnInput() {
  return EditorState.transactionFilter.of((tr) => {
    if (!tr.docChanged || tr.annotation(Transaction.userEvent) != "input")
      return tr;
    let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
    if (!rules.length)
      return tr;
    let doc2 = tr.newDoc, {head} = tr.newSelection.main, line = doc2.lineAt(head);
    if (head > line.from + DontIndentBeyond)
      return tr;
    let lineStart = doc2.sliceString(line.from, head);
    if (!rules.some((r) => r.test(lineStart)))
      return tr;
    let {state} = tr, last = -1, changes = [];
    for (let {head: head2} of state.selection.ranges) {
      let line2 = state.doc.lineAt(head2);
      if (line2.from == last)
        continue;
      last = line2.from;
      let indent = getIndentation(state, line2.from);
      if (indent == null)
        continue;
      let cur2 = /^\s*/.exec(line2.text)[0];
      let norm = indentString(state, indent);
      if (cur2 != norm)
        changes.push({from: line2.from, to: line2.from + cur2.length, insert: norm});
    }
    return changes.length ? [tr, {changes}] : tr;
  });
}
var foldService = Facet.define();
var foldNodeProp = new NodeProp();
function foldInside(node) {
  let first = node.firstChild, last = node.lastChild;
  return first && first.to < last.from ? {from: first.to, to: last.type.isError ? node.to : last.from} : null;
}
function syntaxFolding(state, start, end) {
  let tree = syntaxTree(state);
  if (tree.length == 0)
    return null;
  let inner = tree.resolve(end);
  let found = null;
  for (let cur2 = inner; cur2; cur2 = cur2.parent) {
    if (cur2.to <= end || cur2.from > end)
      continue;
    if (found && cur2.from < start)
      break;
    let prop = cur2.type.prop(foldNodeProp);
    if (prop) {
      let value = prop(cur2, state);
      if (value && value.from <= end && value.from >= start && value.to > end)
        found = value;
    }
  }
  return found;
}
function foldable(state, lineStart, lineEnd) {
  for (let service of state.facet(foldService)) {
    let result = service(state, lineStart, lineEnd);
    if (result)
      return result;
  }
  return syntaxFolding(state, lineStart, lineEnd);
}

// node_modules/@codemirror/highlight/dist/index.js
var nextTagID = 0;
var Tag = class {
  constructor(set, base2, modified) {
    this.set = set;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  static define(parent) {
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new Tag([], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  static defineModifier() {
    let mod = new Modifier();
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class {
  constructor() {
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length)
      return base2;
    let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(set, base2, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = permute(mods);
    for (let parent of base2.set)
      for (let config2 of configs)
        set.push(Modifier.get(parent, config2));
    return tag;
  }
};
function sameArray2(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function permute(array) {
  let result = [array];
  for (let i = 0; i < array.length; i++) {
    for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))
      result.push(a);
  }
  return result;
}
function styleTags(spec) {
  let byName = Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? null : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = /* @__PURE__ */ new NodeProp();
var highlightStyle = /* @__PURE__ */ Facet.define({
  combine(stylings) {
    return stylings.length ? HighlightStyle.combinedMatch(stylings) : null;
  }
});
var fallbackHighlightStyle = /* @__PURE__ */ Facet.define({
  combine(values) {
    return values.length ? values[0].match : null;
  }
});
function getHighlightStyle(state) {
  return state.facet(highlightStyle) || state.facet(fallbackHighlightStyle);
}
var Rule = class {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
var HighlightStyle = class {
  constructor(spec, options2) {
    this.map = Object.create(null);
    let modSpec;
    function def(spec2) {
      let cls = StyleModule.newName();
      (modSpec || (modSpec = Object.create(null)))["." + cls] = spec2;
      return cls;
    }
    this.all = typeof options2.all == "string" ? options2.all : options2.all ? def(options2.all) : null;
    for (let style of spec) {
      let cls = (style.class || def(Object.assign({}, style, {tag: null}))) + (this.all ? " " + this.all : "");
      let tags2 = style.tag;
      if (!Array.isArray(tags2))
        this.map[tags2.id] = cls;
      else
        for (let tag of tags2)
          this.map[tag.id] = cls;
    }
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.scope = options2.scope || null;
    this.match = this.match.bind(this);
    let ext = [treeHighlighter];
    if (this.module)
      ext.push(EditorView.styleModule.of(this.module));
    this.extension = ext.concat(highlightStyle.of(this));
    this.fallback = ext.concat(fallbackHighlightStyle.of(this));
  }
  match(tag, scope) {
    if (this.scope && scope != this.scope)
      return null;
    for (let t2 of tag.set) {
      let match = this.map[t2.id];
      if (match !== void 0) {
        if (t2 != tag)
          this.map[tag.id] = match;
        return match;
      }
    }
    return this.map[tag.id] = this.all;
  }
  static combinedMatch(styles) {
    if (styles.length == 1)
      return styles[0].match;
    let cache = styles.some((s2) => s2.scope) ? void 0 : Object.create(null);
    return (tag, scope) => {
      let cached2 = cache && cache[tag.id];
      if (cached2 !== void 0)
        return cached2;
      let result = null;
      for (let style of styles) {
        let value = style.match(tag, scope);
        if (value)
          result = result ? result + " " + value : value;
      }
      if (cache)
        cache[tag.id] = result;
      return result;
    };
  }
  static define(specs, options2) {
    return new HighlightStyle(specs, options2 || {});
  }
  static get(state, tag, scope) {
    let style = getHighlightStyle(state);
    return style && style(tag, scope || NodeType.none);
  }
};
var TreeHighlighter = class {
  constructor(view) {
    this.markCache = Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlightStyle(view.state));
  }
  update(update) {
    let tree = syntaxTree(update.state), style = getHighlightStyle(update.state);
    let styleChange = style != update.startState.facet(highlightStyle);
    if (tree.length < update.view.viewport.to && !styleChange) {
      this.decorations = this.decorations.map(update.changes);
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, style);
    }
  }
  buildDeco(view, match) {
    if (!match || !this.tree.length)
      return Decoration.none;
    let builder = new RangeSetBuilder();
    for (let {from, to} of view.visibleRanges) {
      highlightTreeRange(this.tree, from, to, match, (from2, to2, style) => {
        builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({class: style})));
      });
    }
    return builder.finish();
  }
};
var treeHighlighter = /* @__PURE__ */ Prec.fallback(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v) => v.decorations
}));
var nodeStack = [""];
function highlightTreeRange(tree, from, to, style, span) {
  let spanStart = from, spanClass = "";
  let cursor = tree.topNode.cursor;
  function flush(at, newClass) {
    if (spanClass)
      span(spanStart, at, spanClass);
    spanStart = at;
    spanClass = newClass;
  }
  function node(inheritedClass, depth2, scope) {
    let {type, from: start, to: end} = cursor;
    if (start >= to || end <= from)
      return;
    nodeStack[depth2] = type.name;
    if (type.isTop)
      scope = type;
    let cls = inheritedClass;
    let rule = type.prop(ruleNodeProp), opaque = false;
    while (rule) {
      if (!rule.context || matchContext(rule.context, nodeStack, depth2)) {
        for (let tag of rule.tags) {
          let st = style(tag, scope);
          if (st) {
            if (cls)
              cls += " ";
            cls += st;
            if (rule.mode == 1)
              inheritedClass += (inheritedClass ? " " : "") + st;
            else if (rule.mode == 0)
              opaque = true;
          }
        }
        break;
      }
      rule = rule.next;
    }
    let upto = start;
    if (!opaque && cursor.firstChild()) {
      do {
        if (cursor.from > upto && spanClass != cls)
          flush(upto, cls);
        upto = cursor.to;
        node(inheritedClass, depth2 + 1, scope);
      } while (cursor.nextSibling());
      cursor.parent();
    }
    if (end > upto && spanClass != cls)
      flush(upto, cls);
  }
  node("", 0, tree.type);
  flush(to, "");
}
function matchContext(context, stack, depth2) {
  if (context.length > depth2 - 1)
    return false;
  for (let d = depth2 - 1, i = context.length - 1; i >= 0; i--, d--) {
    let check = context[i];
    if (check && check != stack[d])
      return false;
  }
  return true;
}
var t = Tag.define;
var comment = /* @__PURE__ */ t();
var name = /* @__PURE__ */ t();
var typeName = /* @__PURE__ */ t(name);
var literal = /* @__PURE__ */ t();
var string = /* @__PURE__ */ t(literal);
var number = /* @__PURE__ */ t(literal);
var content = /* @__PURE__ */ t();
var heading = /* @__PURE__ */ t(content);
var keyword = /* @__PURE__ */ t();
var operator = /* @__PURE__ */ t();
var punctuation = /* @__PURE__ */ t();
var bracket = /* @__PURE__ */ t(punctuation);
var meta = /* @__PURE__ */ t();
var tags = {
  comment,
  lineComment: /* @__PURE__ */ t(comment),
  blockComment: /* @__PURE__ */ t(comment),
  docComment: /* @__PURE__ */ t(comment),
  name,
  variableName: /* @__PURE__ */ t(name),
  typeName,
  tagName: /* @__PURE__ */ t(typeName),
  propertyName: /* @__PURE__ */ t(name),
  className: /* @__PURE__ */ t(name),
  labelName: /* @__PURE__ */ t(name),
  namespace: /* @__PURE__ */ t(name),
  macroName: /* @__PURE__ */ t(name),
  literal,
  string,
  docString: /* @__PURE__ */ t(string),
  character: /* @__PURE__ */ t(string),
  number,
  integer: /* @__PURE__ */ t(number),
  float: /* @__PURE__ */ t(number),
  bool: /* @__PURE__ */ t(literal),
  regexp: /* @__PURE__ */ t(literal),
  escape: /* @__PURE__ */ t(literal),
  color: /* @__PURE__ */ t(literal),
  url: /* @__PURE__ */ t(literal),
  keyword,
  self: /* @__PURE__ */ t(keyword),
  null: /* @__PURE__ */ t(keyword),
  atom: /* @__PURE__ */ t(keyword),
  unit: /* @__PURE__ */ t(keyword),
  modifier: /* @__PURE__ */ t(keyword),
  operatorKeyword: /* @__PURE__ */ t(keyword),
  controlKeyword: /* @__PURE__ */ t(keyword),
  definitionKeyword: /* @__PURE__ */ t(keyword),
  operator,
  derefOperator: /* @__PURE__ */ t(operator),
  arithmeticOperator: /* @__PURE__ */ t(operator),
  logicOperator: /* @__PURE__ */ t(operator),
  bitwiseOperator: /* @__PURE__ */ t(operator),
  compareOperator: /* @__PURE__ */ t(operator),
  updateOperator: /* @__PURE__ */ t(operator),
  definitionOperator: /* @__PURE__ */ t(operator),
  typeOperator: /* @__PURE__ */ t(operator),
  controlOperator: /* @__PURE__ */ t(operator),
  punctuation,
  separator: /* @__PURE__ */ t(punctuation),
  bracket,
  angleBracket: /* @__PURE__ */ t(bracket),
  squareBracket: /* @__PURE__ */ t(bracket),
  paren: /* @__PURE__ */ t(bracket),
  brace: /* @__PURE__ */ t(bracket),
  content,
  heading,
  heading1: /* @__PURE__ */ t(heading),
  heading2: /* @__PURE__ */ t(heading),
  heading3: /* @__PURE__ */ t(heading),
  heading4: /* @__PURE__ */ t(heading),
  heading5: /* @__PURE__ */ t(heading),
  heading6: /* @__PURE__ */ t(heading),
  contentSeparator: /* @__PURE__ */ t(content),
  list: /* @__PURE__ */ t(content),
  quote: /* @__PURE__ */ t(content),
  emphasis: /* @__PURE__ */ t(content),
  strong: /* @__PURE__ */ t(content),
  link: /* @__PURE__ */ t(content),
  monospace: /* @__PURE__ */ t(content),
  strikethrough: /* @__PURE__ */ t(content),
  inserted: /* @__PURE__ */ t(),
  deleted: /* @__PURE__ */ t(),
  changed: /* @__PURE__ */ t(),
  invalid: /* @__PURE__ */ t(),
  meta,
  documentMeta: /* @__PURE__ */ t(meta),
  annotation: /* @__PURE__ */ t(meta),
  processingInstruction: /* @__PURE__ */ t(meta),
  definition: /* @__PURE__ */ Tag.defineModifier(),
  constant: /* @__PURE__ */ Tag.defineModifier(),
  function: /* @__PURE__ */ Tag.defineModifier(),
  standard: /* @__PURE__ */ Tag.defineModifier(),
  local: /* @__PURE__ */ Tag.defineModifier(),
  special: /* @__PURE__ */ Tag.defineModifier()
};
var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
  {
    tag: tags.link,
    textDecoration: "underline"
  },
  {
    tag: tags.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags.strong,
    fontWeight: "bold"
  },
  {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags.keyword,
    color: "#708"
  },
  {
    tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
    color: "#219"
  },
  {
    tag: [tags.literal, tags.inserted],
    color: "#164"
  },
  {
    tag: [tags.string, tags.deleted],
    color: "#a11"
  },
  {
    tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ tags.local(tags.variableName),
    color: "#30a"
  },
  {
    tag: [tags.typeName, tags.namespace],
    color: "#085"
  },
  {
    tag: tags.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.propertyName),
    color: "#00c"
  },
  {
    tag: tags.comment,
    color: "#940"
  },
  {
    tag: tags.meta,
    color: "#7a757a"
  },
  {
    tag: tags.invalid,
    color: "#f00"
  }
]);
var classHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
  {tag: tags.link, class: "cmt-link"},
  {tag: tags.heading, class: "cmt-heading"},
  {tag: tags.emphasis, class: "cmt-emphasis"},
  {tag: tags.strong, class: "cmt-strong"},
  {tag: tags.keyword, class: "cmt-keyword"},
  {tag: tags.atom, class: "cmt-atom"},
  {tag: tags.bool, class: "cmt-bool"},
  {tag: tags.url, class: "cmt-url"},
  {tag: tags.labelName, class: "cmt-labelName"},
  {tag: tags.inserted, class: "cmt-inserted"},
  {tag: tags.deleted, class: "cmt-deleted"},
  {tag: tags.literal, class: "cmt-literal"},
  {tag: tags.string, class: "cmt-string"},
  {tag: tags.number, class: "cmt-number"},
  {tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)], class: "cmt-string2"},
  {tag: tags.variableName, class: "cmt-variableName"},
  {tag: /* @__PURE__ */ tags.local(tags.variableName), class: "cmt-variableName cmt-local"},
  {tag: /* @__PURE__ */ tags.definition(tags.variableName), class: "cmt-variableName cmt-definition"},
  {tag: /* @__PURE__ */ tags.special(tags.variableName), class: "cmt-variableName2"},
  {tag: tags.typeName, class: "cmt-typeName"},
  {tag: tags.namespace, class: "cmt-namespace"},
  {tag: tags.macroName, class: "cmt-macroName"},
  {tag: tags.propertyName, class: "cmt-propertyName"},
  {tag: tags.operator, class: "cmt-operator"},
  {tag: tags.comment, class: "cmt-comment"},
  {tag: tags.meta, class: "cmt-meta"},
  {tag: tags.invalid, class: "cmt-invalid"},
  {tag: tags.punctuation, class: "cmt-punctuation"}
]);

// node_modules/@codemirror/tooltip/dist/index.js
var ios = typeof navigator != "undefined" && !/Edge\/(\d+)/.exec(navigator.userAgent) && /Apple Computer/.test(navigator.vendor) && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
var Outside = "-10000px";
var tooltipPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.inView = true;
    this.measureReq = {read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this};
    this.input = view.state.facet(showTooltip);
    this.tooltips = this.input.filter((t2) => t2);
    this.tooltipViews = this.tooltips.map((tp) => this.createTooltip(tp));
  }
  update(update) {
    let input = update.state.facet(showTooltip);
    if (input == this.input) {
      for (let t2 of this.tooltipViews)
        if (t2.update)
          t2.update(update);
    } else {
      let tooltips = input.filter((x) => x);
      let views = [];
      for (let i = 0; i < tooltips.length; i++) {
        let tip = tooltips[i], known = -1;
        if (!tip)
          continue;
        for (let i2 = 0; i2 < this.tooltips.length; i2++) {
          let other = this.tooltips[i2];
          if (other && other.create == tip.create)
            known = i2;
        }
        if (known < 0) {
          views[i] = this.createTooltip(tip);
        } else {
          let tooltipView = views[i] = this.tooltipViews[known];
          if (tooltipView.update)
            tooltipView.update(update);
        }
      }
      for (let t2 of this.tooltipViews)
        if (views.indexOf(t2) < 0)
          t2.dom.remove();
      this.input = input;
      this.tooltips = tooltips;
      this.tooltipViews = views;
      this.maybeMeasure();
    }
  }
  createTooltip(tooltip) {
    let tooltipView = tooltip.create(this.view);
    tooltipView.dom.classList.add("cm-tooltip");
    if (tooltip.class)
      tooltipView.dom.classList.add(tooltip.class);
    tooltipView.dom.style.top = Outside;
    this.view.dom.appendChild(tooltipView.dom);
    if (tooltipView.mount)
      tooltipView.mount(this.view);
    return tooltipView;
  }
  destroy() {
    for (let {dom} of this.tooltipViews)
      dom.remove();
  }
  readMeasure() {
    return {
      editor: this.view.dom.getBoundingClientRect(),
      pos: this.tooltips.map((t2) => this.view.coordsAtPos(t2.pos)),
      size: this.tooltipViews.map(({dom}) => dom.getBoundingClientRect()),
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight
    };
  }
  writeMeasure(measured) {
    let {editor: editor2} = measured;
    for (let i = 0; i < this.tooltipViews.length; i++) {
      let tooltip = this.tooltips[i], tView = this.tooltipViews[i], {dom} = tView;
      let pos = measured.pos[i], size = measured.size[i];
      if (!pos || pos.bottom <= editor2.top || pos.top >= editor2.bottom || pos.right <= editor2.left || pos.left >= editor2.right) {
        dom.style.top = Outside;
        continue;
      }
      let width = size.right - size.left, height = size.bottom - size.top;
      let left = this.view.textDirection == Direction.LTR ? Math.min(pos.left, measured.innerWidth - width) : Math.max(0, pos.left - width);
      let above = !!tooltip.above;
      if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) < 0 : pos.bottom + (size.bottom - size.top) > measured.innerHeight))
        above = !above;
      if (ios) {
        dom.style.top = (above ? pos.top - height : pos.bottom) - editor2.top + "px";
        dom.style.left = left - editor2.left + "px";
        dom.style.position = "absolute";
      } else {
        dom.style.top = (above ? pos.top - height : pos.bottom) + "px";
        dom.style.left = left + "px";
      }
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned)
        tView.positioned();
    }
  }
  maybeMeasure() {
    if (this.tooltips.length) {
      if (this.view.inView || this.inView)
        this.view.requestMeasure(this.measureReq);
      this.inView = this.view.inView;
    }
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
var baseTheme2 = EditorView.baseTheme({
  ".cm-tooltip": {
    position: "fixed",
    zIndex: 100
  },
  "&light .cm-tooltip": {
    border: "1px solid #ddd",
    backgroundColor: "#f5f5f5"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  }
});
var showTooltip = Facet.define({
  enables: [tooltipPlugin, baseTheme2]
});
var HoverTime = 750;
var HoverMaxDist = 6;
var HoverPlugin = class {
  constructor(view, source, field, setHover) {
    this.view = view;
    this.source = source;
    this.field = field;
    this.setHover = setHover;
    this.lastMouseMove = null;
    this.hoverTimeout = -1;
    this.restartTimeout = -1;
    this.pending = null;
    this.checkHover = this.checkHover.bind(this);
    view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
    view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    if (this.pending) {
      this.pending = null;
      clearTimeout(this.restartTimeout);
      this.restartTimeout = setTimeout(() => this.startHover(), 20);
    }
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    this.hoverTimeout = -1;
    if (this.active)
      return;
    let now = Date.now(), lastMove = this.lastMouseMove;
    if (now - lastMove.timeStamp < HoverTime)
      this.hoverTimeout = setTimeout(this.checkHover, HoverTime - (now - lastMove.timeStamp));
    else
      this.startHover();
  }
  startHover() {
    var _a;
    clearTimeout(this.restartTimeout);
    let lastMove = this.lastMouseMove;
    let coords = {x: lastMove.clientX, y: lastMove.clientY};
    let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(coords) : null;
    if (pos == null)
      return;
    let posCoords = this.view.coordsAtPos(pos);
    if (posCoords == null || coords.y < posCoords.top || coords.y > posCoords.bottom || coords.x < posCoords.left - this.view.defaultCharacterWidth || coords.x > posCoords.right + this.view.defaultCharacterWidth)
      return;
    let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find((s2) => s2.from <= pos && s2.to >= pos);
    let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
    let open = this.source(this.view, pos, coords.x < posCoords.left ? -rtl : rtl);
    if ((_a = open) === null || _a === void 0 ? void 0 : _a.then) {
      let pending = this.pending = {pos};
      open.then((result) => {
        if (this.pending == pending) {
          this.pending = null;
          if (result)
            this.view.dispatch({effects: this.setHover.of(result)});
        }
      }, (e) => logException(this.view.state, e, "hover tooltip"));
    } else if (open) {
      this.view.dispatch({effects: this.setHover.of(open)});
    }
  }
  mousemove(event) {
    var _a;
    this.lastMouseMove = event;
    if (this.hoverTimeout < 0)
      this.hoverTimeout = setTimeout(this.checkHover, HoverTime);
    let tooltip = this.active;
    if (tooltip && !isInTooltip(event.target) || this.pending) {
      let {pos} = tooltip || this.pending, end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;
      if (pos == end ? this.view.posAtCoords({x: event.clientX, y: event.clientY}) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, HoverMaxDist)) {
        this.view.dispatch({effects: this.setHover.of(null)});
        this.pending = null;
      }
    }
  }
  mouseleave() {
    clearTimeout(this.hoverTimeout);
    this.hoverTimeout = -1;
    if (this.active)
      this.view.dispatch({effects: this.setHover.of(null)});
  }
  destroy() {
    clearTimeout(this.hoverTimeout);
    this.view.dom.removeEventListener("mouseleave", this.mouseleave);
    this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
};
function isInTooltip(elt) {
  for (let cur2 = elt; cur2; cur2 = cur2.parentNode)
    if (cur2.nodeType == 1 && cur2.classList.contains("cm-tooltip"))
      return true;
  return false;
}
function isOverRange(view, from, to, x, y, margin) {
  let range = document.createRange();
  let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);
  range.setEnd(toDOM.node, toDOM.offset);
  range.setStart(fromDOM.node, fromDOM.offset);
  let rects = range.getClientRects();
  range.detach();
  for (let i = 0; i < rects.length; i++) {
    let rect = rects[i];
    let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
    if (dist <= margin)
      return true;
  }
  return false;
}
function hoverTooltip(source, options2 = {}) {
  const setHover = StateEffect.define();
  const hoverState = StateField.define({
    create() {
      return null;
    },
    update(value, tr) {
      if (value && (options2.hideOnChange && (tr.docChanged || tr.selection)))
        return null;
      for (let effect of tr.effects)
        if (effect.is(setHover))
          return effect.value;
      if (value && tr.docChanged) {
        let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
        if (newPos == null)
          return null;
        let copy = Object.assign(Object.create(null), value);
        copy.pos = newPos;
        if (value.end != null)
          copy.end = tr.changes.mapPos(value.end);
        return copy;
      }
      return value;
    },
    provide: (f) => showTooltip.from(f)
  });
  return [
    hoverState,
    ViewPlugin.define((view) => new HoverPlugin(view, source, hoverState, setHover))
  ];
}

// node_modules/@codemirror/autocomplete/dist/index.js
var CompletionContext = class {
  constructor(state, pos, explicit) {
    this.state = state;
    this.pos = pos;
    this.explicit = explicit;
    this.abortListeners = [];
  }
  tokenBefore(types3) {
    let token = syntaxTree(this.state).resolve(this.pos, -1);
    while (token && types3.indexOf(token.name) < 0)
      token = token.parent;
    return token ? {
      from: token.from,
      to: this.pos,
      text: this.state.sliceDoc(token.from, this.pos),
      type: token.type
    } : null;
  }
  matchBefore(expr) {
    let line = this.state.doc.lineAt(this.pos);
    let start = Math.max(line.from, this.pos - 250);
    let str = line.text.slice(start - line.from, this.pos - line.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : {from: start + found, to: this.pos, text: str.slice(found)};
  }
  get aborted() {
    return this.abortListeners == null;
  }
  addEventListener(type, listener) {
    if (type == "abort" && this.abortListeners)
      this.abortListeners.push(listener);
  }
};
function toSet(chars2) {
  let flat = Object.keys(chars2).join("");
  let words = /\w/.test(flat);
  if (words)
    flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options2) {
  let first = Object.create(null), rest = Object.create(null);
  for (let {label} of options2) {
    first[label[0]] = true;
    for (let i = 1; i < label.length; i++)
      rest[label[i]] = true;
  }
  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
  let options2 = list.map((o) => typeof o == "string" ? {label: o} : o);
  let [span, match] = options2.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options2);
  return (context) => {
    let token = context.matchBefore(match);
    return token || context.explicit ? {from: token ? token.from : context.pos, options: options2, span} : null;
  };
}
function ifNotIn(nodes, source) {
  return (context) => {
    for (let pos = syntaxTree(context.state).resolve(context.pos, -1); pos; pos = pos.parent)
      if (nodes.indexOf(pos.name) > -1)
        return null;
    return source(context);
  };
}
var Option = class {
  constructor(completion, source, match) {
    this.completion = completion;
    this.source = source;
    this.match = match;
  }
};
function cur(state) {
  return state.selection.main.head;
}
function ensureAnchor(expr, start) {
  var _a;
  let {source} = expr;
  let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd)
    return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? "i" : "");
}
function applyCompletion(view, option) {
  let apply = option.completion.apply || option.completion.label;
  let result = option.source;
  if (typeof apply == "string") {
    view.dispatch({
      changes: {from: result.from, to: result.to, insert: apply},
      selection: {anchor: result.from + apply.length}
    });
  } else {
    apply(view, option.completion, result.from, result.to);
  }
}
var SourceCache = /* @__PURE__ */ new WeakMap();
function asSource(source) {
  if (!Array.isArray(source))
    return source;
  let known = SourceCache.get(source);
  if (!known)
    SourceCache.set(source, known = completeFromList(source));
  return known;
}
var FuzzyMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.chars = [];
    this.folded = [];
    this.any = [];
    this.precise = [];
    this.byWord = [];
    for (let p = 0; p < pattern.length; ) {
      let char = codePointAt(pattern, p), size = codePointSize(char);
      this.chars.push(char);
      let part = pattern.slice(p, p + size), upper = part.toUpperCase();
      this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
      p += size;
    }
    this.astral = pattern.length != this.chars.length;
  }
  match(word) {
    if (this.pattern.length == 0)
      return [0];
    if (word.length < this.pattern.length)
      return null;
    let {chars: chars2, folded, any, precise, byWord} = this;
    if (chars2.length == 1) {
      let first = codePointAt(word, 0);
      return first == chars2[0] ? [0, 0, codePointSize(first)] : first == folded[0] ? [-200, 0, codePointSize(first)] : null;
    }
    let direct = word.indexOf(this.pattern);
    if (direct == 0)
      return [0, 0, this.pattern.length];
    let len = chars2.length, anyTo = 0;
    if (direct < 0) {
      for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len; ) {
        let next = codePointAt(word, i);
        if (next == chars2[anyTo] || next == folded[anyTo])
          any[anyTo++] = i;
        i += codePointSize(next);
      }
      if (anyTo < len)
        return null;
    }
    let preciseTo = 0;
    let byWordTo = 0, byWordFolded = false;
    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word);
    for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len; ) {
      let next = codePointAt(word, i);
      if (direct < 0) {
        if (preciseTo < len && next == chars2[preciseTo])
          precise[preciseTo++] = i;
        if (adjacentTo < len) {
          if (next == chars2[adjacentTo] || next == folded[adjacentTo]) {
            if (adjacentTo == 0)
              adjacentStart = i;
            adjacentEnd = i;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }
      let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
      if ((type == 1 && hasLower || prevType == 0 && type != 0) && (chars2[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true)))
        byWord[byWordTo++] = i;
      prevType = type;
      i += codePointSize(next);
    }
    if (byWordTo == len && byWord[0] == 0)
      return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0)
      return [-200, 0, adjacentEnd];
    if (direct > -1)
      return [-700, direct, direct + this.pattern.length];
    if (adjacentTo == len)
      return [-200 + -700, adjacentStart, adjacentEnd];
    if (byWordTo == len)
      return this.result(-100 + (byWordFolded ? -200 : 0) + -700, byWord, word);
    return chars2.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
  }
  result(score2, positions, word) {
    let result = [score2], i = 1;
    for (let pos of positions) {
      let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
      if (i > 1 && result[i - 1] == pos)
        result[i - 1] = to;
      else {
        result[i++] = pos;
        result[i++] = to;
      }
    }
    return result;
  }
};
var completionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      activateOnTyping: true,
      override: null,
      maxRenderedOptions: 100,
      defaultKeymap: true
    }, {
      defaultKeymap: (a, b) => a && b
    });
  }
});
var MaxInfoWidth = 300;
var baseTheme3 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      maxHeight: "10em",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li": {
        cursor: "pointer",
        padding: "1px 1em 1px 3px",
        lineHeight: 1.2
      },
      "& > li[aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      }
    }
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"\xB7\xB7\xB7"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: MaxInfoWidth + "px"
  },
  ".cm-completionInfo.cm-completionInfo-left": {right: "100%"},
  ".cm-completionInfo.cm-completionInfo-right": {left: "100%"},
  "&light .cm-snippetField": {backgroundColor: "#00000022"},
  "&dark .cm-snippetField": {backgroundColor: "#ffffff22"},
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": {content: "'\u0192'"}
  },
  ".cm-completionIcon-class": {
    "&:after": {content: "'\u25CB'"}
  },
  ".cm-completionIcon-interface": {
    "&:after": {content: "'\u25CC'"}
  },
  ".cm-completionIcon-variable": {
    "&:after": {content: "'\u{1D465}'"}
  },
  ".cm-completionIcon-constant": {
    "&:after": {content: "'\u{1D436}'"}
  },
  ".cm-completionIcon-type": {
    "&:after": {content: "'\u{1D461}'"}
  },
  ".cm-completionIcon-enum": {
    "&:after": {content: "'\u222A'"}
  },
  ".cm-completionIcon-property": {
    "&:after": {content: "'\u25A1'"}
  },
  ".cm-completionIcon-keyword": {
    "&:after": {content: "'\u{1F511}\uFE0E'"}
  },
  ".cm-completionIcon-namespace": {
    "&:after": {content: "'\u25A2'"}
  },
  ".cm-completionIcon-text": {
    "&:after": {content: "'abc'", fontSize: "50%", verticalAlign: "middle"}
  }
});
function createListBox(options2, id, range) {
  const ul = document.createElement("ul");
  ul.id = id;
  ul.setAttribute("role", "listbox");
  ul.setAttribute("aria-expanded", "true");
  for (let i = range.from; i < range.to; i++) {
    let {completion, match} = options2[i];
    const li = ul.appendChild(document.createElement("li"));
    li.id = id + "-" + i;
    let icon = li.appendChild(document.createElement("div"));
    icon.classList.add("cm-completionIcon");
    if (completion.type)
      icon.classList.add("cm-completionIcon-" + completion.type);
    icon.setAttribute("aria-hidden", "true");
    let labelElt = li.appendChild(document.createElement("span"));
    labelElt.className = "cm-completionLabel";
    let {label, detail} = completion, off = 0;
    for (let j = 1; j < match.length; ) {
      let from = match[j++], to = match[j++];
      if (from > off)
        labelElt.appendChild(document.createTextNode(label.slice(off, from)));
      let span = labelElt.appendChild(document.createElement("span"));
      span.appendChild(document.createTextNode(label.slice(from, to)));
      span.className = "cm-completionMatchedText";
      off = to;
    }
    if (off < label.length)
      labelElt.appendChild(document.createTextNode(label.slice(off)));
    if (detail) {
      let detailElt = li.appendChild(document.createElement("span"));
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = detail;
    }
    li.setAttribute("role", "option");
  }
  if (range.from)
    ul.classList.add("cm-completionListIncompleteTop");
  if (range.to < options2.length)
    ul.classList.add("cm-completionListIncompleteBottom");
  return ul;
}
function createInfoDialog(option, view) {
  let dom = document.createElement("div");
  dom.className = "cm-tooltip cm-completionInfo";
  let {info} = option.completion;
  if (typeof info == "string") {
    dom.textContent = info;
  } else {
    let content2 = info(option.completion);
    if (content2.then)
      content2.then((node) => dom.appendChild(node), (e) => logException(view.state, e, "completion info"));
    else
      dom.appendChild(content2);
  }
  return dom;
}
function rangeAroundSelected(total, selected, max) {
  if (total <= max)
    return {from: 0, to: total};
  if (selected <= total >> 1) {
    let off2 = Math.floor(selected / max);
    return {from: off2 * max, to: (off2 + 1) * max};
  }
  let off = Math.floor((total - selected) / max);
  return {from: total - (off + 1) * max, to: total - off * max};
}
var CompletionTooltip = class {
  constructor(view, stateField) {
    this.view = view;
    this.stateField = stateField;
    this.info = null;
    this.placeInfo = {
      read: () => this.measureInfo(),
      write: (pos) => this.positionInfo(pos),
      key: this
    };
    let cState = view.state.field(stateField);
    let {options: options2, selected} = cState.open;
    let config2 = view.state.facet(completionConfig);
    this.range = rangeAroundSelected(options2.length, selected, config2.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.dom.addEventListener("mousedown", (e) => {
      for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
        if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options2.length) {
          applyCompletion(view, options2[+match[1]]);
          e.preventDefault();
          return;
        }
      }
    });
    this.list = this.dom.appendChild(createListBox(options2, cState.id, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info)
        this.view.requestMeasure(this.placeInfo);
    });
  }
  mount() {
    this.updateSel();
  }
  update(update) {
    if (update.state.field(this.stateField) != update.startState.field(this.stateField))
      this.updateSel();
  }
  positioned() {
    if (this.info)
      this.view.requestMeasure(this.placeInfo);
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField), open = cState.open;
    if (open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.list.remove();
      this.list = this.dom.appendChild(createListBox(open.options, cState.id, this.range));
      this.list.addEventListener("scroll", () => {
        if (this.info)
          this.view.requestMeasure(this.placeInfo);
      });
    }
    if (this.updateSelectedOption(open.selected)) {
      if (this.info) {
        this.info.remove();
        this.info = null;
      }
      let option = open.options[open.selected];
      if (option.completion.info) {
        this.info = this.dom.appendChild(createInfoDialog(option, this.view));
        this.view.requestMeasure(this.placeInfo);
      }
    }
  }
  updateSelectedOption(selected) {
    let set = null;
    for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
      if (i == selected) {
        if (!opt.hasAttribute("aria-selected")) {
          opt.setAttribute("aria-selected", "true");
          set = opt;
        }
      } else {
        if (opt.hasAttribute("aria-selected"))
          opt.removeAttribute("aria-selected");
      }
    }
    if (set)
      scrollIntoView(this.list, set);
    return set;
  }
  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel)
      return null;
    let rect = this.dom.getBoundingClientRect();
    let top2 = sel.getBoundingClientRect().top - rect.top;
    if (top2 < 0 || top2 > this.list.clientHeight - 10)
      return null;
    let left = this.view.textDirection == Direction.RTL;
    let spaceLeft = rect.left, spaceRight = innerWidth - rect.right;
    if (left && spaceLeft < Math.min(MaxInfoWidth, spaceRight))
      left = false;
    else if (!left && spaceRight < Math.min(MaxInfoWidth, spaceLeft))
      left = true;
    return {top: top2, left};
  }
  positionInfo(pos) {
    if (this.info && pos) {
      this.info.style.top = pos.top + "px";
      this.info.classList.toggle("cm-completionInfo-left", pos.left);
      this.info.classList.toggle("cm-completionInfo-right", !pos.left);
    }
  }
};
function completionTooltip(stateField) {
  return (view) => new CompletionTooltip(view, stateField);
}
function scrollIntoView(container, element) {
  let parent = container.getBoundingClientRect();
  let self2 = element.getBoundingClientRect();
  if (self2.top < parent.top)
    container.scrollTop -= parent.top - self2.top;
  else if (self2.bottom > parent.bottom)
    container.scrollTop += self2.bottom - parent.bottom;
}
var MaxOptions = 300;
function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state) {
  let options2 = [];
  for (let a of active)
    if (a.hasResult()) {
      let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)), match;
      for (let option of a.result.options)
        if (match = matcher.match(option.label)) {
          if (option.boost != null)
            match[0] += option.boost;
          options2.push(new Option(option, a, match));
        }
    }
  options2.sort(cmpOption);
  let result = [], prev = null;
  for (let opt of options2.sort(cmpOption)) {
    if (result.length == MaxOptions)
      break;
    if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail)
      result.push(opt);
    else if (score(opt.completion) > score(prev))
      result[result.length - 1] = opt;
    prev = opt.completion;
  }
  return result;
}
var CompletionDialog = class {
  constructor(options2, attrs, tooltip, timestamp, selected) {
    this.options = options2;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
  }
  setSelected(selected, id) {
    return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected);
  }
  static build(active, state, id, prev) {
    let options2 = sortOptions(active, state);
    if (!options2.length)
      return null;
    let selected = 0;
    if (prev && prev.selected) {
      let selectedValue = prev.options[prev.selected].completion;
      for (let i = 0; i < options2.length && !selected; i++) {
        if (options2[i].completion == selectedValue)
          selected = i;
      }
    }
    return new CompletionDialog(options2, makeAttrs(id, selected), {
      pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
      create: completionTooltip(completionState)
    }, prev ? prev.timestamp : Date.now(), selected);
  }
  map(changes) {
    return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {pos: changes.mapPos(this.tooltip.pos)}), this.timestamp, this.selected);
  }
};
var CompletionState = class {
  constructor(active, id, open) {
    this.active = active;
    this.id = id;
    this.open = open;
  }
  static start() {
    return new CompletionState(none3, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(tr) {
    let {state} = tr, conf = state.facet(completionConfig);
    let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
    let active = sources.map((source) => {
      let value = this.active.find((s2) => s2.source == source) || new ActiveSource(source, 0, false);
      return value.update(tr, conf);
    });
    if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
      active = this.active;
    let open = tr.selection || active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) ? CompletionDialog.build(active, state, this.id, this.open) : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;
    if (!open && active.every((a) => a.state != 1) && active.some((a) => a.hasResult()))
      active = active.map((a) => a.hasResult() ? new ActiveSource(a.source, 0, false) : a);
    for (let effect of tr.effects)
      if (effect.is(setSelectedEffect))
        open = open && open.setSelected(effect.value, this.id);
    return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : baseAttrs;
  }
};
function sameResults(a, b) {
  if (a == b)
    return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a.length && !a[iA].hasResult)
      iA++;
    while (iB < b.length && !b[iB].hasResult)
      iB++;
    let endA = iA == a.length, endB = iB == b.length;
    if (endA || endB)
      return endA == endB;
    if (a[iA++].result != b[iB++].result)
      return false;
  }
}
function makeAttrs(id, selected) {
  return {
    "aria-autocomplete": "list",
    "aria-activedescendant": id + "-" + selected,
    "aria-owns": id
  };
}
var baseAttrs = {"aria-autocomplete": "list"};
var none3 = [];
function cmpOption(a, b) {
  let dScore = b.match[0] - a.match[0];
  if (dScore)
    return dScore;
  let lA = a.completion.label, lB = b.completion.label;
  return lA < lB ? -1 : lA == lB ? 0 : 1;
}
var ActiveSource = class {
  constructor(source, state, explicit) {
    this.source = source;
    this.state = state;
    this.explicit = explicit;
  }
  hasResult() {
    return false;
  }
  update(tr, conf) {
    let event = tr.annotation(Transaction.userEvent), value = this;
    if (event == "input" || event == "delete")
      value = value.handleUserEvent(tr, event, conf);
    else if (tr.docChanged)
      value = value.handleChange(tr);
    else if (tr.selection && value.state != 0)
      value = new ActiveSource(value.source, 0, false);
    for (let effect of tr.effects) {
      if (effect.is(startCompletionEffect))
        value = new ActiveSource(value.source, 1, effect.value);
      else if (effect.is(closeCompletionEffect))
        value = new ActiveSource(value.source, 0, false);
      else if (effect.is(setActiveEffect)) {
        for (let active of effect.value)
          if (active.source == value.source)
            value = active;
      }
    }
    return value;
  }
  handleUserEvent(_tr, type, conf) {
    return type == "delete" || !conf.activateOnTyping ? this : new ActiveSource(this.source, 1, false);
  }
  handleChange(tr) {
    return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0, false) : this;
  }
};
var ActiveResult = class extends ActiveSource {
  constructor(source, explicit, result, from, to, span) {
    super(source, 2, explicit);
    this.result = result;
    this.from = from;
    this.to = to;
    this.span = span;
  }
  hasResult() {
    return true;
  }
  handleUserEvent(tr, type, conf) {
    let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
    let pos = cur(tr.state);
    if ((this.explicit ? pos < from : pos <= from) || pos > to)
      return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? 1 : 0, false);
    if (this.span && (from == to || this.span.test(tr.state.sliceDoc(from, to))))
      return new ActiveResult(this.source, this.explicit, this.result, from, to, this.span);
    return new ActiveSource(this.source, 1, this.explicit);
  }
  handleChange(tr) {
    return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0, false) : new ActiveResult(this.source, this.explicit, this.result, tr.changes.mapPos(this.from), tr.changes.mapPos(this.to, 1), this.span);
  }
  map(mapping) {
    return new ActiveResult(this.source, this.explicit, this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1), this.span);
  }
};
var startCompletionEffect = /* @__PURE__ */ StateEffect.define();
var closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
var setActiveEffect = /* @__PURE__ */ StateEffect.define({
  map(sources, mapping) {
    return sources.map((s2) => s2.hasResult() && !mapping.empty ? s2.map(mapping) : s2);
  }
});
var setSelectedEffect = /* @__PURE__ */ StateEffect.define();
var completionState = /* @__PURE__ */ StateField.define({
  create() {
    return CompletionState.start();
  },
  update(value, tr) {
    return value.update(tr);
  },
  provide: (f) => [
    showTooltip.from(f, (val) => val.tooltip),
    EditorView.contentAttributes.from(f, (state) => state.attrs)
  ]
});
var CompletionInteractMargin = 75;
function moveCompletionSelection(forward, by = "option") {
  return (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)
      return false;
    let step = 1, tooltip;
    if (by == "page" && (tooltip = view.dom.querySelector(".cm-tooltip-autocomplete")))
      step = Math.max(2, Math.floor(tooltip.offsetHeight / tooltip.firstChild.offsetHeight));
    let selected = cState.open.selected + step * (forward ? 1 : -1), {length} = cState.open.options;
    if (selected < 0)
      selected = by == "page" ? 0 : length - 1;
    else if (selected >= length)
      selected = by == "page" ? length - 1 : 0;
    view.dispatch({effects: setSelectedEffect.of(selected)});
    return true;
  };
}
var acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)
    return false;
  applyCompletion(view, cState.open.options[cState.open.selected]);
  return true;
};
var startCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState)
    return false;
  view.dispatch({effects: startCompletionEffect.of(true)});
  return true;
};
var closeCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some((a) => a.state != 0))
    return false;
  view.dispatch({effects: closeCompletionEffect.of(null)});
  return true;
};
var RunningQuery = class {
  constructor(source, context) {
    this.source = source;
    this.context = context;
    this.time = Date.now();
    this.updates = [];
    this.done = void 0;
  }
};
var DebounceTime = 50;
var MaxUpdateCount = 50;
var MinAbortTime = 1e3;
var completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.debounceUpdate = -1;
    this.running = [];
    this.debounceAccept = -1;
    this.composing = 0;
    for (let active of view.state.field(completionState).active)
      if (active.state == 1)
        this.startQuery(active);
  }
  update(update) {
    let cState = update.state.field(completionState);
    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
      return;
    let doesReset = update.transactions.some((tr) => {
      let event = tr.annotation(Transaction.userEvent);
      return (tr.selection || tr.docChanged) && event != "input" && event != "delete";
    });
    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];
      if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && query.time - Date.now() > MinAbortTime) {
        for (let handler of query.context.abortListeners) {
          try {
            handler();
          } catch (e) {
            logException(this.view.state, e);
          }
        }
        query.context.abortListeners = null;
        this.running.splice(i--, 1);
      } else {
        query.updates.push(...update.transactions);
      }
    }
    if (this.debounceUpdate > -1)
      clearTimeout(this.debounceUpdate);
    this.debounceUpdate = cState.active.some((a) => a.state == 1 && !this.running.some((q) => q.source == a.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
    if (this.composing != 0)
      for (let tr of update.transactions) {
        if (tr.annotation(Transaction.userEvent) == "input")
          this.composing = 2;
        else if (this.composing == 2 && tr.selection)
          this.composing = 3;
      }
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let {state} = this.view, cState = state.field(completionState);
    for (let active of cState.active) {
      if (active.state == 1 && !this.running.some((r) => r.source == active.source))
        this.startQuery(active);
    }
  }
  startQuery(active) {
    let {state} = this.view, pos = cur(state);
    let context = new CompletionContext(state, pos, active.explicit);
    let pending = new RunningQuery(active.source, context);
    this.running.push(pending);
    Promise.resolve(active.source(context)).then((result) => {
      if (!pending.context.aborted) {
        pending.done = result || null;
        this.scheduleAccept();
      }
    }, (err) => {
      this.view.dispatch({effects: closeCompletionEffect.of(null)});
      logException(this.view.state, err);
    });
  }
  scheduleAccept() {
    if (this.running.every((q) => q.done !== void 0))
      this.accept();
    else if (this.debounceAccept < 0)
      this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
  }
  accept() {
    var _a;
    if (this.debounceAccept > -1)
      clearTimeout(this.debounceAccept);
    this.debounceAccept = -1;
    let updated = [];
    let conf = this.view.state.facet(completionConfig);
    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];
      if (query.done === void 0)
        continue;
      this.running.splice(i--, 1);
      if (query.done) {
        let active = new ActiveResult(query.source, query.context.explicit, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state), query.done.span ? ensureAnchor(query.done.span, true) : null);
        for (let tr of query.updates)
          active = active.update(tr, conf);
        if (active.hasResult()) {
          updated.push(active);
          continue;
        }
      }
      let current = this.view.state.field(completionState).active.find((a) => a.source == query.source);
      if (current && current.state == 1) {
        if (query.done == null) {
          let active = new ActiveSource(query.source, 0, false);
          for (let tr of query.updates)
            active = active.update(tr, conf);
          if (active.state != 1)
            updated.push(active);
        } else {
          this.startQuery(current);
        }
      }
    }
    if (updated.length)
      this.view.dispatch({effects: setActiveEffect.of(updated)});
  }
}, {
  eventHandlers: {
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      if (this.composing == 3) {
        setTimeout(() => this.view.dispatch({effects: startCompletionEffect.of(false)}), 20);
      }
      this.composing = 0;
    }
  }
});
var FieldPos = class {
  constructor(field, line, from, to) {
    this.field = field;
    this.line = line;
    this.from = from;
    this.to = to;
  }
};
var FieldRange = class {
  constructor(field, from, to) {
    this.field = field;
    this.from = from;
    this.to = to;
  }
  map(changes) {
    return new FieldRange(this.field, changes.mapPos(this.from, -1), changes.mapPos(this.to, 1));
  }
};
var Snippet = class {
  constructor(lines, fieldPositions) {
    this.lines = lines;
    this.fieldPositions = fieldPositions;
  }
  instantiate(state, pos) {
    let text = [], lineStart = [pos];
    let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
    for (let line of this.lines) {
      if (text.length) {
        let indent = baseIndent, tabs = /^\t*/.exec(line)[0].length;
        for (let i = 0; i < tabs; i++)
          indent += state.facet(indentUnit);
        lineStart.push(pos + indent.length - tabs);
        line = indent + line.slice(tabs);
      }
      text.push(line);
      pos += line.length + 1;
    }
    let ranges = this.fieldPositions.map((pos2) => new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to));
    return {text, ranges};
  }
  static parse(template3) {
    let fields = [];
    let lines = [], positions = [], m;
    for (let line of template3.split(/\r\n?|\n/)) {
      while (m = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line)) {
        let seq = m[1] ? +m[1] : null, name2 = m[2] || m[3], found = -1;
        for (let i = 0; i < fields.length; i++) {
          if (seq != null ? fields[i].seq == seq : name2 ? fields[i].name == name2 : false)
            found = i;
        }
        if (found < 0) {
          let i = 0;
          while (i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq))
            i++;
          fields.splice(i, 0, {seq, name: name2 || null});
          found = i;
          for (let pos of positions)
            if (pos.field >= found)
              pos.field++;
        }
        positions.push(new FieldPos(found, lines.length, m.index, m.index + name2.length));
        line = line.slice(0, m.index) + name2 + line.slice(m.index + m[0].length);
      }
      lines.push(line);
    }
    return new Snippet(lines, positions);
  }
};
var fieldMarker = /* @__PURE__ */ Decoration.widget({widget: /* @__PURE__ */ new class extends WidgetType {
  toDOM() {
    let span = document.createElement("span");
    span.className = "cm-snippetFieldPosition";
    return span;
  }
  ignoreEvent() {
    return false;
  }
}()});
var fieldRange = /* @__PURE__ */ Decoration.mark({class: "cm-snippetField"});
var ActiveSnippet = class {
  constructor(ranges, active) {
    this.ranges = ranges;
    this.active = active;
    this.deco = Decoration.set(ranges.map((r) => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
  }
  map(changes) {
    return new ActiveSnippet(this.ranges.map((r) => r.map(changes)), this.active);
  }
  selectionInsideField(sel) {
    return sel.ranges.every((range) => this.ranges.some((r) => r.field == this.active && r.from <= range.from && r.to >= range.to));
  }
};
var setActive = /* @__PURE__ */ StateEffect.define({
  map(value, changes) {
    return value && value.map(changes);
  }
});
var moveToField = /* @__PURE__ */ StateEffect.define();
var snippetState = /* @__PURE__ */ StateField.define({
  create() {
    return null;
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setActive))
        return effect.value;
      if (effect.is(moveToField) && value)
        return new ActiveSnippet(value.ranges, effect.value);
    }
    if (value && tr.docChanged)
      value = value.map(tr.changes);
    if (value && tr.selection && !value.selectionInsideField(tr.selection))
      value = null;
    return value;
  },
  provide: (f) => EditorView.decorations.from(f, (val) => val ? val.deco : Decoration.none)
});
function fieldSelection(ranges, field) {
  return EditorSelection.create(ranges.filter((r) => r.field == field).map((r) => EditorSelection.range(r.from, r.to)));
}
function snippet(template3) {
  let snippet2 = Snippet.parse(template3);
  return (editor2, _completion, from, to) => {
    let {text, ranges} = snippet2.instantiate(editor2.state, from);
    let spec = {changes: {from, to, insert: Text.of(text)}};
    if (ranges.length)
      spec.selection = fieldSelection(ranges, 0);
    if (ranges.length > 1) {
      let active = new ActiveSnippet(ranges, 0);
      let effects = spec.effects = [setActive.of(active)];
      if (editor2.state.field(snippetState, false) === void 0)
        effects.push(StateEffect.appendConfig.of([
          snippetState.init(() => active),
          addSnippetKeymap,
          snippetPointerHandler,
          baseTheme3
        ]));
    }
    editor2.dispatch(editor2.state.update(spec));
  };
}
function moveField(dir) {
  return ({state, dispatch}) => {
    let active = state.field(snippetState, false);
    if (!active || dir < 0 && active.active == 0)
      return false;
    let next = active.active + dir, last = dir > 0 && !active.ranges.some((r) => r.field == next + dir);
    dispatch(state.update({
      selection: fieldSelection(active.ranges, next),
      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))
    }));
    return true;
  };
}
var clearSnippet = ({state, dispatch}) => {
  let active = state.field(snippetState, false);
  if (!active)
    return false;
  dispatch(state.update({effects: setActive.of(null)}));
  return true;
};
var nextSnippetField = /* @__PURE__ */ moveField(1);
var prevSnippetField = /* @__PURE__ */ moveField(-1);
var defaultSnippetKeymap = [
  {key: "Tab", run: nextSnippetField, shift: prevSnippetField},
  {key: "Escape", run: clearSnippet}
];
var snippetKeymap = /* @__PURE__ */ Facet.define({
  combine(maps) {
    return maps.length ? maps[0] : defaultSnippetKeymap;
  }
});
var addSnippetKeymap = /* @__PURE__ */ Prec.override(/* @__PURE__ */ keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap)));
function snippetCompletion(template3, completion) {
  return Object.assign(Object.assign({}, completion), {apply: snippet(template3)});
}
var snippetPointerHandler = /* @__PURE__ */ EditorView.domEventHandlers({
  mousedown(event, view) {
    let active = view.state.field(snippetState, false), pos;
    if (!active || (pos = view.posAtCoords({x: event.clientX, y: event.clientY})) == null)
      return false;
    let match = active.ranges.find((r) => r.from <= pos && r.to >= pos);
    if (!match || match.field == active.active)
      return false;
    view.dispatch({
      selection: fieldSelection(active.ranges, match.field),
      effects: setActive.of(active.ranges.some((r) => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)
    });
    return true;
  }
});
function autocompletion(config2 = {}) {
  return [
    completionState,
    completionConfig.of(config2),
    completionPlugin,
    completionKeymapExt,
    baseTheme3
  ];
}
var completionKeymap = [
  {key: "Ctrl-Space", run: startCompletion},
  {key: "Escape", run: closeCompletion},
  {key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true)},
  {key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false)},
  {key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page")},
  {key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page")},
  {key: "Enter", run: acceptCompletion}
];
var completionKeymapExt = /* @__PURE__ */ Prec.override(/* @__PURE__ */ keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

// node_modules/@codemirror/lang-javascript/dist/index.js
var snippets = [
  snippetCompletion("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  snippetCompletion("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  snippetCompletion("try {\n	${}\n} catch (${error}) {\n	${}\n}", {
    label: "try",
    detail: "block",
    type: "keyword"
  }),
  snippetCompletion("class ${name} {\n	constructor(${params}) {\n		${}\n	}\n}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  snippetCompletion('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  snippetCompletion('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
];
var javascriptLanguage = LezerLanguage.define({
  parser: parser.configure({
    props: [
      indentNodeProp.add({
        IfStatement: continuedIndent({except: /^\s*({|else\b)/}),
        TryStatement: continuedIndent({except: /^\s*({|catch|finally)\b/}),
        LabeledStatement: flatIndent,
        SwitchBody: (context) => {
          let after = context.textAfter, closed = /^\s*\}/.test(after), isCase = /^\s*(case|default)\b/.test(after);
          return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
        },
        Block: delimitedIndent({closing: "}"}),
        ArrowFunction: (cx) => cx.baseIndent + cx.unit,
        "TemplateString BlockComment": () => -1,
        "Statement Property": continuedIndent({except: /^{/}),
        JSXElement(context) {
          let closed = /^\s*<\//.test(context.textAfter);
          return context.lineIndent(context.state.doc.lineAt(context.node.from)) + (closed ? 0 : context.unit);
        },
        JSXEscape(context) {
          let closed = /\s*\}/.test(context.textAfter);
          return context.lineIndent(context.state.doc.lineAt(context.node.from)) + (closed ? 0 : context.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(context) {
          return context.column(context.node.from) + context.unit;
        }
      }),
      foldNodeProp.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": foldInside,
        BlockComment(tree) {
          return {from: tree.from + 2, to: tree.to - 2};
        }
      }),
      styleTags({
        "get set async static": tags.modifier,
        "for while do if else switch try catch finally return throw break continue default case": tags.controlKeyword,
        "in of await yield void typeof delete instanceof": tags.operatorKeyword,
        "export import let var const function class extends": tags.definitionKeyword,
        "with debugger from as new": tags.keyword,
        TemplateString: tags.special(tags.string),
        Super: tags.atom,
        BooleanLiteral: tags.bool,
        this: tags.self,
        null: tags.null,
        Star: tags.modifier,
        VariableName: tags.variableName,
        "CallExpression/VariableName": tags.function(tags.variableName),
        VariableDefinition: tags.definition(tags.variableName),
        Label: tags.labelName,
        PropertyName: tags.propertyName,
        "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
        "FunctionDeclaration/VariableDefinition": tags.function(tags.definition(tags.variableName)),
        "ClassDeclaration/VariableDefinition": tags.definition(tags.className),
        PropertyNameDefinition: tags.definition(tags.propertyName),
        UpdateOp: tags.updateOperator,
        LineComment: tags.lineComment,
        BlockComment: tags.blockComment,
        Number: tags.number,
        String: tags.string,
        ArithOp: tags.arithmeticOperator,
        LogicOp: tags.logicOperator,
        BitOp: tags.bitwiseOperator,
        CompareOp: tags.compareOperator,
        RegExp: tags.regexp,
        Equals: tags.definitionOperator,
        "Arrow : Spread": tags.punctuation,
        "( )": tags.paren,
        "[ ]": tags.squareBracket,
        "{ }": tags.brace,
        ".": tags.derefOperator,
        ", ;": tags.separator,
        TypeName: tags.typeName,
        TypeDefinition: tags.definition(tags.typeName),
        "type enum interface implements namespace module declare": tags.definitionKeyword,
        "abstract global privacy readonly": tags.modifier,
        "is keyof unique infer": tags.operatorKeyword,
        JSXAttributeValue: tags.string,
        JSXText: tags.content,
        "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": tags.angleBracket,
        "JSXIdentifier JSXNameSpacedName": tags.tagName,
        "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": tags.propertyName
      })
    ]
  }),
  languageData: {
    closeBrackets: {brackets: ["(", "[", "{", "'", '"', "`"]},
    commentTokens: {line: "//", block: {open: "/*", close: "*/"}},
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
});
var typescriptLanguage = javascriptLanguage.configure({dialect: "ts"});
var jsxLanguage = javascriptLanguage.configure({dialect: "jsx"});
var tsxLanguage = javascriptLanguage.configure({dialect: "jsx ts"});
function javascript(config2 = {}) {
  let lang = config2.jsx ? config2.typescript ? tsxLanguage : jsxLanguage : config2.typescript ? typescriptLanguage : javascriptLanguage;
  return new LanguageSupport(lang, javascriptLanguage.data.of({
    autocomplete: ifNotIn(["LineComment", "BlockComment", "String"], completeFromList(snippets))
  }));
}

// node_modules/@codemirror/history/dist/index.js
var fromHistory = Annotation.define();
var isolateHistory = Annotation.define();
var invertedEffects = Facet.define();
var historyConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500
    }, {minDepth: Math.max, newGroupDelay: Math.min});
  }
});
var historyField_ = StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr) {
    let config2 = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);
    if (fromHist) {
      let item = HistEvent.fromTransaction(tr), from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config2.minDepth, item);
      else
        other = addSelection(other, tr.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr.annotation(Transaction.addToHistory) === false)
      return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr);
    let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
    if (event)
      state = state.addChanges(event, time, userEvent, config2.newGroupDelay, config2.minDepth);
    else if (tr.selection)
      state = state.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value) {
    return {done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON())};
  },
  fromJSON(json) {
    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
  }
});
function history(config2 = {}) {
  return [
    historyField_,
    historyConfig.of(config2),
    EditorView.domEventHandlers({
      beforeinput(e, view) {
        if (e.inputType == "historyUndo")
          return undo(view);
        if (e.inputType == "historyRedo")
          return redo(view);
        return false;
      }
    })
  ];
}
function cmd(side, selection) {
  return function({state, dispatch}) {
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr = historyState.pop(side, state, selection);
    if (!tr)
      return false;
    dispatch(tr);
    return true;
  };
}
var undo = cmd(0, false);
var redo = cmd(1, false);
var undoSelection = cmd(0, true);
var redoSelection = cmd(1, true);
function depth(side) {
  return function(state) {
    let histState = state.field(historyField_, false);
    if (!histState)
      return 0;
    let branch = side == 0 ? histState.done : histState.undone;
    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
  };
}
var undoDepth = depth(0);
var redoDepth = depth(1);
var HistEvent = class {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a, _b, _c;
    return {
      changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s2) => s2.toJSON())
    };
  }
  static fromJSON(json) {
    return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
  }
  static fromTransaction(tr) {
    let effects = none4;
    for (let invert of tr.startState.facet(invertedEffects)) {
      let result = invert(tr);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr.changes.empty)
      return null;
    return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, tr.startState.selection, none4);
  }
  static selection(selections) {
    return new HistEvent(void 0, none4, void 0, void 0, selections);
  }
};
function updateBranch(branch, to, maxLen, newEvent) {
  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a, b) {
  let ranges = [], isAdjacent2 = false;
  a.iterChangedRanges((f, t2) => ranges.push(f, t2));
  b.iterChangedRanges((_f, _t, f, t2) => {
    for (let i = 0; i < ranges.length; ) {
      let from = ranges[i++], to = ranges[i++];
      if (t2 >= from && f <= to)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a, b) {
  return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a, b) {
  return !a.length ? b : !b.length ? a : a.concat(b);
}
var none4 = [];
var MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
  if (!branch.length) {
    return [HistEvent.selection([selection])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection))
      return branch;
    sels.push(selection);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length = branch.length, selections = none4;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none4;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s2) => s2.map(mapping)) : none4, extraSelections);
  if (!event.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
var HistoryState = class {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, newGroupDelay, maxLen) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && time - this.prevTime < newGroupDelay && !lastEvent.selectionsAfter.length && !lastEvent.changes.empty && event.changes && isAdjacent(lastEvent.changes, event.changes)) {
      done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none4));
    } else {
      done = updateBranch(done, done.length, maxLen, event);
    }
    return new HistoryState(done, none4, time, userEvent);
  }
  addSelection(selection, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none4;
    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == "keyboardselection" && this.prevUserEvent == userEvent && eqSelectionShape(last[last.length - 1], selection))
      return this;
    return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, selection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0)
      return null;
    let event = branch[branch.length - 1];
    if (selection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({side, rest: popSelection(branch)})
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none4 : branch.slice(0, branch.length - 1);
      if (event.mapped)
        rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({side, rest}),
        filter: false
      });
    }
  }
};
HistoryState.empty = new HistoryState(none4, none4);
var historyKeymap = [
  {key: "Mod-z", run: undo, preventDefault: true},
  {key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true},
  {key: "Mod-u", run: undoSelection, preventDefault: true},
  {key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true}
];

// node_modules/@codemirror/gutter/dist/index.js
var GutterMarker = class extends RangeValue {
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  eq(other) {
    return false;
  }
  at(pos) {
    return this.range(pos);
  }
};
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
var gutterLineClass = /* @__PURE__ */ Facet.define();
var defaults = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => RangeSet.empty,
  lineMarker: () => null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
};
var activeGutters = /* @__PURE__ */ Facet.define();
function gutter(config2) {
  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config2))];
}
var baseTheme4 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-gutters": {
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    left: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#999",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    height: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  }
});
var unfixGutters = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x) => x)
});
function gutters(config2) {
  let result = [
    gutterView,
    baseTheme4
  ];
  if (config2 && config2.fixed === false)
    result.push(unfixGutters.of(true));
  return result;
}
var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters";
    this.dom.setAttribute("aria-hidden", "true");
    this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
    for (let gutter2 of this.gutters)
      this.dom.appendChild(gutter2.dom);
    this.fixed = !view.state.facet(unfixGutters);
    if (this.fixed) {
      this.dom.style.position = "sticky";
    }
    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    this.syncGutters();
  }
  update(update) {
    if (this.updateGutters(update))
      this.syncGutters();
  }
  syncGutters() {
    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
    let classSet = [];
    let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport));
    this.view.viewportLines((line) => {
      let text;
      if (Array.isArray(line.type)) {
        for (let b of line.type)
          if (b.type == BlockType.Text) {
            text = b;
            break;
          }
      } else {
        text = line.type == BlockType.Text ? line : void 0;
      }
      if (!text)
        return;
      if (classSet.length)
        classSet = [];
      advanceCursor(lineClasses, classSet, line.from);
      for (let cx of contexts)
        cx.line(this.view, text, classSet);
    }, 0);
    for (let cx of contexts)
      cx.finish();
    this.dom.style.minHeight = this.view.contentHeight + "px";
    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
    }
  }
  updateGutters(update) {
    let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
    let change = update.docChanged || update.heightChanged || update.viewportChanged;
    if (prev == cur2) {
      for (let gutter2 of this.gutters)
        if (gutter2.update(update))
          change = true;
    } else {
      change = true;
      let gutters2 = [];
      for (let conf of cur2) {
        let known = prev.indexOf(conf);
        if (known < 0) {
          gutters2.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update);
          gutters2.push(this.gutters[known]);
        }
      }
      for (let g of this.gutters)
        g.dom.remove();
      for (let g of gutters2)
        this.dom.appendChild(g.dom);
      this.gutters = gutters2;
    }
    return change;
  }
  destroy() {
    this.dom.remove();
  }
}, {
  provide: /* @__PURE__ */ PluginField.scrollMargins.from((value) => {
    if (value.gutters.length == 0 || !value.fixed)
      return null;
    return value.view.textDirection == Direction.LTR ? {left: value.dom.offsetWidth} : {right: value.dom.offsetWidth};
  })
});
function asArray2(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor, collect, pos) {
  while (cursor.value && cursor.from <= pos) {
    if (cursor.from == pos)
      collect.push(cursor.value);
    cursor.next();
  }
}
var UpdateContext = class {
  constructor(gutter2, viewport) {
    this.gutter = gutter2;
    this.localMarkers = [];
    this.i = 0;
    this.height = 0;
    this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
  }
  line(view, line, extraMarkers) {
    if (this.localMarkers.length)
      this.localMarkers = [];
    advanceCursor(this.cursor, this.localMarkers, line.from);
    let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
    if (forLine)
      localMarkers.unshift(forLine);
    let gutter2 = this.gutter;
    if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
      return;
    let above = line.top - this.height;
    if (this.i == gutter2.elements.length) {
      let newElt = new GutterElement(view, line.height, above, localMarkers);
      gutter2.elements.push(newElt);
      gutter2.dom.appendChild(newElt.dom);
    } else {
      let elt = gutter2.elements[this.i];
      if (sameMarkers(localMarkers, elt.markers))
        localMarkers = elt.markers;
      elt.update(view, line.height, above, localMarkers);
    }
    this.height = line.bottom;
    this.i++;
  }
  finish() {
    let gutter2 = this.gutter;
    while (gutter2.elements.length > this.i)
      gutter2.dom.removeChild(gutter2.elements.pop().dom);
  }
};
var SingleGutterView = class {
  constructor(view, config2) {
    this.view = view;
    this.config = config2;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let prop in config2.domEventHandlers) {
      this.dom.addEventListener(prop, (event) => {
        let line = view.visualLineAtHeight(event.clientY, view.contentDOM.getBoundingClientRect().top);
        if (config2.domEventHandlers[prop](view, line, event))
          event.preventDefault();
      });
    }
    this.markers = asArray2(config2.markers(view));
    if (config2.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }
  update(update) {
    let prevMarkers = this.markers;
    this.markers = asArray2(this.config.markers(update.view));
    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update);
      if (updated != this.spacer.markers[0])
        this.spacer.update(update.view, 0, 0, [updated]);
    }
    return this.markers != prevMarkers;
  }
};
var GutterElement = class {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.dom = document.createElement("div");
    this.update(view, height, above, markers);
  }
  update(view, height, above, markers) {
    if (this.height != height)
      this.dom.style.height = (this.height = height) + "px";
    if (this.above != above)
      this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
    if (this.markers != markers) {
      this.markers = markers;
      for (let ch; ch = this.dom.lastChild; )
        ch.remove();
      let cls = "cm-gutterElement";
      for (let m of markers) {
        if (m.toDOM)
          this.dom.appendChild(m.toDOM(view));
        let c = m.elementClass;
        if (c)
          cls += " " + c;
      }
      this.dom.className = cls;
    }
  }
};
function sameMarkers(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].compare(b[i]))
      return false;
  return true;
}
var lineNumberMarkers = /* @__PURE__ */ Facet.define();
var lineNumberConfig = /* @__PURE__ */ Facet.define({
  combine(values) {
    return combineConfig(values, {formatNumber: String, domEventHandlers: {}}, {
      domEventHandlers(a, b) {
        let result = Object.assign({}, a);
        for (let event in b) {
          let exists = result[event], add2 = b[event];
          result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add2(view, line, event2) : add2;
        }
        return result;
      }
    });
  }
});
var NumberMarker = class extends GutterMarker {
  constructor(number2) {
    super();
    this.number = number2;
  }
  eq(other) {
    return this.number == other.number;
  }
  toDOM(_view) {
    return document.createTextNode(this.number);
  }
};
function formatNumber(view, number2) {
  return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
}
var lineNumberGutter = /* @__PURE__ */ gutter({
  class: "cm-lineNumbers",
  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },
  lineMarker(view, line, others) {
    if (others.some((m) => m.toDOM))
      return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
  },
  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },
  updateSpacer(spacer, update) {
    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
    return max == spacer.number ? spacer : new NumberMarker(max);
  }
});
function lineNumbers(config2 = {}) {
  return [
    lineNumberConfig.of(config2),
    lineNumberGutter
  ];
}
function maxLineNumber(lines) {
  let last = 9;
  while (last < lines)
    last = last * 10 + 9;
  return last;
}
var activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-activeLineGutter";
  }
  eq() {
    return true;
  }
}();
var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
  let marks = [], last = -1;
  for (let range of state.selection.ranges)
    if (range.empty) {
      let linePos = state.doc.lineAt(range.head).from;
      if (linePos > last) {
        last = linePos;
        marks.push(activeLineGutterMarker.range(linePos));
      }
    }
  return RangeSet.of(marks);
});
function highlightActiveLineGutter() {
  return activeLineGutterHighlighter;
}

// node_modules/@codemirror/fold/dist/index.js
function mapRange(range, mapping) {
  let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
  return from >= to ? void 0 : {from, to};
}
var foldEffect = /* @__PURE__ */ StateEffect.define({map: mapRange});
var unfoldEffect = /* @__PURE__ */ StateEffect.define({map: mapRange});
function selectedLines(view) {
  let lines = [];
  for (let {head} of view.state.selection.ranges) {
    if (lines.some((l) => l.from <= head && l.to >= head))
      continue;
    lines.push(view.visualLineAt(head));
  }
  return lines;
}
var foldState = /* @__PURE__ */ StateField.define({
  create() {
    return Decoration.none;
  },
  update(folded, tr) {
    folded = folded.map(tr.changes);
    for (let e of tr.effects) {
      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))
        folded = folded.update({add: [foldWidget.range(e.value.from, e.value.to)]});
      else if (e.is(unfoldEffect))
        folded = folded.update({
          filter: (from, to) => e.value.from != from || e.value.to != to,
          filterFrom: e.value.from,
          filterTo: e.value.to
        });
    }
    if (tr.selection) {
      let onSelection = false, {head} = tr.selection.main;
      folded.between(head, head, (a, b) => {
        if (a < head && b > head)
          onSelection = true;
      });
      if (onSelection)
        folded = folded.update({
          filterFrom: head,
          filterTo: head,
          filter: (a, b) => b <= head || a >= head
        });
    }
    return folded;
  },
  provide: (f) => EditorView.decorations.compute([f], (s2) => s2.field(f))
});
function foldInside2(state, from, to) {
  var _a;
  let found = null;
  (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from2, to2) => {
    if (!found || found.from > from2)
      found = {from: from2, to: to2};
  });
  return found;
}
function foldExists(folded, from, to) {
  let found = false;
  folded.between(from, from, (a, b) => {
    if (a == from && b == to)
      found = true;
  });
  return found;
}
function maybeEnable(state, other) {
  return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
}
var foldCode = (view) => {
  for (let line of selectedLines(view)) {
    let range = foldable(view.state, line.from, line.to);
    if (range) {
      view.dispatch({effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)])});
      return true;
    }
  }
  return false;
};
var unfoldCode = (view) => {
  if (!view.state.field(foldState, false))
    return false;
  let effects = [];
  for (let line of selectedLines(view)) {
    let folded = foldInside2(view.state, line.from, line.to);
    if (folded)
      effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
  }
  if (effects.length)
    view.dispatch({effects});
  return effects.length > 0;
};
function announceFold(view, range, fold = true) {
  let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
  return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
var foldAll = (view) => {
  let {state} = view, effects = [];
  for (let pos = 0; pos < state.doc.length; ) {
    let line = view.visualLineAt(pos), range = foldable(state, line.from, line.to);
    if (range)
      effects.push(foldEffect.of(range));
    pos = (range ? view.visualLineAt(range.to) : line).to + 1;
  }
  if (effects.length)
    view.dispatch({effects: maybeEnable(view.state, effects)});
  return !!effects.length;
};
var unfoldAll = (view) => {
  let field = view.state.field(foldState, false);
  if (!field || !field.size)
    return false;
  let effects = [];
  field.between(0, view.state.doc.length, (from, to) => {
    effects.push(unfoldEffect.of({from, to}));
  });
  view.dispatch({effects});
  return true;
};
var foldKeymap = [
  {key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode},
  {key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode},
  {key: "Ctrl-Alt-[", run: foldAll},
  {key: "Ctrl-Alt-]", run: unfoldAll}
];
var defaultConfig = {
  placeholderDOM: null,
  placeholderText: "\u2026"
};
var foldConfig = /* @__PURE__ */ Facet.define({
  combine(values) {
    return combineConfig(values, defaultConfig);
  }
});
function codeFolding(config2) {
  let result = [foldState, baseTheme5];
  if (config2)
    result.push(foldConfig.of(config2));
  return result;
}
var foldWidget = /* @__PURE__ */ Decoration.replace({widget: /* @__PURE__ */ new class extends WidgetType {
  ignoreEvents() {
    return false;
  }
  toDOM(view) {
    let {state} = view, conf = state.facet(foldConfig);
    if (conf.placeholderDOM)
      return conf.placeholderDOM();
    let element = document.createElement("span");
    element.textContent = conf.placeholderText;
    element.setAttribute("aria-label", state.phrase("folded code"));
    element.title = state.phrase("unfold");
    element.className = "cm-foldPlaceholder";
    element.onclick = (event) => {
      let line = view.visualLineAt(view.posAtDOM(event.target));
      let folded = foldInside2(view.state, line.from, line.to);
      if (folded)
        view.dispatch({effects: unfoldEffect.of(folded)});
      event.preventDefault();
    };
    return element;
  }
}()});
var foldGutterDefaults = {
  openText: "\u2304",
  closedText: "\u203A"
};
var FoldMarker = class extends GutterMarker {
  constructor(config2, open) {
    super();
    this.config = config2;
    this.open = open;
  }
  eq(other) {
    return this.config == other.config && this.open == other.open;
  }
  toDOM(view) {
    let span = document.createElement("span");
    span.textContent = this.open ? this.config.openText : this.config.closedText;
    span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
    return span;
  }
};
function foldGutter(config2 = {}) {
  let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config2);
  let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
  let markers = ViewPlugin.fromClass(class {
    constructor(view) {
      this.from = view.viewport.from;
      this.markers = this.buildMarkers(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false))
        this.markers = this.buildMarkers(update.view);
    }
    buildMarkers(view) {
      let builder = new RangeSetBuilder();
      view.viewportLines((line) => {
        let mark = foldInside2(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
        if (mark)
          builder.add(line.from, line.from, mark);
      });
      return builder.finish();
    }
  });
  return [
    markers,
    gutter({
      class: "cm-foldGutter",
      markers(view) {
        var _a;
        return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || RangeSet.empty;
      },
      initialSpacer() {
        return new FoldMarker(fullConfig, false);
      },
      domEventHandlers: {
        click: (view, line) => {
          let folded = foldInside2(view.state, line.from, line.to);
          if (folded) {
            view.dispatch({effects: unfoldEffect.of(folded)});
            return true;
          }
          let range = foldable(view.state, line.from, line.to);
          if (range) {
            view.dispatch({effects: foldEffect.of(range)});
            return true;
          }
          return false;
        }
      }
    }),
    codeFolding()
  ];
}
var baseTheme5 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter .cm-gutterElement": {
    padding: "0 1px",
    cursor: "pointer"
  }
});

// node_modules/@codemirror/matchbrackets/dist/index.js
var baseTheme6 = EditorView.baseTheme({
  ".cm-matchingBracket": {color: "#0b0"},
  ".cm-nonmatchingBracket": {color: "#a22"}
});
var DefaultScanDist = 1e4;
var DefaultBrackets = "()[]{}";
var bracketMatchingConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      afterCursor: true,
      brackets: DefaultBrackets,
      maxScanDistance: DefaultScanDist
    });
  }
});
var matchingMark = Decoration.mark({class: "cm-matchingBracket"});
var nonmatchingMark = Decoration.mark({class: "cm-nonmatchingBracket"});
var bracketMatchingState = StateField.define({
  create() {
    return Decoration.none;
  },
  update(deco, tr) {
    if (!tr.docChanged && !tr.selection)
      return deco;
    let decorations2 = [];
    let config2 = tr.state.facet(bracketMatchingConfig);
    for (let range of tr.state.selection.ranges) {
      if (!range.empty)
        continue;
      let match = matchBrackets(tr.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range.head, 1, config2) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config2));
      if (!match)
        continue;
      let mark = match.matched ? matchingMark : nonmatchingMark;
      decorations2.push(mark.range(match.start.from, match.start.to));
      if (match.end)
        decorations2.push(mark.range(match.end.from, match.end.to));
    }
    return Decoration.set(decorations2, true);
  },
  provide: (f) => EditorView.decorations.from(f)
});
var bracketMatchingUnique = [
  bracketMatchingState,
  baseTheme6
];
function bracketMatching(config2 = {}) {
  return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
}
function matchingNodes(node, dir, brackets) {
  let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (byProp)
    return byProp;
  if (node.name.length == 1) {
    let index2 = brackets.indexOf(node.name);
    if (index2 > -1 && index2 % 2 == (dir < 0 ? 1 : 0))
      return [brackets[index2 + dir]];
  }
  return null;
}
function matchBrackets(state, pos, dir, config2 = {}) {
  let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
  let tree = syntaxTree(state), sub = tree.resolve(pos, dir), matches;
  if (matches = matchingNodes(sub.type, dir, brackets))
    return matchMarkedBrackets(state, pos, dir, sub, matches, brackets);
  else
    return matchPlainBrackets(state, pos, dir, tree, sub.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {
  let parent = token.parent, firstToken = {from: token.from, to: token.to};
  let depth2 = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;
  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
    do {
      if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
        if (depth2 == 0 && matching.indexOf(cursor.type.name) > -1) {
          return {start: firstToken, end: {from: cursor.from, to: cursor.to}, matched: true};
        } else if (matchingNodes(cursor.type, dir, brackets)) {
          depth2++;
        } else if (matchingNodes(cursor.type, -dir, brackets)) {
          depth2--;
          if (depth2 == 0)
            return {start: firstToken, end: {from: cursor.from, to: cursor.to}, matched: false};
        }
      }
    } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
  return {start: firstToken, matched: false};
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket2 = brackets.indexOf(startCh);
  if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
    return null;
  let startToken = {from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos};
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth2 = 0;
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
    let text = iter.value;
    if (dir < 0)
      distance += text.length;
    let basePos = pos + distance * dir;
    for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
      let found = brackets.indexOf(text[pos2]);
      if (found < 0 || tree.resolve(basePos + pos2, 1).type != tokenType)
        continue;
      if (found % 2 == 0 == dir > 0) {
        depth2++;
      } else if (depth2 == 1) {
        return {start: startToken, end: {from: basePos + pos2, to: basePos + pos2 + 1}, matched: found >> 1 == bracket2 >> 1};
      } else {
        depth2--;
      }
    }
    if (dir > 0)
      distance += text.length;
  }
  return iter.done ? {start: startToken, matched: false} : null;
}

// node_modules/@codemirror/commands/dist/index.js
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
  return state.update({selection, scrollIntoView: true, annotations: Transaction.userEvent.of("keyboardselection")});
}
function moveSel({state, dispatch}, how) {
  let selection = updateSel(state.selection, how);
  if (selection.eq(state.selection))
    return false;
  dispatch(setSel(state, selection));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
var cursorCharLeft = (view) => cursorByChar(view, view.textDirection != Direction.LTR);
var cursorCharRight = (view) => cursorByChar(view, view.textDirection == Direction.LTR);
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
var cursorGroupLeft = (view) => cursorByGroup(view, view.textDirection != Direction.LTR);
var cursorGroupRight = (view) => cursorByGroup(view, view.textDirection == Direction.LTR);
var cursorGroupForward = (view) => cursorByGroup(view, true);
var cursorGroupBackward = (view) => cursorByGroup(view, false);
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp))
    return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolve(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at = start.head; ; ) {
    let next = forward ? pos.childAfter(at) : pos.childBefore(at);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at = forward ? next.to : next.from;
  }
  let bracket2 = pos.type.prop(bracketProp), match, newPos;
  if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
    newPos = forward ? match.end.to : match.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, view.textDirection != Direction.LTR));
var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, view.textDirection == Direction.LTR));
function cursorByLine(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveVertically(range, forward) : rangeEnd(range, forward));
}
var cursorLineUp = (view) => cursorByLine(view, false);
var cursorLineDown = (view) => cursorByLine(view, true);
function cursorByPage(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveVertically(range, forward, view.dom.clientHeight) : rangeEnd(range, forward));
}
var cursorPageUp = (view) => cursorByPage(view, false);
var cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.visualLineAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space2 = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space2 && start.head != line.from + space2)
      moved = EditorSelection.cursor(line.from + space2);
  }
  return moved;
}
var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.visualLineAt(range.head).from, 1));
var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.visualLineAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend2) {
  let found = false, selection = updateSel(state.selection, (range) => {
    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching || !matching.end)
      return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return extend2 ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection));
  return true;
}
var cursorMatchingBracket = ({state, dispatch}) => toMatchingBracket(state, dispatch, false);
function extendSel(view, how) {
  let selection = updateSel(view.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn);
  });
  if (selection.eq(view.state.selection))
    return false;
  view.dispatch(setSel(view.state, selection));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
var selectCharLeft = (view) => selectByChar(view, view.textDirection != Direction.LTR);
var selectCharRight = (view) => selectByChar(view, view.textDirection == Direction.LTR);
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
var selectGroupLeft = (view) => selectByGroup(view, view.textDirection != Direction.LTR);
var selectGroupRight = (view) => selectByGroup(view, view.textDirection == Direction.LTR);
var selectGroupForward = (view) => selectByGroup(view, true);
var selectGroupBackward = (view) => selectByGroup(view, false);
var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, view.textDirection != Direction.LTR));
var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, view.textDirection == Direction.LTR));
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
var selectLineUp = (view) => selectByLine(view, false);
var selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, view.dom.clientHeight));
}
var selectPageUp = (view) => selectByPage(view, false);
var selectPageDown = (view) => selectByPage(view, true);
var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.visualLineAt(range.head).from));
var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.visualLineAt(range.head).to));
var cursorDocStart = ({state, dispatch}) => {
  dispatch(setSel(state, {anchor: 0}));
  return true;
};
var cursorDocEnd = ({state, dispatch}) => {
  dispatch(setSel(state, {anchor: state.doc.length}));
  return true;
};
var selectDocStart = ({state, dispatch}) => {
  dispatch(setSel(state, {anchor: state.selection.main.anchor, head: 0}));
  return true;
};
var selectDocEnd = ({state, dispatch}) => {
  dispatch(setSel(state, {anchor: state.selection.main.anchor, head: state.doc.length}));
  return true;
};
var selectAll = ({state, dispatch}) => {
  dispatch(state.update({selection: {anchor: 0, head: state.doc.length}, annotations: Transaction.userEvent.of("keyboardselection")}));
  return true;
};
var selectLine = ({state, dispatch}) => {
  let ranges = selectedLineBlocks(state).map(({from, to}) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
  dispatch(state.update({selection: EditorSelection.create(ranges), annotations: Transaction.userEvent.of("keyboardselection")}));
  return true;
};
var selectParentSyntax = ({state, dispatch}) => {
  let selection = updateSel(state.selection, (range) => {
    var _a;
    let context = syntaxTree(state).resolve(range.head, 1);
    while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))
      context = context.parent;
    return EditorSelection.range(context.to, context.from);
  });
  dispatch(setSel(state, selection));
  return true;
};
var simplifySelection = ({state, dispatch}) => {
  let cur2 = state.selection, selection = null;
  if (cur2.ranges.length > 1)
    selection = EditorSelection.create([cur2.main]);
  else if (!cur2.main.empty)
    selection = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
  if (!selection)
    return false;
  dispatch(setSel(state, selection));
  return true;
};
function deleteBy({state, dispatch}, by) {
  let changes = state.changeByRange((range) => {
    let {from, to} = range;
    if (from == to) {
      let towards = by(from);
      from = Math.min(from, towards);
      to = Math.max(to, towards);
    }
    return from == to ? {range} : {changes: {from, to}, range: EditorSelection.cursor(from)};
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, {scrollIntoView: true, annotations: Transaction.userEvent.of("delete")}));
  return true;
}
var deleteByChar = (target, forward, codePoint) => deleteBy(target, (pos) => {
  let {state} = target, line = state.doc.lineAt(pos), before;
  if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, 0, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
      pos--;
    return pos;
  }
  let targetPos;
  if (codePoint) {
    let next = line.text.slice(pos - line.from + (forward ? 0 : -2), pos - line.from + (forward ? 2 : 0));
    let size = next ? codePointSize(codePointAt(next, 0)) : 1;
    targetPos = forward ? Math.min(state.doc.length, pos + size) : Math.max(0, pos - size);
  } else {
    targetPos = findClusterBreak(line.text, pos - line.from, forward) + line.from;
  }
  if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
    targetPos += forward ? 1 : -1;
  return targetPos;
});
var deleteCodePointBackward = (view) => deleteByChar(view, false, true);
var deleteCharBackward = (view) => deleteByChar(view, false, false);
var deleteCharForward = (view) => deleteByChar(view, true, false);
var deleteByGroup = (target, forward) => deleteBy(target, (start) => {
  let pos = start, {state} = target, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == start && line.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
    let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar2);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar2 != " " || pos != start)
      cat = nextCat;
    pos = next;
  }
  return pos;
});
var deleteGroupBackward = (target) => deleteByGroup(target, false);
var deleteGroupForward = (target) => deleteByGroup(target, true);
var deleteToLineEnd = (view) => deleteBy(view, (pos) => {
  let lineEnd = view.visualLineAt(pos).to;
  if (pos < lineEnd)
    return lineEnd;
  return Math.min(view.state.doc.length, pos + 1);
});
var deleteToLineStart = (view) => deleteBy(view, (pos) => {
  let lineStart = view.visualLineAt(pos).from;
  if (pos > lineStart)
    return lineStart;
  return Math.max(0, pos - 1);
});
var splitLine = ({state, dispatch}) => {
  let changes = state.changeByRange((range) => {
    return {
      changes: {from: range.from, to: range.to, insert: Text.of(["", ""])},
      range: EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, {scrollIntoView: true, annotations: Transaction.userEvent.of("input")}));
  return true;
};
var transposeChars = ({state, dispatch}) => {
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length)
      return {range};
    let pos = range.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
    let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
    return {
      changes: {from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))},
      range: EditorSelection.cursor(to)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, {scrollIntoView: true}));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (upto == startLine.number)
      blocks[blocks.length - 1].to = endLine.to;
    else
      blocks.push({from: startLine.from, to: endLine.to});
    upto = endLine.number;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    if (forward)
      changes.push({from: block.to, to: nextLine.to}, {from: block.from, insert: nextLine.text + state.lineBreak});
    else
      changes.push({from: nextLine.from, to: block.from}, {from: block.to, insert: state.lineBreak + nextLine.text});
  }
  if (!changes.length)
    return false;
  dispatch(state.update({changes, scrollIntoView: true}));
  return true;
}
var moveLineUp = ({state, dispatch}) => moveLine(state, dispatch, false);
var moveLineDown = ({state, dispatch}) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak});
    else
      changes.push({from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to)});
  }
  dispatch(state.update({changes, scrollIntoView: true}));
  return true;
}
var copyLineUp = ({state, dispatch}) => copyLine(state, dispatch, false);
var copyLineDown = ({state, dispatch}) => copyLine(state, dispatch, true);
var deleteLine = (view) => {
  let {state} = view, changes = state.changes(selectedLineBlocks(state).map(({from, to}) => {
    if (from > 0)
      from--;
    else if (to < state.doc.length)
      to++;
    return {from, to};
  }));
  let selection = updateSel(state.selection, (range) => view.moveVertically(range, true)).map(changes);
  view.dispatch({changes, selection, scrollIntoView: true});
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return {from: pos, to: pos};
  let context = syntaxTree(state).resolve(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)
    return {from: before.to, to: after.from};
  return null;
}
var insertNewlineAndIndent = ({state, dispatch}) => {
  let changes = state.changeByRange(({from, to}) => {
    let explode = from == to && isBetweenBrackets(state, from);
    let cx = new IndentContext(state, {simulateBreak: from, simulateDoubleBreak: !!explode});
    let indent = getIndentation(cx, from);
    if (indent == null)
      indent = /^\s*/.exec(state.doc.lineAt(from).text)[0].length;
    let line = state.doc.lineAt(from);
    while (to < line.to && /\s/.test(line.text.slice(to - line.from, to + 1 - line.from)))
      to++;
    if (explode)
      ({from, to} = explode);
    else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
      from = line.from;
    let insert2 = ["", indentString(state, indent)];
    if (explode)
      insert2.push(indentString(state, cx.lineIndent(line)));
    return {
      changes: {from, to, insert: Text.of(insert2)},
      range: EditorSelection.cursor(from + 1 + insert2[1].length)
    };
  });
  dispatch(state.update(changes, {scrollIntoView: true}));
  return true;
};
function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
var indentSelection = ({state, dispatch}) => {
  let updated = Object.create(null);
  let context = new IndentContext(state, {overrideIndentation: (start) => {
    let found = updated[start];
    return found == null ? -1 : found;
  }});
  let changes = changeBySelectedLine(state, (line, changes2, range) => {
    let indent = getIndentation(context, line.from);
    if (indent == null)
      return;
    let cur2 = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent);
    if (cur2 != norm || range.from < line.from + cur2.length) {
      updated[line.from] = indent;
      changes2.push({from: line.from, to: line.from + cur2.length, insert: norm});
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes));
  return true;
};
var indentMore = ({state, dispatch}) => {
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({from: line.from, insert: state.facet(indentUnit)});
  })));
  return true;
};
var indentLess = ({state, dispatch}) => {
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space2 = /^\s*/.exec(line.text)[0];
    if (!space2)
      return;
    let col = countColumn(space2, 0, state.tabSize), keep = 0;
    let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space2.length && keep < insert2.length && space2.charCodeAt(keep) == insert2.charCodeAt(keep))
      keep++;
    changes.push({from: line.from + keep, to: line.from + space2.length, insert: insert2.slice(keep)});
  })));
  return true;
};
var emacsStyleKeymap = [
  {key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true},
  {key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight},
  {key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp},
  {key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown},
  {key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart},
  {key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd},
  {key: "Ctrl-d", run: deleteCharForward},
  {key: "Ctrl-h", run: deleteCharBackward},
  {key: "Ctrl-k", run: deleteToLineEnd},
  {key: "Alt-d", run: deleteGroupForward},
  {key: "Ctrl-Alt-h", run: deleteGroupBackward},
  {key: "Ctrl-o", run: splitLine},
  {key: "Ctrl-t", run: transposeChars},
  {key: "Alt-f", run: cursorGroupForward, shift: selectGroupForward},
  {key: "Alt-b", run: cursorGroupBackward, shift: selectGroupBackward},
  {key: "Alt-<", run: cursorDocStart},
  {key: "Alt->", run: cursorDocEnd},
  {key: "Ctrl-v", run: cursorPageDown},
  {key: "Alt-v", run: cursorPageUp}
];
var standardKeymap = /* @__PURE__ */ [
  {key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft},
  {key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft},
  {mac: "Cmd-ArrowLeft", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward},
  {key: "ArrowRight", run: cursorCharRight, shift: selectCharRight},
  {key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight},
  {mac: "Cmd-ArrowRight", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward},
  {key: "ArrowUp", run: cursorLineUp, shift: selectLineUp},
  {mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart},
  {mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp},
  {key: "ArrowDown", run: cursorLineDown, shift: selectLineDown},
  {mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd},
  {mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown},
  {key: "PageUp", run: cursorPageUp, shift: selectPageUp},
  {key: "PageDown", run: cursorPageDown, shift: selectPageDown},
  {key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward},
  {key: "Mod-Home", run: cursorDocStart, shift: selectDocStart},
  {key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward},
  {key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd},
  {key: "Enter", run: insertNewlineAndIndent},
  {key: "Mod-a", run: selectAll},
  {key: "Backspace", run: deleteCodePointBackward, shift: deleteCodePointBackward},
  {key: "Delete", run: deleteCharForward, shift: deleteCharForward},
  {key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward},
  {key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward},
  {mac: "Mod-Backspace", run: deleteToLineStart},
  {mac: "Mod-Delete", run: deleteToLineEnd}
].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({mac: b.key, run: b.run, shift: b.shift})));
var defaultKeymap = /* @__PURE__ */ [
  {key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft},
  {key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight},
  {key: "Alt-ArrowUp", run: moveLineUp},
  {key: "Shift-Alt-ArrowUp", run: copyLineUp},
  {key: "Alt-ArrowDown", run: moveLineDown},
  {key: "Shift-Alt-ArrowDown", run: copyLineDown},
  {key: "Escape", run: simplifySelection},
  {key: "Alt-l", mac: "Ctrl-l", run: selectLine},
  {key: "Mod-i", run: selectParentSyntax, preventDefault: true},
  {key: "Mod-[", run: indentLess},
  {key: "Mod-]", run: indentMore},
  {key: "Mod-Alt-\\", run: indentSelection},
  {key: "Shift-Mod-k", run: deleteLine},
  {key: "Shift-Mod-\\", run: cursorMatchingBracket}
].concat(standardKeymap);

// node_modules/@codemirror/closebrackets/dist/index.js
var defaults2 = {
  brackets: ["(", "[", "{", "'", '"'],
  before: `)]}'":;>`
};
var closeBracketEffect = StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
    return mapped == null ? void 0 : mapped;
  }
});
var skipBracketEffect = StateEffect.define({
  map(value, mapping) {
    return mapping.mapPos(value);
  }
});
var closedBracket = new class extends RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
var bracketState = StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(value, tr) {
    if (tr.selection) {
      let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
      let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
      if (lineStart != tr.changes.mapPos(prevLineStart, -1))
        value = RangeSet.empty;
    }
    value = value.map(tr.changes);
    for (let effect of tr.effects) {
      if (effect.is(closeBracketEffect))
        value = value.update({add: [closedBracket.range(effect.value, effect.value + 1)]});
      else if (effect.is(skipBracketEffect))
        value = value.update({filter: (from) => from != effect.value});
    }
    return value;
  }
});
function closeBrackets() {
  return [EditorView.inputHandler.of(handleInput), bracketState];
}
var definedClosing = "()[]{}<>";
function closing(ch) {
  for (let i = 0; i < definedClosing.length; i += 2)
    if (definedClosing.charCodeAt(i) == ch)
      return definedClosing.charAt(i + 1);
  return fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults2;
}
function handleInput(view, from, to, insert2) {
  if (view.composing)
    return false;
  let sel = view.state.selection.main;
  if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from != sel.from || to != sel.to)
    return false;
  let tr = insertBracket(view.state, insert2);
  if (!tr)
    return false;
  view.dispatch(tr);
  return true;
}
var deleteBracketPair = ({state, dispatch}) => {
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults2.brackets;
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty) {
      let before = prevChar(state.doc, range.head);
      for (let token of tokens) {
        if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))
          return {
            changes: {from: range.head - token.length, to: range.head + token.length},
            range: EditorSelection.cursor(range.head - token.length),
            annotations: Transaction.userEvent.of("delete")
          };
      }
    }
    return {range: dont = range};
  });
  if (!dont)
    dispatch(state.update(changes, {scrollIntoView: true}));
  return !dont;
};
var closeBracketsKeymap = [
  {key: "Backspace", run: deleteBracketPair}
];
function insertBracket(state, bracket2) {
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults2.brackets;
  for (let tok of tokens) {
    let closed = closing(codePointAt(tok, 0));
    if (bracket2 == tok)
      return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1) : handleOpen(state, tok, closed, conf.before || defaults2.before);
    if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
      return handleClose(state, tok, closed);
  }
  return null;
}
function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, (from) => {
    if (from == pos)
      found = true;
  });
  return found;
}
function nextChar(doc2, pos) {
  let next = doc2.sliceString(pos, pos + 2);
  return next.slice(0, codePointSize(codePointAt(next, 0)));
}
function prevChar(doc2, pos) {
  let prev = doc2.sliceString(pos - 2, pos);
  return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state, open, close, closeBefore) {
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{insert: open, from: range.from}, {insert: close, from: range.to}],
        effects: closeBracketEffect.of(range.to + open.length),
        range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
      };
    let next = nextChar(state.doc, range.head);
    if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
      return {
        changes: {insert: open + close, from: range.head},
        effects: closeBracketEffect.of(range.head + open.length),
        range: EditorSelection.cursor(range.head + open.length)
      };
    return {range: dont = range};
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    annotations: Transaction.userEvent.of("input")
  });
}
function handleClose(state, _open, close) {
  let dont = null, moved = state.selection.ranges.map((range) => {
    if (range.empty && nextChar(state.doc, range.head) == close)
      return EditorSelection.cursor(range.head + close.length);
    return dont = range;
  });
  return dont ? null : state.update({
    selection: EditorSelection.create(moved, state.selection.mainIndex),
    scrollIntoView: true,
    effects: state.selection.ranges.map(({from}) => skipBracketEffect.of(from))
  });
}
function handleSame(state, token, allowTriple) {
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{insert: token, from: range.from}, {insert: token, from: range.to}],
        effects: closeBracketEffect.of(range.to + token.length),
        range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
      };
    let pos = range.head, next = nextChar(state.doc, pos);
    if (next == token) {
      if (nodeStart(state, pos)) {
        return {
          changes: {insert: token + token, from: pos},
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
        return {
          range: EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),
          effects: skipBracketEffect.of(pos)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && nodeStart(state, pos - 2 * token.length)) {
      return {
        changes: {insert: token + token + token + token, from: pos},
        effects: closeBracketEffect.of(pos + token.length),
        range: EditorSelection.cursor(pos + token.length)
      };
    } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
      let prev = state.sliceDoc(pos - 1, pos);
      if (prev != token && state.charCategorizer(pos)(prev) != CharCategory.Word)
        return {
          changes: {insert: token + token, from: pos},
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
    }
    return {range: dont = range};
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    annotations: Transaction.userEvent.of("input")
  });
}
function nodeStart(state, pos) {
  let tree = syntaxTree(state).resolve(pos + 1);
  return tree.parent && tree.from == pos;
}

// node_modules/@codemirror/panel/dist/index.js
var panelConfig = Facet.define({
  combine(configs) {
    let topContainer, bottomContainer;
    for (let c of configs) {
      topContainer = topContainer || c.topContainer;
      bottomContainer = bottomContainer || c.bottomContainer;
    }
    return {topContainer, bottomContainer};
  }
});
function getPanel(view, panel) {
  let plugin = view.plugin(panelPlugin);
  let index2 = plugin ? plugin.specs.indexOf(panel) : -1;
  return index2 > -1 ? plugin.panels[index2] : null;
}
var panelPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.input = view.state.facet(showPanel);
    this.specs = this.input.filter((s2) => s2);
    this.panels = this.specs.map((spec) => spec(view));
    let conf = view.state.facet(panelConfig);
    this.top = new PanelGroup(view, true, conf.topContainer);
    this.bottom = new PanelGroup(view, false, conf.bottomContainer);
    this.top.sync(this.panels.filter((p) => p.top));
    this.bottom.sync(this.panels.filter((p) => !p.top));
    for (let p of this.panels) {
      p.dom.classList.add("cm-panel");
      if (p.class)
        p.dom.classList.add(p.class);
      if (p.mount)
        p.mount();
    }
  }
  update(update) {
    let conf = update.state.facet(panelConfig);
    if (this.top.container != conf.topContainer) {
      this.top.sync([]);
      this.top = new PanelGroup(update.view, true, conf.topContainer);
    }
    if (this.bottom.container != conf.bottomContainer) {
      this.bottom.sync([]);
      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
    }
    this.top.syncClasses();
    this.bottom.syncClasses();
    let input = update.state.facet(showPanel);
    if (input != this.input) {
      let specs = input.filter((x) => x);
      let panels = [], top2 = [], bottom = [], mount = [];
      for (let spec of specs) {
        let known = this.specs.indexOf(spec), panel;
        if (known < 0) {
          panel = spec(update.view);
          mount.push(panel);
        } else {
          panel = this.panels[known];
          if (panel.update)
            panel.update(update);
        }
        panels.push(panel);
        (panel.top ? top2 : bottom).push(panel);
      }
      this.specs = specs;
      this.panels = panels;
      this.top.sync(top2);
      this.bottom.sync(bottom);
      for (let p of mount) {
        p.dom.classList.add("cm-panel");
        if (p.class)
          p.dom.classList.add(p.class);
        if (p.mount)
          p.mount();
      }
    } else {
      for (let p of this.panels)
        if (p.update)
          p.update(update);
    }
  }
  destroy() {
    this.top.sync([]);
    this.bottom.sync([]);
  }
}, {
  provide: PluginField.scrollMargins.from((value) => ({top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin()}))
});
var PanelGroup = class {
  constructor(view, top2, container) {
    this.view = view;
    this.top = top2;
    this.container = container;
    this.dom = void 0;
    this.classes = "";
    this.panels = [];
    this.syncClasses();
  }
  sync(panels) {
    this.panels = panels;
    this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove();
        this.dom = void 0;
      }
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
      this.dom.style[this.top ? "top" : "bottom"] = "0";
      let parent = this.container || this.view.dom;
      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
    }
    let curDOM = this.dom.firstChild;
    for (let panel of this.panels) {
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom)
          curDOM = rm2(curDOM);
        curDOM = curDOM.nextSibling;
      } else {
        this.dom.insertBefore(panel.dom, curDOM);
      }
    }
    while (curDOM)
      curDOM = rm2(curDOM);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - this.view.scrollDOM.getBoundingClientRect().top : this.view.scrollDOM.getBoundingClientRect().bottom - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses)
      return;
    for (let cls of this.classes.split(" "))
      if (cls)
        this.container.classList.remove(cls);
    for (let cls of (this.classes = this.view.themeClasses).split(" "))
      if (cls)
        this.container.classList.add(cls);
  }
};
function rm2(node) {
  let next = node.nextSibling;
  node.remove();
  return next;
}
var baseTheme7 = EditorView.baseTheme({
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  }
});
var showPanel = Facet.define({
  enables: [panelPlugin, baseTheme7]
});

// node_modules/crelt/index.es.js
function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string")
    elt = document.createElement(elt);
  var i = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name2 in next)
      if (Object.prototype.hasOwnProperty.call(next, name2)) {
        var value = next[name2];
        if (typeof value == "string")
          elt.setAttribute(name2, value);
        else if (value != null)
          elt[name2] = value;
      }
    i++;
  }
  for (; i < arguments.length; i++)
    add(elt, arguments[i]);
  return elt;
}
function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++)
      add(elt, child[i]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}

// node_modules/@codemirror/search/dist/index.js
var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
var SearchCursor = class {
  constructor(text, query, from = 0, to = text.length, normalize2) {
    this.value = {from: 0, to: 0};
    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text.iterRange(from, to);
    this.bufferStart = from;
    this.normalize = normalize2 ? (x) => normalize2(basicNormalize(x)) : basicNormalize;
    this.query = this.normalize(query);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done)
        return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }
    return codePointAt(this.buffer, this.bufferPos);
  }
  next() {
    while (this.matches.length)
      this.matches.pop();
    return this.nextOverlapping();
  }
  nextOverlapping() {
    for (; ; ) {
      let next = this.peek();
      if (next < 0) {
        this.done = true;
        return this;
      }
      let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize(next);
      let norm = this.normalize(str);
      for (let i = 0, pos = start; ; i++) {
        let code = norm.charCodeAt(i);
        let match = this.match(code, pos);
        if (match) {
          this.value = match;
          return this;
        }
        if (i == norm.length - 1)
          break;
        if (pos == start && i < str.length && str.charCodeAt(i) == code)
          pos++;
      }
    }
  }
  match(code, pos) {
    let match = null;
    for (let i = 0; i < this.matches.length; i += 2) {
      let index2 = this.matches[i], keep = false;
      if (this.query.charCodeAt(index2) == code) {
        if (index2 == this.query.length - 1) {
          match = {from: this.matches[i + 1], to: pos + 1};
        } else {
          this.matches[i]++;
          keep = true;
        }
      }
      if (!keep) {
        this.matches.splice(i, 2);
        i -= 2;
      }
    }
    if (this.query.charCodeAt(0) == code) {
      if (this.query.length == 1)
        match = {from: pos, to: pos + 1};
      else
        this.matches.push(1, pos);
    }
    return match;
  }
};
var empty = {from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("")};
var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
var RegExpCursor = class {
  constructor(text, query, options2, from = 0, to = text.length) {
    this.to = to;
    this.curLine = "";
    this.done = false;
    this.value = empty;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
      return new MultilineRegExpCursor(text, query, options2, from, to);
    this.re = new RegExp(query, baseFlags + ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreCase) ? "i" : ""));
    this.iter = text.iter();
    let startLine = text.lineAt(from);
    this.curLineStart = startLine.from;
    this.matchPos = from;
    this.getLine(this.curLineStart);
  }
  getLine(skip) {
    this.iter.next(skip);
    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to)
        this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to)
      this.curLine = "";
    else
      this.getLine(0);
  }
  next() {
    for (let off = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off;
      let match = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (match) {
        let from = this.curLineStart + match.index, to = from + match[0].length;
        this.matchPos = to + (from == to ? 1 : 0);
        if (from == this.curLine.length)
          this.nextLine();
        if (from < to || from > this.value.to) {
          this.value = {from, to, match};
          return this;
        }
        off = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }
};
var flattened = /* @__PURE__ */ new WeakMap();
var FlattenedDoc = class {
  constructor(from, text) {
    this.from = from;
    this.text = text;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(doc2, from, to) {
    let cached2 = flattened.get(doc2);
    if (!cached2 || cached2.from >= to || cached2.to <= from) {
      let flat = new FlattenedDoc(from, doc2.sliceString(from, to));
      flattened.set(doc2, flat);
      return flat;
    }
    if (cached2.from == from && cached2.to == to)
      return cached2;
    let {text, from: cachedFrom} = cached2;
    if (cachedFrom > from) {
      text = doc2.sliceString(from, cachedFrom) + text;
      cachedFrom = from;
    }
    if (cached2.to < to)
      text += doc2.sliceString(cached2.to, to);
    flattened.set(doc2, new FlattenedDoc(cachedFrom, text));
    return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
  }
};
var MultilineRegExpCursor = class {
  constructor(text, query, options2, from, to) {
    this.text = text;
    this.to = to;
    this.done = false;
    this.value = empty;
    this.matchPos = from;
    this.re = new RegExp(query, baseFlags + ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreCase) ? "i" : ""));
    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5e3));
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }
  next() {
    for (; ; ) {
      let off = this.re.lastIndex = this.matchPos - this.flat.from;
      let match = this.re.exec(this.flat.text);
      if (match && !match[0] && match.index == off) {
        this.re.lastIndex = off + 1;
        match = this.re.exec(this.flat.text);
      }
      if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10)
        match = null;
      if (match) {
        let from = this.flat.from + match.index, to = from + match[0].length;
        this.value = {from, to, match};
        this.matchPos = to + (from == to ? 1 : 0);
        return this;
      } else {
        if (this.flat.to == this.to) {
          this.done = true;
          return this;
        }
        this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
      }
    }
  }
};
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a) {
    return false;
  }
}
function createLineDialog(view) {
  let input = crelt("input", {class: "cm-textfield", name: "line"});
  let dom = crelt("form", {
    class: "cm-gotoLine",
    onkeydown: (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        view.dispatch({effects: dialogEffect.of(false)});
        view.focus();
      } else if (event.keyCode == 13) {
        event.preventDefault();
        go();
      }
    },
    onsubmit: (event) => {
      event.preventDefault();
      go();
    }
  }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", {class: "cm-button", type: "submit"}, view.state.phrase("go")));
  function go() {
    let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
    if (!match)
      return;
    let {state} = view, startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln, cl, percent] = match;
    let col = cl ? +cl.slice(1) : 0;
    let line = ln ? +ln : startLine.number;
    if (ln && percent) {
      let pc = line / 100;
      if (sign)
        pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line = Math.round(state.doc.lines * pc);
    } else if (ln && sign) {
      line = line * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
    view.dispatch({
      effects: dialogEffect.of(false),
      selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
      scrollIntoView: true
    });
    view.focus();
  }
  return {dom, pos: -10};
}
var dialogEffect = /* @__PURE__ */ StateEffect.define();
var dialogField = /* @__PURE__ */ StateField.define({
  create() {
    return true;
  },
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(dialogEffect))
        value = e.value;
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
});
var gotoLine = (view) => {
  let panel = getPanel(view, createLineDialog);
  if (!panel) {
    let effects = [dialogEffect.of(true)];
    if (view.state.field(dialogField, false) == null)
      effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));
    view.dispatch({effects});
    panel = getPanel(view, createLineDialog);
  }
  if (panel)
    panel.dom.querySelector("input").focus();
  return true;
};
var baseTheme$1 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": {fontSize: "80%"}
  }
});
var defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100
};
var highlightConfig = /* @__PURE__ */ Facet.define({
  combine(options2) {
    return combineConfig(options2, defaultHighlightOptions, {
      highlightWordAroundCursor: (a, b) => a || b,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function highlightSelectionMatches(options2) {
  let ext = [defaultTheme, matchHighlighter];
  if (options2)
    ext.push(highlightConfig.of(options2));
  return ext;
}
var matchDeco = /* @__PURE__ */ Decoration.mark({class: "cm-selectionMatch"});
var mainMatchDeco = /* @__PURE__ */ Decoration.mark({class: "cm-selectionMatch cm-selectionMatch-main"});
var matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.selectionSet || update.docChanged || update.viewportChanged)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let {state} = view, sel = state.selection;
    if (sel.ranges.length > 1)
      return Decoration.none;
    let range = sel.main, query, check = null;
    if (range.empty) {
      if (!conf.highlightWordAroundCursor)
        return Decoration.none;
      let word = state.wordAt(range.head);
      if (!word)
        return Decoration.none;
      check = state.charCategorizer(range.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range.to - range.from;
      if (len < conf.minSelectionLength || len > 200)
        return Decoration.none;
      query = state.sliceDoc(range.from, range.to).trim();
      if (!query)
        return Decoration.none;
    }
    let deco = [];
    for (let part of view.visibleRanges) {
      let cursor = new SearchCursor(state.doc, query, part.from, part.to);
      while (!cursor.nextOverlapping().done) {
        let {from, to} = cursor.value;
        if (!check || (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word)) {
          if (check && from <= range.from && to >= range.to)
            deco.push(mainMatchDeco.range(from, to));
          else if (from >= range.to || to <= range.from)
            deco.push(matchDeco.range(from, to));
          if (deco.length > conf.maxMatches)
            return Decoration.none;
        }
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-selectionMatch": {backgroundColor: "#99ff7780"},
  ".cm-searchMatch .cm-selectionMatch": {backgroundColor: "transparent"}
});
var selectWord = ({state, dispatch}) => {
  let {selection} = state;
  let newSel = EditorSelection.create(selection.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);
  if (newSel.eq(selection))
    return false;
  dispatch(state.update({selection: newSel}));
  return true;
};
function findNextOccurrence(state, query) {
  let {ranges} = state.selection;
  let ahead = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to).next();
  if (!ahead.done)
    return ahead.value;
  let cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
  while (!cursor.next().done) {
    if (!ranges.some((r) => r.from === cursor.value.from))
      return cursor.value;
  }
  return null;
}
var selectNextOccurrence = ({state, dispatch}) => {
  let {ranges} = state.selection;
  if (ranges.some((sel) => sel.from === sel.to))
    return selectWord({state, dispatch});
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
  if (state.selection.ranges.some((r) => state.sliceDoc(r.from, r.to) != searchedText))
    return false;
  let range = findNextOccurrence(state, searchedText);
  if (!range)
    return false;
  dispatch(state.update({
    selection: state.selection.addRange(EditorSelection.range(range.from, range.to)),
    scrollIntoView: true
  }));
  return true;
};
var Query = class {
  constructor(search, replace, caseInsensitive) {
    this.search = search;
    this.replace = replace;
    this.caseInsensitive = caseInsensitive;
  }
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseInsensitive == other.caseInsensitive && this.constructor == other.constructor;
  }
};
var StringQuery = class extends Query {
  constructor(search, replace, caseInsensitive) {
    super(search, replace, caseInsensitive);
    this.unquoted = search.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  cursor(doc2, from = 0, to = doc2.length) {
    return new SearchCursor(doc2, this.unquoted, from, to, this.caseInsensitive ? (x) => x.toLowerCase() : void 0);
  }
  nextMatch(doc2, curFrom, curTo) {
    let cursor = this.cursor(doc2, curTo).nextOverlapping();
    if (cursor.done)
      cursor = this.cursor(doc2, 0, curFrom).nextOverlapping();
    return cursor.done ? null : cursor.value;
  }
  prevMatchInRange(doc2, from, to) {
    for (let pos = to; ; ) {
      let start = Math.max(from, pos - 1e4 - this.unquoted.length);
      let cursor = this.cursor(doc2, start, pos), range = null;
      while (!cursor.nextOverlapping().done)
        range = cursor.value;
      if (range)
        return range;
      if (start == from)
        return null;
      pos -= 1e4;
    }
  }
  prevMatch(doc2, curFrom, curTo) {
    return this.prevMatchInRange(doc2, 0, curFrom) || this.prevMatchInRange(doc2, curTo, doc2.length);
  }
  getReplacement(_result) {
    return this.replace;
  }
  matchAll(doc2, limit) {
    let cursor = this.cursor(doc2), ranges = [];
    while (!cursor.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor.value);
    }
    return ranges;
  }
  highlight(doc2, from, to, add2) {
    let cursor = this.cursor(doc2, Math.max(0, from - this.unquoted.length), Math.min(to + this.unquoted.length, doc2.length));
    while (!cursor.next().done)
      add2(cursor.value.from, cursor.value.to);
  }
  get valid() {
    return !!this.search;
  }
};
var RegExpQuery = class extends Query {
  constructor(search, replace, caseInsensitive) {
    super(search, replace, caseInsensitive);
    this.valid = !!search && validRegExp(search);
  }
  cursor(doc2, from = 0, to = doc2.length) {
    return new RegExpCursor(doc2, this.search, this.caseInsensitive ? {ignoreCase: true} : void 0, from, to);
  }
  nextMatch(doc2, curFrom, curTo) {
    let cursor = this.cursor(doc2, curTo).next();
    if (cursor.done)
      cursor = this.cursor(doc2, 0, curFrom).next();
    return cursor.done ? null : cursor.value;
  }
  prevMatchInRange(doc2, from, to) {
    for (let size = 1; ; size++) {
      let start = Math.max(from, to - size * 1e4);
      let cursor = this.cursor(doc2, start, to), range = null;
      while (!cursor.next().done)
        range = cursor.value;
      if (range && (start == from || range.from > start + 10))
        return range;
      if (start == from)
        return null;
    }
  }
  prevMatch(doc2, curFrom, curTo) {
    return this.prevMatchInRange(doc2, 0, curFrom) || this.prevMatchInRange(doc2, curTo, doc2.length);
  }
  getReplacement(result) {
    return this.replace.replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$" : i == "&" ? result.match[0] : i != "0" && +i < result.match.length ? result.match[i] : m);
  }
  matchAll(doc2, limit) {
    let cursor = this.cursor(doc2), ranges = [];
    while (!cursor.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor.value);
    }
    return ranges;
  }
  highlight(doc2, from, to, add2) {
    let cursor = this.cursor(doc2, Math.max(0, from - 250), Math.min(to + 250, doc2.length));
    while (!cursor.next().done)
      add2(cursor.value.from, cursor.value.to);
  }
};
var setQuery = /* @__PURE__ */ StateEffect.define();
var togglePanel = /* @__PURE__ */ StateEffect.define();
var searchState = /* @__PURE__ */ StateField.define({
  create() {
    return new SearchState(new StringQuery("", "", false), createSearchPanel);
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setQuery))
        value = new SearchState(effect.value, value.panel);
      else if (effect.is(togglePanel))
        value = new SearchState(value.query, effect.value ? createSearchPanel : null);
    }
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val.panel)
});
var SearchState = class {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }
};
var matchMark = /* @__PURE__ */ Decoration.mark({class: "cm-searchMatch"});
var selectedMatchMark = /* @__PURE__ */ Decoration.mark({class: "cm-searchMatch cm-searchMatch-selected"});
var searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }
  update(update) {
    let state = update.state.field(searchState);
    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet)
      this.decorations = this.highlight(state);
  }
  highlight({query, panel}) {
    if (!panel || !query.valid)
      return Decoration.none;
    let {view} = this;
    let builder = new RangeSetBuilder();
    for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
      let {from, to} = ranges[i];
      while (i < l - 1 && to > ranges[i + 1].from - 2 * 250)
        to = ranges[++i].to;
      query.highlight(view.state.doc, from, to, (from2, to2) => {
        let selected = view.state.selection.ranges.some((r) => r.from == from2 && r.to == to2);
        builder.add(from2, to2, selected ? selectedMatchMark : matchMark);
      });
    }
    return builder.finish();
  }
}, {
  decorations: (v) => v.decorations
});
function searchCommand(f) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.valid ? f(view, state) : openSearchPanel(view);
  };
}
var findNext = /* @__PURE__ */ searchCommand((view, {query}) => {
  let {from, to} = view.state.selection.main;
  let next = query.nextMatch(view.state.doc, from, to);
  if (!next || next.from == from && next.to == to)
    return false;
  view.dispatch({
    selection: {anchor: next.from, head: next.to},
    scrollIntoView: true,
    effects: announceMatch(view, next)
  });
  return true;
});
var findPrevious = /* @__PURE__ */ searchCommand((view, {query}) => {
  let {state} = view, {from, to} = state.selection.main;
  let range = query.prevMatch(state.doc, from, to);
  if (!range)
    return false;
  view.dispatch({
    selection: {anchor: range.from, head: range.to},
    scrollIntoView: true,
    effects: announceMatch(view, range)
  });
  return true;
});
var selectMatches = /* @__PURE__ */ searchCommand((view, {query}) => {
  let ranges = query.matchAll(view.state.doc, 1e3);
  if (!ranges || !ranges.length)
    return false;
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to)))
  });
  return true;
});
var selectSelectionMatches = ({state, dispatch}) => {
  let sel = state.selection;
  if (sel.ranges.length > 1 || sel.main.empty)
    return false;
  let {from, to} = sel.main;
  let ranges = [], main = 0;
  for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur2.next().done; ) {
    if (ranges.length > 1e3)
      return false;
    if (cur2.value.from == from)
      main = ranges.length;
    ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
  }
  dispatch(state.update({selection: EditorSelection.create(ranges, main)}));
  return true;
};
var replaceNext = /* @__PURE__ */ searchCommand((view, {query}) => {
  let {state} = view, {from, to} = state.selection.main;
  let next = query.nextMatch(state.doc, from, from);
  if (!next)
    return false;
  let changes = [], selection, replacement;
  if (next.from == from && next.to == to) {
    replacement = state.toText(query.getReplacement(next));
    changes.push({from: next.from, to: next.to, insert: replacement});
    next = query.nextMatch(state.doc, next.from, next.to);
  }
  if (next) {
    let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
    selection = {anchor: next.from - off, head: next.to - off};
  }
  view.dispatch({
    changes,
    selection,
    scrollIntoView: !!selection,
    effects: next ? announceMatch(view, next) : void 0
  });
  return true;
});
var replaceAll = /* @__PURE__ */ searchCommand((view, {query}) => {
  let changes = query.matchAll(view.state.doc, 1e9).map((match) => {
    let {from, to} = match;
    return {from, to, insert: query.getReplacement(match)};
  });
  if (!changes.length)
    return false;
  view.dispatch({changes});
  return true;
});
function createSearchPanel(view) {
  let {query} = view.state.field(searchState);
  return {
    dom: buildPanel({
      view,
      query,
      updateQuery(q) {
        if (!query.eq(q)) {
          query = q;
          view.dispatch({effects: setQuery.of(query)});
        }
      }
    }),
    mount() {
      this.dom.querySelector("[name=search]").select();
    },
    pos: 80
  };
}
var openSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (state && state.panel) {
    let panel = getPanel(view, createSearchPanel);
    if (!panel)
      return false;
    panel.dom.querySelector("[name=search]").focus();
  } else {
    view.dispatch({effects: [togglePanel.of(true), ...state ? [] : [StateEffect.appendConfig.of(searchExtensions)]]});
  }
  return true;
};
var closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel)
    return false;
  let panel = getPanel(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement))
    view.focus();
  view.dispatch({effects: togglePanel.of(false)});
  return true;
};
var searchKeymap = [
  {key: "Mod-f", run: openSearchPanel, scope: "editor search-panel"},
  {key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel"},
  {key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel"},
  {key: "Escape", run: closeSearchPanel, scope: "editor search-panel"},
  {key: "Mod-Shift-l", run: selectSelectionMatches},
  {key: "Alt-g", run: gotoLine},
  {key: "Mod-d", run: selectNextOccurrence}
];
function buildPanel(conf) {
  function phrase(phrase2) {
    return conf.view.state.phrase(phrase2);
  }
  let searchField = crelt("input", {
    value: conf.query.search,
    placeholder: phrase("Find"),
    "aria-label": phrase("Find"),
    class: "cm-textfield",
    name: "search",
    onchange: update,
    onkeyup: update
  });
  let replaceField = crelt("input", {
    value: conf.query.replace,
    placeholder: phrase("Replace"),
    "aria-label": phrase("Replace"),
    class: "cm-textfield",
    name: "replace",
    onchange: update,
    onkeyup: update
  });
  let caseField = crelt("input", {
    type: "checkbox",
    name: "case",
    checked: !conf.query.caseInsensitive,
    onchange: update
  });
  let reField = crelt("input", {
    type: "checkbox",
    name: "re",
    checked: conf.query instanceof RegExpQuery,
    onchange: update
  });
  function update() {
    conf.updateQuery(new (reField.checked ? RegExpQuery : StringQuery)(searchField.value, replaceField.value, !caseField.checked));
  }
  function keydown(e) {
    if (runScopeHandlers(conf.view, e, "search-panel")) {
      e.preventDefault();
    } else if (e.keyCode == 13 && e.target == searchField) {
      e.preventDefault();
      (e.shiftKey ? findPrevious : findNext)(conf.view);
    } else if (e.keyCode == 13 && e.target == replaceField) {
      e.preventDefault();
      replaceNext(conf.view);
    }
  }
  function button(name2, onclick, content2) {
    return crelt("button", {class: "cm-button", name: name2, onclick}, content2);
  }
  let panel = crelt("div", {onkeydown: keydown, class: "cm-search"}, [
    searchField,
    button("next", () => findNext(conf.view), [phrase("next")]),
    button("prev", () => findPrevious(conf.view), [phrase("previous")]),
    button("select", () => selectMatches(conf.view), [phrase("all")]),
    crelt("label", null, [caseField, phrase("match case")]),
    crelt("label", null, [reField, phrase("regexp")]),
    crelt("br"),
    replaceField,
    button("replace", () => replaceNext(conf.view), [phrase("replace")]),
    button("replaceAll", () => replaceAll(conf.view), [phrase("replace all")]),
    crelt("button", {name: "close", onclick: () => closeSearchPanel(conf.view), "aria-label": phrase("close")}, ["\xD7"])
  ]);
  return panel;
}
var AnnounceMargin = 30;
var Break = /[\s\.,:;?!]/;
function announceMatch(view, {from, to}) {
  let lineStart = view.state.doc.lineAt(from).from, lineEnd = view.state.doc.lineAt(to).to;
  let start = Math.max(lineStart, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
  let text = view.state.sliceDoc(start, end);
  if (start != lineStart) {
    for (let i = 0; i < AnnounceMargin; i++)
      if (!Break.test(text[i + 1]) && Break.test(text[i])) {
        text = text.slice(i);
        break;
      }
  }
  if (end != lineEnd) {
    for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
      if (!Break.test(text[i - 1]) && Break.test(text[i])) {
        text = text.slice(0, i);
        break;
      }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${view.state.doc.lineAt(from).number}`);
}
var baseTheme8 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": {backgroundColor: "#ffff0054"},
  "&dark .cm-searchMatch": {backgroundColor: "#00ffff8a"},
  "&light .cm-searchMatch-selected": {backgroundColor: "#ff6a0054"},
  "&dark .cm-searchMatch-selected": {backgroundColor: "#ff00ff8a"}
});
var searchExtensions = [
  searchState,
  /* @__PURE__ */ Prec.override(searchHighlighter),
  baseTheme8
];

// node_modules/@codemirror/comment/dist/index.js
var toggleComment = (target) => {
  let config2 = getConfig(target.state);
  return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockComment(target) : false;
};
function command(f, option) {
  return ({state, dispatch}) => {
    let tr = f(option, state.selection.ranges, state);
    if (!tr)
      return false;
    dispatch(state.update(tr));
    return true;
  };
}
var toggleLineComment = /* @__PURE__ */ command(changeLineComment, 0);
var toggleBlockComment = /* @__PURE__ */ command(changeBlockComment, 0);
var commentKeymap = [
  {key: "Mod-/", run: toggleComment},
  {key: "Alt-A", run: toggleBlockComment}
];
function getConfig(state, pos = state.selection.main.head) {
  let data = state.languageDataAt("commentTokens", pos);
  return data.length ? data[0] : {};
}
var SearchMargin = 50;
function findBlockComment(state, {open, close}, from, to) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: {pos: from - spaceBefore, margin: spaceBefore && 1},
      close: {pos: to + spaceAfter, margin: spaceAfter && 1}
    };
  }
  let startText, endText;
  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function changeBlockComment(option, ranges, state) {
  let tokens = ranges.map((r) => getConfig(state, r.from).block);
  if (!tokens.every((c) => c))
    return null;
  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
  if (option != 2 && !comments.every((c) => c)) {
    let index2 = 0;
    return state.changeByRange((range) => {
      let {open, close} = tokens[index2++];
      if (comments[index2])
        return {range};
      let shift2 = open.length + 1;
      return {
        changes: [{from: range.from, insert: open + " "}, {from: range.to, insert: " " + close}],
        range: EditorSelection.range(range.anchor + shift2, range.head + shift2)
      };
    });
  } else if (option != 1 && comments.some((c) => c)) {
    let changes = [];
    for (let i = 0, comment2; i < comments.length; i++)
      if (comment2 = comments[i]) {
        let token = tokens[i], {open, close} = comment2;
        changes.push({from: open.pos - token.open.length, to: open.pos + open.margin}, {from: close.pos - close.margin, to: close.pos + token.close.length});
      }
    return {changes};
  }
  return null;
}
function changeLineComment(option, ranges, state) {
  let lines = [];
  let prevLine = -1;
  for (let {from, to} of ranges) {
    let startI = lines.length, minIndent = 1e9;
    for (let pos = from; pos <= to; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from;
        let token = getConfig(state, pos).line;
        if (!token)
          continue;
        let indent = /^\s*/.exec(line.text)[0].length;
        let empty3 = indent == line.length;
        let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
        if (indent < line.text.length && indent < minIndent)
          minIndent = indent;
        lines.push({line, comment: comment2, token, indent, empty: empty3, single: false});
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i = startI; i < lines.length; i++)
        if (lines[i].indent < lines[i].line.text.length)
          lines[i].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
    let changes = [];
    for (let {line, token, indent, empty: empty3, single} of lines)
      if (single || !empty3)
        changes.push({from: line.from + indent, insert: token + " "});
    let changeSet = state.changes(changes);
    return {changes: changeSet, selection: state.selection.map(changeSet, 1)};
  } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
    let changes = [];
    for (let {line, comment: comment2, token} of lines)
      if (comment2 >= 0) {
        let from = line.from + comment2, to = from + token.length;
        if (line.text[to - line.from] == " ")
          to++;
        changes.push({from, to});
      }
    return {changes};
  }
  return null;
}

// node_modules/@codemirror/rectangular-selection/dist/index.js
var MaxOff = 2e3;
function rectangleFor(state, a, b) {
  let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
  let ranges = [];
  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
    let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      if (line.length <= endOff)
        ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
    }
  } else {
    let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i), str = line.length > MaxOff ? line.text.slice(0, 2 * endCol) : line.text;
      let start = findColumn(str, 0, startCol, state.tabSize), end = findColumn(str, 0, endCol, state.tabSize);
      if (!start.leftOver)
        ranges.push(EditorSelection.range(line.from + start.offset, line.from + end.offset));
    }
  }
  return ranges;
}
function absoluteColumn(view, x) {
  let ref = view.coordsAtPos(view.viewport.from);
  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
  let offset = view.posAtCoords({x: event.clientX, y: event.clientY});
  if (offset == null)
    return null;
  let line = view.state.doc.lineAt(offset), off = offset - line.from;
  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text.slice(0, offset - line.from), 0, view.state.tabSize);
  return {line: line.number, col, off};
}
function rectangleSelectionStyle(view, event) {
  let start = getPos(view, event), startSel = view.state.selection;
  if (!start)
    return null;
  return {
    update(update) {
      if (update.docChanged) {
        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
        let newLine = update.state.doc.lineAt(newStart);
        start = {line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length)};
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, _extend, multiple) {
      let cur2 = getPos(view, event2);
      if (!cur2)
        return startSel;
      let ranges = rectangleFor(view.state, start, cur2);
      if (!ranges.length)
        return startSel;
      if (multiple)
        return EditorSelection.create(ranges.concat(startSel.ranges));
      else
        return EditorSelection.create(ranges);
    }
  };
}
function rectangularSelection(options2) {
  let filter = (options2 === null || options2 === void 0 ? void 0 : options2.eventFilter) || ((e) => e.altKey && e.button == 0);
  return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}

// node_modules/@codemirror/lint/dist/index.js
var SelectedDiagnostic = class {
  constructor(from, to, diagnostic) {
    this.from = from;
    this.to = to;
    this.diagnostic = diagnostic;
  }
};
var LintState = class {
  constructor(diagnostics, panel, selected) {
    this.diagnostics = diagnostics;
    this.panel = panel;
    this.selected = selected;
  }
  static init(diagnostics, panel) {
    let ranges = Decoration.set(diagnostics.map((d) => {
      return d.from < d.to ? Decoration.mark({
        attributes: {class: "cm-lintRange cm-lintRange-" + d.severity},
        diagnostic: d
      }).range(d.from, d.to) : Decoration.widget({
        widget: new DiagnosticWidget(d),
        diagnostic: d
      }).range(d.from);
    }));
    return new LintState(ranges, panel, findDiagnostic(ranges));
  }
};
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from, to, {spec}) => {
    if (diagnostic && spec.diagnostic != diagnostic)
      return;
    found = new SelectedDiagnostic(from, to, spec.diagnostic);
    return false;
  });
  return found;
}
function maybeEnableLint(state, effects, diagnostics) {
  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of([
    diagnostics ? lintState.init(() => LintState.init(diagnostics, null)) : lintState,
    EditorView.decorations.compute([lintState], (state2) => {
      let {selected, panel} = state2.field(lintState);
      return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
        activeMark.range(selected.from, selected.to)
      ]);
    }),
    hoverTooltip(lintTooltip),
    baseTheme9
  ]));
}
var setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
var togglePanel2 = /* @__PURE__ */ StateEffect.define();
var movePanelSelection = /* @__PURE__ */ StateEffect.define();
var lintState = /* @__PURE__ */ StateField.define({
  create() {
    return new LintState(Decoration.none, null, null);
  },
  update(value, tr) {
    if (tr.docChanged) {
      let mapped = value.diagnostics.map(tr.changes), selected = null;
      if (value.selected) {
        let selPos = tr.changes.mapPos(value.selected.from, 1);
        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
      }
      value = new LintState(mapped, value.panel, selected);
    }
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        value = LintState.init(effect.value, value.panel);
      } else if (effect.is(togglePanel2)) {
        value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
      } else if (effect.is(movePanelSelection)) {
        value = new LintState(value.diagnostics, value.panel, effect.value);
      }
    }
    return value;
  },
  provide: (f) => [
    showPanel.from(f, (val) => val.panel),
    EditorView.decorations.from(f, (s2) => s2.diagnostics)
  ]
});
var activeMark = /* @__PURE__ */ Decoration.mark({class: "cm-lintRange cm-lintRange-active"});
function lintTooltip(view, pos, side) {
  let {diagnostics} = view.state.field(lintState);
  let found = [], stackStart = 2e8, stackEnd = 0;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, {spec}) => {
    if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
      found.push(spec.diagnostic);
      stackStart = Math.min(from, stackStart);
      stackEnd = Math.max(to, stackEnd);
    }
  });
  if (!found.length)
    return null;
  return {
    pos: stackStart,
    end: stackEnd,
    above: view.state.doc.lineAt(stackStart).to < stackEnd,
    create() {
      return {dom: crelt("ul", {class: "cm-tooltip-lint"}, found.map((d) => renderDiagnostic(view, d, false)))};
    }
  };
}
var openLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    view.dispatch({effects: maybeEnableLint(view.state, [togglePanel2.of(true)])});
  let panel = getPanel(view, LintPanel.open);
  if (panel)
    panel.dom.querySelector(".cm-panel-lint ul").focus();
  return true;
};
var closeLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    return false;
  view.dispatch({effects: togglePanel2.of(false)});
  return true;
};
var nextDiagnostic = (view) => {
  let field = view.state.field(lintState, false);
  if (!field)
    return false;
  let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
  if (!next.value) {
    next = field.diagnostics.iter(0);
    if (!next.value || next.from == sel.from && next.to == sel.to)
      return false;
  }
  view.dispatch({selection: {anchor: next.from, head: next.to}, scrollIntoView: true});
  return true;
};
var lintKeymap = [
  {key: "Mod-Shift-m", run: openLintPanel},
  {key: "F8", run: nextDiagnostic}
];
function assignKeys(actions) {
  let assigned = [];
  if (actions)
    actions:
      for (let {name: name2} of actions) {
        for (let i = 0; i < name2.length; i++) {
          let ch = name2[i];
          if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
            assigned.push(ch);
            continue actions;
          }
        }
        assigned.push("");
      }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a;
  let keys = inPanel ? assignKeys(diagnostic.actions) : [];
  return crelt("li", {class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity}, crelt("span", {class: "cm-diagnosticText"}, diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {
    let click = (e) => {
      e.preventDefault();
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found)
        action.apply(view, found.from, found.to);
    };
    let {name: name2} = action, keyIndex = keys[i] ? name2.indexOf(keys[i]) : -1;
    let nameElt = keyIndex < 0 ? name2 : [
      name2.slice(0, keyIndex),
      crelt("u", name2.slice(keyIndex, keyIndex + 1)),
      name2.slice(keyIndex + 1)
    ];
    return crelt("button", {
      class: "cm-diagnosticAction",
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys[i]})"`}.`
    }, nameElt);
  }), diagnostic.source && crelt("div", {class: "cm-diagnosticSource"}, diagnostic.source));
}
var DiagnosticWidget = class extends WidgetType {
  constructor(diagnostic) {
    super();
    this.diagnostic = diagnostic;
  }
  eq(other) {
    return other.diagnostic == this.diagnostic;
  }
  toDOM() {
    return crelt("span", {class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity});
  }
};
var PanelItem = class {
  constructor(view, diagnostic) {
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  }
};
var LintPanel = class {
  constructor(view) {
    this.view = view;
    this.items = [];
    let onkeydown = (event) => {
      if (event.keyCode == 27) {
        closeLintPanel(this.view);
        this.view.focus();
      } else if (event.keyCode == 38 || event.keyCode == 33) {
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      } else if (event.keyCode == 40 || event.keyCode == 34) {
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      } else if (event.keyCode == 36) {
        this.moveSelection(0);
      } else if (event.keyCode == 35) {
        this.moveSelection(this.items.length - 1);
      } else if (event.keyCode == 13) {
        this.view.focus();
      } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.items.length) {
        let {diagnostic} = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
        for (let i = 0; i < keys.length; i++)
          if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {
            let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
            if (found)
              diagnostic.actions[i].apply(view, found.from, found.to);
          }
      } else {
        return;
      }
      event.preventDefault();
    };
    let onclick = (event) => {
      for (let i = 0; i < this.items.length; i++) {
        if (this.items[i].dom.contains(event.target))
          this.moveSelection(i);
      }
    };
    this.list = crelt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown,
      onclick
    });
    this.dom = crelt("div", {class: "cm-panel-lint"}, this.list, crelt("button", {
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => closeLintPanel(this.view)
    }, "\xD7"));
    this.update();
  }
  get selectedIndex() {
    let selected = this.view.state.field(lintState).selected;
    if (!selected)
      return -1;
    for (let i = 0; i < this.items.length; i++)
      if (this.items[i].diagnostic == selected.diagnostic)
        return i;
    return -1;
  }
  update() {
    let {diagnostics, selected} = this.view.state.field(lintState);
    let i = 0, needsSync = false, newSelectedItem = null;
    diagnostics.between(0, this.view.state.doc.length, (_start, _end, {spec}) => {
      let found = -1, item;
      for (let j = i; j < this.items.length; j++)
        if (this.items[j].diagnostic == spec.diagnostic) {
          found = j;
          break;
        }
      if (found < 0) {
        item = new PanelItem(this.view, spec.diagnostic);
        this.items.splice(i, 0, item);
        needsSync = true;
      } else {
        item = this.items[found];
        if (found > i) {
          this.items.splice(i, found - i);
          needsSync = true;
        }
      }
      if (selected && item.diagnostic == selected.diagnostic) {
        if (!item.dom.hasAttribute("aria-selected")) {
          item.dom.setAttribute("aria-selected", "true");
          newSelectedItem = item;
        }
      } else if (item.dom.hasAttribute("aria-selected")) {
        item.dom.removeAttribute("aria-selected");
      }
      i++;
    });
    while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
      needsSync = true;
      this.items.pop();
    }
    if (this.items.length == 0) {
      this.items.push(new PanelItem(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      }));
      needsSync = true;
    }
    if (newSelectedItem) {
      this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
      this.view.requestMeasure({
        key: this,
        read: () => ({sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect()}),
        write: ({sel, panel}) => {
          if (sel.top < panel.top)
            this.list.scrollTop -= panel.top - sel.top;
          else if (sel.bottom > panel.bottom)
            this.list.scrollTop += sel.bottom - panel.bottom;
        }
      });
    } else if (!this.items.length) {
      this.list.removeAttribute("aria-activedescendant");
    }
    if (needsSync)
      this.sync();
  }
  sync() {
    let domPos = this.list.firstChild;
    function rm3() {
      let prev = domPos;
      domPos = prev.nextSibling;
      prev.remove();
    }
    for (let item of this.items) {
      if (item.dom.parentNode == this.list) {
        while (domPos != item.dom)
          rm3();
        domPos = item.dom.nextSibling;
      } else {
        this.list.insertBefore(item.dom, domPos);
      }
    }
    while (domPos)
      rm3();
  }
  moveSelection(selectedIndex) {
    if (this.items.length == 0)
      return;
    let field = this.view.state.field(lintState);
    let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
    if (!selection)
      return;
    this.view.dispatch({
      selection: {anchor: selection.from, head: selection.to},
      scrollIntoView: true,
      effects: movePanelSelection.of(selection)
    });
  }
  static open(view) {
    return new LintPanel(view);
  }
};
function underline(color) {
  if (typeof btoa != "function")
    return "none";
  let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="6" height="3">
    <path d="m0 3 l2 -2 l1 0 l2 2 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>
  </svg>`;
  return `url('data:image/svg+xml;base64,${btoa(svg)}')`;
}
var baseTheme9 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": {borderLeft: "5px solid #d11"},
  ".cm-diagnostic-warning": {borderLeft: "5px solid orange"},
  ".cm-diagnostic-info": {borderLeft: "5px solid #999"},
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x"
  },
  ".cm-lintRange-error": {backgroundImage: /* @__PURE__ */ underline("#d11")},
  ".cm-lintRange-warning": {backgroundImage: /* @__PURE__ */ underline("orange")},
  ".cm-lintRange-info": {backgroundImage: /* @__PURE__ */ underline("#999")},
  ".cm-lintRange-active": {backgroundColor: "#ffdd9980"},
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": {borderBottomColor: "orange"}
  },
  ".cm-lintPoint-info": {
    "&:after": {borderBottomColor: "#999"}
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": {textDecoration: "underline"}
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": {textDecoration: "none"},
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});

// node_modules/@codemirror/basic-setup/dist/index.js
var basicSetup = [
  /* @__PURE__ */ lineNumbers(),
  /* @__PURE__ */ highlightActiveLineGutter(),
  /* @__PURE__ */ highlightSpecialChars(),
  /* @__PURE__ */ history(),
  /* @__PURE__ */ foldGutter(),
  /* @__PURE__ */ drawSelection(),
  /* @__PURE__ */ EditorState.allowMultipleSelections.of(true),
  /* @__PURE__ */ indentOnInput(),
  defaultHighlightStyle.fallback,
  /* @__PURE__ */ bracketMatching(),
  /* @__PURE__ */ closeBrackets(),
  /* @__PURE__ */ autocompletion(),
  /* @__PURE__ */ rectangularSelection(),
  /* @__PURE__ */ highlightActiveLine(),
  /* @__PURE__ */ highlightSelectionMatches(),
  /* @__PURE__ */ keymap.of([
    ...closeBracketsKeymap,
    ...defaultKeymap,
    ...searchKeymap,
    ...historyKeymap,
    ...foldKeymap,
    ...commentKeymap,
    ...completionKeymap,
    ...lintKeymap
  ])
];

// .svelte-kit/output/server/app.js
var css$3 = {
  code: "#svelte-announcer.svelte-9z6sc{position:absolute;left:0;top:0;clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n</script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}/>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>\\n\\t#svelte-announcer {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\ttop: 0;\\n\\t\\tclip: rect(0 0 0 0);\\n\\t\\t-webkit-clip-path: inset(50%);\\n\\t\\t        clip-path: inset(50%);\\n\\t\\toverflow: hidden;\\n\\t\\twhite-space: nowrap;\\n\\t\\twidth: 1px;\\n\\t\\theight: 1px;\\n\\t}</style>"],"names":[],"mappings":"AAsDC,iBAAiB,aAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnB,iBAAiB,CAAE,MAAM,GAAG,CAAC,CACrB,SAAS,CAAE,MAAM,GAAG,CAAC,CAC7B,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACZ,CAAC"}`
};
var Root$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {stores} = $$props;
  let {page} = $$props;
  let {components} = $$props;
  let {props_0 = null} = $$props;
  let {props_1 = null} = $$props;
  let {props_2 = null} = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  let mounted = false;
  let navigated = false;
  let title = null;
  onMount(() => {
    const unsubscribe = stores.page.subscribe(() => {
      if (mounted) {
        navigated = true;
        title = document.title || "untitled page";
      }
    });
    mounted = true;
    return unsubscribe;
  });
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  $$result.css.add(css$3);
  {
    stores.page.set(page);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
    })}` : ``}`
  })}

${mounted ? `<div id="${"svelte-announcer"}" aria-live="${"assertive"}" aria-atomic="${"true"}" class="${"svelte-9z6sc"}">${navigated ? `${escape2(title)}` : ``}</div>` : ``}`;
});
function set_paths(paths) {
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var template2 = ({head, body}) => '<!DOCTYPE html>\r\n<html lang="en">\r\n	<head>\r\n		<meta charset="utf-8" />\r\n		<link rel="icon" href="/favicon.ico" />\r\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\r\n		' + head + '\r\n	</head>\r\n	<body class="min-w-full">\r\n		<div id="svelte">' + body + "</div>\r\n	</body>\r\n</html>\r\n";
var options = null;
function init(settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: "/./_app/start-33dd441c.js",
      css: ["/./_app/assets/start-9aa571ba.css", "/./_app/assets/vendor-981ad568.css"],
      js: ["/./_app/start-33dd441c.js", "/./_app/chunks/vendor-628176ef.js", "/./_app/chunks/singletons-bb9012b7.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => "/./_app/" + entry_lookup[id],
    get_stack: (error22) => String(error22),
    handle_error: (error22) => {
      console.error(error22.stack);
      error22.stack = options.get_stack(error22);
    },
    hooks: get_hooks(user_hooks),
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    read: settings.read,
    root: Root$1,
    router: true,
    ssr: true,
    target: "#svelte",
    template: template2,
    trailing_slash: "never"
  };
}
var empty2 = () => ({});
var manifest = {
  assets: [{"file": "favicon.ico", "size": 1150, "type": "image/vnd.microsoft.icon"}, {"file": "images/svg/Mobile login-pana.svg", "size": 24330, "type": "image/svg+xml"}, {"file": "images/svg/Teaching-rafiki.svg", "size": 36938, "type": "image/svg+xml"}, {"file": "images/svg/Telecommuting-cuate.svg", "size": 126575, "type": "image/svg+xml"}, {"file": "robots.txt", "size": 70, "type": "text/plain"}],
  layout: "src/routes/__layout.svelte",
  error: ".svelte-kit/build/components/error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty2,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/projects\/?$/,
      params: empty2,
      a: ["src/routes/__layout.svelte", "src/routes/projects.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/pricing\/?$/,
      params: empty2,
      a: ["src/routes/__layout.svelte", "src/routes/pricing.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/editor\/?$/,
      params: empty2,
      a: ["src/routes/__layout.svelte", "src/routes/editor.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/signin\/?$/,
      params: empty2,
      a: ["src/routes/__layout.svelte", "src/routes/signin.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/login\/?$/,
      params: empty2,
      a: ["src/routes/__layout.svelte", "src/routes/login.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/api\/?$/,
      params: empty2,
      load: () => Promise.resolve().then(function() {
        return index$1;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/signup\/?$/,
      params: empty2,
      load: () => Promise.resolve().then(function() {
        return signup;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/login\/?$/,
      params: empty2,
      load: () => Promise.resolve().then(function() {
        return login$1;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/users\/?$/,
      params: empty2,
      load: () => Promise.resolve().then(function() {
        return users;
      })
    }
  ]
};
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({request, render: render2}) => render2(request))
});
var module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(function() {
    return error2;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index;
  }),
  "src/routes/projects.svelte": () => Promise.resolve().then(function() {
    return projects;
  }),
  "src/routes/pricing.svelte": () => Promise.resolve().then(function() {
    return pricing;
  }),
  "src/routes/editor.svelte": () => Promise.resolve().then(function() {
    return editor;
  }),
  "src/routes/signin.svelte": () => Promise.resolve().then(function() {
    return signin;
  }),
  "src/routes/login.svelte": () => Promise.resolve().then(function() {
    return login;
  })
};
var metadata_lookup = {"src/routes/__layout.svelte": {"entry": "/./_app/pages/__layout.svelte-84f6fe61.js", "css": ["/./_app/assets/pages/__layout.svelte-17e66a27.css", "/./_app/assets/vendor-981ad568.css"], "js": ["/./_app/pages/__layout.svelte-84f6fe61.js", "/./_app/chunks/vendor-628176ef.js"], "styles": null}, ".svelte-kit/build/components/error.svelte": {"entry": "/./_app/error.svelte-91396150.js", "css": ["/./_app/assets/vendor-981ad568.css"], "js": ["/./_app/error.svelte-91396150.js", "/./_app/chunks/vendor-628176ef.js"], "styles": null}, "src/routes/index.svelte": {"entry": "/./_app/pages/index.svelte-62d66af1.js", "css": ["/./_app/assets/vendor-981ad568.css"], "js": ["/./_app/pages/index.svelte-62d66af1.js", "/./_app/chunks/vendor-628176ef.js", "/./_app/chunks/singletons-bb9012b7.js"], "styles": null}, "src/routes/projects.svelte": {"entry": "/./_app/pages/projects.svelte-690dd174.js", "css": ["/./_app/assets/vendor-981ad568.css"], "js": ["/./_app/pages/projects.svelte-690dd174.js", "/./_app/chunks/vendor-628176ef.js", "/./_app/chunks/Explorer-2b6c9f23.js"], "styles": null}, "src/routes/pricing.svelte": {"entry": "/./_app/pages/pricing.svelte-5a59e888.js", "css": ["/./_app/assets/vendor-981ad568.css"], "js": ["/./_app/pages/pricing.svelte-5a59e888.js", "/./_app/chunks/vendor-628176ef.js"], "styles": null}, "src/routes/editor.svelte": {"entry": "/./_app/pages/editor.svelte-395f19db.js", "css": ["/./_app/assets/pages/editor.svelte-6e7c7d17.css", "/./_app/assets/vendor-981ad568.css"], "js": ["/./_app/pages/editor.svelte-395f19db.js", "/./_app/chunks/vendor-628176ef.js", "/./_app/chunks/Explorer-2b6c9f23.js"], "styles": null}, "src/routes/signin.svelte": {"entry": "/./_app/pages/signin.svelte-9a88b05f.js", "css": ["/./_app/assets/vendor-981ad568.css"], "js": ["/./_app/pages/signin.svelte-9a88b05f.js", "/./_app/chunks/vendor-628176ef.js"], "styles": null}, "src/routes/login.svelte": {"entry": "/./_app/pages/login.svelte-fcaa072f.js", "css": ["/./_app/assets/vendor-981ad568.css"], "js": ["/./_app/pages/login.svelte-fcaa072f.js", "/./_app/chunks/vendor-628176ef.js"], "styles": null}};
async function load_component(file) {
  return {
    module: await module_lookup[file](),
    ...metadata_lookup[file]
  };
}
init({paths: {"base": "", "assets": "/."}});
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({...request, host}, options, {prerender});
}
async function get$1(params) {
  return {
    body: "server up and running"
  };
}
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$1
});
import_dotenv.default.config();
var {MongoClient} = import_mongodb.default;
var {MONGODB_URI, MONGODB_DB} = process.env;
if (!MONGODB_URI) {
  throw new Error("Please define the MONGODB_URI environment variable inside .env.local");
}
if (!MONGODB_DB) {
  throw new Error("Please define the MONGODB_DB environment variable inside .env.local");
}
var cached = global.mongo;
if (!cached) {
  cached = global.mongo = {conn: null, promise: null};
}
async function connectToDatabase() {
  if (cached.conn) {
    return cached.conn;
  }
  if (!cached.promise) {
    const opts = {
      useNewUrlParser: true,
      useUnifiedTopology: true
    };
    cached.promise = MongoClient.connect(MONGODB_URI, opts).then((client) => {
      return {
        client,
        db: client.db(MONGODB_DB)
      };
    });
  }
  cached.conn = await cached.promise;
  return cached.conn;
}
var ok = (body) => {
  return {status: 200, body};
};
var server_error = (body) => {
  return {status: 500, body};
};
var not_found = () => {
  return {status: 404, body: {message: "Usu\xE1rio n\xE3o encontrado"}};
};
var ErrorFactory = (err) => {
  if (err.message == "NotFound") {
    return not_found();
  }
  return server_error({message: err.message});
};
async function post$1(req) {
  try {
    const dbConnection = await connectToDatabase();
    const db = dbConnection.db;
    const collection = db.collection("user");
    const body = JSON.parse(req.body);
    const user = {
      name: body["user"],
      password: body["password"]
    };
    const already_exissts = await collection.findOne({name: body["user"]});
    if (already_exissts) {
      throw new Error("UserAlreadySignUp");
    }
    const result = await collection.insertOne(user);
    return ok({result: result.insertedId});
  } catch (err) {
    return ErrorFactory(err);
  }
}
var signup = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$1
});
async function post(req) {
  try {
    const dbConnection = await connectToDatabase();
    const db = dbConnection.db;
    const collection = db.collection("user");
    const body = JSON.parse(req.body);
    const user = await collection.findOne({name: body["user"]});
    if (user) {
      if (user.password == body["password"]) {
        return ok({id: user._id});
      } else {
        throw new Error("IncorrectPassword");
      }
    } else {
      throw new Error("NotFound");
    }
  } catch (err) {
    return ErrorFactory(err);
  }
}
var login$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post
});
async function get(req) {
  try {
    const dbConnection = await connectToDatabase();
    const db = dbConnection.db;
    const collection = db.collection("user");
    const user = await collection.find().toArray();
    return ok({users: user});
  } catch (err) {
    return ErrorFactory(err);
  }
}
var users = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get
});
var css$2 = {
  code: `*,*::before,*::after{box-sizing:border-box}:root{-moz-tab-size:4;-o-tab-size:4;tab-size:4}html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}body{font-family:system-ui,
		-apple-system, /* Firefox supports this but not yet \`system-ui\` */
		'Segoe UI',
		Roboto,
		Helvetica,
		Arial,
		sans-serif,
		'Apple Color Emoji',
		'Segoe UI Emoji'}hr{height:0;color:inherit}abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,
		SFMono-Regular,
		Consolas,
		'Liberation Mono',
		Menlo,
		monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}button,[type='button'],[type='reset'],[type='submit']{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type='search']{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}button{background-color:transparent;background-image:none}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}fieldset{margin:0;padding:0}ol,ul{list-style:none;margin:0;padding:0}html{font-family:ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";line-height:1.5}body{font-family:inherit;line-height:inherit}*,::before,::after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}hr{border-top-width:1px}img{border-style:solid}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input:-ms-input-placeholder,textarea:-ms-input-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role="button"]{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit}pre,code,kbd,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}*{--tw-shadow:0 0 #0000;--tw-ring-inset:var(--tw-empty,/*!*/ /*!*/);--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59, 130, 246, 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;scrollbar-color:initial;scrollbar-width:initial}.container{width:100%}@media(min-width: 640px){.container{max-width:640px}}@media(min-width: 768px){.container{max-width:768px}}@media(min-width: 1024px){.container{max-width:1024px}}@media(min-width: 1280px){.container{max-width:1280px}}@media(min-width: 1536px){.container{max-width:1536px}}.visible{visibility:visible}.relative{position:relative}.absolute{position:absolute}.static{position:static}.inset-y-0{top:0px;bottom:0px}.bottom-0{bottom:0px}.right-0{right:0px}.left-0{left:0px}.z-10{z-index:10}.-m-4{margin:-1rem}.m-auto{margin:auto}.m-2{margin:0.5rem}.mx-auto{margin-left:auto;margin-right:auto}.mb-4{margin-bottom:1rem}.mr-1{margin-right:0.25rem}.mr-4{margin-right:1rem}.mb-2{margin-bottom:0.5rem}.mb-8{margin-bottom:2rem}.mt-5{margin-top:1.25rem}.ml-2{margin-left:0.5rem}.mt-10{margin-top:2.5rem}.mb-20{margin-bottom:5rem}.mt-6{margin-top:1.5rem}.mt-3{margin-top:0.75rem}.mt-8{margin-top:2rem}.mb-3{margin-bottom:0.75rem}.ml-4{margin-left:1rem}.mb-5{margin-bottom:1.25rem}.mb-1{margin-bottom:0.25rem}.ml-1{margin-left:0.25rem}.mr-2{margin-right:0.5rem}.mt-auto{margin-top:auto}.ml-auto{margin-left:auto}.-mb-px{margin-bottom:-1px}.table{display:table}.table-cell{display:table-cell}.inline-block{display:inline-block}.flex{display:flex}.block{display:block}.inline-flex{display:inline-flex}.hidden{display:none}.h-10{height:2.5rem}.h-full{height:100%}.h-3{height:0.75rem}.h-6{height:1.5rem}.h-screen{height:100vh}.h-4{height:1rem}.h-16{height:4rem}.h-8{height:2rem}.w-10{width:2.5rem}.w-full{width:100%}.w-3{width:0.75rem}.w-6{width:1.5rem}.w-4{width:1rem}.w-16{width:4rem}.w-72{width:18rem}.w-9\\/12{width:75%}.w-8{width:2rem}.w-1\\/3{width:33.333333%}.w-56{width:14rem}.w-20{width:5rem}.w-60{width:15rem}.min-w-full{min-width:100%}.max-w-md{max-width:28rem}.max-w-sm{max-width:24rem}.flex-shrink-0{flex-shrink:0}.flex-shrink{flex-shrink:1}.flex-grow{flex-grow:1}.transform{--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;transform:translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.-translate-x-full{--tw-translate-x:-100%}.-translate-x-1{--tw-translate-x:-0.25rem}.rotate-90{--tw-rotate:90deg}.cursor-pointer{cursor:pointer}.flex-col{flex-direction:column}.flex-row{flex-direction:row}.flex-wrap{flex-wrap:wrap}.items-center{align-items:center}.items-stretch{align-items:stretch}.items-start{align-items:flex-start}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.divide-y>:not([hidden])~:not([hidden]){--tw-divide-y-reverse:0;border-top-width:calc(1px * calc(1 - var(--tw-divide-y-reverse)));border-bottom-width:calc(1px * var(--tw-divide-y-reverse))}.divide-indigo-300>:not([hidden])~:not([hidden]){--tw-divide-opacity:1;border-color:rgba(165, 180, 252, var(--tw-divide-opacity))}.divide-indigo-500>:not([hidden])~:not([hidden]){--tw-divide-opacity:1;border-color:rgba(99, 102, 241, var(--tw-divide-opacity))}.divide-green-500>:not([hidden])~:not([hidden]){--tw-divide-opacity:1;border-color:rgba(16, 185, 129, var(--tw-divide-opacity))}.overflow-hidden{overflow:hidden}.overflow-auto{overflow:auto}.overflow-scroll{overflow:scroll}.rounded-full{border-radius:9999px}.rounded{border-radius:0.25rem}.rounded-md{border-radius:0.375rem}.rounded-lg{border-radius:0.5rem}.rounded-t{border-top-left-radius:0.25rem;border-top-right-radius:0.25rem}.border-2{border-width:2px}.border{border-width:1px}.border-0{border-width:0px}.border-l-4{border-left-width:4px}.border-b{border-bottom-width:1px}.border-l{border-left-width:1px}.border-b-2{border-bottom-width:2px}.border-white{--tw-border-opacity:1;border-color:rgba(255, 255, 255, var(--tw-border-opacity))}.border-indigo-500{--tw-border-opacity:1;border-color:rgba(99, 102, 241, var(--tw-border-opacity))}.border-gray-500{--tw-border-opacity:1;border-color:rgba(107, 114, 128, var(--tw-border-opacity))}.border-indigo-800{--tw-border-opacity:1;border-color:rgba(55, 48, 163, var(--tw-border-opacity))}.border-gray-300{--tw-border-opacity:1;border-color:rgba(209, 213, 219, var(--tw-border-opacity))}.border-gray-200{--tw-border-opacity:1;border-color:rgba(229, 231, 235, var(--tw-border-opacity))}.border-black{--tw-border-opacity:1;border-color:rgba(0, 0, 0, var(--tw-border-opacity))}.border-opacity-0{--tw-border-opacity:0}.border-opacity-25{--tw-border-opacity:0.25}.bg-green-600{--tw-bg-opacity:1;background-color:rgba(5, 150, 105, var(--tw-bg-opacity))}.bg-red-400{--tw-bg-opacity:1;background-color:rgba(248, 113, 113, var(--tw-bg-opacity))}.bg-indigo-500{--tw-bg-opacity:1;background-color:rgba(99, 102, 241, var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity:1;background-color:rgba(255, 255, 255, var(--tw-bg-opacity))}.bg-indigo-100{--tw-bg-opacity:1;background-color:rgba(224, 231, 255, var(--tw-bg-opacity))}.bg-indigo-200{--tw-bg-opacity:1;background-color:rgba(199, 210, 254, var(--tw-bg-opacity))}.bg-gray-100{--tw-bg-opacity:1;background-color:rgba(243, 244, 246, var(--tw-bg-opacity))}.bg-transparent{background-color:transparent}.bg-red-500{--tw-bg-opacity:1;background-color:rgba(239, 68, 68, var(--tw-bg-opacity))}.bg-green-500{--tw-bg-opacity:1;background-color:rgba(16, 185, 129, var(--tw-bg-opacity))}.bg-yellow-500{--tw-bg-opacity:1;background-color:rgba(245, 158, 11, var(--tw-bg-opacity))}.bg-purple-500{--tw-bg-opacity:1;background-color:rgba(139, 92, 246, var(--tw-bg-opacity))}.bg-indigo-300{--tw-bg-opacity:1;background-color:rgba(165, 180, 252, var(--tw-bg-opacity))}.bg-gray-200{--tw-bg-opacity:1;background-color:rgba(229, 231, 235, var(--tw-bg-opacity))}.bg-gray-400{--tw-bg-opacity:1;background-color:rgba(156, 163, 175, var(--tw-bg-opacity))}.p-2{padding:0.5rem}.p-20{padding:5rem}.p-4{padding:1rem}.p-6{padding:1.5rem}.p-1{padding:0.25rem}.px-2{padding-left:0.5rem;padding-right:0.5rem}.py-1{padding-top:0.25rem;padding-bottom:0.25rem}.px-5{padding-left:1.25rem;padding-right:1.25rem}.py-10{padding-top:2.5rem;padding-bottom:2.5rem}.py-3{padding-top:0.75rem;padding-bottom:0.75rem}.py-24{padding-top:6rem;padding-bottom:6rem}.px-4{padding-left:1rem;padding-right:1rem}.py-4{padding-top:1rem;padding-bottom:1rem}.px-3{padding-left:0.75rem;padding-right:0.75rem}.py-2{padding-top:0.5rem;padding-bottom:0.5rem}.px-1{padding-left:0.25rem;padding-right:0.25rem}.pl-3{padding-left:0.75rem}.pl-8{padding-left:2rem}.pr-1{padding-right:0.25rem}.pt-4{padding-top:1rem}.pl-4{padding-left:1rem}.pr-4{padding-right:1rem}.pt-10{padding-top:2.5rem}.pt-5{padding-top:1.25rem}.pt-2{padding-top:0.5rem}.pt-8{padding-top:2rem}.pl-10{padding-left:2.5rem}.pb-1{padding-bottom:0.25rem}.pb-2{padding-bottom:0.5rem}.pl-2{padding-left:0.5rem}.pt-1{padding-top:0.25rem}.pb-4{padding-bottom:1rem}.pl-1{padding-left:0.25rem}.text-center{text-align:center}.align-middle{vertical-align:middle}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-6xl{font-size:3.75rem;line-height:1}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-base{font-size:1rem;line-height:1.5rem}.text-sm{font-size:0.875rem;line-height:1.25rem}.text-2xl{font-size:1.5rem;line-height:2rem}.text-5xl{font-size:3rem;line-height:1}.font-bold{font-weight:700}.font-light{font-weight:300}.font-normal{font-weight:400}.font-medium{font-weight:500}.font-semibold{font-weight:600}.italic{font-style:italic}.leading-relaxed{line-height:1.625}.leading-snug{line-height:1.375}.leading-none{line-height:1}.tracking-normal{letter-spacing:0em}.tracking-widest{letter-spacing:0.1em}.text-black{--tw-text-opacity:1;color:rgba(0, 0, 0, var(--tw-text-opacity))}.text-white{--tw-text-opacity:1;color:rgba(255, 255, 255, var(--tw-text-opacity))}.text-green-500{--tw-text-opacity:1;color:rgba(16, 185, 129, var(--tw-text-opacity))}.text-gray-800{--tw-text-opacity:1;color:rgba(31, 41, 55, var(--tw-text-opacity))}.text-gray-700{--tw-text-opacity:1;color:rgba(55, 65, 81, var(--tw-text-opacity))}.text-indigo-500{--tw-text-opacity:1;color:rgba(99, 102, 241, var(--tw-text-opacity))}.text-gray-600{--tw-text-opacity:1;color:rgba(75, 85, 99, var(--tw-text-opacity))}.text-gray-900{--tw-text-opacity:1;color:rgba(17, 24, 39, var(--tw-text-opacity))}.text-gray-500{--tw-text-opacity:1;color:rgba(107, 114, 128, var(--tw-text-opacity))}.text-indigo-300{--tw-text-opacity:1;color:rgba(165, 180, 252, var(--tw-text-opacity))}.text-green-400{--tw-text-opacity:1;color:rgba(52, 211, 153, var(--tw-text-opacity))}.text-red-400{--tw-text-opacity:1;color:rgba(248, 113, 113, var(--tw-text-opacity))}.underline{text-decoration:underline}.line-through{text-decoration:line-through}.opacity-0{opacity:0}.opacity-50{opacity:0.5}.shadow-inner{--tw-shadow:inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow{--tw-shadow:0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.outline-none{outline:2px solid transparent;outline-offset:2px}.transition{transition-property:background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;transition-property:background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.duration-200{transition-duration:200ms}.duration-500{transition-duration:500ms}.ease-in-out{transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}.hover\\:-translate-y-1:hover{--tw-translate-y:-0.25rem}.hover\\:scale-125:hover{--tw-scale-x:1.25;--tw-scale-y:1.25}.hover\\:scale-110:hover{--tw-scale-x:1.1;--tw-scale-y:1.1}.hover\\:border-indigo-500:hover{--tw-border-opacity:1;border-color:rgba(99, 102, 241, var(--tw-border-opacity))}.hover\\:border-opacity-100:hover{--tw-border-opacity:1}.hover\\:bg-indigo-600:hover{--tw-bg-opacity:1;background-color:rgba(79, 70, 229, var(--tw-bg-opacity))}.hover\\:bg-indigo-300:hover{--tw-bg-opacity:1;background-color:rgba(165, 180, 252, var(--tw-bg-opacity))}.hover\\:bg-purple-300:hover{--tw-bg-opacity:1;background-color:rgba(196, 181, 253, var(--tw-bg-opacity))}.hover\\:text-red-600:hover{--tw-text-opacity:1;color:rgba(220, 38, 38, var(--tw-text-opacity))}.hover\\:opacity-100:hover{opacity:1}.hover\\:opacity-70:hover{opacity:0.7}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\\:ring:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.group:hover .group-hover\\:opacity-40{opacity:0.4}@media(min-width: 640px){.sm\\:text-4xl{font-size:2.25rem;line-height:2.5rem}}@media(min-width: 768px){.md\\:relative{position:relative}.md\\:block{display:block}.md\\:w-1\\/2{width:50%}.md\\:translate-x-0{--tw-translate-x:0px}}@media(min-width: 1024px){.lg\\:w-2\\/3{width:66.666667%}}@media(min-width: 1280px){.xl\\:w-1\\/4{width:25%}}`,
  map: `{"version":3,"file":"TailwindCss.svelte","sources":["TailwindCss.svelte"],"sourcesContent":["<style global>/*! tailwindcss v2.1.2 | MIT License | https://tailwindcss.com *//*! modern-normalize v1.0.0 | MIT License | https://github.com/sindresorhus/modern-normalize */\\n\\n/*\\nDocument\\n========\\n*/\\n\\n/**\\nUse a better box model (opinionated).\\n*/\\n\\n:global(*),\\n:global(*::before),\\n:global(*::after) {\\n\\tbox-sizing: border-box;\\n}\\n\\n/**\\nUse a more readable tab size (opinionated).\\n*/\\n\\n:global(:root) {\\n\\t-moz-tab-size: 4;\\n\\t-o-tab-size: 4;\\n\\t   tab-size: 4;\\n}\\n\\n/**\\n1. Correct the line height in all browsers.\\n2. Prevent adjustments of font size after orientation changes in iOS.\\n*/\\n\\n:global(html) {\\n\\tline-height: 1.15; /* 1 */\\n\\t-webkit-text-size-adjust: 100%; /* 2 */\\n}\\n\\n/*\\nSections\\n========\\n*/\\n\\n/**\\nRemove the margin in all browsers.\\n*/\\n\\n:global(body) {\\n\\tmargin: 0;\\n}\\n\\n/**\\nImprove consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3)\\n*/\\n\\n:global(body) {\\n\\tfont-family:\\n\\t\\tsystem-ui,\\n\\t\\t-apple-system, /* Firefox supports this but not yet \`system-ui\` */\\n\\t\\t'Segoe UI',\\n\\t\\tRoboto,\\n\\t\\tHelvetica,\\n\\t\\tArial,\\n\\t\\tsans-serif,\\n\\t\\t'Apple Color Emoji',\\n\\t\\t'Segoe UI Emoji';\\n}\\n\\n/*\\nGrouping content\\n================\\n*/\\n\\n/**\\n1. Add the correct height in Firefox.\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n*/\\n\\n:global(hr) {\\n\\theight: 0; /* 1 */\\n\\tcolor: inherit; /* 2 */\\n}\\n\\n/*\\nText-level semantics\\n====================\\n*/\\n\\n/**\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\n*/\\n\\n:global(abbr[title]) {\\n\\t-webkit-text-decoration: underline dotted;\\n\\t        text-decoration: underline dotted;\\n}\\n\\n/**\\nAdd the correct font weight in Edge and Safari.\\n*/\\n\\n:global(b),\\n:global(strong) {\\n\\tfont-weight: bolder;\\n}\\n\\n/**\\n1. Improve consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3)\\n2. Correct the odd 'em' font sizing in all browsers.\\n*/\\n\\n:global(code),\\n:global(kbd),\\n:global(samp),\\n:global(pre) {\\n\\tfont-family:\\n\\t\\tui-monospace,\\n\\t\\tSFMono-Regular,\\n\\t\\tConsolas,\\n\\t\\t'Liberation Mono',\\n\\t\\tMenlo,\\n\\t\\tmonospace; /* 1 */\\n\\tfont-size: 1em; /* 2 */\\n}\\n\\n/**\\nAdd the correct font size in all browsers.\\n*/\\n\\n:global(small) {\\n\\tfont-size: 80%;\\n}\\n\\n/**\\nPrevent 'sub' and 'sup' elements from affecting the line height in all browsers.\\n*/\\n\\n:global(sub),\\n:global(sup) {\\n\\tfont-size: 75%;\\n\\tline-height: 0;\\n\\tposition: relative;\\n\\tvertical-align: baseline;\\n}\\n\\n:global(sub) {\\n\\tbottom: -0.25em;\\n}\\n\\n:global(sup) {\\n\\ttop: -0.5em;\\n}\\n\\n/*\\nTabular data\\n============\\n*/\\n\\n/**\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n*/\\n\\n:global(table) {\\n\\ttext-indent: 0; /* 1 */\\n\\tborder-color: inherit; /* 2 */\\n}\\n\\n/*\\nForms\\n=====\\n*/\\n\\n/**\\n1. Change the font styles in all browsers.\\n2. Remove the margin in Firefox and Safari.\\n*/\\n\\n:global(button),\\n:global(input),\\n:global(optgroup),\\n:global(select),\\n:global(textarea) {\\n\\tfont-family: inherit; /* 1 */\\n\\tfont-size: 100%; /* 1 */\\n\\tline-height: 1.15; /* 1 */\\n\\tmargin: 0; /* 2 */\\n}\\n\\n/**\\nRemove the inheritance of text transform in Edge and Firefox.\\n1. Remove the inheritance of text transform in Firefox.\\n*/\\n\\n:global(button),\\n:global(select) { /* 1 */\\n\\ttext-transform: none;\\n}\\n\\n/**\\nCorrect the inability to style clickable types in iOS and Safari.\\n*/\\n\\n:global(button),\\n:global([type='button']),\\n:global([type='reset']),\\n:global([type='submit']) {\\n\\t-webkit-appearance: button;\\n}\\n\\n/**\\nRemove the inner border and padding in Firefox.\\n*/\\n\\n:global(::-moz-focus-inner) {\\n\\tborder-style: none;\\n\\tpadding: 0;\\n}\\n\\n/**\\nRestore the focus styles unset by the previous rule.\\n*/\\n\\n:global(:-moz-focusring) {\\n\\toutline: 1px dotted ButtonText;\\n}\\n\\n/**\\nRemove the additional ':invalid' styles in Firefox.\\nSee: https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737\\n*/\\n\\n:global(:-moz-ui-invalid) {\\n\\tbox-shadow: none;\\n}\\n\\n/**\\nRemove the padding so developers are not caught out when they zero out 'fieldset' elements in all browsers.\\n*/\\n\\n:global(legend) {\\n\\tpadding: 0;\\n}\\n\\n/**\\nAdd the correct vertical alignment in Chrome and Firefox.\\n*/\\n\\n:global(progress) {\\n\\tvertical-align: baseline;\\n}\\n\\n/**\\nCorrect the cursor style of increment and decrement buttons in Safari.\\n*/\\n\\n:global(::-webkit-inner-spin-button),\\n:global(::-webkit-outer-spin-button) {\\n\\theight: auto;\\n}\\n\\n/**\\n1. Correct the odd appearance in Chrome and Safari.\\n2. Correct the outline style in Safari.\\n*/\\n\\n:global([type='search']) {\\n\\t-webkit-appearance: textfield; /* 1 */\\n\\toutline-offset: -2px; /* 2 */\\n}\\n\\n/**\\nRemove the inner padding in Chrome and Safari on macOS.\\n*/\\n\\n:global(::-webkit-search-decoration) {\\n\\t-webkit-appearance: none;\\n}\\n\\n/**\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Change font properties to 'inherit' in Safari.\\n*/\\n\\n:global(::-webkit-file-upload-button) {\\n\\t-webkit-appearance: button; /* 1 */\\n\\tfont: inherit; /* 2 */\\n}\\n\\n/*\\nInteractive\\n===========\\n*/\\n\\n/*\\nAdd the correct display in Chrome and Safari.\\n*/\\n\\n:global(summary) {\\n\\tdisplay: list-item;\\n}/**\\n * Manually forked from SUIT CSS Base: https://github.com/suitcss/base\\n * A thin layer on top of normalize.css that provides a starting point more\\n * suitable for web applications.\\n */\\n\\n/**\\n * Removes the default spacing and border for appropriate elements.\\n */\\n\\n:global(blockquote),\\n:global(dl),\\n:global(dd),\\n:global(h1),\\n:global(h2),\\n:global(h3),\\n:global(h4),\\n:global(h5),\\n:global(h6),\\n:global(hr),\\n:global(figure),\\n:global(p),\\n:global(pre) {\\n  margin: 0;\\n}\\n\\n:global(button) {\\n  background-color: transparent;\\n  background-image: none;\\n}\\n\\n/**\\n * Work around a Firefox/IE bug where the transparent \`button\` background\\n * results in a loss of the default \`button\` focus styles.\\n */\\n\\n:global(button:focus) {\\n  outline: 1px dotted;\\n  outline: 5px auto -webkit-focus-ring-color;\\n}\\n\\n:global(fieldset) {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n:global(ol),\\n:global(ul) {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/**\\n * Tailwind custom reset styles\\n */\\n\\n/**\\n * 1. Use the user's configured \`sans\` font-family (with Tailwind's default\\n *    sans-serif font stack as a fallback) as a sane default.\\n * 2. Use Tailwind's default \\"normal\\" line-height so the user isn't forced\\n *    to override it to ensure consistency even when using the default theme.\\n */\\n\\n:global(html) {\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\"Segoe UI\\", Roboto, \\"Helvetica Neue\\", Arial, \\"Noto Sans\\", sans-serif, \\"Apple Color Emoji\\", \\"Segoe UI Emoji\\", \\"Segoe UI Symbol\\", \\"Noto Color Emoji\\"; /* 1 */\\n  line-height: 1.5; /* 2 */\\n}\\n\\n\\n/**\\n * Inherit font-family and line-height from \`html\` so users can set them as\\n * a class directly on the \`html\` element.\\n */\\n\\n:global(body) {\\n  font-family: inherit;\\n  line-height: inherit;\\n}\\n\\n/**\\n * 1. Prevent padding and border from affecting element width.\\n *\\n *    We used to set this in the html element and inherit from\\n *    the parent element for everything else. This caused issues\\n *    in shadow-dom-enhanced elements like <details> where the content\\n *    is wrapped by a div with box-sizing set to \`content-box\`.\\n *\\n *    https://github.com/mozdevs/cssremedy/issues/4\\n *\\n *\\n * 2. Allow adding a border to an element by just adding a border-width.\\n *\\n *    By default, the way the browser specifies that an element should have no\\n *    border is by setting it's border-style to \`none\` in the user-agent\\n *    stylesheet.\\n *\\n *    In order to easily add borders to elements by just setting the \`border-width\`\\n *    property, we change the default border-style for all elements to \`solid\`, and\\n *    use border-width to hide them instead. This way our \`border\` utilities only\\n *    need to set the \`border-width\` property instead of the entire \`border\`\\n *    shorthand, making our border utilities much more straightforward to compose.\\n *\\n *    https://github.com/tailwindcss/tailwindcss/pull/116\\n */\\n\\n:global(*),\\n:global(::before),\\n:global(::after) {\\n  box-sizing: border-box; /* 1 */\\n  border-width: 0; /* 2 */\\n  border-style: solid; /* 2 */\\n  border-color: #e5e7eb; /* 2 */\\n}\\n\\n/*\\n * Ensure horizontal rules are visible by default\\n */\\n\\n:global(hr) {\\n  border-top-width: 1px;\\n}\\n\\n/**\\n * Undo the \`border-style: none\` reset that Normalize applies to images so that\\n * our \`border-{width}\` utilities have the expected effect.\\n *\\n * The Normalize reset is unnecessary for us since we default the border-width\\n * to 0 on all elements.\\n *\\n * https://github.com/tailwindcss/tailwindcss/issues/362\\n */\\n\\n:global(img) {\\n  border-style: solid;\\n}\\n\\n:global(textarea) {\\n  resize: vertical;\\n}\\n\\n:global(input::-moz-placeholder), :global(textarea::-moz-placeholder) {\\n  opacity: 1;\\n  color: #9ca3af;\\n}\\n\\n:global(input:-ms-input-placeholder), :global(textarea:-ms-input-placeholder) {\\n  opacity: 1;\\n  color: #9ca3af;\\n}\\n\\n:global(input::placeholder),\\n:global(textarea::placeholder) {\\n  opacity: 1;\\n  color: #9ca3af;\\n}\\n\\n:global(button),\\n:global([role=\\"button\\"]) {\\n  cursor: pointer;\\n}\\n\\n:global(table) {\\n  border-collapse: collapse;\\n}\\n\\n:global(h1),\\n:global(h2),\\n:global(h3),\\n:global(h4),\\n:global(h5),\\n:global(h6) {\\n  font-size: inherit;\\n  font-weight: inherit;\\n}\\n\\n/**\\n * Reset links to optimize for opt-in styling instead of\\n * opt-out.\\n */\\n\\n:global(a) {\\n  color: inherit;\\n  text-decoration: inherit;\\n}\\n\\n/**\\n * Reset form element properties that are easy to forget to\\n * style explicitly so you don't inadvertently introduce\\n * styles that deviate from your design system. These styles\\n * supplement a partial reset that is already applied by\\n * normalize.css.\\n */\\n\\n:global(button),\\n:global(input),\\n:global(optgroup),\\n:global(select),\\n:global(textarea) {\\n  padding: 0;\\n  line-height: inherit;\\n  color: inherit;\\n}\\n\\n/**\\n * Use the configured 'mono' font family for elements that\\n * are expected to be rendered with a monospace font, falling\\n * back to the system monospace stack if there is no configured\\n * 'mono' font family.\\n */\\n\\n:global(pre),\\n:global(code),\\n:global(kbd),\\n:global(samp) {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\"Liberation Mono\\", \\"Courier New\\", monospace;\\n}\\n\\n/**\\n * Make replaced elements \`display: block\` by default as that's\\n * the behavior you want almost all of the time. Inspired by\\n * CSS Remedy, with \`svg\` added as well.\\n *\\n * https://github.com/mozdevs/cssremedy/issues/14\\n */\\n\\n:global(img),\\n:global(svg),\\n:global(video),\\n:global(canvas),\\n:global(audio),\\n:global(iframe),\\n:global(embed),\\n:global(object) {\\n  display: block;\\n  vertical-align: middle;\\n}\\n\\n/**\\n * Constrain images and videos to the parent width and preserve\\n * their intrinsic aspect ratio.\\n *\\n * https://github.com/mozdevs/cssremedy/issues/14\\n */\\n\\n:global(img),\\n:global(video) {\\n  max-width: 100%;\\n  height: auto;\\n}\\n\\n:global(*) {\\n\\t--tw-shadow: 0 0 #0000;\\n\\t--tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);\\n\\t--tw-ring-offset-width: 0px;\\n\\t--tw-ring-offset-color: #fff;\\n\\t--tw-ring-color: rgba(59, 130, 246, 0.5);\\n\\t--tw-ring-offset-shadow: 0 0 #0000;\\n\\t--tw-ring-shadow: 0 0 #0000;\\n\\tscrollbar-color: initial;\\n\\tscrollbar-width: initial;\\n}\\r\\n  :global(.container) {\\n\\twidth: 100%;\\n}\\r\\n  @media (min-width: 640px) {\\n\\n\\t:global(.container) {\\n\\t\\tmax-width: 640px;\\n\\t}\\n}\\r\\n  @media (min-width: 768px) {\\n\\n\\t:global(.container) {\\n\\t\\tmax-width: 768px;\\n\\t}\\n}\\r\\n  @media (min-width: 1024px) {\\n\\n\\t:global(.container) {\\n\\t\\tmax-width: 1024px;\\n\\t}\\n}\\r\\n  @media (min-width: 1280px) {\\n\\n\\t:global(.container) {\\n\\t\\tmax-width: 1280px;\\n\\t}\\n}\\r\\n  @media (min-width: 1536px) {\\n\\n\\t:global(.container) {\\n\\t\\tmax-width: 1536px;\\n\\t}\\n}\\r\\n  :global(.visible) {\\n\\tvisibility: visible;\\n}\\r\\n  :global(.relative) {\\n\\tposition: relative;\\n}\\r\\n  :global(.absolute) {\\n\\tposition: absolute;\\n}\\r\\n  :global(.static) {\\n\\tposition: static;\\n}\\r\\n  :global(.inset-y-0) {\\n\\ttop: 0px;\\n\\tbottom: 0px;\\n}\\r\\n  :global(.bottom-0) {\\n\\tbottom: 0px;\\n}\\r\\n  :global(.right-0) {\\n\\tright: 0px;\\n}\\r\\n  :global(.left-0) {\\n\\tleft: 0px;\\n}\\r\\n  :global(.z-10) {\\n\\tz-index: 10;\\n}\\r\\n  :global(.-m-4) {\\n\\tmargin: -1rem;\\n}\\r\\n  :global(.m-auto) {\\n\\tmargin: auto;\\n}\\r\\n  :global(.m-2) {\\n\\tmargin: 0.5rem;\\n}\\r\\n  :global(.mx-auto) {\\n\\tmargin-left: auto;\\n\\tmargin-right: auto;\\n}\\r\\n  :global(.mb-4) {\\n\\tmargin-bottom: 1rem;\\n}\\r\\n  :global(.mr-1) {\\n\\tmargin-right: 0.25rem;\\n}\\r\\n  :global(.mr-4) {\\n\\tmargin-right: 1rem;\\n}\\r\\n  :global(.mb-2) {\\n\\tmargin-bottom: 0.5rem;\\n}\\r\\n  :global(.mb-8) {\\n\\tmargin-bottom: 2rem;\\n}\\r\\n  :global(.mt-5) {\\n\\tmargin-top: 1.25rem;\\n}\\r\\n  :global(.ml-2) {\\n\\tmargin-left: 0.5rem;\\n}\\r\\n  :global(.mt-10) {\\n\\tmargin-top: 2.5rem;\\n}\\r\\n  :global(.mb-20) {\\n\\tmargin-bottom: 5rem;\\n}\\r\\n  :global(.mt-6) {\\n\\tmargin-top: 1.5rem;\\n}\\r\\n  :global(.mt-3) {\\n\\tmargin-top: 0.75rem;\\n}\\r\\n  :global(.mt-8) {\\n\\tmargin-top: 2rem;\\n}\\r\\n  :global(.mb-3) {\\n\\tmargin-bottom: 0.75rem;\\n}\\r\\n  :global(.ml-4) {\\n\\tmargin-left: 1rem;\\n}\\r\\n  :global(.mb-5) {\\n\\tmargin-bottom: 1.25rem;\\n}\\r\\n  :global(.mb-1) {\\n\\tmargin-bottom: 0.25rem;\\n}\\r\\n  :global(.ml-1) {\\n\\tmargin-left: 0.25rem;\\n}\\r\\n  :global(.mr-2) {\\n\\tmargin-right: 0.5rem;\\n}\\r\\n  :global(.mt-auto) {\\n\\tmargin-top: auto;\\n}\\r\\n  :global(.ml-auto) {\\n\\tmargin-left: auto;\\n}\\r\\n  :global(.-mb-px) {\\n\\tmargin-bottom: -1px;\\n}\\r\\n  :global(.table) {\\n\\tdisplay: table;\\n}\\r\\n  :global(.table-cell) {\\n\\tdisplay: table-cell;\\n}\\r\\n  :global(.inline-block) {\\n\\tdisplay: inline-block;\\n}\\r\\n  :global(.flex) {\\n\\tdisplay: flex;\\n}\\r\\n  :global(.block) {\\n\\tdisplay: block;\\n}\\r\\n  :global(.inline-flex) {\\n\\tdisplay: inline-flex;\\n}\\r\\n  :global(.hidden) {\\n\\tdisplay: none;\\n}\\r\\n  :global(.h-10) {\\n\\theight: 2.5rem;\\n}\\r\\n  :global(.h-full) {\\n\\theight: 100%;\\n}\\r\\n  :global(.h-3) {\\n\\theight: 0.75rem;\\n}\\r\\n  :global(.h-6) {\\n\\theight: 1.5rem;\\n}\\r\\n  :global(.h-screen) {\\n\\theight: 100vh;\\n}\\r\\n  :global(.h-4) {\\n\\theight: 1rem;\\n}\\r\\n  :global(.h-16) {\\n\\theight: 4rem;\\n}\\r\\n  :global(.h-8) {\\n\\theight: 2rem;\\n}\\r\\n  :global(.w-10) {\\n\\twidth: 2.5rem;\\n}\\r\\n  :global(.w-full) {\\n\\twidth: 100%;\\n}\\r\\n  :global(.w-3) {\\n\\twidth: 0.75rem;\\n}\\r\\n  :global(.w-6) {\\n\\twidth: 1.5rem;\\n}\\r\\n  :global(.w-4) {\\n\\twidth: 1rem;\\n}\\r\\n  :global(.w-16) {\\n\\twidth: 4rem;\\n}\\r\\n  :global(.w-72) {\\n\\twidth: 18rem;\\n}\\r\\n  :global(.w-9\\\\/12) {\\n\\twidth: 75%;\\n}\\r\\n  :global(.w-8) {\\n\\twidth: 2rem;\\n}\\r\\n  :global(.w-1\\\\/3) {\\n\\twidth: 33.333333%;\\n}\\r\\n  :global(.w-56) {\\n\\twidth: 14rem;\\n}\\r\\n  :global(.w-20) {\\n\\twidth: 5rem;\\n}\\r\\n  :global(.w-60) {\\n\\twidth: 15rem;\\n}\\r\\n  :global(.min-w-full) {\\n\\tmin-width: 100%;\\n}\\r\\n  :global(.max-w-md) {\\n\\tmax-width: 28rem;\\n}\\r\\n  :global(.max-w-sm) {\\n\\tmax-width: 24rem;\\n}\\r\\n  :global(.flex-shrink-0) {\\n\\tflex-shrink: 0;\\n}\\r\\n  :global(.flex-shrink) {\\n\\tflex-shrink: 1;\\n}\\r\\n  :global(.flex-grow) {\\n\\tflex-grow: 1;\\n}\\r\\n  :global(.transform) {\\n\\t--tw-translate-x: 0;\\n\\t--tw-translate-y: 0;\\n\\t--tw-rotate: 0;\\n\\t--tw-skew-x: 0;\\n\\t--tw-skew-y: 0;\\n\\t--tw-scale-x: 1;\\n\\t--tw-scale-y: 1;\\n\\ttransform: translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\r\\n  :global(.-translate-x-full) {\\n\\t--tw-translate-x: -100%;\\n}\\r\\n  :global(.-translate-x-1) {\\n\\t--tw-translate-x: -0.25rem;\\n}\\r\\n  :global(.rotate-90) {\\n\\t--tw-rotate: 90deg;\\n}\\r\\n  :global(.cursor-pointer) {\\n\\tcursor: pointer;\\n}\\r\\n  :global(.flex-col) {\\n\\tflex-direction: column;\\n}\\r\\n  :global(.flex-row) {\\n\\tflex-direction: row;\\n}\\r\\n  :global(.flex-wrap) {\\n\\tflex-wrap: wrap;\\n}\\r\\n  :global(.items-center) {\\n\\talign-items: center;\\n}\\r\\n  :global(.items-stretch) {\\n\\talign-items: stretch;\\n}\\r\\n  :global(.items-start) {\\n\\talign-items: flex-start;\\n}\\r\\n  :global(.justify-between) {\\n\\tjustify-content: space-between;\\n}\\r\\n  :global(.justify-center) {\\n\\tjustify-content: center;\\n}\\r\\n  :global(.divide-y) > :global(:not([hidden])) ~ :global(:not([hidden])) {\\n\\t--tw-divide-y-reverse: 0;\\n\\tborder-top-width: calc(1px * calc(1 - var(--tw-divide-y-reverse)));\\n\\tborder-bottom-width: calc(1px * var(--tw-divide-y-reverse));\\n}\\r\\n  :global(.divide-indigo-300) > :global(:not([hidden])) ~ :global(:not([hidden])) {\\n\\t--tw-divide-opacity: 1;\\n\\tborder-color: rgba(165, 180, 252, var(--tw-divide-opacity));\\n}\\r\\n  :global(.divide-indigo-500) > :global(:not([hidden])) ~ :global(:not([hidden])) {\\n\\t--tw-divide-opacity: 1;\\n\\tborder-color: rgba(99, 102, 241, var(--tw-divide-opacity));\\n}\\r\\n  :global(.divide-green-500) > :global(:not([hidden])) ~ :global(:not([hidden])) {\\n\\t--tw-divide-opacity: 1;\\n\\tborder-color: rgba(16, 185, 129, var(--tw-divide-opacity));\\n}\\r\\n  :global(.overflow-hidden) {\\n\\toverflow: hidden;\\n}\\r\\n  :global(.overflow-auto) {\\n\\toverflow: auto;\\n}\\r\\n  :global(.overflow-scroll) {\\n\\toverflow: scroll;\\n}\\r\\n  :global(.rounded-full) {\\n\\tborder-radius: 9999px;\\n}\\r\\n  :global(.rounded) {\\n\\tborder-radius: 0.25rem;\\n}\\r\\n  :global(.rounded-md) {\\n\\tborder-radius: 0.375rem;\\n}\\r\\n  :global(.rounded-lg) {\\n\\tborder-radius: 0.5rem;\\n}\\r\\n  :global(.rounded-t) {\\n\\tborder-top-left-radius: 0.25rem;\\n\\tborder-top-right-radius: 0.25rem;\\n}\\r\\n  :global(.border-2) {\\n\\tborder-width: 2px;\\n}\\r\\n  :global(.border) {\\n\\tborder-width: 1px;\\n}\\r\\n  :global(.border-0) {\\n\\tborder-width: 0px;\\n}\\r\\n  :global(.border-l-4) {\\n\\tborder-left-width: 4px;\\n}\\r\\n  :global(.border-b) {\\n\\tborder-bottom-width: 1px;\\n}\\r\\n  :global(.border-l) {\\n\\tborder-left-width: 1px;\\n}\\r\\n  :global(.border-b-2) {\\n\\tborder-bottom-width: 2px;\\n}\\r\\n  :global(.border-white) {\\n\\t--tw-border-opacity: 1;\\n\\tborder-color: rgba(255, 255, 255, var(--tw-border-opacity));\\n}\\r\\n  :global(.border-indigo-500) {\\n\\t--tw-border-opacity: 1;\\n\\tborder-color: rgba(99, 102, 241, var(--tw-border-opacity));\\n}\\r\\n  :global(.border-gray-500) {\\n\\t--tw-border-opacity: 1;\\n\\tborder-color: rgba(107, 114, 128, var(--tw-border-opacity));\\n}\\r\\n  :global(.border-indigo-800) {\\n\\t--tw-border-opacity: 1;\\n\\tborder-color: rgba(55, 48, 163, var(--tw-border-opacity));\\n}\\r\\n  :global(.border-gray-300) {\\n\\t--tw-border-opacity: 1;\\n\\tborder-color: rgba(209, 213, 219, var(--tw-border-opacity));\\n}\\r\\n  :global(.border-gray-200) {\\n\\t--tw-border-opacity: 1;\\n\\tborder-color: rgba(229, 231, 235, var(--tw-border-opacity));\\n}\\r\\n  :global(.border-black) {\\n\\t--tw-border-opacity: 1;\\n\\tborder-color: rgba(0, 0, 0, var(--tw-border-opacity));\\n}\\r\\n  :global(.border-opacity-0) {\\n\\t--tw-border-opacity: 0;\\n}\\r\\n  :global(.border-opacity-25) {\\n\\t--tw-border-opacity: 0.25;\\n}\\r\\n  :global(.bg-green-600) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(5, 150, 105, var(--tw-bg-opacity));\\n}\\r\\n  :global(.bg-red-400) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(248, 113, 113, var(--tw-bg-opacity));\\n}\\r\\n  :global(.bg-indigo-500) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(99, 102, 241, var(--tw-bg-opacity));\\n}\\r\\n  :global(.bg-white) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(255, 255, 255, var(--tw-bg-opacity));\\n}\\r\\n  :global(.bg-indigo-100) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(224, 231, 255, var(--tw-bg-opacity));\\n}\\r\\n  :global(.bg-indigo-200) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(199, 210, 254, var(--tw-bg-opacity));\\n}\\r\\n  :global(.bg-gray-100) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(243, 244, 246, var(--tw-bg-opacity));\\n}\\r\\n  :global(.bg-transparent) {\\n\\tbackground-color: transparent;\\n}\\r\\n  :global(.bg-red-500) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(239, 68, 68, var(--tw-bg-opacity));\\n}\\r\\n  :global(.bg-green-500) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(16, 185, 129, var(--tw-bg-opacity));\\n}\\r\\n  :global(.bg-yellow-500) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(245, 158, 11, var(--tw-bg-opacity));\\n}\\r\\n  :global(.bg-purple-500) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(139, 92, 246, var(--tw-bg-opacity));\\n}\\r\\n  :global(.bg-indigo-300) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(165, 180, 252, var(--tw-bg-opacity));\\n}\\r\\n  :global(.bg-gray-200) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(229, 231, 235, var(--tw-bg-opacity));\\n}\\r\\n  :global(.bg-gray-400) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(156, 163, 175, var(--tw-bg-opacity));\\n}\\r\\n  :global(.p-2) {\\n\\tpadding: 0.5rem;\\n}\\r\\n  :global(.p-20) {\\n\\tpadding: 5rem;\\n}\\r\\n  :global(.p-4) {\\n\\tpadding: 1rem;\\n}\\r\\n  :global(.p-6) {\\n\\tpadding: 1.5rem;\\n}\\r\\n  :global(.p-1) {\\n\\tpadding: 0.25rem;\\n}\\r\\n  :global(.px-2) {\\n\\tpadding-left: 0.5rem;\\n\\tpadding-right: 0.5rem;\\n}\\r\\n  :global(.py-1) {\\n\\tpadding-top: 0.25rem;\\n\\tpadding-bottom: 0.25rem;\\n}\\r\\n  :global(.px-5) {\\n\\tpadding-left: 1.25rem;\\n\\tpadding-right: 1.25rem;\\n}\\r\\n  :global(.py-10) {\\n\\tpadding-top: 2.5rem;\\n\\tpadding-bottom: 2.5rem;\\n}\\r\\n  :global(.py-3) {\\n\\tpadding-top: 0.75rem;\\n\\tpadding-bottom: 0.75rem;\\n}\\r\\n  :global(.py-24) {\\n\\tpadding-top: 6rem;\\n\\tpadding-bottom: 6rem;\\n}\\r\\n  :global(.px-4) {\\n\\tpadding-left: 1rem;\\n\\tpadding-right: 1rem;\\n}\\r\\n  :global(.py-4) {\\n\\tpadding-top: 1rem;\\n\\tpadding-bottom: 1rem;\\n}\\r\\n  :global(.px-3) {\\n\\tpadding-left: 0.75rem;\\n\\tpadding-right: 0.75rem;\\n}\\r\\n  :global(.py-2) {\\n\\tpadding-top: 0.5rem;\\n\\tpadding-bottom: 0.5rem;\\n}\\r\\n  :global(.px-1) {\\n\\tpadding-left: 0.25rem;\\n\\tpadding-right: 0.25rem;\\n}\\r\\n  :global(.pl-3) {\\n\\tpadding-left: 0.75rem;\\n}\\r\\n  :global(.pl-8) {\\n\\tpadding-left: 2rem;\\n}\\r\\n  :global(.pr-1) {\\n\\tpadding-right: 0.25rem;\\n}\\r\\n  :global(.pt-4) {\\n\\tpadding-top: 1rem;\\n}\\r\\n  :global(.pl-4) {\\n\\tpadding-left: 1rem;\\n}\\r\\n  :global(.pr-4) {\\n\\tpadding-right: 1rem;\\n}\\r\\n  :global(.pt-10) {\\n\\tpadding-top: 2.5rem;\\n}\\r\\n  :global(.pt-5) {\\n\\tpadding-top: 1.25rem;\\n}\\r\\n  :global(.pt-2) {\\n\\tpadding-top: 0.5rem;\\n}\\r\\n  :global(.pt-8) {\\n\\tpadding-top: 2rem;\\n}\\r\\n  :global(.pl-10) {\\n\\tpadding-left: 2.5rem;\\n}\\r\\n  :global(.pb-1) {\\n\\tpadding-bottom: 0.25rem;\\n}\\r\\n  :global(.pb-2) {\\n\\tpadding-bottom: 0.5rem;\\n}\\r\\n  :global(.pl-2) {\\n\\tpadding-left: 0.5rem;\\n}\\r\\n  :global(.pt-1) {\\n\\tpadding-top: 0.25rem;\\n}\\r\\n  :global(.pb-4) {\\n\\tpadding-bottom: 1rem;\\n}\\r\\n  :global(.pl-1) {\\n\\tpadding-left: 0.25rem;\\n}\\r\\n  :global(.text-center) {\\n\\ttext-align: center;\\n}\\r\\n  :global(.align-middle) {\\n\\tvertical-align: middle;\\n}\\r\\n  :global(.text-3xl) {\\n\\tfont-size: 1.875rem;\\n\\tline-height: 2.25rem;\\n}\\r\\n  :global(.text-xl) {\\n\\tfont-size: 1.25rem;\\n\\tline-height: 1.75rem;\\n}\\r\\n  :global(.text-6xl) {\\n\\tfont-size: 3.75rem;\\n\\tline-height: 1;\\n}\\r\\n  :global(.text-lg) {\\n\\tfont-size: 1.125rem;\\n\\tline-height: 1.75rem;\\n}\\r\\n  :global(.text-4xl) {\\n\\tfont-size: 2.25rem;\\n\\tline-height: 2.5rem;\\n}\\r\\n  :global(.text-base) {\\n\\tfont-size: 1rem;\\n\\tline-height: 1.5rem;\\n}\\r\\n  :global(.text-sm) {\\n\\tfont-size: 0.875rem;\\n\\tline-height: 1.25rem;\\n}\\r\\n  :global(.text-2xl) {\\n\\tfont-size: 1.5rem;\\n\\tline-height: 2rem;\\n}\\r\\n  :global(.text-5xl) {\\n\\tfont-size: 3rem;\\n\\tline-height: 1;\\n}\\r\\n  :global(.font-bold) {\\n\\tfont-weight: 700;\\n}\\r\\n  :global(.font-light) {\\n\\tfont-weight: 300;\\n}\\r\\n  :global(.font-normal) {\\n\\tfont-weight: 400;\\n}\\r\\n  :global(.font-medium) {\\n\\tfont-weight: 500;\\n}\\r\\n  :global(.font-semibold) {\\n\\tfont-weight: 600;\\n}\\r\\n  :global(.italic) {\\n\\tfont-style: italic;\\n}\\r\\n  :global(.leading-relaxed) {\\n\\tline-height: 1.625;\\n}\\r\\n  :global(.leading-snug) {\\n\\tline-height: 1.375;\\n}\\r\\n  :global(.leading-none) {\\n\\tline-height: 1;\\n}\\r\\n  :global(.tracking-normal) {\\n\\tletter-spacing: 0em;\\n}\\r\\n  :global(.tracking-widest) {\\n\\tletter-spacing: 0.1em;\\n}\\r\\n  :global(.text-black) {\\n\\t--tw-text-opacity: 1;\\n\\tcolor: rgba(0, 0, 0, var(--tw-text-opacity));\\n}\\r\\n  :global(.text-white) {\\n\\t--tw-text-opacity: 1;\\n\\tcolor: rgba(255, 255, 255, var(--tw-text-opacity));\\n}\\r\\n  :global(.text-green-500) {\\n\\t--tw-text-opacity: 1;\\n\\tcolor: rgba(16, 185, 129, var(--tw-text-opacity));\\n}\\r\\n  :global(.text-gray-800) {\\n\\t--tw-text-opacity: 1;\\n\\tcolor: rgba(31, 41, 55, var(--tw-text-opacity));\\n}\\r\\n  :global(.text-gray-700) {\\n\\t--tw-text-opacity: 1;\\n\\tcolor: rgba(55, 65, 81, var(--tw-text-opacity));\\n}\\r\\n  :global(.text-indigo-500) {\\n\\t--tw-text-opacity: 1;\\n\\tcolor: rgba(99, 102, 241, var(--tw-text-opacity));\\n}\\r\\n  :global(.text-gray-600) {\\n\\t--tw-text-opacity: 1;\\n\\tcolor: rgba(75, 85, 99, var(--tw-text-opacity));\\n}\\r\\n  :global(.text-gray-900) {\\n\\t--tw-text-opacity: 1;\\n\\tcolor: rgba(17, 24, 39, var(--tw-text-opacity));\\n}\\r\\n  :global(.text-gray-500) {\\n\\t--tw-text-opacity: 1;\\n\\tcolor: rgba(107, 114, 128, var(--tw-text-opacity));\\n}\\r\\n  :global(.text-indigo-300) {\\n\\t--tw-text-opacity: 1;\\n\\tcolor: rgba(165, 180, 252, var(--tw-text-opacity));\\n}\\r\\n  :global(.text-green-400) {\\n\\t--tw-text-opacity: 1;\\n\\tcolor: rgba(52, 211, 153, var(--tw-text-opacity));\\n}\\r\\n  :global(.text-red-400) {\\n\\t--tw-text-opacity: 1;\\n\\tcolor: rgba(248, 113, 113, var(--tw-text-opacity));\\n}\\r\\n  :global(.underline) {\\n\\ttext-decoration: underline;\\n}\\r\\n  :global(.line-through) {\\n\\ttext-decoration: line-through;\\n}\\r\\n  :global(.opacity-0) {\\n\\topacity: 0;\\n}\\r\\n  :global(.opacity-50) {\\n\\topacity: 0.5;\\n}\\r\\n  :global(.shadow-inner) {\\n\\t--tw-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);\\n\\tbox-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\r\\n  :global(.shadow) {\\n\\t--tw-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);\\n\\tbox-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\r\\n  :global(.outline-none) {\\n\\toutline: 2px solid transparent;\\n\\toutline-offset: 2px;\\n}\\r\\n  :global(.transition) {\\n\\ttransition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\\n\\ttransition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\\n\\ttransition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\\n\\ttransition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n\\ttransition-duration: 150ms;\\n}\\r\\n  :global(.duration-200) {\\n\\ttransition-duration: 200ms;\\n}\\r\\n  :global(.duration-500) {\\n\\ttransition-duration: 500ms;\\n}\\r\\n  :global(.ease-in-out) {\\n\\ttransition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n}\\r\\n  :global(.hover\\\\:-translate-y-1:hover) {\\n\\t--tw-translate-y: -0.25rem;\\n}\\r\\n  :global(.hover\\\\:scale-125:hover) {\\n\\t--tw-scale-x: 1.25;\\n\\t--tw-scale-y: 1.25;\\n}\\r\\n  :global(.hover\\\\:scale-110:hover) {\\n\\t--tw-scale-x: 1.1;\\n\\t--tw-scale-y: 1.1;\\n}\\r\\n  :global(.hover\\\\:border-indigo-500:hover) {\\n\\t--tw-border-opacity: 1;\\n\\tborder-color: rgba(99, 102, 241, var(--tw-border-opacity));\\n}\\r\\n  :global(.hover\\\\:border-opacity-100:hover) {\\n\\t--tw-border-opacity: 1;\\n}\\r\\n  :global(.hover\\\\:bg-indigo-600:hover) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(79, 70, 229, var(--tw-bg-opacity));\\n}\\r\\n  :global(.hover\\\\:bg-indigo-300:hover) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(165, 180, 252, var(--tw-bg-opacity));\\n}\\r\\n  :global(.hover\\\\:bg-purple-300:hover) {\\n\\t--tw-bg-opacity: 1;\\n\\tbackground-color: rgba(196, 181, 253, var(--tw-bg-opacity));\\n}\\r\\n  :global(.hover\\\\:text-red-600:hover) {\\n\\t--tw-text-opacity: 1;\\n\\tcolor: rgba(220, 38, 38, var(--tw-text-opacity));\\n}\\r\\n  :global(.hover\\\\:opacity-100:hover) {\\n\\topacity: 1;\\n}\\r\\n  :global(.hover\\\\:opacity-70:hover) {\\n\\topacity: 0.7;\\n}\\r\\n  :global(.focus\\\\:outline-none:focus) {\\n\\toutline: 2px solid transparent;\\n\\toutline-offset: 2px;\\n}\\r\\n  :global(.focus\\\\:ring:focus) {\\n\\t--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n\\t--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n\\tbox-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\r\\n  :global(.group:hover) :global(.group-hover\\\\:opacity-40) {\\n\\topacity: 0.4;\\n}\\r\\n  @media (min-width: 640px) {\\n\\n\\t:global(.sm\\\\:text-4xl) {\\n\\t\\tfont-size: 2.25rem;\\n\\t\\tline-height: 2.5rem;\\n\\t}\\n}\\r\\n  @media (min-width: 768px) {\\n\\n\\t:global(.md\\\\:relative) {\\n\\t\\tposition: relative;\\n\\t}\\n\\n\\t:global(.md\\\\:block) {\\n\\t\\tdisplay: block;\\n\\t}\\n\\n\\t:global(.md\\\\:w-1\\\\/2) {\\n\\t\\twidth: 50%;\\n\\t}\\n\\n\\t:global(.md\\\\:translate-x-0) {\\n\\t\\t--tw-translate-x: 0px;\\n\\t}\\n}\\r\\n  @media (min-width: 1024px) {\\n\\n\\t:global(.lg\\\\:w-2\\\\/3) {\\n\\t\\twidth: 66.666667%;\\n\\t}\\n}\\r\\n  @media (min-width: 1280px) {\\n\\n\\t:global(.xl\\\\:w-1\\\\/4) {\\n\\t\\twidth: 25%;\\n\\t}\\n}</style>\\r\\n"],"names":[],"mappings":"AAWQ,CAAC,AAAC,CACF,SAAS,AAAC,CACV,QAAQ,AAAE,CAAC,AAClB,UAAU,CAAE,UAAU,AACvB,CAAC,AAMO,KAAK,AAAE,CAAC,AACf,aAAa,CAAE,CAAC,CAChB,WAAW,CAAE,CAAC,CACX,QAAQ,CAAE,CAAC,AACf,CAAC,AAOO,IAAI,AAAE,CAAC,AACd,WAAW,CAAE,IAAI,CACjB,wBAAwB,CAAE,IAAI,AAC/B,CAAC,AAWO,IAAI,AAAE,CAAC,AACd,MAAM,CAAE,CAAC,AACV,CAAC,AAMO,IAAI,AAAE,CAAC,AACd,WAAW,CACV,SAAS,CAAC;EACV,aAAa,CAAC;EACd,UAAU,CAAC;EACX,MAAM,CAAC;EACP,SAAS,CAAC;EACV,KAAK,CAAC;EACN,UAAU,CAAC;EACX,mBAAmB,CAAC;EACpB,gBAAgB,AAClB,CAAC,AAYO,EAAE,AAAE,CAAC,AACZ,MAAM,CAAE,CAAC,CACT,KAAK,CAAE,OAAO,AACf,CAAC,AAWO,WAAW,AAAE,CAAC,AACrB,uBAAuB,CAAE,SAAS,CAAC,MAAM,CACjC,eAAe,CAAE,SAAS,CAAC,MAAM,AAC1C,CAAC,AAMO,CAAC,AAAC,CACF,MAAM,AAAE,CAAC,AAChB,WAAW,CAAE,MAAM,AACpB,CAAC,AAOO,IAAI,AAAC,CACL,GAAG,AAAC,CACJ,IAAI,AAAC,CACL,GAAG,AAAE,CAAC,AACb,WAAW,CACV,YAAY,CAAC;EACb,cAAc,CAAC;EACf,QAAQ,CAAC;EACT,iBAAiB,CAAC;EAClB,KAAK,CAAC;EACN,SAAS,CACV,SAAS,CAAE,GAAG,AACf,CAAC,AAMO,KAAK,AAAE,CAAC,AACf,SAAS,CAAE,GAAG,AACf,CAAC,AAMO,GAAG,AAAC,CACJ,GAAG,AAAE,CAAC,AACb,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,CAAC,CACd,QAAQ,CAAE,QAAQ,CAClB,cAAc,CAAE,QAAQ,AACzB,CAAC,AAEO,GAAG,AAAE,CAAC,AACb,MAAM,CAAE,OAAO,AAChB,CAAC,AAEO,GAAG,AAAE,CAAC,AACb,GAAG,CAAE,MAAM,AACZ,CAAC,AAYO,KAAK,AAAE,CAAC,AACf,WAAW,CAAE,CAAC,CACd,YAAY,CAAE,OAAO,AACtB,CAAC,AAYO,MAAM,AAAC,CACP,KAAK,AAAC,CACN,QAAQ,AAAC,CACT,MAAM,AAAC,CACP,QAAQ,AAAE,CAAC,AAClB,WAAW,CAAE,OAAO,CACpB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,IAAI,CACjB,MAAM,CAAE,CAAC,AACV,CAAC,AAOO,MAAM,AAAC,CACP,MAAM,AAAE,CAAC,AAChB,cAAc,CAAE,IAAI,AACrB,CAAC,AAMO,MAAM,AAAC,CACP,eAAe,AAAC,CAChB,cAAc,AAAC,CACf,eAAe,AAAE,CAAC,AACzB,kBAAkB,CAAE,MAAM,AAC3B,CAAC,AAMO,kBAAkB,AAAE,CAAC,AAC5B,YAAY,CAAE,IAAI,CAClB,OAAO,CAAE,CAAC,AACX,CAAC,AAMO,eAAe,AAAE,CAAC,AACzB,OAAO,CAAE,GAAG,CAAC,MAAM,CAAC,UAAU,AAC/B,CAAC,AAOO,gBAAgB,AAAE,CAAC,AAC1B,UAAU,CAAE,IAAI,AACjB,CAAC,AAMO,MAAM,AAAE,CAAC,AAChB,OAAO,CAAE,CAAC,AACX,CAAC,AAMO,QAAQ,AAAE,CAAC,AAClB,cAAc,CAAE,QAAQ,AACzB,CAAC,AAMO,2BAA2B,AAAC,CAC5B,2BAA2B,AAAE,CAAC,AACrC,MAAM,CAAE,IAAI,AACb,CAAC,AAOO,eAAe,AAAE,CAAC,AACzB,kBAAkB,CAAE,SAAS,CAC7B,cAAc,CAAE,IAAI,AACrB,CAAC,AAMO,2BAA2B,AAAE,CAAC,AACrC,kBAAkB,CAAE,IAAI,AACzB,CAAC,AAOO,4BAA4B,AAAE,CAAC,AACtC,kBAAkB,CAAE,MAAM,CAC1B,IAAI,CAAE,OAAO,AACd,CAAC,AAWO,OAAO,AAAE,CAAC,AACjB,OAAO,CAAE,SAAS,AACnB,CAAC,AAUO,UAAU,AAAC,CACX,EAAE,AAAC,CACH,EAAE,AAAC,CACH,EAAE,AAAC,CACH,EAAE,AAAC,CACH,EAAE,AAAC,CACH,EAAE,AAAC,CACH,EAAE,AAAC,CACH,EAAE,AAAC,CACH,EAAE,AAAC,CACH,MAAM,AAAC,CACP,CAAC,AAAC,CACF,GAAG,AAAE,CAAC,AACZ,MAAM,CAAE,CAAC,AACX,CAAC,AAEO,MAAM,AAAE,CAAC,AACf,gBAAgB,CAAE,WAAW,CAC7B,gBAAgB,CAAE,IAAI,AACxB,CAAC,AAOO,YAAY,AAAE,CAAC,AACrB,OAAO,CAAE,GAAG,CAAC,MAAM,CACnB,OAAO,CAAE,GAAG,CAAC,IAAI,CAAC,wBAAwB,AAC5C,CAAC,AAEO,QAAQ,AAAE,CAAC,AACjB,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,AACZ,CAAC,AAEO,EAAE,AAAC,CACH,EAAE,AAAE,CAAC,AACX,UAAU,CAAE,IAAI,CAChB,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,AACZ,CAAC,AAaO,IAAI,AAAE,CAAC,AACb,WAAW,CAAE,aAAa,CAAC,CAAC,SAAS,CAAC,CAAC,aAAa,CAAC,CAAC,kBAAkB,CAAC,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAC,gBAAgB,CAAC,CAAC,KAAK,CAAC,CAAC,WAAW,CAAC,CAAC,UAAU,CAAC,CAAC,mBAAmB,CAAC,CAAC,gBAAgB,CAAC,CAAC,iBAAiB,CAAC,CAAC,kBAAkB,CAC5N,WAAW,CAAE,GAAG,AAClB,CAAC,AAQO,IAAI,AAAE,CAAC,AACb,WAAW,CAAE,OAAO,CACpB,WAAW,CAAE,OAAO,AACtB,CAAC,AA4BO,CAAC,AAAC,CACF,QAAQ,AAAC,CACT,OAAO,AAAE,CAAC,AAChB,UAAU,CAAE,UAAU,CACtB,YAAY,CAAE,CAAC,CACf,YAAY,CAAE,KAAK,CACnB,YAAY,CAAE,OAAO,AACvB,CAAC,AAMO,EAAE,AAAE,CAAC,AACX,gBAAgB,CAAE,GAAG,AACvB,CAAC,AAYO,GAAG,AAAE,CAAC,AACZ,YAAY,CAAE,KAAK,AACrB,CAAC,AAEO,QAAQ,AAAE,CAAC,AACjB,MAAM,CAAE,QAAQ,AAClB,CAAC,AAEO,uBAAuB,AAAC,CAAU,0BAA0B,AAAE,CAAC,AACrE,OAAO,CAAE,CAAC,CACV,KAAK,CAAE,OAAO,AAChB,CAAC,AAEO,2BAA2B,AAAC,CAAU,8BAA8B,AAAE,CAAC,AAC7E,OAAO,CAAE,CAAC,CACV,KAAK,CAAE,OAAO,AAChB,CAAC,AAEO,kBAAkB,AAAC,CACnB,qBAAqB,AAAE,CAAC,AAC9B,OAAO,CAAE,CAAC,CACV,KAAK,CAAE,OAAO,AAChB,CAAC,AAEO,MAAM,AAAC,CACP,eAAe,AAAE,CAAC,AACxB,MAAM,CAAE,OAAO,AACjB,CAAC,AAEO,KAAK,AAAE,CAAC,AACd,eAAe,CAAE,QAAQ,AAC3B,CAAC,AAEO,EAAE,AAAC,CACH,EAAE,AAAC,CACH,EAAE,AAAC,CACH,EAAE,AAAC,CACH,EAAE,AAAC,CACH,EAAE,AAAE,CAAC,AACX,SAAS,CAAE,OAAO,CAClB,WAAW,CAAE,OAAO,AACtB,CAAC,AAOO,CAAC,AAAE,CAAC,AACV,KAAK,CAAE,OAAO,CACd,eAAe,CAAE,OAAO,AAC1B,CAAC,AAUO,MAAM,AAAC,CACP,KAAK,AAAC,CACN,QAAQ,AAAC,CACT,MAAM,AAAC,CACP,QAAQ,AAAE,CAAC,AACjB,OAAO,CAAE,CAAC,CACV,WAAW,CAAE,OAAO,CACpB,KAAK,CAAE,OAAO,AAChB,CAAC,AASO,GAAG,AAAC,CACJ,IAAI,AAAC,CACL,GAAG,AAAC,CACJ,IAAI,AAAE,CAAC,AACb,WAAW,CAAE,YAAY,CAAC,CAAC,cAAc,CAAC,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,CAAC,iBAAiB,CAAC,CAAC,aAAa,CAAC,CAAC,SAAS,AACjH,CAAC,AAUO,GAAG,AAAC,CACJ,GAAG,AAAC,CACJ,KAAK,AAAC,CACN,MAAM,AAAC,CACP,KAAK,AAAC,CACN,MAAM,AAAC,CACP,KAAK,AAAC,CACN,MAAM,AAAE,CAAC,AACf,OAAO,CAAE,KAAK,CACd,cAAc,CAAE,MAAM,AACxB,CAAC,AASO,GAAG,AAAC,CACJ,KAAK,AAAE,CAAC,AACd,SAAS,CAAE,IAAI,CACf,MAAM,CAAE,IAAI,AACd,CAAC,AAEO,CAAC,AAAE,CAAC,AACX,WAAW,CAAE,SAAS,CACtB,eAAe,CAAE,2BAA2B,CAC5C,sBAAsB,CAAE,GAAG,CAC3B,sBAAsB,CAAE,IAAI,CAC5B,eAAe,CAAE,uBAAuB,CACxC,uBAAuB,CAAE,SAAS,CAClC,gBAAgB,CAAE,SAAS,CAC3B,eAAe,CAAE,OAAO,CACxB,eAAe,CAAE,OAAO,AACzB,CAAC,AACS,UAAU,AAAE,CAAC,AACtB,KAAK,CAAE,IAAI,AACZ,CAAC,AACC,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAEpB,UAAU,AAAE,CAAC,AACpB,SAAS,CAAE,KAAK,AACjB,CAAC,AACF,CAAC,AACC,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAEpB,UAAU,AAAE,CAAC,AACpB,SAAS,CAAE,KAAK,AACjB,CAAC,AACF,CAAC,AACC,MAAM,AAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AAErB,UAAU,AAAE,CAAC,AACpB,SAAS,CAAE,MAAM,AAClB,CAAC,AACF,CAAC,AACC,MAAM,AAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AAErB,UAAU,AAAE,CAAC,AACpB,SAAS,CAAE,MAAM,AAClB,CAAC,AACF,CAAC,AACC,MAAM,AAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AAErB,UAAU,AAAE,CAAC,AACpB,SAAS,CAAE,MAAM,AAClB,CAAC,AACF,CAAC,AACS,QAAQ,AAAE,CAAC,AACpB,UAAU,CAAE,OAAO,AACpB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,QAAQ,CAAE,QAAQ,AACnB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,QAAQ,CAAE,QAAQ,AACnB,CAAC,AACS,OAAO,AAAE,CAAC,AACnB,QAAQ,CAAE,MAAM,AACjB,CAAC,AACS,UAAU,AAAE,CAAC,AACtB,GAAG,CAAE,GAAG,CACR,MAAM,CAAE,GAAG,AACZ,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,MAAM,CAAE,GAAG,AACZ,CAAC,AACS,QAAQ,AAAE,CAAC,AACpB,KAAK,CAAE,GAAG,AACX,CAAC,AACS,OAAO,AAAE,CAAC,AACnB,IAAI,CAAE,GAAG,AACV,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,OAAO,CAAE,EAAE,AACZ,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,MAAM,CAAE,KAAK,AACd,CAAC,AACS,OAAO,AAAE,CAAC,AACnB,MAAM,CAAE,IAAI,AACb,CAAC,AACS,IAAI,AAAE,CAAC,AAChB,MAAM,CAAE,MAAM,AACf,CAAC,AACS,QAAQ,AAAE,CAAC,AACpB,WAAW,CAAE,IAAI,CACjB,YAAY,CAAE,IAAI,AACnB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,aAAa,CAAE,IAAI,AACpB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,YAAY,CAAE,OAAO,AACtB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,YAAY,CAAE,IAAI,AACnB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,aAAa,CAAE,MAAM,AACtB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,aAAa,CAAE,IAAI,AACpB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,UAAU,CAAE,OAAO,AACpB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,WAAW,CAAE,MAAM,AACpB,CAAC,AACS,MAAM,AAAE,CAAC,AAClB,UAAU,CAAE,MAAM,AACnB,CAAC,AACS,MAAM,AAAE,CAAC,AAClB,aAAa,CAAE,IAAI,AACpB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,UAAU,CAAE,MAAM,AACnB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,UAAU,CAAE,OAAO,AACpB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,UAAU,CAAE,IAAI,AACjB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,aAAa,CAAE,OAAO,AACvB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,WAAW,CAAE,IAAI,AAClB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,aAAa,CAAE,OAAO,AACvB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,aAAa,CAAE,OAAO,AACvB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,WAAW,CAAE,OAAO,AACrB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,YAAY,CAAE,MAAM,AACrB,CAAC,AACS,QAAQ,AAAE,CAAC,AACpB,UAAU,CAAE,IAAI,AACjB,CAAC,AACS,QAAQ,AAAE,CAAC,AACpB,WAAW,CAAE,IAAI,AAClB,CAAC,AACS,OAAO,AAAE,CAAC,AACnB,aAAa,CAAE,IAAI,AACpB,CAAC,AACS,MAAM,AAAE,CAAC,AAClB,OAAO,CAAE,KAAK,AACf,CAAC,AACS,WAAW,AAAE,CAAC,AACvB,OAAO,CAAE,UAAU,AACpB,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,OAAO,CAAE,YAAY,AACtB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,OAAO,CAAE,IAAI,AACd,CAAC,AACS,MAAM,AAAE,CAAC,AAClB,OAAO,CAAE,KAAK,AACf,CAAC,AACS,YAAY,AAAE,CAAC,AACxB,OAAO,CAAE,WAAW,AACrB,CAAC,AACS,OAAO,AAAE,CAAC,AACnB,OAAO,CAAE,IAAI,AACd,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,MAAM,CAAE,MAAM,AACf,CAAC,AACS,OAAO,AAAE,CAAC,AACnB,MAAM,CAAE,IAAI,AACb,CAAC,AACS,IAAI,AAAE,CAAC,AAChB,MAAM,CAAE,OAAO,AAChB,CAAC,AACS,IAAI,AAAE,CAAC,AAChB,MAAM,CAAE,MAAM,AACf,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,MAAM,CAAE,KAAK,AACd,CAAC,AACS,IAAI,AAAE,CAAC,AAChB,MAAM,CAAE,IAAI,AACb,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,MAAM,CAAE,IAAI,AACb,CAAC,AACS,IAAI,AAAE,CAAC,AAChB,MAAM,CAAE,IAAI,AACb,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,KAAK,CAAE,MAAM,AACd,CAAC,AACS,OAAO,AAAE,CAAC,AACnB,KAAK,CAAE,IAAI,AACZ,CAAC,AACS,IAAI,AAAE,CAAC,AAChB,KAAK,CAAE,OAAO,AACf,CAAC,AACS,IAAI,AAAE,CAAC,AAChB,KAAK,CAAE,MAAM,AACd,CAAC,AACS,IAAI,AAAE,CAAC,AAChB,KAAK,CAAE,IAAI,AACZ,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,KAAK,CAAE,IAAI,AACZ,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,KAAK,CAAE,KAAK,AACb,CAAC,AACS,QAAQ,AAAE,CAAC,AACpB,KAAK,CAAE,GAAG,AACX,CAAC,AACS,IAAI,AAAE,CAAC,AAChB,KAAK,CAAE,IAAI,AACZ,CAAC,AACS,OAAO,AAAE,CAAC,AACnB,KAAK,CAAE,UAAU,AAClB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,KAAK,CAAE,KAAK,AACb,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,KAAK,CAAE,IAAI,AACZ,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,KAAK,CAAE,KAAK,AACb,CAAC,AACS,WAAW,AAAE,CAAC,AACvB,SAAS,CAAE,IAAI,AAChB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,SAAS,CAAE,KAAK,AACjB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,SAAS,CAAE,KAAK,AACjB,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,WAAW,CAAE,CAAC,AACf,CAAC,AACS,YAAY,AAAE,CAAC,AACxB,WAAW,CAAE,CAAC,AACf,CAAC,AACS,UAAU,AAAE,CAAC,AACtB,SAAS,CAAE,CAAC,AACb,CAAC,AACS,UAAU,AAAE,CAAC,AACtB,gBAAgB,CAAE,CAAC,CACnB,gBAAgB,CAAE,CAAC,CACnB,WAAW,CAAE,CAAC,CACd,WAAW,CAAE,CAAC,CACd,WAAW,CAAE,CAAC,CACd,YAAY,CAAE,CAAC,CACf,YAAY,CAAE,CAAC,CACf,SAAS,CAAE,WAAW,IAAI,gBAAgB,CAAC,CAAC,CAAC,WAAW,IAAI,gBAAgB,CAAC,CAAC,CAAC,OAAO,IAAI,WAAW,CAAC,CAAC,CAAC,MAAM,IAAI,WAAW,CAAC,CAAC,CAAC,MAAM,IAAI,WAAW,CAAC,CAAC,CAAC,OAAO,IAAI,YAAY,CAAC,CAAC,CAAC,OAAO,IAAI,YAAY,CAAC,CAAC,AAC5M,CAAC,AACS,kBAAkB,AAAE,CAAC,AAC9B,gBAAgB,CAAE,KAAK,AACxB,CAAC,AACS,eAAe,AAAE,CAAC,AAC3B,gBAAgB,CAAE,QAAQ,AAC3B,CAAC,AACS,UAAU,AAAE,CAAC,AACtB,WAAW,CAAE,KAAK,AACnB,CAAC,AACS,eAAe,AAAE,CAAC,AAC3B,MAAM,CAAE,OAAO,AAChB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,cAAc,CAAE,MAAM,AACvB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,cAAc,CAAE,GAAG,AACpB,CAAC,AACS,UAAU,AAAE,CAAC,AACtB,SAAS,CAAE,IAAI,AAChB,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,WAAW,CAAE,MAAM,AACpB,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,WAAW,CAAE,OAAO,AACrB,CAAC,AACS,YAAY,AAAE,CAAC,AACxB,WAAW,CAAE,UAAU,AACxB,CAAC,AACS,gBAAgB,AAAE,CAAC,AAC5B,eAAe,CAAE,aAAa,AAC/B,CAAC,AACS,eAAe,AAAE,CAAC,AAC3B,eAAe,CAAE,MAAM,AACxB,CAAC,AACS,SAAS,AAAC,CAAW,cAAc,AAAC,CAAW,cAAc,AAAE,CAAC,AACzE,qBAAqB,CAAE,CAAC,CACxB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,qBAAqB,CAAC,CAAC,CAAC,CAClE,mBAAmB,CAAE,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,qBAAqB,CAAC,CAAC,AAC5D,CAAC,AACS,kBAAkB,AAAC,CAAW,cAAc,AAAC,CAAW,cAAc,AAAE,CAAC,AAClF,mBAAmB,CAAE,CAAC,CACtB,YAAY,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,mBAAmB,CAAC,CAAC,AAC5D,CAAC,AACS,kBAAkB,AAAC,CAAW,cAAc,AAAC,CAAW,cAAc,AAAE,CAAC,AAClF,mBAAmB,CAAE,CAAC,CACtB,YAAY,CAAE,KAAK,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,mBAAmB,CAAC,CAAC,AAC3D,CAAC,AACS,iBAAiB,AAAC,CAAW,cAAc,AAAC,CAAW,cAAc,AAAE,CAAC,AACjF,mBAAmB,CAAE,CAAC,CACtB,YAAY,CAAE,KAAK,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,mBAAmB,CAAC,CAAC,AAC3D,CAAC,AACS,gBAAgB,AAAE,CAAC,AAC5B,QAAQ,CAAE,MAAM,AACjB,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,QAAQ,CAAE,IAAI,AACf,CAAC,AACS,gBAAgB,AAAE,CAAC,AAC5B,QAAQ,CAAE,MAAM,AACjB,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,aAAa,CAAE,MAAM,AACtB,CAAC,AACS,QAAQ,AAAE,CAAC,AACpB,aAAa,CAAE,OAAO,AACvB,CAAC,AACS,WAAW,AAAE,CAAC,AACvB,aAAa,CAAE,QAAQ,AACxB,CAAC,AACS,WAAW,AAAE,CAAC,AACvB,aAAa,CAAE,MAAM,AACtB,CAAC,AACS,UAAU,AAAE,CAAC,AACtB,sBAAsB,CAAE,OAAO,CAC/B,uBAAuB,CAAE,OAAO,AACjC,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,YAAY,CAAE,GAAG,AAClB,CAAC,AACS,OAAO,AAAE,CAAC,AACnB,YAAY,CAAE,GAAG,AAClB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,YAAY,CAAE,GAAG,AAClB,CAAC,AACS,WAAW,AAAE,CAAC,AACvB,iBAAiB,CAAE,GAAG,AACvB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,mBAAmB,CAAE,GAAG,AACzB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,iBAAiB,CAAE,GAAG,AACvB,CAAC,AACS,WAAW,AAAE,CAAC,AACvB,mBAAmB,CAAE,GAAG,AACzB,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,mBAAmB,CAAE,CAAC,CACtB,YAAY,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,mBAAmB,CAAC,CAAC,AAC5D,CAAC,AACS,kBAAkB,AAAE,CAAC,AAC9B,mBAAmB,CAAE,CAAC,CACtB,YAAY,CAAE,KAAK,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,mBAAmB,CAAC,CAAC,AAC3D,CAAC,AACS,gBAAgB,AAAE,CAAC,AAC5B,mBAAmB,CAAE,CAAC,CACtB,YAAY,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,mBAAmB,CAAC,CAAC,AAC5D,CAAC,AACS,kBAAkB,AAAE,CAAC,AAC9B,mBAAmB,CAAE,CAAC,CACtB,YAAY,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,mBAAmB,CAAC,CAAC,AAC1D,CAAC,AACS,gBAAgB,AAAE,CAAC,AAC5B,mBAAmB,CAAE,CAAC,CACtB,YAAY,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,mBAAmB,CAAC,CAAC,AAC5D,CAAC,AACS,gBAAgB,AAAE,CAAC,AAC5B,mBAAmB,CAAE,CAAC,CACtB,YAAY,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,mBAAmB,CAAC,CAAC,AAC5D,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,mBAAmB,CAAE,CAAC,CACtB,YAAY,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,mBAAmB,CAAC,CAAC,AACtD,CAAC,AACS,iBAAiB,AAAE,CAAC,AAC7B,mBAAmB,CAAE,CAAC,AACvB,CAAC,AACS,kBAAkB,AAAE,CAAC,AAC9B,mBAAmB,CAAE,IAAI,AAC1B,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC1D,CAAC,AACS,WAAW,AAAE,CAAC,AACvB,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC5D,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC3D,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC5D,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC5D,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC5D,CAAC,AACS,YAAY,AAAE,CAAC,AACxB,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC5D,CAAC,AACS,eAAe,AAAE,CAAC,AAC3B,gBAAgB,CAAE,WAAW,AAC9B,CAAC,AACS,WAAW,AAAE,CAAC,AACvB,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC1D,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC3D,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC3D,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC3D,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC5D,CAAC,AACS,YAAY,AAAE,CAAC,AACxB,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC5D,CAAC,AACS,YAAY,AAAE,CAAC,AACxB,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC5D,CAAC,AACS,IAAI,AAAE,CAAC,AAChB,OAAO,CAAE,MAAM,AAChB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,OAAO,CAAE,IAAI,AACd,CAAC,AACS,IAAI,AAAE,CAAC,AAChB,OAAO,CAAE,IAAI,AACd,CAAC,AACS,IAAI,AAAE,CAAC,AAChB,OAAO,CAAE,MAAM,AAChB,CAAC,AACS,IAAI,AAAE,CAAC,AAChB,OAAO,CAAE,OAAO,AACjB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,YAAY,CAAE,MAAM,CACpB,aAAa,CAAE,MAAM,AACtB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,WAAW,CAAE,OAAO,CACpB,cAAc,CAAE,OAAO,AACxB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,YAAY,CAAE,OAAO,CACrB,aAAa,CAAE,OAAO,AACvB,CAAC,AACS,MAAM,AAAE,CAAC,AAClB,WAAW,CAAE,MAAM,CACnB,cAAc,CAAE,MAAM,AACvB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,WAAW,CAAE,OAAO,CACpB,cAAc,CAAE,OAAO,AACxB,CAAC,AACS,MAAM,AAAE,CAAC,AAClB,WAAW,CAAE,IAAI,CACjB,cAAc,CAAE,IAAI,AACrB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,YAAY,CAAE,IAAI,CAClB,aAAa,CAAE,IAAI,AACpB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,WAAW,CAAE,IAAI,CACjB,cAAc,CAAE,IAAI,AACrB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,YAAY,CAAE,OAAO,CACrB,aAAa,CAAE,OAAO,AACvB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,WAAW,CAAE,MAAM,CACnB,cAAc,CAAE,MAAM,AACvB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,YAAY,CAAE,OAAO,CACrB,aAAa,CAAE,OAAO,AACvB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,YAAY,CAAE,OAAO,AACtB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,YAAY,CAAE,IAAI,AACnB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,aAAa,CAAE,OAAO,AACvB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,WAAW,CAAE,IAAI,AAClB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,YAAY,CAAE,IAAI,AACnB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,aAAa,CAAE,IAAI,AACpB,CAAC,AACS,MAAM,AAAE,CAAC,AAClB,WAAW,CAAE,MAAM,AACpB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,WAAW,CAAE,OAAO,AACrB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,WAAW,CAAE,MAAM,AACpB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,WAAW,CAAE,IAAI,AAClB,CAAC,AACS,MAAM,AAAE,CAAC,AAClB,YAAY,CAAE,MAAM,AACrB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,cAAc,CAAE,OAAO,AACxB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,cAAc,CAAE,MAAM,AACvB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,YAAY,CAAE,MAAM,AACrB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,WAAW,CAAE,OAAO,AACrB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,cAAc,CAAE,IAAI,AACrB,CAAC,AACS,KAAK,AAAE,CAAC,AACjB,YAAY,CAAE,OAAO,AACtB,CAAC,AACS,YAAY,AAAE,CAAC,AACxB,UAAU,CAAE,MAAM,AACnB,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,cAAc,CAAE,MAAM,AACvB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,SAAS,CAAE,QAAQ,CACnB,WAAW,CAAE,OAAO,AACrB,CAAC,AACS,QAAQ,AAAE,CAAC,AACpB,SAAS,CAAE,OAAO,CAClB,WAAW,CAAE,OAAO,AACrB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,SAAS,CAAE,OAAO,CAClB,WAAW,CAAE,CAAC,AACf,CAAC,AACS,QAAQ,AAAE,CAAC,AACpB,SAAS,CAAE,QAAQ,CACnB,WAAW,CAAE,OAAO,AACrB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,SAAS,CAAE,OAAO,CAClB,WAAW,CAAE,MAAM,AACpB,CAAC,AACS,UAAU,AAAE,CAAC,AACtB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,MAAM,AACpB,CAAC,AACS,QAAQ,AAAE,CAAC,AACpB,SAAS,CAAE,QAAQ,CACnB,WAAW,CAAE,OAAO,AACrB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,SAAS,CAAE,MAAM,CACjB,WAAW,CAAE,IAAI,AAClB,CAAC,AACS,SAAS,AAAE,CAAC,AACrB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,CAAC,AACf,CAAC,AACS,UAAU,AAAE,CAAC,AACtB,WAAW,CAAE,GAAG,AACjB,CAAC,AACS,WAAW,AAAE,CAAC,AACvB,WAAW,CAAE,GAAG,AACjB,CAAC,AACS,YAAY,AAAE,CAAC,AACxB,WAAW,CAAE,GAAG,AACjB,CAAC,AACS,YAAY,AAAE,CAAC,AACxB,WAAW,CAAE,GAAG,AACjB,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,WAAW,CAAE,GAAG,AACjB,CAAC,AACS,OAAO,AAAE,CAAC,AACnB,UAAU,CAAE,MAAM,AACnB,CAAC,AACS,gBAAgB,AAAE,CAAC,AAC5B,WAAW,CAAE,KAAK,AACnB,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,WAAW,CAAE,KAAK,AACnB,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,WAAW,CAAE,CAAC,AACf,CAAC,AACS,gBAAgB,AAAE,CAAC,AAC5B,cAAc,CAAE,GAAG,AACpB,CAAC,AACS,gBAAgB,AAAE,CAAC,AAC5B,cAAc,CAAE,KAAK,AACtB,CAAC,AACS,WAAW,AAAE,CAAC,AACvB,iBAAiB,CAAE,CAAC,CACpB,KAAK,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,AAC7C,CAAC,AACS,WAAW,AAAE,CAAC,AACvB,iBAAiB,CAAE,CAAC,CACpB,KAAK,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,AACnD,CAAC,AACS,eAAe,AAAE,CAAC,AAC3B,iBAAiB,CAAE,CAAC,CACpB,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,AAClD,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,iBAAiB,CAAE,CAAC,CACpB,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,AAChD,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,iBAAiB,CAAE,CAAC,CACpB,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,AAChD,CAAC,AACS,gBAAgB,AAAE,CAAC,AAC5B,iBAAiB,CAAE,CAAC,CACpB,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,AAClD,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,iBAAiB,CAAE,CAAC,CACpB,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,AAChD,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,iBAAiB,CAAE,CAAC,CACpB,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,AAChD,CAAC,AACS,cAAc,AAAE,CAAC,AAC1B,iBAAiB,CAAE,CAAC,CACpB,KAAK,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,AACnD,CAAC,AACS,gBAAgB,AAAE,CAAC,AAC5B,iBAAiB,CAAE,CAAC,CACpB,KAAK,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,AACnD,CAAC,AACS,eAAe,AAAE,CAAC,AAC3B,iBAAiB,CAAE,CAAC,CACpB,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,AAClD,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,iBAAiB,CAAE,CAAC,CACpB,KAAK,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,AACnD,CAAC,AACS,UAAU,AAAE,CAAC,AACtB,eAAe,CAAE,SAAS,AAC3B,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,eAAe,CAAE,YAAY,AAC9B,CAAC,AACS,UAAU,AAAE,CAAC,AACtB,OAAO,CAAE,CAAC,AACX,CAAC,AACS,WAAW,AAAE,CAAC,AACvB,OAAO,CAAE,GAAG,AACb,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,WAAW,CAAE,qCAAqC,CAClD,UAAU,CAAE,IAAI,uBAAuB,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,gBAAgB,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,WAAW,CAAC,AACxG,CAAC,AACS,OAAO,AAAE,CAAC,AACnB,WAAW,CAAE,+DAA+D,CAC5E,UAAU,CAAE,IAAI,uBAAuB,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,gBAAgB,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,WAAW,CAAC,AACxG,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,OAAO,CAAE,GAAG,CAAC,KAAK,CAAC,WAAW,CAC9B,cAAc,CAAE,GAAG,AACpB,CAAC,AACS,WAAW,AAAE,CAAC,AACvB,mBAAmB,CAAE,gBAAgB,CAAC,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,UAAU,CAAC,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,CAAC,uBAAuB,CACzI,mBAAmB,CAAE,gBAAgB,CAAC,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,UAAU,CAAC,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,CAAC,eAAe,CACjI,mBAAmB,CAAE,gBAAgB,CAAC,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,UAAU,CAAC,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,CAAC,eAAe,CAAC,CAAC,uBAAuB,CAC1J,0BAA0B,CAAE,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CACxD,mBAAmB,CAAE,KAAK,AAC3B,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,mBAAmB,CAAE,KAAK,AAC3B,CAAC,AACS,aAAa,AAAE,CAAC,AACzB,mBAAmB,CAAE,KAAK,AAC3B,CAAC,AACS,YAAY,AAAE,CAAC,AACxB,0BAA0B,CAAE,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,AACzD,CAAC,AACS,4BAA4B,AAAE,CAAC,AACxC,gBAAgB,CAAE,QAAQ,AAC3B,CAAC,AACS,uBAAuB,AAAE,CAAC,AACnC,YAAY,CAAE,IAAI,CAClB,YAAY,CAAE,IAAI,AACnB,CAAC,AACS,uBAAuB,AAAE,CAAC,AACnC,YAAY,CAAE,GAAG,CACjB,YAAY,CAAE,GAAG,AAClB,CAAC,AACS,+BAA+B,AAAE,CAAC,AAC3C,mBAAmB,CAAE,CAAC,CACtB,YAAY,CAAE,KAAK,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,mBAAmB,CAAC,CAAC,AAC3D,CAAC,AACS,gCAAgC,AAAE,CAAC,AAC5C,mBAAmB,CAAE,CAAC,AACvB,CAAC,AACS,2BAA2B,AAAE,CAAC,AACvC,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC1D,CAAC,AACS,2BAA2B,AAAE,CAAC,AACvC,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC5D,CAAC,AACS,2BAA2B,AAAE,CAAC,AACvC,eAAe,CAAE,CAAC,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,AAC5D,CAAC,AACS,0BAA0B,AAAE,CAAC,AACtC,iBAAiB,CAAE,CAAC,CACpB,KAAK,CAAE,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,AACjD,CAAC,AACS,yBAAyB,AAAE,CAAC,AACrC,OAAO,CAAE,CAAC,AACX,CAAC,AACS,wBAAwB,AAAE,CAAC,AACpC,OAAO,CAAE,GAAG,AACb,CAAC,AACS,0BAA0B,AAAE,CAAC,AACtC,OAAO,CAAE,GAAG,CAAC,KAAK,CAAC,WAAW,CAC9B,cAAc,CAAE,GAAG,AACpB,CAAC,AACS,kBAAkB,AAAE,CAAC,AAC9B,uBAAuB,CAAE,kFAAkF,CAC3G,gBAAgB,CAAE,uFAAuF,CACzG,UAAU,CAAE,IAAI,uBAAuB,CAAC,CAAC,CAAC,IAAI,gBAAgB,CAAC,CAAC,CAAC,IAAI,WAAW,CAAC,UAAU,CAAC,AAC7F,CAAC,AACS,YAAY,AAAC,CAAC,AAAQ,wBAAwB,AAAE,CAAC,AAC1D,OAAO,CAAE,GAAG,AACb,CAAC,AACC,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAEpB,aAAa,AAAE,CAAC,AACvB,SAAS,CAAE,OAAO,CAClB,WAAW,CAAE,MAAM,AACpB,CAAC,AACF,CAAC,AACC,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAEpB,aAAa,AAAE,CAAC,AACvB,QAAQ,CAAE,QAAQ,AACnB,CAAC,AAEO,UAAU,AAAE,CAAC,AACpB,OAAO,CAAE,KAAK,AACf,CAAC,AAEO,WAAW,AAAE,CAAC,AACrB,KAAK,CAAE,GAAG,AACX,CAAC,AAEO,kBAAkB,AAAE,CAAC,AAC5B,gBAAgB,CAAE,GAAG,AACtB,CAAC,AACF,CAAC,AACC,MAAM,AAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AAErB,WAAW,AAAE,CAAC,AACrB,KAAK,CAAE,UAAU,AAClB,CAAC,AACF,CAAC,AACC,MAAM,AAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AAErB,WAAW,AAAE,CAAC,AACrB,KAAK,CAAE,GAAG,AACX,CAAC,AACF,CAAC"}`
};
var TailwindCss = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css$2);
  return ``;
});
var _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(TailwindCss, "TailwindCss").$$render($$result, {}, {}, {})}

${slots.default ? slots.default({}) : ``}`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout
});
function load({error: error22, status}) {
  return {props: {error: error22, status}};
}
var Error$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {status} = $$props;
  let {error: error22} = $$props;
  if ($$props.status === void 0 && $$bindings.status && status !== void 0)
    $$bindings.status(status);
  if ($$props.error === void 0 && $$bindings.error && error22 !== void 0)
    $$bindings.error(error22);
  return `<h1>${escape2(status)}</h1>

<p>${escape2(error22.message)}</p>


${error22.stack ? `<pre>${escape2(error22.stack)}</pre>` : ``}`;
});
var error2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Error$1,
  load
});
var Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<main class="${"min-w-full h-screen"}"><body class="${"container min-w-full"}"><header class="${"flex justify-between pl-8 pr-1 pt-4"}"><div class="${"ld-8 text-3xl"}">Teilen</div>
			<div class="${"text-xl"}"><a class="${"mr-4"}">Why Teilen</a>
				<a href="${"pricing"}" class="${"mr-4"}">Pricing</a>
				<a class="${"mr-4"}">About</a>
				<button class="${"mr-4 border border-indigo-500 p-2 pl-4 pr-4 rounded"}">LogIn</button>
				<button class="${"text-white bg-indigo-500 mr-4 border  p-2 pl-4 pr-4 rounded"}">SignIn</button></div></header>
		<div class="${"flex"}"><div class="${"container h-screen w-full"}"><div class="${" pt-10 px- p-20"}"><h1 class="${"text-6xl font-bold text-gray-800"}">Make learning fun
					</h1>
					<h2 class="${"pt-5 font-normal text-lg tracking-normal text-gray-700"}">Lorem ipsum dolor sit amet, consectetur adipiscing elit
					
					</h2></div></div>
			<div class="${"container h-screen hidden md:block"}"><div><img class="${"w-full"}" href="${"https://storyset.com/education"}" src="${"../../static/images/svg/Telecommuting-cuate.svg"}" alt="${"Kiwi standing on oval"}">
				  <a href="${"https://storyset.com/work"}">Illustration by Freepik Storyset</a></div></div></div></body>
	
</main>`;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes
});
var css$1 = {
  code: "svg.svelte-3h8371{stroke:currentColor;fill:currentColor;stroke-width:0;width:100%;height:auto;max-height:100%}",
  map: '{"version":3,"file":"IconBase.svelte","sources":["IconBase.svelte"],"sourcesContent":["<script>\\n  export let title = null;\\n  export let viewBox;\\n</script>\\n\\n<style>\\n  svg {\\n    stroke: currentColor;\\n    fill: currentColor;\\n    stroke-width: 0;\\n    width: 100%;\\n    height: auto;\\n    max-height: 100%;\\n  }</style>\\n\\n<svg xmlns=\\"http://www.w3.org/2000/svg\\" {viewBox}>\\n  {#if title}\\n    <title>{title}</title>\\n  {/if}\\n  <slot />\\n</svg>\\n"],"names":[],"mappings":"AAME,GAAG,cAAC,CAAC,AACH,MAAM,CAAE,YAAY,CACpB,IAAI,CAAE,YAAY,CAClB,YAAY,CAAE,CAAC,CACf,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,IAAI,AAClB,CAAC"}'
};
var IconBase = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {title = null} = $$props;
  let {viewBox} = $$props;
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  if ($$props.viewBox === void 0 && $$bindings.viewBox && viewBox !== void 0)
    $$bindings.viewBox(viewBox);
  $$result.css.add(css$1);
  return `<svg xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("viewBox", viewBox, 0)} class="${"svelte-3h8371"}">${title ? `<title>${escape2(title)}</title>` : ``}${slots.default ? slots.default({}) : ``}</svg>`;
});
var TiFolder = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 24 24"}, $$props), {}, {
    default: () => `<path d="${"M18 6h-6c0-1.104-.896-2-2-2h-4c-1.654 0-3 1.346-3 3v10c0 1.654 1.346 3 3 3h12c1.654 0 3-1.346 3-3v-8c0-1.654-1.346-3-3-3zm-12 0h4c0 1.104.896 2 2 2h6c.552 0 1 .448 1 1h-14v-2c0-.552.448-1 1-1zm12 12h-12c-.552 0-1-.448-1-1v-7h14v7c0 .552-.448 1-1 1z"}"></path>`
  })}`;
});
var Avatar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {color} = $$props;
  let {name: name2} = $$props;
  if ($$props.color === void 0 && $$bindings.color && color !== void 0)
    $$bindings.color(color);
  if ($$props.name === void 0 && $$bindings.name && name2 !== void 0)
    $$bindings.name(name2);
  return `<div class="${"w-10 h-10 relative mb-4 flex-shrink-0"}"><div class="${escape2(color) + " w-full h-full rounded-full overflow-hidden shadow-inner text-center table cursor-pointer transform hover:scale-125"}"><span class="${"table-cell text-black font-bold align-middle"}">${escape2(name2)}</span></div>
    <span class="${"absolute bottom-0 right-0 inline-block w-3 h-3 bg-green-600 border-2 border-white rounded-full"}"></span></div>`;
});
var ItemType;
(function(ItemType2) {
  ItemType2[ItemType2["File"] = 0] = "File";
  ItemType2[ItemType2["Folder"] = 1] = "Folder";
})(ItemType || (ItemType = {}));
var Root = class {
  constructor(folders) {
    this.folders = folders;
    this.selected = null;
  }
  selectFile(file) {
    this.selected = file;
    this.folders.selectFile(file);
    return this;
  }
};
var Item = class {
  constructor(name2) {
    this.name = name2;
    this.expanded = false;
  }
  folder(children) {
    this.children = children;
    this.type = 1;
    return this;
  }
  file(content2) {
    this.content = content2;
    this.type = 0;
    return this;
  }
  isFolder() {
    return this.type == 1;
  }
  isFile() {
    return this.type == 0;
  }
  equal(item) {
    if (this.type == 0) {
      return item.type == 0 && this.name == item.name && this.content == item.content;
    }
    return item.type == 1 && this.name == item.name && this.children == item.children;
  }
  static fromTab(tab) {
    return new Item(tab.name).file(tab.content);
  }
  selectFile(item) {
    if (this.equal(item)) {
      this.expanded = true;
    } else {
      if (this.isFile()) {
        this.expanded = false;
      }
    }
    if (!this.children) {
      return;
    }
    if (this.children.length < 1) {
      return;
    }
    for (let child of this.children) {
      child.selectFile(item);
    }
  }
};
var Folder$1 = (name2, children) => {
  return new Item(name2).folder(children);
};
var File = (name2, content2) => {
  return new Item(name2).file(content2);
};
var default_folder = Folder$1("src", [
  Folder$1("js", [
    File("a.js", "let a = 2;"),
    File("b.js", "let b = 2"),
    File("c.js", "let c = 2"),
    Folder$1("nested_js", [
      File("d.js", "let d = 2;"),
      File("e.js", "let e = 2"),
      File("f.js", "let f = 2"),
      Folder$1("second_nested_js", [
        File("g.js", "let g = 2;"),
        File("h.js", "let h = 2"),
        File("i.js", "let i = 2")
      ])
    ])
  ]),
  Folder$1("go", [
    File("a.go", "let a = 2"),
    File("b.go", "let b = 2"),
    File("c.go", "let c = 2")
  ]),
  Folder$1("css", [
    File("a.css", "let a = 2"),
    File("b.css", "let b = 2"),
    File("c.css", "let c = 2")
  ]),
  Folder$1("java", [
    File("a.java", "let a = 2"),
    File("b.java", "let b = 2"),
    File("c.java", "let c = 2")
  ]),
  Folder$1("python", [
    File("a.py", "let a = 2"),
    File("b.py", "let b = 2"),
    File("c.py", "let c = 2")
  ]),
  File("a.cpp", "let a = 2"),
  File("b.cpp", "let b = 2"),
  File("c.cpp", "let c = 2")
]);
var MdChevronRight = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 24 24"}, $$props), {}, {
    default: () => `<path d="${"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"}"></path>`
  })}`;
});
var IoMdMore = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 512 512"}, $$props), {}, {
    default: () => `<path d="${"M296 136c0-22.002-17.998-40-40-40s-40 17.998-40 40 17.998 40 40 40 40-17.998 40-40zm0 240c0-22.002-17.998-40-40-40s-40 17.998-40 40 17.998 40 40 40 40-17.998 40-40zm0-120c0-22.002-17.998-40-40-40s-40 17.998-40 40 17.998 40 40 40 40-17.998 40-40z"}"></path>`
  })}`;
});
var DiPython = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 32 32"}, $$props), {}, {
    default: () => `<path d="${"M13.275 15.88h5.417c1.508 0 2.712-1.241 2.712-2.756v-5.164c0-1.47-1.24-2.574-2.712-2.819-0.932-0.155-1.898-0.226-2.825-0.221s-1.813 0.083-2.592 0.221c-2.295 0.405-2.712 1.254-2.712 2.819v2.067h5.423v0.689h-7.459c-1.576 0-2.956 0.947-3.388 2.75-0.498 2.066-0.52 3.355 0 5.512 0.385 1.606 1.306 2.75 2.882 2.75h1.865v-2.478c0-1.79 1.549-3.369 3.388-3.369zM12.933 8.649c-0.562 0-1.018-0.461-1.018-1.030 0-0.572 0.455-1.037 1.018-1.037 0.56 0 1.018 0.465 1.018 1.037 0 0.57-0.457 1.030-1.018 1.030zM26.826 13.465c-0.389-1.569-1.133-2.75-2.712-2.75h-2.035v2.408c0 1.867-1.583 3.439-3.388 3.439h-5.417c-1.484 0-2.712 1.27-2.712 2.756v5.164c0 1.47 1.278 2.334 2.712 2.756 1.717 0.505 3.363 0.596 5.417 0 1.365-0.395 2.712-1.191 2.712-2.756v-2.067h-5.417v-0.689h8.129c1.576 0 2.163-1.099 2.712-2.75 0.566-1.699 0.542-3.332 0-5.512zM19.033 23.794c0.562 0 1.018 0.461 1.018 1.030 0 0.572-0.456 1.037-1.018 1.037-0.56 0-1.018-0.465-1.018-1.037 0-0.57 0.457-1.030 1.018-1.030z"}"></path>`
  })}`;
});
var DiCodeBadge = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 32 32"}, $$props), {}, {
    default: () => `<path d="${"M21.652 3.098h-16.955v26.375h22.607v-20.723l-5.652-5.652zM25.42 27.589h-18.839v-22.607h13.188l5.652 5.652v16.955zM12.269 11.851l-3.644 4.434 3.644 4.434 0.862-1.417-2.455-3.017 2.455-3.017zM13.863 20.614h1.599l2.542-8.681h-1.599zM19.731 11.851l-0.862 1.418 2.455 3.017-2.455 3.017 0.862 1.418 3.644-4.434z"}"></path>`
  })}`;
});
var DiCode = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 32 32"}, $$props), {}, {
    default: () => `<path d="${"M11.067 10.423l-4.817 5.863 4.817 5.862 1.139-1.874-3.246-3.989 3.246-3.989zM13.175 22.008h2.114l3.361-11.477h-2.115zM20.933 10.423l-1.139 1.874 3.246 3.989-3.246 3.989 1.139 1.874 4.817-5.862z"}"></path>`
  })}`;
});
var DiJavascript1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 32 32"}, $$props), {}, {
    default: () => `<path d="${"M9.633 7.968h3.751v10.514c0 4.738-2.271 6.392-5.899 6.392-0.888 0-2.024-0.148-2.764-0.395l0.42-3.036c0.518 0.173 1.185 0.296 1.925 0.296 1.58 0 2.567-0.716 2.567-3.282v-10.489zM16.641 20.753c0.987 0.518 2.567 1.037 4.171 1.037 1.728 0 2.641-0.716 2.641-1.826 0-1.012-0.79-1.629-2.789-2.32-2.764-0.987-4.59-2.517-4.59-4.961 0-2.838 2.394-4.985 6.293-4.985 1.9 0 3.258 0.37 4.245 0.839l-0.839 3.011c-0.642-0.321-1.851-0.79-3.455-0.79-1.629 0-2.419 0.765-2.419 1.604 0 1.061 0.913 1.53 3.085 2.369 2.937 1.086 4.294 2.616 4.294 4.985 0 2.789-2.122 5.158-6.688 5.158-1.9 0-3.776-0.518-4.714-1.037l0.765-3.085z"}"></path>`
  })}`;
});
var DiCss3 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 32 32"}, $$props), {}, {
    default: () => `<path d="${"M16.017 21.044v0zM4.743 3.519l2.049 22.981 9.194 2.552 9.22-2.556 2.051-22.977h-22.514zM23 8.775l-0.693 7.767h-0l-0.48 5.359-0.042 0.476-5.781 1.603-5.773-1.603-0.395-4.426h2.829l0.201 2.248 3.142 0.847 0.008-0.002 0.002-0 3.134-0.846 0.329-3.655-6.579 0-0.056-0.633-0.129-1.429-0.067-0.756 7.081-0 0.258-2.886h-10.786l-0.056-0.634-0.129-1.429-0.067-0.756h14.118l-0.068 0.756z"}"></path>`
  })}`;
});
var DiJava = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 32 32"}, $$props), {}, {
    default: () => `<path d="${"M12.557 23.22c0 0-0.982 0.571 0.699 0.765 2.037 0.232 3.079 0.199 5.324-0.226 0 0 0.59 0.37 1.415 0.691-5.033 2.157-11.39-0.125-7.437-1.23zM11.942 20.405c0 0-1.102 0.816 0.581 0.99 2.176 0.224 3.895 0.243 6.869-0.33 0 0 0.411 0.417 1.058 0.645-6.085 1.779-12.863 0.14-8.508-1.305zM17.127 15.63c1.24 1.428-0.326 2.713-0.326 2.713s3.149-1.625 1.703-3.661c-1.351-1.898-2.386-2.841 3.221-6.093 0 0-8.801 2.198-4.598 7.042zM23.783 25.302c0 0 0.727 0.599-0.801 1.062-2.905 0.88-12.091 1.146-14.643 0.035-0.917-0.399 0.803-0.953 1.344-1.069 0.564-0.122 0.887-0.1 0.887-0.1-1.020-0.719-6.594 1.411-2.831 2.021 10.262 1.664 18.706-0.749 16.044-1.95zM13.029 17.489c0 0-4.673 1.11-1.655 1.513 1.274 0.171 3.814 0.132 6.181-0.066 1.934-0.163 3.876-0.51 3.876-0.51s-0.682 0.292-1.175 0.629c-4.745 1.248-13.911 0.667-11.272-0.609 2.232-1.079 4.046-0.956 4.046-0.956zM21.412 22.174c4.824-2.506 2.593-4.915 1.037-4.591-0.382 0.079-0.552 0.148-0.552 0.148s0.142-0.222 0.412-0.318c3.079-1.083 5.448 3.193-0.994 4.887-0 0 0.075-0.067 0.097-0.126zM18.503 3.337c0 0 2.671 2.672-2.534 6.781-4.174 3.296-0.952 5.176-0.002 7.323-2.436-2.198-4.224-4.133-3.025-5.934 1.761-2.644 6.638-3.925 5.56-8.17zM13.503 28.966c4.63 0.296 11.74-0.164 11.908-2.355 0 0-0.324 0.831-3.826 1.49-3.952 0.744-8.826 0.657-11.716 0.18 0 0 0.592 0.49 3.635 0.685z"}"></path>`
  })}`;
});
var DiGo = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 32 32"}, $$props), {}, {
    default: () => `<path d="${"M15.43 3.426c-0.121 0.015-0.706 0.083-1.29 0.152-1.57 0.182-2.921 0.63-3.9 1.297-0.319 0.22-0.334 0.228-0.569 0.106-0.341-0.174-1.244-0.205-1.692-0.053-0.622 0.205-1.032 0.668-1.153 1.305-0.091 0.478 0.008 1.039 0.258 1.411 0.152 0.228 0.705 0.63 1.039 0.759 0.023 0.015-0.023 0.486-0.106 1.047-0.129 0.857-0.144 1.274-0.114 2.541 0.023 0.835 0.091 1.844 0.152 2.238 0.068 0.395 0.144 0.979 0.167 1.297l0.053 0.577-0.326 0.053c-0.516 0.076-1.305 0.501-1.388 0.736-0.099 0.281-0.008 0.546 0.288 0.865 0.303 0.319 0.485 0.311 0.994-0.030l0.303-0.205v3.49c0 3.467 0 3.505 0.175 3.922 0.228 0.569 0.698 1.282 1.153 1.775l0.379 0.395-0.379 0.243c-0.417 0.273-0.759 0.766-0.759 1.108 0 0.144 0.083 0.288 0.273 0.463 0.228 0.22 0.326 0.258 0.637 0.258 0.334 0 0.417-0.038 0.774-0.341 0.22-0.19 0.546-0.417 0.721-0.508l0.326-0.167 0.698 0.235c1.183 0.402 1.904 0.508 3.437 0.501 1.942-0.008 3.551-0.288 4.734-0.827 0.22-0.099 0.463-0.182 0.523-0.182 0.068 0 0.387 0.281 0.713 0.614 0.584 0.615 0.592 0.622 0.903 0.577 0.448-0.061 0.751-0.372 0.751-0.759 0-0.417-0.182-0.759-0.622-1.153l-0.372-0.334 0.356-0.478c0.675-0.918 1.062-1.927 1.328-3.46 0.152-0.918 0.182-2.671 0.084-4.628-0.030-0.508-0.046-0.926-0.046-0.926 0.008 0 0.167 0.083 0.341 0.19 0.44 0.25 0.706 0.243 0.948-0.015 0.22-0.235 0.281-0.432 0.243-0.789-0.030-0.326-0.326-0.531-1.024-0.721-0.281-0.068-0.531-0.144-0.554-0.167-0.023-0.015-0.061-1.381-0.091-3.035-0.053-3.095-0.053-3.141-0.417-4.704-0.023-0.099-0.008-0.167 0.053-0.167 0.19 0 0.766-0.478 0.941-0.781 0.372-0.622 0.326-1.419-0.114-2.026-0.455-0.63-1.441-0.85-2.375-0.539l-0.478 0.159-0.387-0.25c-0.539-0.364-1.449-0.728-2.253-0.903-0.66-0.144-2.777-0.25-3.338-0.167zM18.358 3.798c2.496 0.432 3.839 1.601 4.628 4.006 0.47 1.434 0.531 2.064 0.599 6.16 0.038 2.041 0.106 4.415 0.152 5.273s0.061 1.897 0.038 2.314c-0.099 1.51-0.432 2.906-0.918 3.831-0.326 0.622-0.956 1.411-1.184 1.479-0.099 0.030-0.311 0.182-0.478 0.341-0.872 0.827-2.762 1.335-5.235 1.419-1.51 0.046-2.397-0.061-3.573-0.433-0.66-0.212-0.789-0.288-1.092-0.599-0.379-0.402-0.728-0.615-1.017-0.615-0.379 0-1.396-1.32-1.715-2.215-0.228-0.645-0.266-2.261-0.152-5.94l0.099-3.217-0.182-1.426c-0.478-3.748-0.008-6.661 1.366-8.368 0.607-0.751 1.548-1.297 2.913-1.684 1.343-0.379 4.438-0.561 5.751-0.326zM23.593 4.905c0.956 0.486 1.001 1.995 0.084 2.58-0.19 0.121-0.364 0.22-0.387 0.22-0.030 0-0.121-0.212-0.212-0.463l-0.174-0.47 0.197-0.228c0.144-0.167 0.182-0.281 0.144-0.425-0.091-0.364-0.296-0.47-0.721-0.372-0.159 0.038-0.235-0.015-0.516-0.372-0.182-0.228-0.319-0.425-0.303-0.448 0.015-0.015 0.22-0.076 0.448-0.144 0.493-0.137 1.032-0.091 1.441 0.121zM9.239 5.133c0.212 0.046 0.402 0.114 0.425 0.144 0.023 0.038-0.106 0.258-0.281 0.486-0.311 0.402-0.341 0.417-0.599 0.379-0.235-0.038-0.296-0.015-0.432 0.159-0.212 0.273-0.212 0.432 0.015 0.69l0.175 0.212-0.144 0.44c-0.083 0.243-0.19 0.44-0.235 0.44-0.152 0-0.637-0.326-0.797-0.531-0.645-0.85-0.228-2.117 0.797-2.397 0.463-0.121 0.607-0.129 1.077-0.023zM24.678 16.225c0.523 0.197 0.774 0.47 0.698 0.766l-0.046 0.19-0.258-0.152c-0.152-0.091-0.281-0.121-0.303-0.076-0.030 0.038 0.015 0.091 0.099 0.121 0.243 0.076 0.349 0.243 0.235 0.379-0.152 0.182-0.478 0.137-0.857-0.121l-0.357-0.235v-0.523c0-0.493 0.008-0.523 0.174-0.516 0.091 0 0.372 0.076 0.614 0.167zM8.26 16.52c0 0.614-0.083 0.819-0.417 1.047-0.463 0.319-0.668 0.357-0.88 0.144-0.159-0.159-0.167-0.175-0.038-0.25 0.311-0.19 0.372-0.25 0.296-0.296-0.045-0.030-0.167 0.023-0.281 0.106-0.167 0.129-0.205 0.137-0.243 0.038-0.137-0.357 0.129-0.652 0.812-0.888 0.622-0.212 0.751-0.197 0.751 0.099zM22.425 27.195c0.402 0.296 0.751 0.971 0.652 1.267-0.106 0.319-0.197 0.288-0.402-0.144-0.106-0.212-0.228-0.402-0.273-0.41-0.046-0.015 0.015 0.174 0.144 0.425 0.121 0.25 0.197 0.485 0.167 0.531-0.023 0.046-0.159 0.083-0.303 0.083-0.212 0-0.319-0.076-0.721-0.531-0.25-0.288-0.531-0.546-0.614-0.569-0.228-0.076-0.175-0.22 0.197-0.561 0.425-0.387 0.713-0.41 1.153-0.091zM10.68 27.24c0.121 0.061 0.341 0.258 0.493 0.432l0.281 0.319-0.296 0.137c-0.159 0.076-0.493 0.311-0.743 0.523-0.508 0.432-0.698 0.501-1.017 0.372-0.197-0.083-0.212-0.106-0.144-0.288 0.046-0.114 0.167-0.319 0.273-0.455s0.175-0.273 0.152-0.296c-0.061-0.053-0.41 0.349-0.516 0.599-0.106 0.266-0.205 0.273-0.266 0.023-0.106-0.432 0.197-0.888 0.835-1.252 0.432-0.25 0.637-0.281 0.948-0.114zM18.176 4.746c-0.766 0.197-1.434 0.744-1.745 1.434-0.235 0.508-0.22 1.358 0.023 1.866 0.258 0.531 0.812 1.055 1.343 1.252 0.592 0.22 1.563 0.19 2.071-0.068 0.842-0.432 1.229-1.024 1.274-1.995 0.030-0.577 0.008-0.698-0.152-1.062-0.265-0.577-0.607-0.933-1.146-1.199-0.523-0.25-1.191-0.341-1.669-0.228zM19.663 5.034c1.282 0.569 1.768 2.147 1.032 3.315-0.698 1.1-2.496 1.305-3.52 0.402-0.88-0.774-1.032-1.95-0.379-2.906 0.622-0.91 1.859-1.259 2.868-0.812zM16.894 6.711c-0.614 0.546-0.015 1.517 0.804 1.29 0.303-0.083 0.576-0.432 0.576-0.736 0-0.69-0.85-1.032-1.381-0.554zM11.978 5.042c-0.607 0.19-1.206 0.69-1.502 1.252-0.175 0.326-0.205 0.485-0.205 1.032 0 0.531 0.030 0.713 0.182 1.017 0.721 1.464 2.67 1.836 3.877 0.751 0.584-0.523 0.797-0.979 0.797-1.73 0-0.516-0.030-0.675-0.212-1.039-0.417-0.85-1.259-1.358-2.238-1.343-0.281 0-0.592 0.030-0.698 0.061zM13.814 5.376c1.661 0.971 1.57 3.171-0.167 4.021-0.531 0.258-1.411 0.235-1.988-0.046-1.722-0.85-1.699-3.217 0.046-4.051 0.341-0.159 0.47-0.182 1.070-0.159 0.584 0.023 0.743 0.061 1.039 0.235zM11.181 6.696c-0.228 0.053-0.546 0.387-0.592 0.615-0.053 0.266 0.106 0.645 0.334 0.804 0.099 0.068 0.319 0.121 0.493 0.121 0.88 0 1.1-1.146 0.288-1.487-0.265-0.114-0.273-0.114-0.524-0.053zM15.452 8.759c-0.395 0.083-0.668 0.281-0.721 0.546-0.023 0.144-0.121 0.266-0.25 0.334-0.478 0.25-0.728 0.781-0.561 1.214 0.068 0.159 0.425 0.341 0.698 0.341h0.22l-0.068 0.395c-0.083 0.501-0.023 0.857 0.175 1.055s0.47 0.182 0.721-0.038l0.212-0.175 0.129 0.152c0.159 0.205 0.622 0.205 0.842 0 0.137-0.121 0.152-0.205 0.121-0.766l-0.030-0.622h0.235c0.865 0 0.85-1.13-0.023-1.555-0.212-0.099-0.319-0.197-0.319-0.303-0.008-0.22-0.167-0.402-0.478-0.531-0.296-0.121-0.455-0.129-0.903-0.046zM17.053 9.753c0.41 0.205 0.614 0.486 0.614 0.85 0 0.266-0.030 0.311-0.25 0.402-0.266 0.114-0.592 0.068-1.214-0.152-0.341-0.121-0.379-0.121-0.88 0.030-0.903 0.273-1.297 0.167-1.312-0.349-0.008-0.303 0.121-0.508 0.44-0.713 0.266-0.159 0.281-0.159 0.546-0.030 0.152 0.068 0.448 0.144 0.66 0.167 0.311 0.030 0.44 0 0.721-0.152 0.19-0.106 0.349-0.197 0.364-0.197 0.008-0.008 0.152 0.061 0.311 0.144zM15.801 11.589c-0.061 0.804-0.114 0.948-0.372 1.017-0.455 0.114-0.622-0.197-0.524-0.933l0.068-0.516 0.379-0.129c0.212-0.068 0.402-0.129 0.432-0.137 0.030 0 0.038 0.319 0.015 0.698zM16.386 11.050c0.379 0.129 0.448 0.258 0.448 0.842 0 0.455-0.023 0.523-0.182 0.63-0.258 0.167-0.569 0.076-0.622-0.182-0.023-0.106-0.061-0.25-0.076-0.311-0.053-0.152 0.053-1.062 0.121-1.062 0.030 0 0.167 0.038 0.311 0.083z"}"></path>`
  })}`;
});
var Folder = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  get_current_component();
  createEventDispatcher();
  let {folder} = $$props;
  if ($$props.folder === void 0 && $$bindings.folder && folder !== void 0)
    $$bindings.folder(folder);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `<div class="${"group flex items-center cursor-pointer pb-1 hover:bg-indigo-300 rounded font-semibold justify-between"}"><div class="${"flex"}"><div class="${"w-6 h-6 mr-1 transform -translate-x-1"}">${folder.expanded ? `<div class="${"transform rotate-90"}">${validate_component(MdChevronRight, "MdChevronRight").$$render($$result, {}, {}, {})}</div>` : `${validate_component(MdChevronRight, "MdChevronRight").$$render($$result, {}, {}, {})}`}</div>
        ${escape2(folder.name)}</div>
    
    <div class="${"w-6 h-6 opacity-0 group-hover:opacity-40 hover:opacity-100"}">${validate_component(IoMdMore, "IoMdMore").$$render($$result, {}, {}, {})}</div></div>
${folder.expanded ? `${each(folder.children, (child) => `<div class="${"pl-2 border-l border-black border-opacity-25"}">${child.isFolder() ? `${validate_component(Folder, "svelte:self").$$render($$result, {folder: child}, {
      folder: ($$value) => {
        child = $$value;
        $$settled = false;
      }
    }, {})}` : `<div class="${"flex items-center cursor-pointer hover:bg-purple-300"}"><div class="${"w-6 h-6 text-indigo-500 mr-1"}">${child.name.endsWith("js") ? `${validate_component(DiJavascript1, "DiJavascript1").$$render($$result, {}, {}, {})}` : `${child.name.endsWith("java") ? `${validate_component(DiJava, "DiJava").$$render($$result, {}, {}, {})}` : `${child.name.endsWith("css") ? `${validate_component(DiCss3, "DiCss3").$$render($$result, {}, {}, {})}` : `${child.name.endsWith("py") ? `${validate_component(DiPython, "DiPython").$$render($$result, {}, {}, {})}` : `${child.name.endsWith("go") ? `${validate_component(DiGo, "DiGo").$$render($$result, {}, {}, {})}` : `${validate_component(DiCode, "DiCode").$$render($$result, {}, {}, {})}`}`}`}`}`}</div>
                    ${child.expanded ? `<div class="${"font-bold text-indigo-500"}">${escape2(child.name)}</div>` : `<div>${escape2(child.name)}</div>`}
                    
                </div>`}
        </div>`)}` : ``}`;
  } while (!$$settled);
  return $$rendered;
});
var Explorer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  createEventDispatcher();
  let {root = new Root(default_folder)} = $$props;
  if ($$props.root === void 0 && $$bindings.root && root !== void 0)
    $$bindings.root(root);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `<ul>${validate_component(Folder, "Folder").$$render($$result, {folder: root.folders}, {
      folder: ($$value) => {
        root.folders = $$value;
        $$settled = false;
      }
    }, {})}</ul>`;
  } while (!$$settled);
  return $$rendered;
});
var MdSearch = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 24 24"}, $$props), {}, {
    default: () => `<path d="${"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"}"></path>`
  })}`;
});
var project_status = "desligado";
function group_array(arr, n) {
  let rt = [];
  let i = 0;
  while (arr.length > 0) {
    rt[i] = [];
    for (let j = 0; j < n; j++) {
      const n2 = arr.shift();
      if (n2) {
        rt[i].push(n2);
      }
    }
    i++;
  }
  return rt;
}
var Projects = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let projects_3;
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let projects2 = [
    {
      name: "Programa\xE7\xE3o Orientada a Objetos",
      version: "Turma: 2018",
      status: "desligado"
    },
    {
      name: "Programa\xE7\xE3o Orientada a Objetos",
      version: "Turma: 2019",
      status: "desligado"
    },
    {
      name: "Programa\xE7\xE3o Orientada a Objetos",
      version: "Turma: 2020",
      status: "desligado"
    },
    {
      name: "Programa\xE7\xE3o Orientada a Objetos 2",
      version: "Turma: 2018",
      status: "desligado"
    },
    {
      name: "Programa\xE7\xE3o Orientada a Objetos 2",
      version: "Turma: 2019",
      status: "desligado"
    },
    {
      name: "Programa\xE7\xE3o Orientada a Objetos 2",
      version: "Turma: 220",
      status: "desligado"
    },
    {
      name: "Programa\xE7\xE3o 1",
      version: "Turma: 2018",
      status: "desligado"
    },
    {
      name: "Programa\xE7\xE3o 2",
      version: "Turma: 2019",
      status: "desligado"
    },
    {
      name: "T\xE9cnicas de programa\xE7\xE3o Avan\xE7adas",
      version: "Turma: 220",
      status: "desligado"
    },
    {
      name: "T\xE9cnicas de programa\xE7\xE3o Avan\xE7adas",
      version: "Turma: 220",
      status: "desligado"
    },
    {
      name: "T\xE9cnicas de pr",
      version: "Turma: 220",
      status: "desligado"
    },
    {
      name: "T\xE9cnicas de programa\xE7\xE3o Avan\xE7adas",
      version: "Turma: 220",
      status: "desligado"
    },
    {
      name: "T",
      version: "Turma: 220",
      status: "desligado"
    },
    {
      name: "T\xE9cnicas de pr",
      version: "Turma: 220",
      status: "desligado"
    }
  ];
  const {Chart} = import_auto.default;
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    renderChart();
  }));
  function renderChart() {
    const canvas = document.getElementById("myChart");
    var ctx = canvas.getContext("2d");
    new Chart(ctx, {
      type: "doughnut",
      data: {
        labels: ["ts", "js", "css", "html", "json"],
        datasets: [
          {
            data: [300, 50, 100, 40, 120],
            backgroundColor: ["#F7464A", "#46BFBD", "#FDB45C", "#949FB1", "#4D5360"],
            hoverBackgroundColor: ["#FF5A5E", "#5AD3D1", "#FFC870", "#A8B3C5", "#616774"]
          }
        ]
      },
      options: {}
    });
  }
  projects_3 = group_array(projects2, 3);
  return `<div class="${"mx-auto h-screen overflow-hidden "}"><div class="${"h-screen "}"><div class="${"flex flex-row flex-grow h-full bg-indigo-100"}">
            <nav class="${"bg-indigo-500 w-16 h-full flex flex-col items-center z-1 justify-between"}">
                <div class="${""}">
                    <div class="${"mx-auto rounded-full bg-white w-10 h-10 mt-3"}"></div>
                    
                    <div class="${"mt-8 w-16 text-white "}"><div class="${"py-4 hover:bg-indigo-600 hover:border-opacity-100 border-opacity-0 border-white border-l-4 rounded h-16"}"><div class="${"w-6 h-6 m-auto"}">${validate_component(TiFolder, "TiFolder").$$render($$result, {}, {}, {})}</div></div>
                        <div class="${"py-4 hover:bg-indigo-600 hover:border-opacity-100 border-opacity-0 border-white border-l-4 rounded h-16"}"><div class="${"w-6 h-6 m-auto"}">${validate_component(TiFolder, "TiFolder").$$render($$result, {}, {}, {})}</div></div>
                        <div class="${"py-4 hover:bg-indigo-600 hover:border-opacity-100 border-opacity-0 border-white border-l-4 rounded h-16"}"><div class="${"w-6 h-6 m-auto"}">${validate_component(TiFolder, "TiFolder").$$render($$result, {}, {}, {})}</div></div>
                        <div class="${"py-4 hover:bg-indigo-600 hover:border-opacity-100 border-opacity-0 border-white border-l-4 rounded h-16"}"><div class="${"w-6 h-6 m-auto"}">${validate_component(TiFolder, "TiFolder").$$render($$result, {}, {}, {})}</div></div>
                        <div class="${"py-4 hover:bg-indigo-600 hover:border-opacity-100 border-opacity-0 border-white border-l-4 rounded h-16"}"><div class="${"w-6 h-6 m-auto"}">${validate_component(TiFolder, "TiFolder").$$render($$result, {}, {}, {})}</div></div></div></div>

                
                
                <a href="${"#"}" class="${"mt-8"}"><img src="${"https://randomuser.me/api/portraits/women/76.jpg"}" class="${"rounded-full w-10 h-10 mb-3 mx-auto"}"></a></nav>
            
            <div class="${"bg-white w-72 h-full flex flex-col items-left z-1 justify-between"}"><div class="${"ml-4 divide-y divide-indigo-300"}"><h1 class="${"text-black-500 tracking-widest text-sm pt-2 mb-3 font-bold "}">Programa\xE7\xE3o Orientada a Objetos</h1>
                    ${`${`<h1 class="${"title-font font-medium text-black-500 tracking-widest text-2xl mb-3 pt-8 "}">Config</h1>`}`}</div></div>
            
            <div class="${"bg-indigo-200 w-full h-full flex flex-col items-center z-1 p-2"}">
                
                <div class="${"relative flex w-9/12 flex-wrap items-stretch mb-3 pt-5"}"><span class="${"z-10 h-full leading-snug font-normal absolute text-center text-blueGray-300 absolute bg-transparent rounded text-lg items-center justify-center w-8 pl-3 py-3"}">${validate_component(MdSearch, "MdSearch").$$render($$result, {}, {}, {})}</span>
                    <input type="${"text"}" placeholder="${"Nome do projeto"}" class="${"h-10 px-3 py-4 placeholder-blueGray-300 text-blueGray-600 relative bg-white bg-white rounded text-base border-0 shadow outline-none focus:outline-none focus:ring w-full pl-10"}"></div>
                
                
                
                <div class="${"flex flex-col overflow-auto w-full"}">${each(projects_3, (project_3) => `<div class="${"flex w-full"}">${each(project_3, (project) => `<div class="${"bg-white m-2 p-2 divide-y w-1/3"}"><div class="${"flex pb-1"}"><div class="${"rounded bg-red-500 w-8 h-8 flex-shrink-0"}"></div>
                                        <span class="${"text-black-500 tracking-widest text-sm mb-3 font-bold pl-4 flex-shrink "}">${escape2(project.name)}</span></div>
                                        <h3 class="${"text-black-500 tracking-widest text-sm mb-1 font-bold"}">${escape2(project.version)}</h3>
                                        <h4 class="${"text-black-500 tracking-widest text-sm mb-1 font-bold "}">Status
                                            ${project.status == "ligado" ? `<span class="${" text-green-400"}">${escape2(project.status)}</span>` : `<span class="${" text-red-400"}">${escape2(project.status)}</span>`}</h4>
                                        
                                            
                                      
                                </div>`)}</div>
                        `)}</div></div>
            
            <div class="${"bg-white w-56 h-full flex flex-col items-start  z-1 justify-between"}"><h2 class="${"text-black-500 tracking-widest text-sm pt-2 mb-3 font-bold pl-2 "}">Status: 
                    ${`<span class="${"bg- text-red-400"}">${escape2(project_status)}</span>`}</h2>
              
                <div class="${"flex flex-col w-full p-2 items-center"}"><h3 class="${"text-black-500 tracking-widest text-sm pt-2 mb-3 font-bold "}">Espa\xE7o</h3>
                    
                    <div class="${"flex border  w-full items-start"}"><h4>Espa\xE7o: 10/100 mb</h4></div>
                    <canvas id="${"myChart"}"></canvas></div></div></div></div></div>`;
});
var projects = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Projects
});
var PricingCardComponent = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {card} = $$props;
  if ($$props.card === void 0 && $$bindings.card && card !== void 0)
    $$bindings.card(card);
  return `<div class="${"p-4 xl:w-1/4 md:w-1/2 w-full"}"><div class="${"h-full p-6 rounded-lg border-2 border-gray-300 hover:border-indigo-500 transition duration-500 ease-in-out transform hover:-translate-y-1 hover:scale-110 flex flex-col relative overflow-hidden"}"><h2 class="${"text-sm tracking-widest title-font mb-1 font-medium"}">${escape2(card.title)}</h2>
      
      <h1 class="${"text-5xl text-gray-900 leading-none flex items-center pb-4 mb-4 border-b border-gray-200"}"><span>${escape2(card.getPrice())}</span>
        ${!card.isFree() ? `<span class="${"text-lg ml-1 font-normal text-gray-500"}">/mo</span>` : ``}</h1>
      
      ${each(card.features, (feature) => `<p class="${"flex items-center text-gray-600 mb-2"}"><span class="${"w-4 h-4 mr-2 inline-flex items-center justify-center bg-gray-400 text-white rounded-full flex-shrink-0"}"><svg fill="${"none"}" stroke="${"currentColor"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" stroke-width="${"2.5"}" class="${"w-3 h-3"}" viewBox="${"0 0 24 24"}"><path d="${"M20 6L9 17l-5-5"}"></path></svg>
            </span>${escape2(feature)}
        </p>`)}
      <button class="${"flex items-center mt-auto text-white bg-indigo-500 border-0 py-2 px-4 w-full focus:outline-none hover:bg-indigo-600 rounded"}">Button
        <svg fill="${"none"}" stroke="${"currentColor"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" stroke-width="${"2"}" class="${"w-4 h-4 ml-auto"}" viewBox="${"0 0 24 24"}"><path d="${"M5 12h14M12 5l7 7-7 7"}"></path></svg></button></div></div>`;
});
var PricingCard = class {
  constructor(title, features, price, end_text) {
    this.title = title;
    this.features = features;
    this.price = price;
    this.end_text = end_text;
  }
  getPrice() {
    return this.isFree() ? "Free" : `$${this.price / 100}`;
  }
  isFree() {
    return this.price == 0;
  }
};
var Pricing = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const cards = [
    new PricingCard("START", ["asdasdsadasdas", "asdasdsadasdas", "asdasdsadasdas"], 0, "asdasdsadasdas"),
    new PricingCard("PRO", [
      "asdasdsadasdas",
      "asdasdsadasdas",
      "asdasdsadasdas",
      "asdasdsadasdas",
      "asdasdsadasdas"
    ], 3800, "asdasdsadasdas"),
    new PricingCard("BUSINESS", [
      "asdasdsadasdas",
      "asdasdsadasdas",
      "asdasdsadasdas",
      "asdasdsadasdas",
      "asdasdsadasdas"
    ], 5600, "asdasdsadasdas"),
    new PricingCard("EDUCATION", [
      "asdasdsadasdas",
      "asdasdsadasdas",
      "asdasdsadasdas",
      "asdasdsadasdas",
      "asdasdsadasdas"
    ], 7200, "asdasdsadasdas")
  ];
  return `<section class="${"text-gray-600 body-font overflow-hidden"}"><div class="${"container px-5 py-24 mx-auto"}"><div class="${"flex flex-col text-center w-full mb-20"}"><h1 class="${"sm:text-4xl text-3xl font-medium title-font mb-2 text-gray-900"}">Server Pricing</h1>
        <p class="${"lg:w-2/3 mx-auto leading-relaxed text-base text-gray-500"}">Whatever cardigan tote bag tumblr hexagon brooklyn asymmetrical.</p>
        <div class="${"flex mx-auto border-2 border-indigo-500 rounded overflow-hidden mt-6"}"><button class="${"py-1 px-4 bg-indigo-500 text-white focus:outline-none"}">Monthly</button>
          <button class="${"py-1 px-4 focus:outline-none"}">Annually</button></div></div>
      <div class="${"flex flex-wrap -m-4"}">${each(cards, (card) => `${validate_component(PricingCardComponent, "PricingCardComponent").$$render($$result, {card}, {}, {})}`)}</div></div></section>`;
});
var pricing = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Pricing
});
var css = {
  code: "@media(prefers-color-scheme: light){:root{--cm-border-color:#ccc;--cm-background-color:white;--cm-medium-color:#ccc;--cm-text-color:#222}}@media(prefers-color-scheme: dark){:root{--cm-border-color:#ccc;--cm-background-color:#222;--cm-medium-color:#ccc;--cm-text-color:white}}.CodeMirror{font-family:monospace;direction:ltr;color:var(--cm-text-color);background:var(--cm-background-color);height:300px}.cm-editor{max-height:300px;width:900px}.cm-content, .cm-gutter{min-height:400px;font-size:30pt}.cm-gutters{margin:1px}.cm-scroller{overflow:auto}.cm-wrap{border:1px solid silver;height:100% }.CodeMirror-lines{padding:4px 0}.CodeMirror pre.CodeMirror-line,\r\n  .CodeMirror pre.CodeMirror-line-like{padding:0 4px}.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler{background-color:var(--cm-background-color)}.CodeMirror-gutters{border-right:1px solid var(--cm-border-color);background-color:var(--cm-background-color);white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#ddd;white-space:nowrap}.CodeMirror-guttermarker{color:var(--cm-text-color)}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:2px solid var(--cm-medium-color);border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid var(--cm-medium-color)}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0 !important;background:var(--cursor-color)}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-fat-cursor-mark{background-color:var(--cursor-color);-webkit-animation:svelte-44wbrv-blink 1.06s steps(1) infinite;animation:svelte-44wbrv-blink 1.06s steps(1) infinite}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:svelte-44wbrv-blink 1.06s steps(1) infinite;animation:svelte-44wbrv-blink 1.06s steps(1) infinite;background-color:var(--cursor-color)}@-webkit-keyframes svelte-44wbrv-blink{0%{}50%{background-color:transparent}100%{}}@keyframes svelte-44wbrv-blink{0%{}50%{background-color:transparent}100%{}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:0;overflow:hidden;min-height:350px}.CodeMirror-ruler{border-left:1px solid var(--cm-medium-color);top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:blue}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header, .cm-strong{font-weight:bold}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3, .cm-s-default .cm-type{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:#f00}.cm-invalidchar{color:#f00}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0b0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#a22}.CodeMirror-matchingtag{background:rgba(255, 150, 0, .3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden}.CodeMirror-scroll{overflow:scroll !important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:none;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler{position:absolute;z-index:6;display:none}.CodeMirror ::-webkit-scrollbar{width:8px;height:8px}.CodeMirror ::-webkit-scrollbar-track{background:#f4f4f4;border-radius:10px}.CodeMirror ::-webkit-scrollbar-thumb{border-radius:10px;background:var(--cm-medium-color)}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll;height:8px}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none !important;border:none !important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent }.CodeMirror-gutter-wrapper ::selection{background-color:transparent }.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent }.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre.CodeMirror-line,\r\n  .CodeMirror pre.CodeMirror-line-like{border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;font-variant-ligatures:contextual}.CodeMirror-wrap pre.CodeMirror-line,\r\n  .CodeMirror-wrap pre.CodeMirror-line-like{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;padding:0.1px}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:none}.CodeMirror-scroll,\r\n    .CodeMirror-sizer,\r\n    .CodeMirror-gutter,\r\n    .CodeMirror-gutters,\r\n    .CodeMirror-linenumber{box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:visible;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection{background:#d7d4f0}.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255, 255, 0, .4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:none}",
  map: `{"version":3,"file":"component2.svelte","sources":["component2.svelte"],"sourcesContent":["<!-- <script context=\\"module\\"> \\r\\n  const WebSocket = import(\\"ws\\")\\r\\n  let connection = new WebSocketClient(new WebSocket(\\"ws://localhost:8080\\"))\\r\\n  let version\\r\\n  let doc\\r\\n\\r\\n  async function create_ext(){\\r\\n    let result = await getDocument(connection)\\r\\n    version = result[0]\\r\\n    doc = result[1]\\r\\n  }\\r\\n  create_ext()\\r\\n</script> -->\\r\\n<script lang=\\"ts\\">import { onMount } from 'svelte';\\r\\nimport { createEventDispatcher } from 'svelte';\\r\\nimport { EditorView, ViewPlugin, ViewUpdate } from '@codemirror/view';\\r\\nimport { EditorState, Transaction, Annotation } from '@codemirror/state';\\r\\nimport { javascript } from \\"@codemirror/lang-javascript\\";\\r\\nimport { defaultHighlightStyle } from \\"@codemirror/highlight\\";\\r\\nimport { basicSetup } from '@codemirror/basic-setup';\\r\\nimport { WebSocketClient, pushUpdates, pullUpdates, getDocument } from '$lib/utils/WebSocketClient';\\r\\nconst dispatch = createEventDispatcher();\\r\\nimport * as Tooltip from \\"@codemirror/tooltip\\";\\r\\nimport { StateField } from \\"@codemirror/state\\";\\r\\nexport let pos = 1;\\r\\nconst cursorTooltipField = (name, above) => {\\r\\n    return StateField.define({\\r\\n        create: getCursorTooltips,\\r\\n        update(tooltips, tr) {\\r\\n            if (!tr.docChanged && !tr.selection)\\r\\n                return tooltips;\\r\\n            return getCursorTooltips(tr.state, name, above);\\r\\n        },\\r\\n        provide: f => Tooltip.showTooltip.computeN([f], state => state.field(f))\\r\\n    });\\r\\n};\\r\\nfunction getCursorTooltips(state, name, above) {\\r\\n    return state.selection.ranges\\r\\n        .filter(range => range.empty)\\r\\n        .map(range => {\\r\\n        let line = state.doc.lineAt(range.head);\\r\\n        let text = line.number + \\":\\" + (range.head - line.from);\\r\\n        return {\\r\\n            pos: pos,\\r\\n            above: above,\\r\\n            strictSide: true,\\r\\n            class: \\"cm-cursor-tooltip\\",\\r\\n            create: () => {\\r\\n                let dom = document.createElement(\\"div\\");\\r\\n                dom.textContent = name;\\r\\n                return { dom };\\r\\n            }\\r\\n        };\\r\\n    });\\r\\n}\\r\\nconst cursorTooltipBaseTheme = EditorView.baseTheme({\\r\\n    \\".cm-tooltip.cm-cursor-tooltip\\": {\\r\\n        backgroundColor: \\"#66b\\",\\r\\n        color: \\"white\\",\\r\\n        transform: \\"translate(-50%, -7px)\\",\\r\\n        border: \\"none\\",\\r\\n        padding: \\"2px 7px\\",\\r\\n        borderRadius: \\"10px\\",\\r\\n        \\"&:before\\": {\\r\\n            position: \\"absolute\\",\\r\\n            content: '\\"\\"',\\r\\n            left: \\"50%\\",\\r\\n            marginLeft: \\"-5px\\",\\r\\n            bottom: \\"-5px\\",\\r\\n            borderLeft: \\"5px solid transparent\\",\\r\\n            borderRight: \\"5px solid transparent\\",\\r\\n            borderTop: \\"5px solid #66b\\"\\r\\n        }\\r\\n    }\\r\\n});\\r\\nlet classes = '';\\r\\nexport let editor = null;\\r\\nexport let options = {};\\r\\nexport { classes as class };\\r\\nlet state;\\r\\nlet element;\\r\\nlet cursor_a = cursorTooltipField(\\"Lucas\\", true);\\r\\nconsole.log(cursor_a);\\r\\nonMount(() => {\\r\\n    createEditor({});\\r\\n});\\r\\n$: if (element) {\\r\\n    createEditor(options);\\r\\n}\\r\\nconst FontSizeTheme = EditorView.theme({\\r\\n    $: {\\r\\n        fontSize: \\"25pt\\"\\r\\n    }\\r\\n});\\r\\n// function peerExtension(startVersion: number, connection: WebSocketClient) {\\r\\n//   let plugin = ViewPlugin.fromClass(class {\\r\\n//     private pushing = false\\r\\n//     private done = false\\r\\n//     constructor(private view: EditorView) { this.pull() }\\r\\n//     update(update: ViewUpdate) {\\r\\n//       if (update.docChanged) this.push()\\r\\n//     }\\r\\n//     async push() {\\r\\n//         let updates = sendableUpdates(this.view.state)\\r\\n//         if (this.pushing || !updates.length) return\\r\\n//         this.pushing = true\\r\\n//         let version = getSyncedVersion(this.view.state)\\r\\n//         await pushUpdates(connection, version, updates)\\r\\n//         this.pushing = false\\r\\n//         // Regardless of whether the push failed or new updates came in\\r\\n//         // while it was running, try again if there's updates remaining\\r\\n//         if (sendableUpdates(this.view.state).length)\\r\\n//           setTimeout(() => this.push(), 100)\\r\\n//       }\\r\\n//       async pull() {\\r\\n//         while (!this.done) {\\r\\n//           let version = getSyncedVersion(this.view.state)\\r\\n//           let updates = await pullUpdates(connection, version)\\r\\n//           this.view.dispatch(receiveUpdates(this.view.state, updates))\\r\\n//         }\\r\\n//       }\\r\\n//       destroy() { this.done = true }\\r\\n//     })\\r\\n//   return [collab({startVersion}), plugin]\\r\\n// }\\r\\nfunction createEditor(options) {\\r\\n    if (editor)\\r\\n        element.innerHTML = '';\\r\\n    state = EditorState.create({ doc: \\"\\", extensions: [\\r\\n            basicSetup,\\r\\n            javascript(),\\r\\n            defaultHighlightStyle,\\r\\n            cursorTooltipBaseTheme,\\r\\n            FontSizeTheme //,\\r\\n            // peerExtension(version, connection)\\r\\n            // [cursor_a, cursorTooltipField(\\"Rodolfo\\", false)],\\r\\n        ] });\\r\\n    editor = new EditorView({\\r\\n        state: state,\\r\\n        parent: element,\\r\\n        dispatch: (tr) => {\\r\\n            //console.log('tr: ', tr)\\r\\n            //console.log('--------------------')\\r\\n            editor.update([tr]);\\r\\n        },\\r\\n    });\\r\\n    // \\t\\teditor.on(\\"cursorActivity\\", (event) => {\\r\\n    // \\t\\t\\t//dispatch('activity', event)\\r\\n    // \\t\\t})\\r\\n    // \\t\\teditor.on(\\"change\\", (event) => {\\r\\n    // \\t\\t\\t//dispatch('change', event)\\r\\n    // \\t\\t})\\r\\n    // More events could be set up here\\r\\n}\\r\\n</script>\\r\\n  \\r\\n  <div bind:this={element} class={classes}/>\\r\\n  \\r\\n  <style unscoped>\\r\\n  @media (prefers-color-scheme: light) {\\r\\n    :root {\\r\\n      --cm-border-color: #ccc;\\r\\n      --cm-background-color: white;\\r\\n      --cm-medium-color: #ccc;\\r\\n      --cm-text-color: #222;\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  @media (prefers-color-scheme: dark) {\\r\\n    :root {\\r\\n      --cm-border-color: #ccc;\\r\\n      --cm-background-color: #222;\\r\\n      --cm-medium-color: #ccc;\\r\\n      --cm-text-color: white;\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  /* BASICS */\\r\\n  :global(.CodeMirror) {\\r\\n    /* Set height, width, borders, and global font properties here */\\r\\n    \\r\\n    font-family: monospace;\\r\\n    direction: ltr;\\r\\n    color: var(--cm-text-color);\\r\\n    background: var(--cm-background-color);\\r\\n    \\r\\n    height: 300px;\\r\\n  }\\r\\n  :global(.cm-editor) {\\r\\n    max-height: 300px; \\r\\n    width: 900px;\\r\\n  }\\r\\n  :global(.cm-content, .cm-gutter) { \\r\\n    min-height: 400px; \\r\\n    font-size: 30pt;\\r\\n  }\\r\\n  \\r\\n  :global(.cm-gutters) { margin: 1px; }\\r\\n  :global(.cm-scroller) { overflow: auto; }\\r\\n  :global(.cm-wrap) { border: 1px solid silver; height: 100% }\\r\\n  /* PADDING */\\r\\n  \\r\\n  :global(.CodeMirror-lines) {\\r\\n    padding: 4px 0; /* Vertical padding around content */\\r\\n  }\\r\\n  :global(.CodeMirror pre.CodeMirror-line,\\r\\n  .CodeMirror pre.CodeMirror-line-like) {\\r\\n    padding: 0 4px; /* Horizontal padding of content */\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler) {\\r\\n    background-color: var(--cm-background-color); /* The little square between H and V scrollbars */\\r\\n  }\\r\\n  \\r\\n  /* GUTTER */\\r\\n  \\r\\n  :global(.CodeMirror-gutters) {\\r\\n    border-right: 1px solid var(--cm-border-color);\\r\\n    background-color: var(--cm-background-color);\\r\\n    white-space: nowrap;\\r\\n  }\\r\\n  :global(.CodeMirror-linenumbers) {}\\r\\n  :global(.CodeMirror-linenumber) {\\r\\n    padding: 0 3px 0 5px;\\r\\n    min-width: 20px;\\r\\n    text-align: right;\\r\\n    color: #ddd;\\r\\n    white-space: nowrap;\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror-guttermarker) { color: var(--cm-text-color); }\\r\\n  :global(.CodeMirror-guttermarker-subtle) { color: #999; }\\r\\n  \\r\\n  /* CURSOR */\\r\\n  \\r\\n  :global(.CodeMirror-cursor) {\\r\\n    border-left: 2px solid var(--cm-medium-color);\\r\\n    border-right: none;\\r\\n    width: 0;\\r\\n  }\\r\\n  /* Shown when moving in bi-directional text */\\r\\n  :global(.CodeMirror div.CodeMirror-secondarycursor) {\\r\\n    border-left: 1px solid var(--cm-medium-color);\\r\\n  }\\r\\n  :global(.cm-fat-cursor .CodeMirror-cursor) {\\r\\n    width: auto;\\r\\n    border: 0 !important;\\r\\n    background: var(--cursor-color);\\r\\n  }\\r\\n  :global(.cm-fat-cursor div.CodeMirror-cursors) {\\r\\n    z-index: 1;\\r\\n  }\\r\\n  :global(.cm-fat-cursor-mark) {\\r\\n    background-color: var(--cursor-color);\\r\\n    -webkit-animation: blink 1.06s steps(1) infinite;\\r\\n    animation: blink 1.06s steps(1) infinite;\\r\\n  }\\r\\n  :global(.cm-animate-fat-cursor) {\\r\\n    width: auto;\\r\\n    border: 0;\\r\\n    -webkit-animation: blink 1.06s steps(1) infinite;\\r\\n    animation: blink 1.06s steps(1) infinite;\\r\\n    background-color: var(--cursor-color);\\r\\n  }\\r\\n  @-webkit-keyframes blink {\\r\\n    0% {}\\r\\n    50% { background-color: transparent; }\\r\\n    100% {}\\r\\n  }\\r\\n  @keyframes blink {\\r\\n    0% {}\\r\\n    50% { background-color: transparent; }\\r\\n    100% {}\\r\\n  }\\r\\n  \\r\\n  /* Can style cursor different in overwrite (non-insert) mode */\\r\\n  :global(.CodeMirror-overwrite .CodeMirror-cursor) {}\\r\\n  \\r\\n  :global(.cm-tab) { display: inline-block; text-decoration: inherit; }\\r\\n  \\r\\n  :global(.CodeMirror-rulers) {\\r\\n    position: absolute;\\r\\n    left: 0; right: 0; top: -50px; bottom: 0;\\r\\n    overflow: hidden;\\r\\n    min-height: 350px;\\r\\n  }\\r\\n  :global(.CodeMirror-ruler) {\\r\\n    border-left: 1px solid var(--cm-medium-color);\\r\\n    top: 0; bottom: 0;\\r\\n    position: absolute;\\r\\n  }\\r\\n  \\r\\n  /* DEFAULT THEME */\\r\\n  :global(.cm-s-default .cm-header) {color: blue;}\\r\\n  :global(.cm-s-default .cm-quote) {color: #090;}\\r\\n  :global(.cm-negative) {color: #d44;}\\r\\n  :global(.cm-positive) {color: #292;}\\r\\n  :global(.cm-header, .cm-strong) {font-weight: bold;}\\r\\n  :global(.cm-em) {font-style: italic;}\\r\\n  :global(.cm-link) {text-decoration: underline;}\\r\\n  :global(.cm-strikethrough) {text-decoration: line-through;}\\r\\n  \\r\\n  :global(.cm-s-default .cm-keyword) {color: #708;}\\r\\n  :global(.cm-s-default .cm-atom) {color: #219;}\\r\\n  :global(.cm-s-default .cm-number) {color: #164;}\\r\\n  :global(.cm-s-default .cm-def) {color: #00f;}\\r\\n  :global(.cm-s-default .cm-variable,\\r\\n  .cm-s-default .cm-punctuation,\\r\\n  .cm-s-default .cm-property,\\r\\n  .cm-s-default .cm-operator) {}\\r\\n  :global(.cm-s-default .cm-variable-2) {color: #05a;}\\r\\n  :global(.cm-s-default .cm-variable-3, .cm-s-default .cm-type) {color: #085;}\\r\\n  :global(.cm-s-default .cm-comment) {color: #a50;}\\r\\n  :global(.cm-s-default .cm-string) {color: #a11;}\\r\\n  :global(.cm-s-default .cm-string-2) {color: #f50;}\\r\\n  :global(.cm-s-default .cm-meta) {color: #555;}\\r\\n  :global(.cm-s-default .cm-qualifier) {color: #555;}\\r\\n  :global(.cm-s-default .cm-builtin) {color: #30a;}\\r\\n  :global(.cm-s-default .cm-bracket) {color: #997;}\\r\\n  :global(.cm-s-default .cm-tag) {color: #170;}\\r\\n  :global(.cm-s-default .cm-attribute) {color: #00c;}\\r\\n  :global(.cm-s-default .cm-hr) {color: #999;}\\r\\n  :global(.cm-s-default .cm-link) {color: #00c;}\\r\\n  \\r\\n  :global(.cm-s-default .cm-error) {color: #f00;}\\r\\n  :global(.cm-invalidchar) {color: #f00;}\\r\\n  \\r\\n  :global(.CodeMirror-composing) { border-bottom: 2px solid; }\\r\\n  \\r\\n  /* Default styles for common addons */\\r\\n  \\r\\n  :global(div.CodeMirror span.CodeMirror-matchingbracket) {color: #0b0;}\\r\\n  :global(div.CodeMirror span.CodeMirror-nonmatchingbracket) {color: #a22;}\\r\\n  :global(.CodeMirror-matchingtag) { background: rgba(255, 150, 0, .3); }\\r\\n  :global(.CodeMirror-activeline-background) {background: #e8f2ff;}\\r\\n  \\r\\n  /* STOP */\\r\\n  \\r\\n  /* The rest of this file contains styles related to the mechanics of\\r\\n     the editor. You probably shouldn't touch them. */\\r\\n  \\r\\n  :global(.CodeMirror) {\\r\\n    position: relative;\\r\\n    overflow: hidden;\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror-scroll) {\\r\\n    overflow: scroll !important; /* Things will break if this is overridden */\\r\\n    /* 30px is the magic margin used to hide the element's real scrollbars */\\r\\n    /* See overflow: hidden in .CodeMirror */\\r\\n    margin-bottom: -30px; margin-right: -30px;\\r\\n    padding-bottom: 30px;\\r\\n    height: 100%;\\r\\n    outline: none; /* Prevent dragging from highlighting the element */\\r\\n    position: relative;\\r\\n  }\\r\\n  :global(.CodeMirror-sizer) {\\r\\n    position: relative;\\r\\n    border-right: 30px solid transparent;\\r\\n  }\\r\\n  \\r\\n  /* The fake, visible scrollbars. Used to force redraw during scrolling\\r\\n     before actual scrolling happens, thus preventing shaking and\\r\\n     flickering artifacts. */\\r\\n  :global(.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler) {\\r\\n    position: absolute;\\r\\n    z-index: 6;\\r\\n    display: none;\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror ::-webkit-scrollbar) {\\r\\n    width: 8px;\\r\\n    height: 8px;\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror ::-webkit-scrollbar-track) {\\r\\n    background: #f4f4f4;\\r\\n    border-radius: 10px;\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror ::-webkit-scrollbar-thumb) {\\r\\n    border-radius: 10px;\\r\\n    background: var(--cm-medium-color);\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror-vscrollbar) {\\r\\n    right: 0; top: 0;\\r\\n    overflow-x: hidden;\\r\\n    overflow-y: scroll;\\r\\n  }\\r\\n  :global(.CodeMirror-hscrollbar) {\\r\\n    bottom: 0; left: 0;\\r\\n    overflow-y: hidden;\\r\\n    overflow-x: scroll;\\r\\n    height: 8px;\\r\\n  }\\r\\n  :global(.CodeMirror-scrollbar-filler) {\\r\\n    right: 0; bottom: 0;\\r\\n  }\\r\\n  :global(.CodeMirror-gutter-filler) {\\r\\n    left: 0; bottom: 0;\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror-gutters) {\\r\\n    position: absolute; left: 0; top: 0;\\r\\n    min-height: 100%;\\r\\n    z-index: 3;\\r\\n  }\\r\\n  :global(.CodeMirror-gutter) {\\r\\n    white-space: normal;\\r\\n    height: 100%;\\r\\n    display: inline-block;\\r\\n    vertical-align: top;\\r\\n    margin-bottom: -30px;\\r\\n  }\\r\\n  :global(.CodeMirror-gutter-wrapper) {\\r\\n    position: absolute;\\r\\n    z-index: 4;\\r\\n    background: none !important;\\r\\n    border: none !important;\\r\\n  }\\r\\n  :global(.CodeMirror-gutter-background) {\\r\\n    position: absolute;\\r\\n    top: 0; bottom: 0;\\r\\n    z-index: 4;\\r\\n  }\\r\\n  :global(.CodeMirror-gutter-elt) {\\r\\n    position: absolute;\\r\\n    cursor: default;\\r\\n    z-index: 4;\\r\\n  }\\r\\n  :global(.CodeMirror-gutter-wrapper ::-moz-selection) { background-color: transparent }\\r\\n  :global(.CodeMirror-gutter-wrapper ::selection) { background-color: transparent }\\r\\n  :global(.CodeMirror-gutter-wrapper ::-moz-selection) { background-color: transparent }\\r\\n  \\r\\n  :global(.CodeMirror-lines) {\\r\\n    cursor: text;\\r\\n    min-height: 1px; /* prevents collapsing before first draw */\\r\\n  }\\r\\n  :global(.CodeMirror pre.CodeMirror-line,\\r\\n  .CodeMirror pre.CodeMirror-line-like) {\\r\\n    /* Reset some styles that the rest of the page might have set */ border-radius: 0;\\r\\n    border-width: 0;\\r\\n    background: transparent;\\r\\n    font-family: inherit;\\r\\n    font-size: inherit;\\r\\n    margin: 0;\\r\\n    white-space: pre;\\r\\n    word-wrap: normal;\\r\\n    line-height: inherit;\\r\\n    color: inherit;\\r\\n    z-index: 2;\\r\\n    position: relative;\\r\\n    overflow: visible;\\r\\n    -webkit-tap-highlight-color: transparent;\\r\\n    font-variant-ligatures: contextual;\\r\\n  }\\r\\n  :global(.CodeMirror-wrap pre.CodeMirror-line,\\r\\n  .CodeMirror-wrap pre.CodeMirror-line-like) {\\r\\n    word-wrap: break-word;\\r\\n    white-space: pre-wrap;\\r\\n    word-break: normal;\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror-linebackground) {\\r\\n    position: absolute;\\r\\n    left: 0; right: 0; top: 0; bottom: 0;\\r\\n    z-index: 0;\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror-linewidget) {\\r\\n    position: relative;\\r\\n    z-index: 2;\\r\\n    padding: 0.1px; /* Force widget margins to stay inside of the container */\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror-widget) {}\\r\\n  \\r\\n  :global(.CodeMirror-rtl pre) { direction: rtl; }\\r\\n  \\r\\n  :global(.CodeMirror-code) {\\r\\n    outline: none;\\r\\n  }\\r\\n  \\r\\n  /* Force content-box sizing for the elements where we expect it */\\r\\n  :global(.CodeMirror-scroll,\\r\\n    .CodeMirror-sizer,\\r\\n    .CodeMirror-gutter,\\r\\n    .CodeMirror-gutters,\\r\\n    .CodeMirror-linenumber) {\\r\\n    box-sizing: content-box;\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror-measure) {\\r\\n    position: absolute;\\r\\n    width: 100%;\\r\\n    height: 0;\\r\\n    overflow: hidden;\\r\\n    visibility: hidden;\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror-cursor) {\\r\\n    position: absolute;\\r\\n    pointer-events: none;\\r\\n  }\\r\\n  :global(.CodeMirror-measure pre) { position: static; }\\r\\n  \\r\\n  :global(div.CodeMirror-cursors) {\\r\\n    /* always show cursor */\\r\\n    visibility: visible;\\r\\n    position: relative;\\r\\n    z-index: 3;\\r\\n  }\\r\\n  :global(div.CodeMirror-dragcursors) {\\r\\n    visibility: visible;\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror-focused div.CodeMirror-cursors) {\\r\\n    visibility: visible;\\r\\n  }\\r\\n  \\r\\n  :global(.CodeMirror-selected) { background: #d9d9d9; }\\r\\n  :global(.CodeMirror-focused .CodeMirror-selected) { background: #d7d4f0; }\\r\\n  :global(.CodeMirror-crosshair) { cursor: crosshair; }\\r\\n  :global(.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection) { background: #d7d4f0; }\\r\\n  :global(.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection) { background: #d7d4f0; }\\r\\n  :global(.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection) { background: #d7d4f0; }\\r\\n  \\r\\n  :global(.cm-searching) {\\r\\n    background-color: #ffa;\\r\\n    background-color: rgba(255, 255, 0, .4);\\r\\n  }\\r\\n  \\r\\n  /* Used to force a border model for a node */\\r\\n  :global(.cm-force-border) { padding-right: .1px; }\\r\\n  \\r\\n  @media print {\\r\\n    /* Hide the cursor when printing */\\r\\n    :global(.CodeMirror div.CodeMirror-cursors) {\\r\\n      visibility: hidden;\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  /* See issue #2901 */\\r\\n  :global(.cm-tab-wrap-hack:after) { content: ''; }\\r\\n  \\r\\n  /* Help users use markselection to safely style text background */\\r\\n  :global(span.CodeMirror-selectedtext) { background: none; }</style>\\r\\n  "],"names":[],"mappings":"AA+JE,MAAM,AAAC,uBAAuB,KAAK,CAAC,AAAC,CAAC,AACpC,KAAK,AAAC,CAAC,AACL,iBAAiB,CAAE,IAAI,CACvB,qBAAqB,CAAE,KAAK,CAC5B,iBAAiB,CAAE,IAAI,CACvB,eAAe,CAAE,IAAI,AACvB,CAAC,AACH,CAAC,AAED,MAAM,AAAC,uBAAuB,IAAI,CAAC,AAAC,CAAC,AACnC,KAAK,AAAC,CAAC,AACL,iBAAiB,CAAE,IAAI,CACvB,qBAAqB,CAAE,IAAI,CAC3B,iBAAiB,CAAE,IAAI,CACvB,eAAe,CAAE,KAAK,AACxB,CAAC,AACH,CAAC,AAGO,WAAW,AAAE,CAAC,AAGpB,WAAW,CAAE,SAAS,CACtB,SAAS,CAAE,GAAG,CACd,KAAK,CAAE,IAAI,eAAe,CAAC,CAC3B,UAAU,CAAE,IAAI,qBAAqB,CAAC,CAEtC,MAAM,CAAE,KAAK,AACf,CAAC,AACO,UAAU,AAAE,CAAC,AACnB,UAAU,CAAE,KAAK,CACjB,KAAK,CAAE,KAAK,AACd,CAAC,AACO,uBAAuB,AAAE,CAAC,AAChC,UAAU,CAAE,KAAK,CACjB,SAAS,CAAE,IAAI,AACjB,CAAC,AAEO,WAAW,AAAE,CAAC,AAAC,MAAM,CAAE,GAAG,AAAE,CAAC,AAC7B,YAAY,AAAE,CAAC,AAAC,QAAQ,CAAE,IAAI,AAAE,CAAC,AACjC,QAAQ,AAAE,CAAC,AAAC,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,MAAM,CAAE,MAAM,CAAE,IAAI,CAAC,CAAC,AAGpD,iBAAiB,AAAE,CAAC,AAC1B,OAAO,CAAE,GAAG,CAAC,CAAC,AAChB,CAAC,AACO;sCAC4B,AAAE,CAAC,AACrC,OAAO,CAAE,CAAC,CAAC,GAAG,AAChB,CAAC,AAEO,uDAAuD,AAAE,CAAC,AAChE,gBAAgB,CAAE,IAAI,qBAAqB,CAAC,AAC9C,CAAC,AAIO,mBAAmB,AAAE,CAAC,AAC5B,YAAY,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,iBAAiB,CAAC,CAC9C,gBAAgB,CAAE,IAAI,qBAAqB,CAAC,CAC5C,WAAW,CAAE,MAAM,AACrB,CAAC,AAEO,sBAAsB,AAAE,CAAC,AAC/B,OAAO,CAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CACpB,SAAS,CAAE,IAAI,CACf,UAAU,CAAE,KAAK,CACjB,KAAK,CAAE,IAAI,CACX,WAAW,CAAE,MAAM,AACrB,CAAC,AAEO,wBAAwB,AAAE,CAAC,AAAC,KAAK,CAAE,IAAI,eAAe,CAAC,AAAE,CAAC,AAC1D,+BAA+B,AAAE,CAAC,AAAC,KAAK,CAAE,IAAI,AAAE,CAAC,AAIjD,kBAAkB,AAAE,CAAC,AAC3B,WAAW,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,iBAAiB,CAAC,CAC7C,YAAY,CAAE,IAAI,CAClB,KAAK,CAAE,CAAC,AACV,CAAC,AAEO,0CAA0C,AAAE,CAAC,AACnD,WAAW,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,iBAAiB,CAAC,AAC/C,CAAC,AACO,iCAAiC,AAAE,CAAC,AAC1C,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,CAAC,CAAC,UAAU,CACpB,UAAU,CAAE,IAAI,cAAc,CAAC,AACjC,CAAC,AACO,qCAAqC,AAAE,CAAC,AAC9C,OAAO,CAAE,CAAC,AACZ,CAAC,AACO,mBAAmB,AAAE,CAAC,AAC5B,gBAAgB,CAAE,IAAI,cAAc,CAAC,CACrC,iBAAiB,CAAE,mBAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,CAChD,SAAS,CAAE,mBAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,AAC1C,CAAC,AACO,sBAAsB,AAAE,CAAC,AAC/B,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,CAAC,CACT,iBAAiB,CAAE,mBAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,CAChD,SAAS,CAAE,mBAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,CACxC,gBAAgB,CAAE,IAAI,cAAc,CAAC,AACvC,CAAC,AACD,mBAAmB,mBAAM,CAAC,AACxB,EAAE,AAAC,EAAE,AACL,GAAG,AAAC,CAAC,AAAC,gBAAgB,CAAE,WAAW,AAAE,CAAC,AACtC,IAAI,AAAC,EAAE,AACT,CAAC,AACD,WAAW,mBAAM,CAAC,AAChB,EAAE,AAAC,EAAE,AACL,GAAG,AAAC,CAAC,AAAC,gBAAgB,CAAE,WAAW,AAAE,CAAC,AACtC,IAAI,AAAC,EAAE,AACT,CAAC,AAKO,OAAO,AAAE,CAAC,AAAC,OAAO,CAAE,YAAY,CAAE,eAAe,CAAE,OAAO,AAAE,CAAC,AAE7D,kBAAkB,AAAE,CAAC,AAC3B,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CAAE,KAAK,CAAE,CAAC,CAAE,GAAG,CAAE,KAAK,CAAE,MAAM,CAAE,CAAC,CACxC,QAAQ,CAAE,MAAM,CAChB,UAAU,CAAE,KAAK,AACnB,CAAC,AACO,iBAAiB,AAAE,CAAC,AAC1B,WAAW,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,iBAAiB,CAAC,CAC7C,GAAG,CAAE,CAAC,CAAE,MAAM,CAAE,CAAC,CACjB,QAAQ,CAAE,QAAQ,AACpB,CAAC,AAGO,wBAAwB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACxC,uBAAuB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACvC,YAAY,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AAC5B,YAAY,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AAC5B,sBAAsB,AAAE,CAAC,WAAW,CAAE,IAAI,AAAC,CAAC,AAC5C,MAAM,AAAE,CAAC,UAAU,CAAE,MAAM,AAAC,CAAC,AAC7B,QAAQ,AAAE,CAAC,eAAe,CAAE,SAAS,AAAC,CAAC,AACvC,iBAAiB,AAAE,CAAC,eAAe,CAAE,YAAY,AAAC,CAAC,AAEnD,yBAAyB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACzC,sBAAsB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACtC,wBAAwB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACxC,qBAAqB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AAKrC,4BAA4B,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AAC5C,oDAAoD,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACpE,yBAAyB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACzC,wBAAwB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACxC,0BAA0B,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AAC1C,sBAAsB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACtC,2BAA2B,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AAC3C,yBAAyB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACzC,yBAAyB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACzC,qBAAqB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACrC,2BAA2B,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AAC3C,oBAAoB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACpC,sBAAsB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AAEtC,uBAAuB,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACvC,eAAe,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AAE/B,qBAAqB,AAAE,CAAC,AAAC,aAAa,CAAE,GAAG,CAAC,KAAK,AAAE,CAAC,AAIpD,8CAA8C,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AAC9D,iDAAiD,AAAE,CAAC,KAAK,CAAE,IAAI,AAAC,CAAC,AACjE,uBAAuB,AAAE,CAAC,AAAC,UAAU,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,AAAE,CAAC,AAC/D,iCAAiC,AAAE,CAAC,UAAU,CAAE,OAAO,AAAC,CAAC,AAOzD,WAAW,AAAE,CAAC,AACpB,QAAQ,CAAE,QAAQ,CAClB,QAAQ,CAAE,MAAM,AAClB,CAAC,AAEO,kBAAkB,AAAE,CAAC,AAC3B,QAAQ,CAAE,MAAM,CAAC,UAAU,CAG3B,aAAa,CAAE,KAAK,CAAE,YAAY,CAAE,KAAK,CACzC,cAAc,CAAE,IAAI,CACpB,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,IAAI,CACb,QAAQ,CAAE,QAAQ,AACpB,CAAC,AACO,iBAAiB,AAAE,CAAC,AAC1B,QAAQ,CAAE,QAAQ,CAClB,YAAY,CAAE,IAAI,CAAC,KAAK,CAAC,WAAW,AACtC,CAAC,AAKO,uGAAuG,AAAE,CAAC,AAChH,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,OAAO,CAAE,IAAI,AACf,CAAC,AAEO,+BAA+B,AAAE,CAAC,AACxC,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACb,CAAC,AAEO,qCAAqC,AAAE,CAAC,AAC9C,UAAU,CAAE,OAAO,CACnB,aAAa,CAAE,IAAI,AACrB,CAAC,AAEO,qCAAqC,AAAE,CAAC,AAC9C,aAAa,CAAE,IAAI,CACnB,UAAU,CAAE,IAAI,iBAAiB,CAAC,AACpC,CAAC,AAEO,sBAAsB,AAAE,CAAC,AAC/B,KAAK,CAAE,CAAC,CAAE,GAAG,CAAE,CAAC,CAChB,UAAU,CAAE,MAAM,CAClB,UAAU,CAAE,MAAM,AACpB,CAAC,AACO,sBAAsB,AAAE,CAAC,AAC/B,MAAM,CAAE,CAAC,CAAE,IAAI,CAAE,CAAC,CAClB,UAAU,CAAE,MAAM,CAClB,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,GAAG,AACb,CAAC,AACO,4BAA4B,AAAE,CAAC,AACrC,KAAK,CAAE,CAAC,CAAE,MAAM,CAAE,CAAC,AACrB,CAAC,AACO,yBAAyB,AAAE,CAAC,AAClC,IAAI,CAAE,CAAC,CAAE,MAAM,CAAE,CAAC,AACpB,CAAC,AAEO,mBAAmB,AAAE,CAAC,AAC5B,QAAQ,CAAE,QAAQ,CAAE,IAAI,CAAE,CAAC,CAAE,GAAG,CAAE,CAAC,CACnC,UAAU,CAAE,IAAI,CAChB,OAAO,CAAE,CAAC,AACZ,CAAC,AACO,kBAAkB,AAAE,CAAC,AAC3B,WAAW,CAAE,MAAM,CACnB,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,YAAY,CACrB,cAAc,CAAE,GAAG,CACnB,aAAa,CAAE,KAAK,AACtB,CAAC,AACO,0BAA0B,AAAE,CAAC,AACnC,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,UAAU,CAAE,IAAI,CAAC,UAAU,CAC3B,MAAM,CAAE,IAAI,CAAC,UAAU,AACzB,CAAC,AACO,6BAA6B,AAAE,CAAC,AACtC,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CAAE,MAAM,CAAE,CAAC,CACjB,OAAO,CAAE,CAAC,AACZ,CAAC,AACO,sBAAsB,AAAE,CAAC,AAC/B,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,OAAO,CACf,OAAO,CAAE,CAAC,AACZ,CAAC,AACO,2CAA2C,AAAE,CAAC,AAAC,gBAAgB,CAAE,WAAW,CAAC,CAAC,AAC9E,sCAAsC,AAAE,CAAC,AAAC,gBAAgB,CAAE,WAAW,CAAC,CAAC,AACzE,2CAA2C,AAAE,CAAC,AAAC,gBAAgB,CAAE,WAAW,CAAC,CAAC,AAE9E,iBAAiB,AAAE,CAAC,AAC1B,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,GAAG,AACjB,CAAC,AACO;sCAC4B,AAAE,CAAC,AAC4B,aAAa,CAAE,CAAC,CACjF,YAAY,CAAE,CAAC,CACf,UAAU,CAAE,WAAW,CACvB,WAAW,CAAE,OAAO,CACpB,SAAS,CAAE,OAAO,CAClB,MAAM,CAAE,CAAC,CACT,WAAW,CAAE,GAAG,CAChB,SAAS,CAAE,MAAM,CACjB,WAAW,CAAE,OAAO,CACpB,KAAK,CAAE,OAAO,CACd,OAAO,CAAE,CAAC,CACV,QAAQ,CAAE,QAAQ,CAClB,QAAQ,CAAE,OAAO,CACjB,2BAA2B,CAAE,WAAW,CACxC,sBAAsB,CAAE,UAAU,AACpC,CAAC,AACO;2CACiC,AAAE,CAAC,AAC1C,SAAS,CAAE,UAAU,CACrB,WAAW,CAAE,QAAQ,CACrB,UAAU,CAAE,MAAM,AACpB,CAAC,AAEO,0BAA0B,AAAE,CAAC,AACnC,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CAAE,KAAK,CAAE,CAAC,CAAE,GAAG,CAAE,CAAC,CAAE,MAAM,CAAE,CAAC,CACpC,OAAO,CAAE,CAAC,AACZ,CAAC,AAEO,sBAAsB,AAAE,CAAC,AAC/B,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,OAAO,CAAE,KAAK,AAChB,CAAC,AAIO,mBAAmB,AAAE,CAAC,AAAC,SAAS,CAAE,GAAG,AAAE,CAAC,AAExC,gBAAgB,AAAE,CAAC,AACzB,OAAO,CAAE,IAAI,AACf,CAAC,AAGO;;;;0BAIgB,AAAE,CAAC,AACzB,UAAU,CAAE,WAAW,AACzB,CAAC,AAEO,mBAAmB,AAAE,CAAC,AAC5B,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,CAAC,CACT,QAAQ,CAAE,MAAM,CAChB,UAAU,CAAE,MAAM,AACpB,CAAC,AAEO,kBAAkB,AAAE,CAAC,AAC3B,QAAQ,CAAE,QAAQ,CAClB,cAAc,CAAE,IAAI,AACtB,CAAC,AACO,uBAAuB,AAAE,CAAC,AAAC,QAAQ,CAAE,MAAM,AAAE,CAAC,AAE9C,sBAAsB,AAAE,CAAC,AAE/B,UAAU,CAAE,OAAO,CACnB,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,AACZ,CAAC,AACO,0BAA0B,AAAE,CAAC,AACnC,UAAU,CAAE,OAAO,AACrB,CAAC,AAEO,0CAA0C,AAAE,CAAC,AACnD,UAAU,CAAE,OAAO,AACrB,CAAC,AAEO,oBAAoB,AAAE,CAAC,AAAC,UAAU,CAAE,OAAO,AAAE,CAAC,AAC9C,wCAAwC,AAAE,CAAC,AAAC,UAAU,CAAE,OAAO,AAAE,CAAC,AAClE,qBAAqB,AAAE,CAAC,AAAC,MAAM,CAAE,SAAS,AAAE,CAAC,AAC7C,yHAAyH,AAAE,CAAC,AAAC,UAAU,CAAE,OAAO,AAAE,CAAC,AACnJ,0GAA0G,AAAE,CAAC,AAAC,UAAU,CAAE,OAAO,AAAE,CAAC,AACpI,yHAAyH,AAAE,CAAC,AAAC,UAAU,CAAE,OAAO,AAAE,CAAC,AAEnJ,aAAa,AAAE,CAAC,AACtB,gBAAgB,CAAE,IAAI,CACtB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,AACzC,CAAC,AAGO,gBAAgB,AAAE,CAAC,AAAC,aAAa,CAAE,IAAI,AAAE,CAAC,AAElD,OAAO,KAAK,AAAC,CAAC,AAEJ,kCAAkC,AAAE,CAAC,AAC3C,UAAU,CAAE,MAAM,AACpB,CAAC,AACH,CAAC,AAGO,uBAAuB,AAAE,CAAC,AAAC,OAAO,CAAE,EAAE,AAAE,CAAC,AAGzC,4BAA4B,AAAE,CAAC,AAAC,UAAU,CAAE,IAAI,AAAE,CAAC"}`
};
var Component2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  createEventDispatcher();
  let {pos = 1} = $$props;
  const cursorTooltipField = (name2, above) => {
    return StateField.define({
      create: getCursorTooltips,
      update(tooltips, tr) {
        if (!tr.docChanged && !tr.selection)
          return tooltips;
        return getCursorTooltips(tr.state, name2, above);
      },
      provide: (f) => showTooltip.computeN([f], (state2) => state2.field(f))
    });
  };
  function getCursorTooltips(state2, name2, above) {
    return state2.selection.ranges.filter((range) => range.empty).map((range) => {
      let line = state2.doc.lineAt(range.head);
      line.number + ":" + (range.head - line.from);
      return {
        pos,
        above,
        strictSide: true,
        class: "cm-cursor-tooltip",
        create: () => {
          let dom = document.createElement("div");
          dom.textContent = name2;
          return {dom};
        }
      };
    });
  }
  const cursorTooltipBaseTheme = EditorView.baseTheme({
    ".cm-tooltip.cm-cursor-tooltip": {
      backgroundColor: "#66b",
      color: "white",
      transform: "translate(-50%, -7px)",
      border: "none",
      padding: "2px 7px",
      borderRadius: "10px",
      "&:before": {
        position: "absolute",
        content: '""',
        left: "50%",
        marginLeft: "-5px",
        bottom: "-5px",
        borderLeft: "5px solid transparent",
        borderRight: "5px solid transparent",
        borderTop: "5px solid #66b"
      }
    }
  });
  let {class: classes = ""} = $$props;
  let {editor: editor2 = null} = $$props;
  let {options: options2 = {}} = $$props;
  let state;
  let element;
  let cursor_a = cursorTooltipField("Lucas", true);
  console.log(cursor_a);
  onMount(() => {
    createEditor();
  });
  const FontSizeTheme = EditorView.theme({$: {fontSize: "25pt"}});
  function createEditor(options3) {
    if (editor2)
      element.innerHTML = "";
    state = EditorState.create({
      doc: "",
      extensions: [
        basicSetup,
        javascript(),
        defaultHighlightStyle,
        cursorTooltipBaseTheme,
        FontSizeTheme
      ]
    });
    editor2 = new EditorView({
      state,
      parent: element,
      dispatch: (tr) => {
        editor2.update([tr]);
      }
    });
  }
  if ($$props.pos === void 0 && $$bindings.pos && pos !== void 0)
    $$bindings.pos(pos);
  if ($$props.class === void 0 && $$bindings.class && classes !== void 0)
    $$bindings.class(classes);
  if ($$props.editor === void 0 && $$bindings.editor && editor2 !== void 0)
    $$bindings.editor(editor2);
  if ($$props.options === void 0 && $$bindings.options && options2 !== void 0)
    $$bindings.options(options2);
  $$result.css.add(css);
  return `

  
  <div class="${escape2(null_to_empty(classes)) + " svelte-44wbrv"}"${add_attribute("this", element, 1)}></div>`;
});
var MdClear = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 24 24"}, $$props), {}, {
    default: () => `<path d="${"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"}"></path>`
  })}`;
});
var TabBar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {tabs} = $$props;
  createEventDispatcher();
  if ($$props.tabs === void 0 && $$bindings.tabs && tabs !== void 0)
    $$bindings.tabs(tabs);
  return `<div class="${"bg-indigo-300 h-8 "}"><ul id="${"tabs"}" class="${"inline-flex w-full px-1 h-full items-center  "}">${each(tabs.items, (tab, i) => `
             ${i == tabs.selected ? `<li class="${"w-20 mr-1 h-full pl-1 pb-1 -mb-px font-semibold text-gray-800 bg-white border-b-2 rounded-t "}"><div class="${"flex justify-between items-center p-1"}"><a id="${"default-tab"}" href="${"#first"}" class="${"text-center"}">${escape2(tab.name)}</a>
                        <div class="${"w-4 h-4 hover:text-red-600 transform hover:scale-125"}">${validate_component(MdClear, "MdClear").$$render($$result, {}, {}, {})}
                        </div></div>
                    
                </li>` : `<li class="${"w-20 h-full mr-1 pl-1 font-semibold text-gray-800 rounded-t bg-white hover:opacity-70 opacity-50"}"><div class="${"flex justify-between items-center p-1"}"><a id="${"default-tab"}" href="${"#first"}" class="${"text-center"}">${escape2(tab.name)}</a>
                        <div class="${"w-4 h-4 hover:text-red-600 transform hover:scale-125"}">${validate_component(MdClear, "MdClear").$$render($$result, {}, {}, {})}
                        </div></div>
                </li>`}`)}</ul></div>`;
});
create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 32 32"}, $$props), {}, {
    default: () => `<path d="${"M15.998 28.895c-0.337 0-0.673-0.088-0.969-0.259l-3.086-1.826c-0.46-0.257-0.235-0.349-0.083-0.402 0.614-0.213 0.739-0.262 1.394-0.635 0.069-0.038 0.159-0.024 0.231 0.018l2.37 1.407c0.087 0.048 0.207 0.048 0.287 0l9.241-5.333c0.086-0.049 0.141-0.149 0.141-0.25v-10.665c0-0.104-0.055-0.202-0.143-0.255l-9.237-5.329c-0.086-0.050-0.199-0.050-0.285 0l-9.235 5.331c-0.090 0.051-0.146 0.152-0.146 0.253v10.666c0 0.102 0.056 0.198 0.145 0.247l2.532 1.462c1.374 0.687 2.215-0.122 2.215-0.935v-10.53c0-0.149 0.12-0.266 0.269-0.266h1.172c0.146 0 0.267 0.117 0.267 0.266v10.53c0 1.833-0.998 2.885-2.736 2.885-0.534 0-0.955 0-2.129-0.579l-2.423-1.395c-0.598-0.346-0.969-0.993-0.969-1.686v-10.665c0-0.693 0.371-1.339 0.969-1.684l9.242-5.34c0.585-0.331 1.362-0.331 1.942 0l9.241 5.34c0.599 0.346 0.971 0.992 0.971 1.684v10.665c0 0.693-0.372 1.337-0.971 1.686l-9.241 5.335c-0.296 0.171-0.631 0.259-0.973 0.259zM18.853 21.547c-4.045 0-4.892-1.857-4.892-3.414 0-0.148 0.118-0.266 0.266-0.266h1.195c0.133 0 0.245 0.096 0.265 0.226 0.18 1.216 0.717 1.831 3.164 1.831 1.946 0 2.775-0.441 2.775-1.473 0-0.596-0.234-1.037-3.26-1.334-2.528-0.25-4.093-0.809-4.093-2.831 0-1.865 1.572-2.977 4.207-2.977 2.961 0 4.425 1.027 4.611 3.233 0.007 0.075-0.020 0.148-0.071 0.205-0.051 0.054-0.121 0.086-0.196 0.086h-1.2c-0.124 0-0.233-0.088-0.259-0.209-0.288-1.28-0.988-1.689-2.886-1.689-2.126 0-2.373 0.74-2.373 1.295 0 0.673 0.292 0.869 3.161 1.248 2.84 0.375 4.19 0.907 4.19 2.902 0 2.014-1.678 3.167-4.606 3.167z"}"></path>`
  })}`;
});
var _expansionState = {};
var TreeView = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {tree} = $$props;
  const {label, children} = tree;
  let expanded = _expansionState[label] || false;
  if ($$props.tree === void 0 && $$bindings.tree && tree !== void 0)
    $$bindings.tree(tree);
  return `<ul>
	<li class="${"pl-3"}">${children ? `<div class="${"flex items-center"}"><div class="${"w-6 h-6 mr-1"}">${expanded ? `<div class="${"transform rotate-90"}">${validate_component(MdChevronRight, "MdChevronRight").$$render($$result, {}, {}, {})}</div>` : `${validate_component(MdChevronRight, "MdChevronRight").$$render($$result, {}, {}, {})}`}</div>
				${escape2(label)}</div>
			${expanded ? `${each(children, (child) => `${validate_component(TreeView, "svelte:self").$$render($$result, {tree: child}, {}, {})}`)}` : ``}` : `<div class="${"flex items-center"}"><div class="${"w-6 h-6 text-white mr-1"}">${validate_component(DiCodeBadge, "DiCodeBadge").$$render($$result, {}, {}, {})}</div>
				<div>${escape2(label)}</div></div>`}</li>
</ul>`;
});
create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 24 24"}, $$props), {}, {
    default: () => `<path d="${"M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"}"></path>`
  })}`;
});
create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(IconBase, "IconBase").$$render($$result, Object.assign({viewBox: "0 0 24 24"}, $$props), {}, {
    default: () => `<path d="${"M22.3 8h-2.4c-.4-1.2-1.5-2-2.8-2h-6c0-1.1-.9-2-2-2h-4.1c-1.7 0-3 1.3-3 3v10c0 1.7 1.3 3 3 3h12c1.7 0 3.4-1.3 3.8-3l2.2-8c.1-.6-.2-1-.7-1zm-18.3 1v-2c0-.6.4-1 1-1h4c0 1.1.9 2 2 2h6c.6 0 1 .4 1 1h-11.1c-.6 0-1.1.4-1.3 1l-1.6 6.3v-7.3zm14.9 7.5c-.2.8-1.1 1.5-1.9 1.5h-12s-.4-.2-.2-.8l1.9-7c0-.1.2-.2.3-.2h13.7l-1.8 6.5z"}"></path>`
  })}`;
});
var Tabs = class {
  constructor(items, selected = 0) {
    this.items = items;
    this.selected = selected;
  }
  getSelected() {
    return this.items[this.selected];
  }
  alreadyOpen(tab) {
    return this.items.filter((t2) => {
      return tab.equal(t2);
    }).length > 0;
  }
  getIndex(tab) {
    let index2 = 0;
    for (let _tab of this.items) {
      if (tab.equal(_tab)) {
        return index2;
      }
      index2++;
    }
    return -1;
  }
  add(tab) {
    this.items.push(tab);
    this.selected = this.items.length - 1;
    return this;
  }
  remove(index2) {
    if (index2 != 0 && index2 == this.selected) {
      console.log("entrou");
      if (index2 == this.items.length - 1) {
        this.selected = index2 - 1;
      } else {
        this.selected = index2;
      }
    } else {
      if (this.selected == this.items.length - 1) {
        this.selected = this.selected - 1;
      }
    }
    this.items.splice(index2, 1);
    return this;
  }
  select(index2) {
    this.selected = index2;
    return this;
  }
};
var Editor = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let options2 = {
    mode: "javascript",
    lineNumbers: true,
    theme: "dracula",
    value: "let a = export bababau"
  };
  let editor2;
  const create_user = () => {
    const colors = ["bg-red-500", "bg-green-500", "bg-yellow-500", "bg-purple-500"];
    const letters = "ABCDEFGHIJKLMNPQRSTUXYZ";
    return {
      color: colors[Math.floor(Math.random() * colors.length)],
      name: `${letters[Math.floor(Math.random() * letters.length)]}${letters[Math.floor(Math.random() * letters.length)]}`
    };
  };
  let users2 = [];
  for (let i = 0; i < 25; i++) {
    users2.push(create_user());
  }
  let project_explorer = new Root(default_folder);
  let tabs = new Tabs([]);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `<div class="${"mx-auto h-screen overflow-hidden "}"><div class="${"h-screen "}"><div class="${"flex flex-row flex-grow h-full "}"><nav class="${"bg-indigo-300 w-20 h-full flex flex-col items-center z-1"}"><a href="${"#"}" class="${"mt-8"}"><img src="${"https://randomuser.me/api/portraits/women/76.jpg"}" class="${"rounded-full w-10 h-10 mb-3 mx-auto"}"></a>

                  <div class="${"w-8  text-white"}">${validate_component(TiFolder, "TiFolder").$$render($$result, {}, {}, {})}</div></nav>
            ${`<nav class="${"bg-gray-200 w-60 h-full divide-y divide-green-500 flex flex-col items-left absolute inset-y-0 left-0 transform -translate-x-full md:relative md:translate-x-0 transition duration-200 ease-in-out"}"><div class="${"ml-4"}"><h1 class="${"title-font font-medium text-black-500 tracking-widest text-2xl mb-3 pt-8 "}">Explorer</h1>
                        ${validate_component(Explorer, "Explorer").$$render($$result, {root: project_explorer}, {
      root: ($$value) => {
        project_explorer = $$value;
        $$settled = false;
      }
    }, {})}</div></nav> `}
            
            <div class="${"flex-col flex-grow"}"><div class="${" bg-indigo-300"}">a sdasdasdasd asdasdasd</div>
                ${validate_component(TabBar, "TabBar").$$render($$result, {tabs}, {
      tabs: ($$value) => {
        tabs = $$value;
        $$settled = false;
      }
    }, {})}
                ${validate_component(Component2, "CodeMirror").$$render($$result, {options: options2, editor: editor2}, {
      editor: ($$value) => {
        editor2 = $$value;
        $$settled = false;
      }
    }, {})}</div>
            ${`<div class="${"flex flex-col bg-indigo-300 pt-1 p-2 pt-2 overflow-scroll"}">${each(users2, (user) => `${validate_component(Avatar, "Avatar").$$render($$result, {name: user.name, color: user.color}, {}, {})}`)}</div>`}</div></div></div>`;
  } while (!$$settled);
  return $$rendered;
});
var Editor_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<div>${validate_component(Editor, "Editor").$$render($$result, {}, {}, {})}</div>`;
});
var editor = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Editor_1
});
var Signin = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  (function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  let checked = false;
  return `<div class="${"bg-white h-screen overflow-hidden"}"><div class="${"flex"}"><div class="${"container h-screen hidden md:block"}"><div class="${"pl-10"}"><img class="${"w-full"}" href="${"https://storyset.com/education"}" src="${"../../static/images/svg/Mobile login-pana.svg"}" alt="${"Kiwi standing on oval"}">
        <a href="${"https://storyset.com/mobile"}">Illustration by Freepik Storyset</a></div></div>
    
    <div class="${"container h-screen w-full p-2 pt-10"}"><div class="${"max-w-sm mx-auto  bg-white px-5 py-10 rounded  tracking-widest"}"><div class="${"mb-2 "}"><h1 class="${"font-bold text-4xl text-gray-800 font-bold"}">Cadastro</h1></div>
        <div class="${"mb-8 "}"><h1 class="${"font-normal text-lg tracking-normal text-gray-700"}">j\xE1 tem conta? 
            <a class="${"text-indigo-500 font-bold"}" href="${"login"}">fa\xE7a login
            </a></h1></div>
        <form action="${"#"}"><div class="${"mt-5 font-bold text-md text-gray-700 block"}"><label for="${"username"}">Email</label>
            <input name="${"username"}" type="${"text"}" id="${"username"}" class="${"block w-full p-2 border  border-gray-500 rounded-full"}"></div>
          <div class="${"mt-5 font-bold text-md text-gray-700 block"}"><label for="${"password"}">Password</label>
            <input name="${"password"}" type="${"password"}" id="${"password"}" class="${"block w-full p-2 border rounded-full border-indigo-800"}"></div>
          <div class="${"flex justify-between pt-4 "}"><div class="${" items-center flex text-center"}"><input class="${"align-middle w-4 h-4"}" type="${"checkbox"}"${add_attribute("checked", checked, 1)}>
              <span class="${"ml-2 text-gray-600"}">Lembrar</span></div></div>
          <div class="${"mt-10"}"><input type="${"submit"}" value="${"Cadastro"}" class="${"py-3 bg-indigo-500 hover:bg-indigo-600 rounded-full text-white font-bold text-center w-full"}"></div></form></div></div></div></div>`;
});
var signin = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Signin
});
var Login = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  (function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  let checked = false;
  return `<div class="${"bg-white h-screen overflow-hidden"}"><div class="${"flex"}">
    <div class="${"container h-screen w-full p-2 pt-10 align-middle"}"><div class="${"max-w-md mx-auto  bg-white px-5 py-10 rounded  tracking-widest  align-middle"}"><div class="${"mb-2 "}"><h1 class="${"font-bold text-4xl text-gray-800 font-bold"}">Ol\xE1 novamente</h1></div>
        <div class="${"mb-8 "}"><h1 class="${"font-normal text-lg tracking-normal text-gray-700"}">N\xE3o tem conta? 
            <a class="${"text-indigo-500 font-bold"}" href="${"signin"}">cadastre-se
            </a></h1></div>
        <form action="${"#"}"><div class="${"mt-5 font-bold text-md text-gray-700 block"}"><label for="${"username"}">Email</label>
            <input name="${"username"}" type="${"text"}" id="${"username"}" class="${"block w-full p-2 border  border-gray-500 rounded-full"}"></div>
          <div class="${"mt-5 font-bold text-md text-gray-700 block"}"><label for="${"password"}">Password</label>
            <input name="${"password"}" type="${"password"}" id="${"password"}" class="${"block w-full p-2 border rounded-full border-indigo-800"}"></div>
          <div class="${"flex justify-between pt-4 "}"><div class="${" items-center flex text-center"}"><input class="${"align-middle w-4 h-4"}" type="${"checkbox"}"${add_attribute("checked", checked, 1)}>
              <span class="${"ml-2 text-gray-600"}">Lembrar</span></div>
            

            <a class="${"text-indigo-500  font-bold"}">Esqueceu sua senha?</a></div>
          <div class="${"mt-10"}"><input type="${"submit"}" value="${"Login"}" class="${"py-3 bg-indigo-500 hover:bg-indigo-600 rounded-full text-white font-bold text-center w-full"}"></div></form></div></div>
    <div class="${"container h-screen hidden md:block"}"><div><img class="${"w-full"}" href="${"https://storyset.com/education"}" src="${"../../static/images/svg/Teaching-rafiki.svg"}" alt="${"Kiwi standing on oval"}">
        <a href="${"https://storyset.com/education"}">Illustration by Freepik Storyset</a></div></div></div></div>`;
});
var login = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Login
});

// .svelte-kit/vercel/entry.js
var entry_default = async (req, res) => {
  const {pathname, searchParams} = new URL(req.url || "", "http://localhost");
  const rendered = await render({
    method: req.method,
    headers: req.headers,
    path: pathname,
    query: searchParams,
    rawBody: await getRawBody(req)
  });
  if (rendered) {
    const {status, headers, body} = rendered;
    return res.writeHead(status, headers).end(body);
  }
  return res.writeHead(404).end();
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.3.0
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
